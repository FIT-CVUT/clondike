require 'Util'

class NegotiatedSession
  TIMEOUT_FOR_CONFIRMATION_IDENTITY = 30
  # Public key of the node requesting the session
  attr_reader :client
  # Public key of the node being requested
  attr_reader :server
  # Id of peer node (used for communication)
  attr_reader :peerNodeId
  # Handshake key generated by client
  attr_accessor :clientChallenge
  # Handshake key generated by server
  attr_accessor :serverChallenge
  # This is a final challenge used for authentication on server connect. During the handshake it is sent only in an encrypted form
  attr_accessor :proof
  # This attribute is set to true when the second party identity is verified (server & client set this at their side in different times)
  # Initially, the attribute is nil. If set to false, it means the identity verification has failed
  attr_reader :confirmed
  # Initially it is a time when the request was send, in the end it is a time when the confirmation was set
  # Timestamp is used for expiration of confirmed negotiations
  # TODO: Implement this auto-deletetion
  attr_accessor :timestamp

  def initialize(clientKey, serverKey, peerNodeId)
    @client = clientKey
    @server = serverKey
    @peerNodeId = peerNodeId
    @confirmed = nil
    @timestamp = Time.now()
    # Monitor object to control waiting
    @monitor = Monitor.new
    @condition = @monitor.new_cond
  end

  def confirmed=(value)
    # Update timestamp on confirmation
    @timestamp = Time.now()
    @confirmed = value
    @monitor.synchronize {
      @condition.broadcast()
    }
  end

  # Waits till confirmation is either false or true
  def waitForConfirmationState
    # TODO: There is a chance we'll wait for full timeout without getting signal. Better locking would be nice
    @monitor.synchronize {
      @condition.wait(TIMEOUT_FOR_CONFIRMATION_IDENTITY) if @confirmed == nil
    }
  end

  def to_s
    "Session with #{@peerNodeId}, timestamp: #{@timestamp}, result: #{@confirmed}"
  end
end

module PseudoRandomNumberGenerator
  def generatePseudoRandomNumber(bits = 64) # The longer is the better, but much long unfortunately caused some troubles
    rand(2**bits)
  end
end

class AuthenticationDispatcher
  include PseudoRandomNumberGenerator

  attr_reader :localIdentity
  attr_reader :trustManagement
  attr_reader :clientNegotiations
  attr_reader :serverNegotiations

  def initialize(localIdentity, interconnection, trustManagement)
    @localIdentity = localIdentity
    @interconnection = interconnection
    @trustManagement = trustManagement
    # Set of session negotiations initiated by this node
    # Key: Public key of peer server
    # Value: Associated NegotiatedSession object
    @clientNegotiations = {}

    # Set of session negotiations initiated by other node, requesting this node to be a server
    # Key: Public key of peer client
    # Value: Associated NegotiatedSession object
    @serverNegotiations = {}

    # Kept on server side. Maps proof to negotiation (assumes proof are unique)
    # TODO: Implement prevention against brute-force attack on proofs!
    # TODO: Timeouts of these records
    @authenticatedNegotiations = {}

    @interconnection.addReceiveHandler(STSInitialRequest, STSInitialRequestHandler.new(@serverNegotiations, @interconnection, @localIdentity, @authenticatedNegotiations, @trustManagement)) if ( interconnection )
    @interconnection.addReceiveHandler(STSServerChallenge, STSServerChallengeHandler.new(@clientNegotiations, @interconnection, @localIdentity, @trustManagement)) if ( interconnection )
    @interconnection.addReceiveHandler(STSFinalize, STSFinalizeHandler.new(@serverNegotiations, @trustManagement)) if ( interconnection )
  end

  # This is called at the server as a callback when a new session is being created in kernel
  # It is assumed the session was prepared by the client by preceding call to prepareSession(..)
  # The request should carry a proof of identity exchanged during the handshake
  def checkNewSessionRequest(proof)
    # No such a session negotiatied?
    # TODO: Check timouts via timestamps!
    return false if ( !@authenticatedNegotiations[proof] )
    remoteKey = @authenticatedNegotiations[proof].client
    @authenticatedNegotiations[proof] = nil # Remote the record
    # There is a chance we got here before getting the client confirmation message => give it a chance to arrive
    @serverNegotiations[remoteKey].waitForConfirmationState()
    # Fail if the identity was not verified
    return false if !@serverNegotiations[remoteKey].confirmed
    # We know the proof is matching as we got neg session by the proof
    return true
  end

  # Prepares session at remote node (requesting side is the client)
  # Executed on client
  # Returns proof to be presented on "connect", if the session negotiation was completed, nil otherwise
  def prepareSession(localNodeId, remoteNodeId, remoteKey)
    $log.debug("Trying to negotiate a new session")
    xValue = generatePseudoRandomNumber
    remoteKeyPEM = remoteKey.to_pem
    initialMessage = STSInitialRequest.new(@trustManagement.convertKeyToPEMString(@localIdentity.publicKey), localNodeId, xValue)
    @clientNegotiations[remoteKeyPEM] = NegotiatedSession.new(@localIdentity.publicKey, remoteKey, remoteNodeId)
    @clientNegotiations[remoteKeyPEM].clientChallenge = xValue
    @interconnection.dispatch(remoteNodeId, initialMessage)
    # Blocking wait for confirmation state (TODO: Better would be to make some callback action to handle this asynchronously so that we do not need to block here!)
    @clientNegotiations[remoteKeyPEM].waitForConfirmationState()
    $log.debug("Negotiation finished. Confirmed = #{@clientNegotiations[remoteKeyPEM].confirmed}")

    return nil if ( @clientNegotiations[remoteKeyPEM].confirmed == false )
    raise TimeoutException.new("No response arrived") if ( @clientNegotiations[remoteKeyPEM].confirmed == nil )

    return @clientNegotiations[remoteKeyPEM].proof
  end

  # Listens on initial session requests and issues server challenge key + signature
  # Executed on server
  class STSInitialRequestHandler
    include PseudoRandomNumberGenerator
    def initialize(serverNegotiations, interconnection, localIdentity, authenticatedNegotiations, trustManagement)
      @serverNegotiations = serverNegotiations
      @interconnection = interconnection
      @localIdentity = localIdentity
      @authenticatedNegotiations = authenticatedNegotiations
      @trustManagement = trustManagement
    end

    def handle(message)
      # Server received an auth challenge => Prepare yValue and challenge the client
      key = @trustManagement.convertPEMStringToKey(message.publicKeyPEM)
      publicKey = key.nil? ? nil : key.public_key 
      publicKeyPEM = message.publicKeyPEM

      xValue = message.challenge
      yValue = generatePseudoRandomNumber
      proof = generatePseudoRandomNumber
      $log.info("Initial authentication request received. X: #{xValue} Y: #{yValue}")
      # TODO and use a real concat
      valueToSign = yValue.to_s + xValue.to_s
      signature = @localIdentity.sign(valueToSign)
      encryptedProof = publicKey.public_encrypt(proof.to_s)
      serverChallengeMessage = STSServerChallenge.new(@trustManagement.convertKeyToPEMString(@localIdentity.publicKey), yValue, signature, encryptedProof)
      @serverNegotiations[publicKeyPEM] = NegotiatedSession.new(publicKey, @localIdentity.publicKey, message.nodeId)
      @serverNegotiations[publicKeyPEM].clientChallenge = xValue
      @serverNegotiations[publicKeyPEM].serverChallenge = yValue
      @serverNegotiations[publicKeyPEM].proof = proof
      # TODO: Check for proof collisions?
      @authenticatedNegotiations[proof.to_s] = @serverNegotiations[publicKeyPEM]
      @interconnection.dispatch(@serverNegotiations[publicKeyPEM].peerNodeId, serverChallengeMessage, DeliveryOptions::ACK_1_MIN)
    end
  end

  # Executed on client
  class STSServerChallengeHandler
    def initialize(clientNegotiations, interconnection, localIdentity, trustManagement)
      @clientNegotiations = clientNegotiations
      @interconnection = interconnection
      @localIdentity = localIdentity
      @trustManagement = trustManagement
    end

    def handle(message)
      $log.info("Server challenge received")
      # Already expired (or other bullshit arrived?)
      key = @trustManagement.convertPEMStringToKey(message.publicKeyPEM)
      publicKey = key.nil? ? nil : key.public_key 
      publicKeyPEM = message.publicKeyPEM

      return if !@clientNegotiations[publicKeyPEM]

      yValue = message.challenge
      xValue = @clientNegotiations[publicKeyPEM].clientChallenge
      valueToSign = yValue.to_s + xValue.to_s
      if !@trustManagement.verifySignature(valueToSign, message.signature, publicKey)
        $log.warn("Server signature verification failed for public key peer #{publicKey}")
        # TODO: Delete record here or let it up-to autodeletion
        @clientNegotiations[publicKeyPEM].confirmed = false
        return
      end

      @clientNegotiations[publicKeyPEM].proof = @localIdentity.decrypt(message.proof)

      $log.debug("Server identity confirmed ")

      valueToSign = xValue.to_s + yValue.to_s
      signature = @localIdentity.sign(valueToSign)
      finalMessage = STSFinalize.new(@trustManagement.convertKeyToPEMString(@localIdentity.publicKey), signature)
      @interconnection.dispatch(@clientNegotiations[publicKeyPEM].peerNodeId, finalMessage)

      @clientNegotiations[publicKeyPEM].confirmed = true
    end
  end

  # Executed on server
  class STSFinalizeHandler
    def initialize(serverNegotiations, trustManagement)
      @serverNegotiations = serverNegotiations
      @trustManagement = trustManagement
    end

    def handle(message)
      # Already expired (or other bullshit arrived?)
      key = @trustManagement.convertPEMStringToKey(message.publicKeyPEM)
      publicKey = key.nil? ? nil : key.public_key 
      publicKeyPEM = message.publicKeyPEM

      return if !@serverNegotiations[publicKeyPEM]
      
      yValue = @serverNegotiations[publicKeyPEM].serverChallenge
      xValue = @serverNegotiations[publicKeyPEM].clientChallenge
      valueToSign = xValue.to_s + yValue.to_s

      if !@trustManagement.verifySignature(valueToSign, message.signature, publicKey)
        $log.warn("Client signature verification failed for public key peer #{publicKey.to_pem}")
        # TODO: Delete record here or let it up-to autodeletion
        @serverNegotiations[publicKeyPEM].confirmed = false
        return
      end

      $log.debug("Client identity confirmed. Registering negotiated proof #{@serverNegotiations[publicKeyPEM].proof}")
      @serverNegotiations[publicKeyPEM].confirmed = true
    end
  end

end
