diff -Naur linux-3.6.11_original/linux-3.6.11/arch/x86/Kconfig linux-3.6.11/arch/x86/Kconfig
--- linux-3.6.11_original/linux-3.6.11/arch/x86/Kconfig	2012-12-17 18:27:45.000000000 +0100
+++ linux-3.6.11/arch/x86/Kconfig	2013-04-06 13:54:14.000000000 +0200
@@ -2235,3 +2235,5 @@
 source "arch/x86/kvm/Kconfig"
 
 source "lib/Kconfig"
+
+source "clondike/Kconfig"
diff -Naur linux-3.6.11_original/linux-3.6.11/arch/x86/kernel/entry_64.S linux-3.6.11/arch/x86/kernel/entry_64.S
--- linux-3.6.11_original/linux-3.6.11/arch/x86/kernel/entry_64.S	2012-12-17 18:27:45.000000000 +0100
+++ linux-3.6.11/arch/x86/kernel/entry_64.S	2013-04-06 13:55:19.000000000 +0200
@@ -1252,6 +1252,36 @@
 	CFI_ENDPROC
 END(kernel_execve)
 
+ /* 
+ In clondike version of we set orig rax value into the register, instead of rax value of pt_regs. 
+ This way, we are able to restore non-zero values, as rax must be zero after successful sys_execve.. 
+ */
+ENTRY(clondike_execve)
+	CFI_STARTPROC
+	FAKE_STACK_FRAME $0
+	SAVE_ALL	
+	movq %rsp,%rcx
+	call sys_execve	
+	movq %rax, RAX(%rsp)
+	testq %rax,%rax
+	jnz failedexec
+	/* After we've checked return value, we set rax to value of orig rax */
+	movq ORIG_RAX(%rsp), %rax
+	/* And in addition we need to set eax to RAX pt regs to correctly survive args restore */
+	movq %rax, RAX(%rsp)
+
+	RESTORE_REST	
+	jmp int_ret_from_sys_call
+failedexec:
+	RESTORE_REST	
+	RESTORE_ARGS
+	UNFAKE_STACK_FRAME
+	ret
+	CFI_ENDPROC
+ENDPROC(clondike_execve)
+
+
+
 /* Call softirq on interrupt stack. Interrupts are off. */
 ENTRY(call_softirq)
 	CFI_STARTPROC
diff -Naur linux-3.6.11_original/linux-3.6.11/arch/x86/kernel/process_64.c linux-3.6.11/arch/x86/kernel/process_64.c
--- linux-3.6.11_original/linux-3.6.11/arch/x86/kernel/process_64.c	2012-12-17 18:27:45.000000000 +0100
+++ linux-3.6.11/arch/x86/kernel/process_64.c	2013-04-06 13:56:22.000000000 +0200
@@ -244,6 +244,7 @@
 	start_thread_common(regs, new_ip, new_sp,
 			    __USER_CS, __USER_DS, 0);
 }
+EXPORT_SYMBOL_GPL(start_thread);
 
 #ifdef CONFIG_IA32_EMULATION
 void start_thread_ia32(struct pt_regs *regs, u32 new_ip, u32 new_sp)
diff -Naur linux-3.6.11_original/linux-3.6.11/arch/x86/kernel/x8664_ksyms_64.c linux-3.6.11/arch/x86/kernel/x8664_ksyms_64.c
--- linux-3.6.11_original/linux-3.6.11/arch/x86/kernel/x8664_ksyms_64.c	2012-12-17 18:27:45.000000000 +0100
+++ linux-3.6.11/arch/x86/kernel/x8664_ksyms_64.c	2013-04-06 14:02:26.000000000 +0200
@@ -38,6 +38,9 @@
 
 EXPORT_SYMBOL(csum_partial);
 
+int clondike_execve(const char *filename, char *const argv[], char *const envp[]);
+EXPORT_SYMBOL(clondike_execve);
+
 /*
  * Export string functions. We normally rely on gcc builtin for most of these,
  * but gcc sometimes decides not to inline them.
diff -Naur linux-3.6.11_original/linux-3.6.11/arch/x86/mm/fault.c linux-3.6.11/arch/x86/mm/fault.c
--- linux-3.6.11_original/linux-3.6.11/arch/x86/mm/fault.c	2012-12-17 18:27:45.000000000 +0100
+++ linux-3.6.11/arch/x86/mm/fault.c	2013-04-06 14:10:58.000000000 +0200
@@ -11,6 +11,7 @@
 #include <linux/kprobes.h>		/* __kprobes, ...		*/
 #include <linux/mmiotrace.h>		/* kmmio_handler, ...		*/
 #include <linux/perf_event.h>		/* perf_sw_event		*/
+#include <clondike/tcmi/tcmi_dbg.h> 
 #include <linux/hugetlb.h>		/* hstate_index_to_shift	*/
 #include <linux/prefetch.h>		/* prefetchw			*/
 
@@ -786,6 +787,11 @@
 	 */
 	up_read(&mm->mmap_sem);
 
+	 TCMI_ON_DEBUG {
+		printk(KERN_DEBUG "Sending SIGSEGV - bad area at %lx, PID: %d\n", address, current->pid);
+		// dump_stack();
+	}
+
 	__bad_area_nosemaphore(regs, error_code, address, si_code);
 }
 
@@ -1018,6 +1024,11 @@
 	/* Get the faulting address: */
 	address = read_cr2();
 
+	 /* TCMI testing */
+  TCMI_ON_DEBUG {
+  	printk(KERN_INFO "Begin page fault at %lx\n", address);
+  }
+
 	/*
 	 * Detect and handle instructions that would cause a page fault for
 	 * both a tracked kernel page and a userspace page.
@@ -1055,6 +1066,12 @@
 		if (spurious_fault(error_code, address))
 			return;
 
+		/* TCMI testing */
+	   	TCMI_ON_DEBUG {
+  			printk(KERN_INFO "Not in kernel space - page fault at %lx \n", address);
+   		}
+
+
 		/* kprobes don't want to hook the spurious faults: */
 		if (notify_page_fault(regs))
 			return;
@@ -1095,6 +1112,10 @@
 	 * in an atomic region then we must not take the fault:
 	 */
 	if (unlikely(in_atomic() || !mm)) {
+		/* TCMI testing */
+		TCMI_ON_DEBUG {
+			printk(KERN_INFO "going to no sem in atomic=%d, mm=%p, page fault at %lx\n", in_atomic(), mm, address);
+		}
 		bad_area_nosemaphore(regs, error_code, address);
 		return;
 	}
@@ -1134,12 +1155,27 @@
 
 	vma = find_vma(mm, address);
 	if (unlikely(!vma)) {
+
+		 TCMI_ON_DEBUG {
+			printk(KERN_DEBUG "Can't find VMA for address %lx\n", address);
+		}
+
 		bad_area(regs, error_code, address);
 		return;
 	}
-	if (likely(vma->vm_start <= address))
+	if (likely(vma->vm_start <= address)){
+    	/* TCMI testing */
+		TCMI_ON_DEBUG {
+			printk(KERN_DEBUG "Address (%lx) in vm area, good area\n", address);
+		}	
 		goto good_area;
+	}
 	if (unlikely(!(vma->vm_flags & VM_GROWSDOWN))) {
+		/* TCMI testing */
+		TCMI_ON_DEBUG {
+			printk(KERN_DEBUG "Address (%lx) not in vm area, and area (start %lx) not VM_GROWSDOWN\n", 
+			       address, vma->vm_start);
+		}	  
 		bad_area(regs, error_code, address);
 		return;
 	}
@@ -1151,11 +1187,19 @@
 		 * 32 pointers and then decrements %sp by 65535.)
 		 */
 		if (unlikely(address + 65536 + 32 * sizeof(unsigned long) < regs->sp)) {
+			/* TCMI testing */
+			TCMI_ON_DEBUG {
+				printk(KERN_DEBUG "User space stack expansion at %lx\n", address);
+			}		  
 			bad_area(regs, error_code, address);
 			return;
 		}
 	}
 	if (unlikely(expand_stack(vma, address))) {
+		/* TCMI testing */
+		TCMI_ON_DEBUG {
+			printk(KERN_DEBUG "Failed to expand stack at %lx\n", address);
+		}
 		bad_area(regs, error_code, address);
 		return;
 	}
@@ -1165,6 +1209,12 @@
 	 * we can handle it..
 	 */
 good_area:
+
+	/* TCMI testing */
+	TCMI_ON_DEBUG {
+		printk(KERN_DEBUG "Good area at %lx, error code was %lx\n", address, error_code);
+	}	
+  
 	if (unlikely(access_error(error_code, vma))) {
 		bad_area_access_error(regs, error_code, address);
 		return;
diff -Naur linux-3.6.11_original/linux-3.6.11/arch/x86/vdso/vdso32-setup.c linux-3.6.11/arch/x86/vdso/vdso32-setup.c
--- linux-3.6.11_original/linux-3.6.11/arch/x86/vdso/vdso32-setup.c	2012-12-17 18:27:45.000000000 +0100
+++ linux-3.6.11/arch/x86/vdso/vdso32-setup.c	2013-04-06 14:13:18.000000000 +0200
@@ -364,6 +364,8 @@
 	return ret;
 }
 
+EXPORT_SYMBOL(arch_setup_additional_pages);
+
 #ifdef CONFIG_X86_64
 
 subsys_initcall(sysenter_setup);
diff -Naur linux-3.6.11_original/linux-3.6.11/clondike/Kconfig linux-3.6.11/clondike/Kconfig
--- linux-3.6.11_original/linux-3.6.11/clondike/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.6.11/clondike/Kconfig	2013-03-14 18:22:38.000000000 +0100
@@ -0,0 +1,57 @@
+#
+# Clondike
+#
+
+menu "Clondike"
+
+config TCMI
+	tristate "Enable TCMI"
+	select TCMI_HOOKS
+	help
+	  Clondike is a clustering project started at FEE CTU Prague.
+    To read more see project website at http://clondike.felk.cvut.cz
+	  Since 2012 is being developed at FIT CTU Prague, project website at https://github.com/FIT-CVUT/Clondike
+	  This option enables Task Checkpointing and Migration Infrastructure(TCMI) 
+	  support in the kernel. 
+	
+
+	  If unsure, say N.
+
+config TCMI_HOOKS
+	bool "TCMI hooks"
+	depends on TCMI
+	help
+	  This option enables kernel hooks used by Task Checkpointing
+	  and Migration Infrastructure(TCMI) to intercept various system
+	  calls and install migration mode handler. 
+
+
+config TCMI_CCN
+	bool "Enable TCMI CCN support"
+	depends on TCMI
+	help
+	  Enables Cluster Core Node (CCN) support in TCMI framework.
+
+
+	  If unsure, say N.
+
+config TCMI_PEN
+	bool "Enable TCMI PEN support"
+	depends on TCMI
+	help
+	  Enables Process Execution Node (PEN) support in TCMI framework.
+
+
+	  If unsure, say N.
+
+config TCMI_DEBUG
+	bool "Enable TCMI debug messages"
+	depends on TCMI
+	help
+	  Enables TCMI debug messages
+	
+	
+	  If unsure, say N.
+
+endmenu
+
diff -Naur linux-3.6.11_original/linux-3.6.11/clondike/Makefile linux-3.6.11/clondike/Makefile
--- linux-3.6.11_original/linux-3.6.11/clondike/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.6.11/clondike/Makefile	2013-01-07 11:22:45.000000000 +0100
@@ -0,0 +1,7 @@
+# Builds the Clondike system
+#
+#
+obj-y += tcmi/
+ifeq ($(CONFIG_TCMI),y)
+	obj-y += src/
+endif
diff -Naur linux-3.6.11_original/linux-3.6.11/clondike/tcmi/Makefile linux-3.6.11/clondike/tcmi/Makefile
--- linux-3.6.11_original/linux-3.6.11/clondike/tcmi/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.6.11/clondike/tcmi/Makefile	2013-01-07 11:22:45.000000000 +0100
@@ -0,0 +1,6 @@
+#
+# Makefile for TCMI components required to be built into kernel
+#
+# 
+
+obj-$(CONFIG_TCMI_HOOKS) :=	tcmi_hooks.o tcmi_dbg.o
diff -Naur linux-3.6.11_original/linux-3.6.11/clondike/tcmi/tcmi_dbg.c linux-3.6.11/clondike/tcmi/tcmi_dbg.c
--- linux-3.6.11_original/linux-3.6.11/clondike/tcmi/tcmi_dbg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.6.11/clondike/tcmi/tcmi_dbg.c	2013-01-07 11:22:45.000000000 +0100
@@ -0,0 +1,6 @@
+#include <clondike/tcmi/tcmi_dbg.h>
+#include <linux/cache.h>
+#include <linux/module.h>
+
+int tcmi_dbg __read_mostly = 1;
+EXPORT_SYMBOL_GPL(tcmi_dbg);
diff -Naur linux-3.6.11_original/linux-3.6.11/clondike/tcmi/tcmi_hooks.c linux-3.6.11/clondike/tcmi/tcmi_hooks.c
--- linux-3.6.11_original/linux-3.6.11/clondike/tcmi/tcmi_hooks.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.6.11/clondike/tcmi/tcmi_hooks.c	2013-01-07 11:22:45.000000000 +0100
@@ -0,0 +1,21 @@
+/**
+ * @file tcmi_hooks.c - Definition of all hooks in kernel requires only
+ *                      including the header file as private
+ * 
+ * 
+ * 
+ * 
+ * 
+ *
+ * Date: 04/21/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: linux-2.6.23-uml-clondike.patch,v 1.1 2009-01-20 14:22:16 andrep1 Exp $
+ *
+ * License....
+ */
+
+#define TCMI_HOOKS_FACTORY_PRIVATE
+#include <clondike/tcmi/tcmi_hooks.h>
+
diff -Naur linux-3.6.11_original/linux-3.6.11/fs/9p/fid.c linux-3.6.11/fs/9p/fid.c
--- linux-3.6.11_original/linux-3.6.11/fs/9p/fid.c	2012-12-17 18:27:45.000000000 +0100
+++ linux-3.6.11/fs/9p/fid.c	2013-04-06 14:14:53.000000000 +0200
@@ -161,9 +161,11 @@
 		if (access == V9FS_ACCESS_SINGLE)
 			return ERR_PTR(-EPERM);
 
-		if (v9fs_proto_dotu(v9ses) || v9fs_proto_dotl(v9ses))
-				uname = NULL;
-		else
+		/*	WTF?? Anyway does not work with our npfs | by Jiri Rakosnik
+ 		if (v9fs_proto_dotu(v9ses) || v9fs_proto_dotl(v9ses))
+ 				uname = NULL;
+ 		else
+		*/
 			uname = v9ses->uname;
 
 		fid = p9_client_attach(v9ses->clnt, NULL, uname, uid,
diff -Naur linux-3.6.11_original/linux-3.6.11/fs/9p/v9fs.c linux-3.6.11/fs/9p/v9fs.c
--- linux-3.6.11_original/linux-3.6.11/fs/9p/v9fs.c	2012-12-17 18:27:45.000000000 +0100
+++ linux-3.6.11/fs/9p/v9fs.c	2013-04-06 14:17:54.000000000 +0200
@@ -51,6 +51,9 @@
 enum {
 	/* Options that take integer arguments */
 	Opt_debug, Opt_dfltuid, Opt_dfltgid, Opt_afid,
+	/* This id will be alias with clondike user id (==999)... in stat this id will be present, but internally 999 user will be marked as owner to pass security checks */
+	Opt_clondike_uid, 
+	Opt_clondike_gid, 	
 	/* String options */
 	Opt_uname, Opt_remotename, Opt_trans, Opt_cache, Opt_cachetag,
 	/* Options that take no arguments */
@@ -68,6 +71,8 @@
 	{Opt_dfltuid, "dfltuid=%u"},
 	{Opt_dfltgid, "dfltgid=%u"},
 	{Opt_afid, "afid=%u"},
+	{Opt_clondike_uid, "cuid=%x"},
+    {Opt_clondike_gid, "cgid=%x"},
 	{Opt_uname, "uname=%s"},
 	{Opt_remotename, "aname=%s"},
 	{Opt_nodevmap, "nodevmap"},
@@ -123,6 +128,9 @@
 	v9ses->cachetag = NULL;
 #endif
 
+	v9ses->cuid = 999; // By default clondike user id is used so that no aliasing is performed
+	v9ses->cgid = 999; // By default clondike group id is used so that no aliasing is performed
+
 	if (!opts)
 		return 0;
 
@@ -183,6 +191,12 @@
 			}
 			v9ses->afid = option;
 			break;
+		case Opt_clondike_uid:
+			v9ses->cuid = option;
+			break;
+		case Opt_clondike_gid:
+			v9ses->cgid = option;
+			break;
 		case Opt_uname:
 			match_strlcpy(v9ses->uname, &args[0], PATH_MAX);
 			break;
diff -Naur linux-3.6.11_original/linux-3.6.11/fs/9p/v9fs.h linux-3.6.11/fs/9p/v9fs.h
--- linux-3.6.11_original/linux-3.6.11/fs/9p/v9fs.h	2012-12-17 18:27:45.000000000 +0100
+++ linux-3.6.11/fs/9p/v9fs.h	2013-04-06 14:19:01.000000000 +0200
@@ -106,6 +106,9 @@
 	struct fscache_cookie *fscache;
 #endif
 
+	unsigned int cuid;	/* Clondike aliased user id */
+  	unsigned int cgid;	/* Clondike aliased group id */
+
 	char *uname;		/* user name to mount as */
 	char *aname;		/* name of remote hierarchy being mounted */
 	unsigned int maxdata;	/* max data for client interface */
diff -Naur linux-3.6.11_original/linux-3.6.11/fs/9p/vfs_inode.c linux-3.6.11/fs/9p/vfs_inode.c
--- linux-3.6.11_original/linux-3.6.11/fs/9p/vfs_inode.c	2012-12-17 18:27:45.000000000 +0100
+++ linux-3.6.11/fs/9p/vfs_inode.c	2013-04-06 14:22:55.000000000 +0200
@@ -283,9 +283,6 @@
 	inode->i_mapping->a_ops = &v9fs_addr_operations;
 
 	switch (mode & S_IFMT) {
-	case S_IFIFO:
-	case S_IFBLK:
-	case S_IFCHR:
 	case S_IFSOCK:
 		if (v9fs_proto_dotl(v9ses)) {
 			inode->i_op = &v9fs_file_inode_operations_dotl;
@@ -299,6 +296,9 @@
 		}
 		init_special_inode(inode, inode->i_mode, inode->i_rdev);
 		break;
+	case S_IFIFO:
+	case S_IFBLK:
+	case S_IFCHR:
 	case S_IFREG:
 		if (v9fs_proto_dotl(v9ses)) {
 			inode->i_op = &v9fs_file_inode_operations_dotl;
@@ -377,7 +377,15 @@
 			__func__, task_pid_nr(current));
 		return ERR_PTR(-ENOMEM);
 	}
-	err = v9fs_init_inode(v9ses, inode, mode, rdev);
+	// Clondike fix for kernel 3.6.11 by Jiri Rakosnik
+	if ( inode->i_uid == v9ses->cuid )
+	// Make clondike aliasing
+		inode->i_uid = 999;
+	if ( inode->i_gid == v9ses->cgid )
+		// Make clondike aliasing
+		inode->i_gid = 999;
+	// End Clondike fix
+ 	err = v9fs_init_inode(v9ses, inode, mode, rdev);
 	if (err) {
 		iput(inode);
 		return ERR_PTR(err);
@@ -1092,6 +1100,13 @@
 	v9fs_stat2inode(st, dentry->d_inode, dentry->d_inode->i_sb);
 	generic_fillattr(dentry->d_inode, stat);
 
+	// If we were aliased, do unaliasing here so that user sees stats as if on home node.
+	// TODO: Note that here we may unalias also files previously not aliased..
+	if ( dentry->d_inode->i_uid == 999 )
+		stat->uid = v9ses->cuid;
+	if ( dentry->d_inode->i_gid == 999 )
+		stat->gid = v9ses->cgid;
+
 	p9stat_free(st);
 	kfree(st);
 	return 0;
@@ -1194,6 +1209,16 @@
 		inode->i_uid = stat->n_uid;
 		inode->i_gid = stat->n_gid;
 	}
+
+	// Clondike fix by Jiri Rakosnik
+	if ( inode->i_uid == v9ses->cuid )
+		// Make clondike aliasing
+		inode->i_uid = 999;
+	if ( inode->i_gid == v9ses->cgid )
+		// Make clondike aliasing
+		inode->i_gid = 999;
+	// End Clondike fix
+
 	if ((S_ISREG(inode->i_mode)) || (S_ISDIR(inode->i_mode))) {
 		if (v9fs_proto_dotu(v9ses) && (stat->extension[0] != '\0')) {
 			/*
diff -Naur linux-3.6.11_original/linux-3.6.11/fs/exec.c linux-3.6.11/fs/exec.c
--- linux-3.6.11_original/linux-3.6.11/fs/exec.c	2012-12-17 18:27:45.000000000 +0100
+++ linux-3.6.11/fs/exec.c	2013-04-06 14:24:59.000000000 +0200
@@ -63,6 +63,7 @@
 
 #include <trace/events/task.h>
 #include "internal.h"
+#include <clondike/tcmi/tcmi_hooks.h>
 
 #include <trace/events/sched.h>
 
@@ -1488,6 +1489,9 @@
 		goto out_ret;
 	}
 
+	// Clondike for kernel 3.7.1 fix this macro, convert type argv and regs by Jiri Rakosnik
+    TCMI_HOOKS_CALL(execve, filename, argv.ptr.native, envp.ptr.native, regs); 	/* TCMI system call hook */
+
 	/* We're below the limit (still or again), so we don't want to make
 	 * further execve() calls fail. */
 	current->flags &= ~PF_NPROC_EXCEEDED;
@@ -1591,6 +1595,8 @@
 	return retval;
 }
 
+EXPORT_SYMBOL(do_execve);
+
 int do_execve(const char *filename,
 	const char __user *const __user *__argv,
 	const char __user *const __user *__envp,
diff -Naur linux-3.6.11_original/linux-3.6.11/fs/fcntl.c linux-3.6.11/fs/fcntl.c
--- linux-3.6.11_original/linux-3.6.11/fs/fcntl.c	2012-12-17 18:27:45.000000000 +0100
+++ linux-3.6.11/fs/fcntl.c	2013-04-08 07:59:01.000000000 +0200
@@ -128,6 +128,7 @@
 	}
 	return sys_dup3(oldfd, newfd, 0);
 }
+EXPORT_SYMBOL(sys_dup2);
 
 SYSCALL_DEFINE1(dup, unsigned int, fildes)
 {
diff -Naur linux-3.6.11_original/linux-3.6.11/fs/namei.c linux-3.6.11/fs/namei.c
--- linux-3.6.11_original/linux-3.6.11/fs/namei.c	2012-12-17 18:27:45.000000000 +0100
+++ linux-3.6.11/fs/namei.c	2013-04-08 15:48:50.000000000 +0200
@@ -1933,7 +1933,7 @@
 	if (!err && !(flags & LOOKUP_PARENT)) {
 		err = lookup_last(nd, &path);
 		while (err > 0) {
-			void *cookie;
+			void *cookie = NULL;
 			struct path link = path;
 			err = may_follow_link(&link, nd);
 			if (unlikely(err))
@@ -2902,7 +2902,7 @@
 	error = do_last(nd, &path, file, op, &opened, pathname);
 	while (unlikely(error > 0)) { /* trailing symlink */
 		struct path link = path;
-		void *cookie;
+		void *cookie = NULL;
 		if (!(nd->flags & LOOKUP_FOLLOW)) {
 			path_put_conditional(&path, nd);
 			path_put(&nd->path);
diff -Naur linux-3.6.11_original/linux-3.6.11/fs/namespace.c linux-3.6.11/fs/namespace.c
--- linux-3.6.11_original/linux-3.6.11/fs/namespace.c	2012-12-17 18:27:45.000000000 +0100
+++ linux-3.6.11/fs/namespace.c	2013-04-08 08:00:06.000000000 +0200
@@ -1278,6 +1278,8 @@
 	return retval;
 }
 
+EXPORT_SYMBOL_GPL(sys_umount);
+
 #ifdef __ARCH_WANT_SYS_OLDUMOUNT
 
 /*
@@ -2276,6 +2278,8 @@
 	return new_ns;
 }
 
+EXPORT_SYMBOL(do_mount);
+
 /*
  * Allocate a new namespace structure and populate it with contents
  * copied from the namespace of the passed in task structure.
diff -Naur linux-3.6.11_original/linux-3.6.11/fs/open.c linux-3.6.11/fs/open.c
--- linux-3.6.11_original/linux-3.6.11/fs/open.c	2012-12-17 18:27:45.000000000 +0100
+++ linux-3.6.11/fs/open.c	2013-04-06 14:29:18.000000000 +0200
@@ -964,6 +964,7 @@
 	}
 	return fd;
 }
+EXPORT_SYMBOL(do_sys_open);
 
 SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode)
 {
diff -Naur linux-3.6.11_original/linux-3.6.11/include/clondike/tcmi/tcmi_dbg.h linux-3.6.11/include/clondike/tcmi/tcmi_dbg.h
--- linux-3.6.11_original/linux-3.6.11/include/clondike/tcmi/tcmi_dbg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.6.11/include/clondike/tcmi/tcmi_dbg.h	2013-01-31 10:18:05.000000000 +0100
@@ -0,0 +1,31 @@
+/**
+* @file tcmi_dbg.h - Helper module when debugging TCMI tasks in kernel
+* 
+* 
+* 
+* 
+* 
+* 
+*
+* Date: 04/21/2005
+*
+* Author: Jan Capek
+*
+* $Id: linux-2.6.23-uml-clondike.patch,v 1.1 2009-01-20 14:22:16 andrep1 Exp $
+*
+* License....
+*/
+
+#ifndef _TCMI_DBG_H
+#define _TCMI_DBG_H
+
+
+extern int tcmi_dbg;
+
+#define TCMI_ON_DEBUG if (tcmi_dbg && current->tcmi.tcmi_task)
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_DBG_H */
\ No newline at end of file
diff -Naur linux-3.6.11_original/linux-3.6.11/include/clondike/tcmi/tcmi_hooks_factory.h linux-3.6.11/include/clondike/tcmi/tcmi_hooks_factory.h
--- linux-3.6.11_original/linux-3.6.11/include/clondike/tcmi/tcmi_hooks_factory.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.6.11/include/clondike/tcmi/tcmi_hooks_factory.h	2013-02-20 12:47:16.000000000 +0100
@@ -0,0 +1,125 @@
+/**
+ * @file tcmi_hooks_factory.h - Declaration of all a factory class that
+ *                              produces hooks declarations and definitions
+ * 
+ * 
+ * 
+ * 
+ * 
+ *
+ * Date: 04/21/2005
+ *
+ * Author: Jan Capek, based on lmmdefs.h by Martin Kacer
+ *
+ * $Id: linux-2.6.23-uml-clondike.patch,v 1.1 2009-01-20 14:22:16 andrep1 Exp $
+ *
+ * License....
+ */
+
+#ifndef _TCMI_HOOKS_FACTORY_H
+#define _TCMI_HOOKS_FACTORY_H
+
+
+/** @defgroup tcmi_hooks_factory_class tcmi_hooks_factory class 
+ * 
+ * This \<\<singleton\>\> class allows declaration and definition
+ * of new kernel hooks. A component that wants to create a new hook
+ * adds its definition in tcmi_hooks.h, using TCMI_HOOKS_DEFINE macro. 
+ * The hook method is then called using TCMI_HOOKS_CALL macro from
+ * appropriate place in the kernel. The parameters passed to the call
+ * must match the hook definition.
+ *
+ * Any module that wants to register a method that will always be
+ * called by the hook calls
+ * tcmi_hooks_register_NAME(custom_method). Where the NAME suffix is
+ * the identifier used in HOOK definition in tcmi_hooks.h.
+ * 
+ * The benefit of this solution, is that we have to export only one
+ * new symbol - the hook pointer. Everything else is handled by static
+ * inline methods or macros.
+ *
+ *
+ *@{
+ */
+
+/** 
+ * Defines a hook that requires:
+ *
+ * - declaration of new data type for the method that is to be
+ * registered. This method is then required as a parameter for the
+ * registration method.
+ *
+ * - declaration of registration/unregistration methods
+ * - declares the pointer to the hooks method
+ *
+ * In addition, since this file is also included by tcmi_hooks.c
+ * module it will define the registration and unregistration function,
+ * and a the default hook method - NULL
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+/* When used as private, we generate also definitions */
+#ifdef TCMI_HOOKS_FACTORY_PRIVATE
+/** 
+ * Following macro is used by the public TCMI_HOOKS_DEFINE to define the actual
+ * hook method pointer and export it. This is done in tcmi_hooks.c and the user
+ * doesn't have to worry about it anymore as it will get linked into the kernel.
+ */
+#define TCMI_HOOKS_DEFINE_PRIVATE(method, args...)					\
+tcmi_hooks_##method##_t *tcmi_hooks_##method = NULL;					\
+EXPORT_SYMBOL(tcmi_hooks_##method);					
+
+#else
+/* empty macro, when included from some place else*/
+#define TCMI_HOOKS_DEFINE_PRIVATE(method, args...)
+#endif /* TCMI_HOOKS_FACTORY_PRIVATE */
+
+/** 
+ * This macro is to declare the hook method pointer in tcmi_hooks.h.
+ * In the tcmi_hooks.c, it also defines the hook pointer.
+ */
+#define TCMI_HOOKS_DEFINE(method, args...)						\
+typedef long tcmi_hooks_##method##_t(args);						\
+extern tcmi_hooks_##method##_t *tcmi_hooks_##method;					\
+static inline void tcmi_hooks_register_##method(tcmi_hooks_##method##_t *method)	\
+{											\
+	tcmi_hooks_##method = method;							\
+}											\
+static inline void tcmi_hooks_unregister_##method(void)					\
+{											\
+	tcmi_hooks_##method = NULL;							\
+}											\
+TCMI_HOOKS_DEFINE_PRIVATE(method, args);
+
+
+
+/**
+ * Since each hook method returns an int, this macro generates an
+ * expression, that calls the hook method if one is defined.
+ * The value of the expression is 0, if no hook method has been registered.
+ * If there is a valid hook method registered, we get back the value
+ * returned by this method. 
+ *
+ * @param method - name of the method(e.g. exec) that
+ * is to be called
+ * @param args - arguments of the method
+ */
+#define TCMI_HOOKS_CALL(method, args...)		\
+({							\
+	int __tcmi_hook_ret = 0;			\
+ if (tcmi_hooks_##method != NULL)		\
+		__tcmi_hook_ret =			\
+			tcmi_hooks_##method(args);	\
+	__tcmi_hook_ret;				\
+})
+
+
+#define TCMI_TASK_GUEST if (current->tcmi.tcmi_task && current->tcmi.task_type == guest)
+
+/**
+ * @}
+ */
+ 
+#endif /* _TCMI_HOOKS_FACTORY_H */
\ No newline at end of file
diff -Naur linux-3.6.11_original/linux-3.6.11/include/clondike/tcmi/tcmi_hooks.h linux-3.6.11/include/clondike/tcmi/tcmi_hooks.h
--- linux-3.6.11_original/linux-3.6.11/include/clondike/tcmi/tcmi_hooks.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.6.11/include/clondike/tcmi/tcmi_hooks.h	2013-03-12 18:55:27.000000000 +0100
@@ -0,0 +1,104 @@
+/**
+ * @file tcmi_hooks.h - Declaration of all hooks that are to be used in the kernel.
+ * 
+ * 
+ * 
+ * 
+ * 
+ * 
+ *
+ * Date: 04/21/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: linux-2.6.23-uml-clondike.patch,v 1.1 2009-01-20 14:22:16 andrep1 Exp $
+ *
+ * License....
+ */
+
+#ifndef _TCMI_HOOKS_H
+#define _TCMI_HOOKS_H
+
+#include <clondike/tcmi/tcmi_hooks_factory.h>
+#include <asm/ptrace.h>
+#include <asm/siginfo.h>
+#include <linux/capability.h>
+#include <linux/resource.h>
+
+/** execve */
+TCMI_HOOKS_DEFINE(execve, const char *, const char * const*, const char * const*, struct pt_regs *);
+
+/** wait */
+TCMI_HOOKS_DEFINE(sys_wait4, pid_t, int __user *, int, struct rusage __user *);
+
+/** fork hooks */
+/** Called in the beginning of the fork */
+TCMI_HOOKS_DEFINE(pre_fork, unsigned long, unsigned long, struct pt_regs *, unsigned long, int __user *, int __user *);
+/** Called in the middle of fork (used to attach shadow/guest task to a newly forked task). Takes new child as a param */
+TCMI_HOOKS_DEFINE(in_fork, struct task_struct*);
+/** 
+ * Called in the end of the fork. Takes as param return value of fork, pid of process forked on associated CCN + result buffers (so that
+ * we can reset them, in case fork failed and we've filled them in prefork.
+ *
+ * The method is called after succesful fork, but befor the process is actually started
+ */
+TCMI_HOOKS_DEFINE(post_fork, struct task_struct*, long, pid_t, int __user *, int __user *);
+
+/** exit hook */
+TCMI_HOOKS_DEFINE(exit, long);
+
+/** syscalls **/
+/** signal */
+TCMI_HOOKS_DEFINE(sys_kill, int, int);
+TCMI_HOOKS_DEFINE(do_tkill, int, int, int);
+TCMI_HOOKS_DEFINE(sys_rt_sigqueueinfo, int, int, siginfo_t*);
+
+/** pid, gid and session manipulation */
+TCMI_HOOKS_DEFINE(sys_getpid, void);
+TCMI_HOOKS_DEFINE(sys_getppid, void);
+TCMI_HOOKS_DEFINE(sys_getpgid, pid_t);
+TCMI_HOOKS_DEFINE(sys_setpgid, pid_t, pid_t);
+TCMI_HOOKS_DEFINE(sys_getsid, pid_t);
+TCMI_HOOKS_DEFINE(sys_setsid, void);
+TCMI_HOOKS_DEFINE(sys_getpgrp, void);
+
+/** user identification */
+TCMI_HOOKS_DEFINE(sys_geteuid, void);
+TCMI_HOOKS_DEFINE(sys_getuid, void);
+TCMI_HOOKS_DEFINE(sys_getresuid, uid_t*, uid_t*, uid_t*);
+TCMI_HOOKS_DEFINE(sys_setresuid, uid_t, uid_t, uid_t);
+TCMI_HOOKS_DEFINE(sys_setuid, uid_t);
+TCMI_HOOKS_DEFINE(sys_setreuid, uid_t, uid_t);
+
+/** group identification */
+TCMI_HOOKS_DEFINE(sys_getegid, void);
+TCMI_HOOKS_DEFINE(sys_getgid, void);
+TCMI_HOOKS_DEFINE(sys_getgroups, int, gid_t *);
+TCMI_HOOKS_DEFINE(sys_getresgid, gid_t*, gid_t*, gid_t*);
+TCMI_HOOKS_DEFINE(sys_setgid, gid_t);
+TCMI_HOOKS_DEFINE(sys_setregid, gid_t, gid_t);
+TCMI_HOOKS_DEFINE(sys_setresgid, gid_t, gid_t, gid_t);
+TCMI_HOOKS_DEFINE(sys_setgroups, int, gid_t *);
+
+/** other */
+TCMI_HOOKS_DEFINE(sys_capget, cap_user_header_t, cap_user_data_t);
+
+
+/** SIGUNUSED default signal handler hook */
+TCMI_HOOKS_DEFINE(sig_unused, struct pt_regs*);
+TCMI_HOOKS_DEFINE(sig_deliver, int);
+TCMI_HOOKS_DEFINE(sig_delivered, int);
+TCMI_HOOKS_DEFINE(did_stop, int);
+TCMI_HOOKS_DEFINE(group_stop, int);
+TCMI_HOOKS_DEFINE(deq_sig, int);
+TCMI_HOOKS_DEFINE(send_sig, int);
+TCMI_HOOKS_DEFINE(doing_sigfatal, int, int);
+
+
+TCMI_HOOKS_DEFINE(replace_proc_self_file, const char*, const char**);
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_HOOKS_H */
\ No newline at end of file
diff -Naur linux-3.6.11_original/linux-3.6.11/include/clondike/tcmi/tcmi_struct.h linux-3.6.11/include/clondike/tcmi/tcmi_struct.h
--- linux-3.6.11_original/linux-3.6.11/include/clondike/tcmi/tcmi_struct.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.6.11/include/clondike/tcmi/tcmi_struct.h	2013-03-26 13:35:11.000000000 +0100
@@ -0,0 +1,58 @@
+/**
+ * @file tcmi_struct.h - Declaration of extension structure for task_struct
+ * 
+ * 
+ * 
+ * 
+ * 
+ * 
+ *
+ * Date: 04/26/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: linux-2.6.23-uml-clondike.patch,v 1.1 2009-01-20 14:22:16 andrep1 Exp $
+ *
+ * License....
+ */
+
+#ifndef _TCMI_STRUCT_H
+#define _TCMI_STRUCT_H
+
+/** handler method type - called when switching to migration mode. */
+typedef void mig_mode_handler_t(void);
+
+enum tcmi_task_type {
+	unresolved_type,
+	shadow,
+	shadow_detached, /** A task, that was shadow once, but it is now running on CCN and so it does not have remote guest */
+	guest
+};
+
+/** Compound structure that holds TCMI related information for
+ * shadow/stub tasks in the task_struct. There are 3 items:
+ * - migration mode handler - this allows the migration component to
+ * run a specific handler for each task. With this approach we can have
+ * CCN and PEN on the same node
+ * - data for the handler - contains a valid pointer to any data. It
+ * should be guaranteed by the component that performs task attaching,
+ * that the the process will retain an extra reference. 
+ * - tcmi_task - points to the tcmi task that describes either
+ * a shadow or a stub task. This data is interpreted by the migration
+ * mode handler.
+ */
+struct tcmi_struct {
+	/* migration mode handler */
+	mig_mode_handler_t *mig_mode_handler;
+	/* data for the handler */
+	void *data;
+	/* tcmi task associated with the handler */
+	void *tcmi_task;
+
+	enum tcmi_task_type task_type;
+};
+
+/**
+ * @}
+ */
+#endif /* _TCMI_STRUCT_H */
\ No newline at end of file
diff -Naur linux-3.6.11_original/linux-3.6.11/include/linux/netfilter_ipv4/ipt_ECN.h linux-3.6.11/include/linux/netfilter_ipv4/ipt_ECN.h
--- linux-3.6.11_original/linux-3.6.11/include/linux/netfilter_ipv4/ipt_ECN.h	2012-12-17 18:27:45.000000000 +0100
+++ linux-3.6.11/include/linux/netfilter_ipv4/ipt_ECN.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,33 +0,0 @@
-/* Header file for iptables ipt_ECN target
- *
- * (C) 2002 by Harald Welte <laforge@gnumonks.org>
- *
- * This software is distributed under GNU GPL v2, 1991
- * 
- * ipt_ECN.h,v 1.3 2002/05/29 12:17:40 laforge Exp
-*/
-#ifndef _IPT_ECN_TARGET_H
-#define _IPT_ECN_TARGET_H
-
-#include <linux/types.h>
-#include <linux/netfilter/xt_DSCP.h>
-
-#define IPT_ECN_IP_MASK	(~XT_DSCP_MASK)
-
-#define IPT_ECN_OP_SET_IP	0x01	/* set ECN bits of IPv4 header */
-#define IPT_ECN_OP_SET_ECE	0x10	/* set ECE bit of TCP header */
-#define IPT_ECN_OP_SET_CWR	0x20	/* set CWR bit of TCP header */
-
-#define IPT_ECN_OP_MASK		0xce
-
-struct ipt_ECN_info {
-	__u8 operation;	/* bitset of operations */
-	__u8 ip_ect;	/* ECT codepoint of IPv4 header, pre-shifted */
-	union {
-		struct {
-			__u8 ece:1, cwr:1; /* TCP ECT bits */
-		} tcp;
-	} proto;
-};
-
-#endif /* _IPT_ECN_TARGET_H */
diff -Naur linux-3.6.11_original/linux-3.6.11/include/linux/netfilter_ipv4/ipt_TTL.h linux-3.6.11/include/linux/netfilter_ipv4/ipt_TTL.h
--- linux-3.6.11_original/linux-3.6.11/include/linux/netfilter_ipv4/ipt_TTL.h	2012-12-17 18:27:45.000000000 +0100
+++ linux-3.6.11/include/linux/netfilter_ipv4/ipt_TTL.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,23 +0,0 @@
-/* TTL modification module for IP tables
- * (C) 2000 by Harald Welte <laforge@netfilter.org> */
-
-#ifndef _IPT_TTL_H
-#define _IPT_TTL_H
-
-#include <linux/types.h>
-
-enum {
-	IPT_TTL_SET = 0,
-	IPT_TTL_INC,
-	IPT_TTL_DEC
-};
-
-#define IPT_TTL_MAXMODE	IPT_TTL_DEC
-
-struct ipt_TTL_info {
-	__u8	mode;
-	__u8	ttl;
-};
-
-
-#endif
diff -Naur linux-3.6.11_original/linux-3.6.11/include/linux/netfilter_ipv6/ip6t_HL.h linux-3.6.11/include/linux/netfilter_ipv6/ip6t_HL.h
--- linux-3.6.11_original/linux-3.6.11/include/linux/netfilter_ipv6/ip6t_HL.h	2012-12-17 18:27:45.000000000 +0100
+++ linux-3.6.11/include/linux/netfilter_ipv6/ip6t_HL.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,24 +0,0 @@
-/* Hop Limit modification module for ip6tables
- * Maciej Soltysiak <solt@dns.toxicfilms.tv>
- * Based on HW's TTL module */
-
-#ifndef _IP6T_HL_H
-#define _IP6T_HL_H
-
-#include <linux/types.h>
-
-enum {
-	IP6T_HL_SET = 0,
-	IP6T_HL_INC,
-	IP6T_HL_DEC
-};
-
-#define IP6T_HL_MAXMODE	IP6T_HL_DEC
-
-struct ip6t_HL_info {
-	__u8	mode;
-	__u8	hop_limit;
-};
-
-
-#endif
diff -Naur linux-3.6.11_original/linux-3.6.11/include/linux/sched.h linux-3.6.11/include/linux/sched.h
--- linux-3.6.11_original/linux-3.6.11/include/linux/sched.h	2012-12-17 18:27:45.000000000 +0100
+++ linux-3.6.11/include/linux/sched.h	2013-04-06 17:11:34.000000000 +0200
@@ -93,6 +93,7 @@
 #include <linux/uidgid.h>
 
 #include <asm/processor.h>
+#include <clondike/tcmi/tcmi_struct.h> /* TCMI extension */
 
 struct exec_domain;
 struct futex_pi_state;
@@ -655,6 +656,7 @@
 	unsigned audit_tty;
 	struct tty_audit_buf *tty_audit_buf;
 #endif
+
 #ifdef CONFIG_CGROUPS
 	/*
 	 * group_rwsem prevents new tasks from entering the threadgroup and
@@ -1499,6 +1501,11 @@
 	int cpuset_mem_spread_rotor;
 	int cpuset_slab_spread_rotor;
 #endif
+
+#if defined CONFIG_TCMI || defined CONFIG_TCMI_MODULE
+	struct tcmi_struct tcmi;
+#endif
+
 #ifdef CONFIG_CGROUPS
 	/* Control Group info protected by css_set_lock */
 	struct css_set __rcu *cgroups;
diff -Naur linux-3.6.11_original/linux-3.6.11/include/linux/signal.h linux-3.6.11/include/linux/signal.h
--- linux-3.6.11_original/linux-3.6.11/include/linux/signal.h	2012-12-17 18:27:45.000000000 +0100
+++ linux-3.6.11/include/linux/signal.h	2013-04-06 14:33:16.000000000 +0200
@@ -351,17 +351,17 @@
 #define siginmask(sig, mask) (rt_sigmask(sig) & (mask))
 
 #define SIG_KERNEL_ONLY_MASK (\
-	rt_sigmask(SIGKILL)   |  rt_sigmask(SIGSTOP))
+	rt_sigmask(SIGKILL)   |  rt_sigmask(SIGSTOP)   |  rt_sigmask(SIGUNUSED))
 
 #define SIG_KERNEL_STOP_MASK (\
 	rt_sigmask(SIGSTOP)   |  rt_sigmask(SIGTSTP)   | \
-	rt_sigmask(SIGTTIN)   |  rt_sigmask(SIGTTOU)   )
+	rt_sigmask(SIGTTIN)   |  rt_sigmask(SIGTTOU)   |  rt_sigmask(SIGUNUSED))
 
 #define SIG_KERNEL_COREDUMP_MASK (\
         rt_sigmask(SIGQUIT)   |  rt_sigmask(SIGILL)    | \
 	rt_sigmask(SIGTRAP)   |  rt_sigmask(SIGABRT)   | \
         rt_sigmask(SIGFPE)    |  rt_sigmask(SIGSEGV)   | \
-	rt_sigmask(SIGBUS)    |  rt_sigmask(SIGSYS)    | \
+	rt_sigmask(SIGBUS)    | \
         rt_sigmask(SIGXCPU)   |  rt_sigmask(SIGXFSZ)   | \
 	SIGEMT_MASK				       )
 
diff -Naur linux-3.6.11_original/linux-3.6.11/kernel/capability.c linux-3.6.11/kernel/capability.c
--- linux-3.6.11_original/linux-3.6.11/kernel/capability.c	2012-12-17 18:27:45.000000000 +0100
+++ linux-3.6.11/kernel/capability.c	2013-04-06 14:34:44.000000000 +0200
@@ -16,6 +16,7 @@
 #include <linux/pid_namespace.h>
 #include <linux/user_namespace.h>
 #include <asm/uaccess.h>
+#include <clondike/tcmi/tcmi_hooks.h>
 
 /*
  * Leveraged for setting/resetting capabilities
@@ -166,6 +167,11 @@
 	if ((dataptr == NULL) || (ret != 0))
 		return ((dataptr == NULL) && (ret == -EINVAL)) ? 0 : ret;
 
+	TCMI_TASK_GUEST{
+	     printk(KERN_INFO "Forwading sys_capget()\n");
+             return TCMI_HOOKS_CALL(sys_capget, header, dataptr);
+ 	}
+
 	if (get_user(pid, &header->pid))
 		return -EFAULT;
 
diff -Naur linux-3.6.11_original/linux-3.6.11/kernel/exit.c linux-3.6.11/kernel/exit.c
--- linux-3.6.11_original/linux-3.6.11/kernel/exit.c	2012-12-17 18:27:45.000000000 +0100
+++ linux-3.6.11/kernel/exit.c	2013-04-06 14:37:01.000000000 +0200
@@ -58,6 +58,7 @@
 #include <asm/unistd.h>
 #include <asm/pgtable.h>
 #include <asm/mmu_context.h>
+#include <clondike/tcmi/tcmi_hooks.h>
 
 static void exit_mm(struct task_struct * tsk);
 
@@ -907,6 +908,8 @@
 	struct task_struct *tsk = current;
 	int group_dead;
 
+	TCMI_HOOKS_CALL(exit, code); 	/* TCMI system call hook */
+
 	profile_task_exit(tsk);
 
 	WARN_ON(blk_needs_flush_plug(tsk));
@@ -1841,6 +1844,11 @@
 			__WNOTHREAD|__WCLONE|__WALL))
 		return -EINVAL;
 
+	TCMI_TASK_GUEST{
+		printk(KERN_INFO "Forwading sys_wait4()\n");
+		return TCMI_HOOKS_CALL(sys_wait4, upid, stat_addr, options, ru);
+	}
+
 	if (upid == -1)
 		type = PIDTYPE_MAX;
 	else if (upid < 0) {
@@ -1868,6 +1876,8 @@
 	return ret;
 }
 
+EXPORT_SYMBOL(sys_wait4);
+
 #ifdef __ARCH_WANT_SYS_WAITPID
 
 /*
diff -Naur linux-3.6.11_original/linux-3.6.11/kernel/fork.c linux-3.6.11/kernel/fork.c
--- linux-3.6.11_original/linux-3.6.11/kernel/fork.c	2012-12-17 18:27:45.000000000 +0100
+++ linux-3.6.11/kernel/fork.c	2013-04-06 17:14:35.000000000 +0200
@@ -82,6 +82,7 @@
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/task.h>
+#include <clondike/tcmi/tcmi_hooks.h>
 
 /*
  * Protected counters by write_lock_irq(&tasklist_lock)
@@ -1436,6 +1437,13 @@
 		p->parent_exec_id = current->self_exec_id;
 	}
 
+	retval = TCMI_HOOKS_CALL(in_fork, p);
+    if ( retval ) {
+		spin_unlock(&current->sighand->siglock);
+		write_unlock_irq(&tasklist_lock);
+		goto bad_fork_free_pid;
+	}
+
 	spin_lock(&current->sighand->siglock);
 
 	/*
@@ -1587,6 +1595,11 @@
 	struct task_struct *p;
 	int trace = 0;
 	long nr;
+	long tcmi_res;
+
+	tcmi_res = TCMI_HOOKS_CALL(pre_fork, clone_flags, stack_start, regs, stack_size, parent_tidptr, child_tidptr);
+	if ( tcmi_res < 0 )
+		return tcmi_res;
 
 	/*
 	 * Do some preliminary argument and permissions checking before we
@@ -1623,6 +1636,11 @@
 
 	p = copy_process(clone_flags, stack_start, regs, stack_size,
 			 child_tidptr, NULL, trace);
+	
+	// TODO: Check if call to ..._vnr is correct
+	tcmi_res = TCMI_HOOKS_CALL(post_fork, p, IS_ERR(p) ? PTR_ERR(p) : task_pid_vnr(p), tcmi_res, parent_tidptr, child_tidptr);
+			 
+
 	/*
 	 * Do this prior waking up the new thread - the thread pointer
 	 * might get invalid after that point, if the thread exits quickly.
@@ -1653,12 +1671,18 @@
 			if (!wait_for_vfork_done(p, &vfork))
 				ptrace_event(PTRACE_EVENT_VFORK_DONE, nr);
 		}
-	} else {
+		   
+       if ( tcmi_res )
+       nr = tcmi_res;
+  
+    } else {
 		nr = PTR_ERR(p);
 	}
 	return nr;
 }
 
+EXPORT_SYMBOL(do_fork);
+
 #ifndef ARCH_MIN_MMSTRUCT_ALIGN
 #define ARCH_MIN_MMSTRUCT_ALIGN 0
 #endif
diff -Naur linux-3.6.11_original/linux-3.6.11/kernel/groups.c linux-3.6.11/kernel/groups.c
--- linux-3.6.11_original/linux-3.6.11/kernel/groups.c	2012-12-17 18:27:45.000000000 +0100
+++ linux-3.6.11/kernel/groups.c	2013-04-06 14:43:33.000000000 +0200
@@ -223,6 +223,8 @@
 	return i;
 }
 
+EXPORT_SYMBOL(sys_getgroups);
+
 /*
  *	SMP: Our groups are copy-on-write. We can set them safely
  *	without another task interfering.
@@ -253,6 +255,8 @@
 	return retval;
 }
 
+EXPORT_SYMBOL(sys_setgroups);
+
 /*
  * Check whether we're fsgid/egid or in the supplemental group..
  */
diff -Naur linux-3.6.11_original/linux-3.6.11/kernel/sched/core.c linux-3.6.11/kernel/sched/core.c
--- linux-3.6.11_original/linux-3.6.11/kernel/sched/core.c	2012-12-17 18:27:45.000000000 +0100
+++ linux-3.6.11/kernel/sched/core.c	2013-04-06 14:46:11.000000000 +0200
@@ -8329,6 +8329,7 @@
 #endif	/* CONFIG_CGROUP_SCHED */
 
 #ifdef CONFIG_CGROUP_CPUACCT
+EXPORT_SYMBOL(tasklist_lock);
 
 /*
  * CPU accounting code for task groups.
diff -Naur linux-3.6.11_original/linux-3.6.11/kernel/signal.c linux-3.6.11/kernel/signal.c
--- linux-3.6.11_original/linux-3.6.11/kernel/signal.c	2012-12-17 18:27:45.000000000 +0100
+++ linux-3.6.11/kernel/signal.c	2013-04-06 14:54:20.000000000 +0200
@@ -39,6 +39,7 @@
 #include <asm/siginfo.h>
 #include <asm/cacheflush.h>
 #include "audit.h"	/* audit_signal_info() */
+#include <clondike/tcmi/tcmi_hooks.h>
 
 /*
  * SLAB caches for signal bits.
@@ -984,6 +985,9 @@
 	    !(signal->flags & (SIGNAL_UNKILLABLE | SIGNAL_GROUP_EXIT)) &&
 	    !sigismember(&t->real_blocked, sig) &&
 	    (sig == SIGKILL || !t->ptrace)) {
+		
+		TCMI_HOOKS_CALL(doing_sigfatal, sig, sig_kernel_coredump(sig));
+
 		/*
 		 * This signal will be fatal to the whole group.
 		 */
@@ -1150,6 +1154,8 @@
 {
 	int from_ancestor_ns = 0;
 
+	TCMI_HOOKS_CALL(send_sig, sig);	
+
 #ifdef CONFIG_PID_NS
 	from_ancestor_ns = si_fromuser(info) &&
 			   !task_pid_nr_ns(current, task_active_pid_ns(t));
@@ -2273,12 +2279,21 @@
 		if (!signr)
 			break; /* will return 0 */
 
+		TCMI_HOOKS_CALL(deq_sig, signr);
+
 		if (unlikely(current->ptrace) && signr != SIGKILL) {
 			signr = ptrace_signal(signr, info,
 					      regs, cookie);
 			if (!signr)
 				continue;
 		}
+		else
+		{
+      	// Clondike fix for patch 3.6.11 by Jiri Rakosnik
+      	// Add only else part
+    	  TCMI_HOOKS_CALL(group_stop, current->signal->group_stop_count);
+    
+	    }
 
 		ka = &sighand->action[signr-1];
 
@@ -2317,6 +2332,14 @@
 				!sig_kernel_only(signr))
 			continue;
 
+		/* TCMI - SIGUNUSED is reserved for TCMI handling - switching to migration mode */
+		if (signr == SIGUNUSED) {
+			spin_unlock_irq(&current->sighand->siglock);
+			TCMI_HOOKS_CALL(sig_unused, regs);
+			goto relock;
+		}
+
+
 		if (sig_kernel_stop(signr)) {
 			/*
 			 * The default action is to stop all threads in
@@ -2340,7 +2363,8 @@
 			}
 
 			if (likely(do_signal_stop(info->si_signo))) {
-				/* It released the siglock.  */
+				TCMI_HOOKS_CALL(did_stop, signr);
+ 				/* It released the siglock.  */
 				goto relock;
 			}
 
@@ -2379,6 +2403,7 @@
 		/* NOTREACHED */
 	}
 	spin_unlock_irq(&sighand->siglock);
+	TCMI_HOOKS_CALL(sig_delivered, signr);	
 	return signr;
 }
 
@@ -2857,6 +2882,11 @@
 {
 	struct siginfo info;
 
+	TCMI_TASK_GUEST{
+		printk(KERN_INFO "Forwading sys_kill(pid=%d, sig=%d)\n", pid, sig);
+		return TCMI_HOOKS_CALL(sys_kill, pid, sig);
+	}	
+
 	info.si_signo = sig;
 	info.si_errno = 0;
 	info.si_code = SI_USER;
@@ -2866,6 +2896,8 @@
 	return kill_something_info(sig, &info, pid);
 }
 
+EXPORT_SYMBOL(sys_kill);
+
 static int
 do_send_specific(pid_t tgid, pid_t pid, int sig, struct siginfo *info)
 {
@@ -2896,7 +2928,7 @@
 	return error;
 }
 
-static int do_tkill(pid_t tgid, pid_t pid, int sig)
+int do_tkill(pid_t tgid, pid_t pid, int sig)
 {
 	struct siginfo info;
 
@@ -2908,6 +2940,7 @@
 
 	return do_send_specific(tgid, pid, sig, &info);
 }
+EXPORT_SYMBOL(do_tkill);
 
 /**
  *  sys_tgkill - send signal to one specific thread
@@ -2971,6 +3004,7 @@
 	/* POSIX.1b doesn't mention process groups.  */
 	return kill_proc_info(sig, &info, pid);
 }
+EXPORT_SYMBOL(sys_rt_sigqueueinfo);
 
 long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t *info)
 {
@@ -3002,6 +3036,8 @@
 	return do_rt_tgsigqueueinfo(tgid, pid, sig, &info);
 }
 
+EXPORT_SYMBOL(do_sigaction);
+
 int do_sigaction(int sig, struct k_sigaction *act, struct k_sigaction *oact)
 {
 	struct task_struct *t = current;
diff -Naur linux-3.6.11_original/linux-3.6.11/kernel/sys.c linux-3.6.11/kernel/sys.c
--- linux-3.6.11_original/linux-3.6.11/kernel/sys.c	2012-12-17 18:27:45.000000000 +0100
+++ linux-3.6.11/kernel/sys.c	2013-04-06 15:06:44.000000000 +0200
@@ -55,6 +55,7 @@
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/unistd.h>
+#include <clondike/tcmi/tcmi_hooks.h>
 
 #ifndef SET_UNALIGN_CTL
 # define SET_UNALIGN_CTL(a,b)	(-EINVAL)
@@ -232,6 +233,7 @@
 	return error;
 }
 
+EXPORT_SYMBOL(sys_setpriority);
 /*
  * Ugh. To avoid negative return values, "getpriority()" will
  * not return the normal nice-value, but a negated value that
@@ -302,6 +304,8 @@
 	return retval;
 }
 
+EXPORT_SYMBOL(sys_getpriority);
+
 /**
  *	emergency_restart - reboot the system
  *
@@ -607,6 +611,8 @@
 	return retval;
 }
 
+EXPORT_SYMBOL(sys_setregid);
+
 /*
  * setgid() is implemented like SysV w/ SAVED_IDS 
  *
@@ -644,6 +650,7 @@
 	return retval;
 }
 
+EXPORT_SYMBOL(sys_setgid);
 /*
  * change the user struct in a credentials set to match the new UID
  */
@@ -747,6 +754,8 @@
 	abort_creds(new);
 	return retval;
 }
+
+EXPORT_SYMBOL(sys_setreuid);
 		
 /*
  * setuid() is implemented like SysV with SAVED_IDS 
@@ -801,6 +810,8 @@
 	return retval;
 }
 
+EXPORT_SYMBOL(sys_setuid);
+
 
 /*
  * This function implements a generic ability to update ruid, euid,
@@ -871,6 +882,8 @@
 	return retval;
 }
 
+EXPORT_SYMBOL(sys_setresuid);
+
 SYSCALL_DEFINE3(getresuid, uid_t __user *, ruidp, uid_t __user *, euidp, uid_t __user *, suidp)
 {
 	const struct cred *cred = current_cred();
@@ -888,6 +901,8 @@
 	return retval;
 }
 
+EXPORT_SYMBOL(sys_getresuid);
+
 /*
  * Same as above, but for rgid, egid, sgid.
  */
@@ -960,6 +975,8 @@
 	return retval;
 }
 
+EXPORT_SYMBOL(sys_getresgid);
+
 
 /*
  * "setfsuid()" sets the fsuid - the uid used for filesystem checks. This
@@ -1003,6 +1020,8 @@
 	return old_fsuid;
 }
 
+EXPORT_SYMBOL(sys_setfsuid);
+
 /*
  * Samma pÃ¥ svenska..
  */
@@ -1041,6 +1060,8 @@
 	return old_fsgid;
 }
 
+EXPORT_SYMBOL(sys_setfsgid);
+
 void do_sys_times(struct tms *tms)
 {
 	cputime_t tgutime, tgstime, cutime, cstime;
@@ -1069,6 +1090,8 @@
 	return (long) jiffies_64_to_clock_t(get_jiffies_64());
 }
 
+EXPORT_SYMBOL(sys_times);
+
 /*
  * This needs some heavy checking ...
  * I just haven't the stomach for it. I also don't fully
@@ -1152,6 +1175,8 @@
 	return err;
 }
 
+EXPORT_SYMBOL(sys_setpgid);
+
 SYSCALL_DEFINE1(getpgid, pid_t, pid)
 {
 	struct task_struct *p;
@@ -1180,13 +1205,15 @@
 	return retval;
 }
 
+EXPORT_SYMBOL(sys_getpgid);
+
 #ifdef __ARCH_WANT_SYS_GETPGRP
 
 SYSCALL_DEFINE0(getpgrp)
 {
 	return sys_getpgid(0);
 }
-
+EXPORT_SYMBOL(sys_getpgrp);
 #endif
 
 SYSCALL_DEFINE1(getsid, pid_t, pid)
@@ -1195,6 +1222,10 @@
 	struct pid *sid;
 	int retval;
 
+	TCMI_TASK_GUEST{
+		return TCMI_HOOKS_CALL(sys_getsid, pid);
+	}
+
 	rcu_read_lock();
 	if (!pid)
 		sid = task_session(current);
@@ -1217,6 +1248,8 @@
 	return retval;
 }
 
+EXPORT_SYMBOL(sys_getsid);
+
 SYSCALL_DEFINE0(setsid)
 {
 	struct task_struct *group_leader = current->group_leader;
@@ -1224,6 +1257,10 @@
 	pid_t session = pid_vnr(sid);
 	int err = -EPERM;
 
+	TCMI_TASK_GUEST{
+		return TCMI_HOOKS_CALL(sys_setsid);
+	}
+
 	write_lock_irq(&tasklist_lock);
 	/* Fail if I am already a session leader */
 	if (group_leader->signal->leader)
@@ -1249,6 +1286,7 @@
 	}
 	return err;
 }
+EXPORT_SYMBOL(sys_setsid);
 
 DECLARE_RWSEM(uts_sem);
 
@@ -1307,6 +1345,8 @@
 	return errno;
 }
 
+EXPORT_SYMBOL(sys_newuname);
+
 #ifdef __ARCH_WANT_SYS_OLD_UNAME
 /*
  * Old cruft
@@ -1389,6 +1429,8 @@
 	return errno;
 }
 
+EXPORT_SYMBOL(sys_sethostname);
+
 #ifdef __ARCH_WANT_SYS_GETHOSTNAME
 
 SYSCALL_DEFINE2(gethostname, char __user *, name, int, len)
@@ -1396,6 +1438,8 @@
 	int i, errno;
 	struct new_utsname *u;
 
+	// TODO: Forward this call to home node?
+
 	if (len < 0)
 		return -EINVAL;
 	down_read(&uts_sem);
@@ -1410,6 +1454,8 @@
 	return errno;
 }
 
+EXPORT_SYMBOL(sys_gethostname);
+
 #endif
 
 /*
@@ -1440,6 +1486,8 @@
 	return errno;
 }
 
+EXPORT_SYMBOL(sys_setdomainname);
+
 SYSCALL_DEFINE2(getrlimit, unsigned int, resource, struct rlimit __user *, rlim)
 {
 	struct rlimit value;
@@ -1452,6 +1500,8 @@
 	return ret;
 }
 
+EXPORT_SYMBOL(sys_getrlimit);
+
 #ifdef __ARCH_WANT_SYS_OLD_GETRLIMIT
 
 /*
@@ -1650,6 +1700,8 @@
 	return do_prlimit(current, resource, &new_rlim, NULL);
 }
 
+EXPORT_SYMBOL(sys_setrlimit);
+
 /*
  * It would make sense to put struct rusage in the task_struct,
  * except that would make the task_struct be *really big*.  After
@@ -1774,6 +1826,8 @@
 	return copy_to_user(ru, &r, sizeof(r)) ? -EFAULT : 0;
 }
 
+EXPORT_SYMBOL(getrusage);
+
 SYSCALL_DEFINE2(getrusage, int, who, struct rusage __user *, ru)
 {
 	if (who != RUSAGE_SELF && who != RUSAGE_CHILDREN &&
@@ -1781,12 +1835,14 @@
 		return -EINVAL;
 	return getrusage(current, who, ru);
 }
+EXPORT_SYMBOL(sys_getrusage);
 
 SYSCALL_DEFINE1(umask, int, mask)
 {
 	mask = xchg(&current->fs->umask, mask & S_IRWXUGO);
 	return mask;
 }
+EXPORT_SYMBOL(sys_umask);
 
 #ifdef CONFIG_CHECKPOINT_RESTORE
 static int prctl_set_mm_exe_file(struct mm_struct *mm, unsigned int fd)
@@ -2170,6 +2226,8 @@
 	return error;
 }
 
+EXPORT_SYMBOL(sys_prctl);
+
 SYSCALL_DEFINE3(getcpu, unsigned __user *, cpup, unsigned __user *, nodep,
 		struct getcpu_cache __user *, unused)
 {
@@ -2182,6 +2240,9 @@
 	return err ? -EFAULT : 0;
 }
 
+EXPORT_SYMBOL(sys_getcpu);
+
+
 char poweroff_cmd[POWEROFF_CMD_PATH_LEN] = "/sbin/poweroff";
 
 static void argv_cleanup(struct subprocess_info *info)
diff -Naur linux-3.6.11_original/linux-3.6.11/kernel/timer.c linux-3.6.11/kernel/timer.c
--- linux-3.6.11_original/linux-3.6.11/kernel/timer.c	2012-12-17 18:27:45.000000000 +0100
+++ linux-3.6.11/kernel/timer.c	2013-04-06 15:14:55.000000000 +0200
@@ -46,6 +46,7 @@
 #include <asm/div64.h>
 #include <asm/timex.h>
 #include <asm/io.h>
+#include <clondike/tcmi/tcmi_hooks.h>
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/timer.h>
@@ -1406,6 +1407,7 @@
 {
 	return alarm_setitimer(seconds);
 }
+EXPORT_SYMBOL(sys_alarm);
 
 #endif
 
@@ -1420,8 +1422,12 @@
  */
 SYSCALL_DEFINE0(getpid)
 {
+	TCMI_TASK_GUEST{
+		return TCMI_HOOKS_CALL(sys_getpid);
+	}
 	return task_tgid_vnr(current);
 }
+EXPORT_SYMBOL(sys_getpid);
 
 /*
  * Accessing ->real_parent is not SMP-safe, it could
@@ -1433,36 +1439,58 @@
 {
 	int pid;
 
+	TCMI_TASK_GUEST{
+		return TCMI_HOOKS_CALL(sys_getppid);
+	}	
+
 	rcu_read_lock();
 	pid = task_tgid_vnr(rcu_dereference(current->real_parent));
 	rcu_read_unlock();
 
 	return pid;
 }
+EXPORT_SYMBOL(sys_getppid);
 
 SYSCALL_DEFINE0(getuid)
 {
+	TCMI_TASK_GUEST{
+		return TCMI_HOOKS_CALL(sys_getgid);
+	}
 	/* Only we change this so SMP safe */
 	return from_kuid_munged(current_user_ns(), current_uid());
 }
+EXPORT_SYMBOL(sys_getuid);
 
 SYSCALL_DEFINE0(geteuid)
 {
+	TCMI_TASK_GUEST{
+		return TCMI_HOOKS_CALL(sys_geteuid);
+	}
 	/* Only we change this so SMP safe */
 	return from_kuid_munged(current_user_ns(), current_euid());
 }
+EXPORT_SYMBOL(sys_geteuid);
 
 SYSCALL_DEFINE0(getgid)
 {
+	TCMI_TASK_GUEST{
+		return TCMI_HOOKS_CALL(sys_getgid);
+	}
 	/* Only we change this so SMP safe */
 	return from_kgid_munged(current_user_ns(), current_gid());
 }
+EXPORT_SYMBOL(sys_getgid);
+
 
 SYSCALL_DEFINE0(getegid)
 {
+	TCMI_TASK_GUEST{
+		return TCMI_HOOKS_CALL(sys_getegid);
+	}
 	/* Only we change this so SMP safe */
 	return from_kgid_munged(current_user_ns(), current_egid());
 }
+EXPORT_SYMBOL(sys_getegid);
 
 static void process_timeout(unsigned long __data)
 {
@@ -1576,6 +1604,7 @@
 {
 	return task_pid_vnr(current);
 }
+EXPORT_SYMBOL(sys_gettid);
 
 /**
  * do_sysinfo - fill in sysinfo struct
@@ -1655,6 +1684,7 @@
 
 	return 0;
 }
+EXPORT_SYMBOL(sys_sysinfo);
 
 static int __cpuinit init_timers_cpu(int cpu)
 {
diff -Naur linux-3.6.11_original/linux-3.6.11/Makefile linux-3.6.11/Makefile
--- linux-3.6.11_original/linux-3.6.11/Makefile	2012-12-17 18:27:45.000000000 +0100
+++ linux-3.6.11/Makefile	2013-04-06 15:16:12.000000000 +0200
@@ -504,7 +504,7 @@
 
 # Objects we will link into vmlinux / subdirs we need to visit
 init-y		:= init/
-drivers-y	:= drivers/ sound/ firmware/
+drivers-y	:= drivers/ sound/ firmware/ clondike/
 net-y		:= net/
 libs-y		:= lib/
 core-y		:= usr/
@@ -553,7 +553,7 @@
 # command line.
 # This allow a user to issue only 'make' to build a kernel including modules
 # Defaults to vmlinux, but the arch makefile usually adds further targets
-all: vmlinux
+all: clondike_symlink vmlinux
 
 ifdef CONFIG_CC_OPTIMIZE_FOR_SIZE
 KBUILD_CFLAGS	+= -Os
@@ -1398,3 +1398,5 @@
 # Declare the contents of the .PHONY variable as phony.  We keep that
 # information in a variable so we can use it in if_changed and friends.
 .PHONY: $(PHONY)
+clondike_symlink:
+	(ln -fsn $(ARCH) clondike/src/arch/current)
\ No newline at end of file
diff -Naur linux-3.6.11_original/linux-3.6.11/mm/memory.c linux-3.6.11/mm/memory.c
--- linux-3.6.11_original/linux-3.6.11/mm/memory.c	2012-12-17 18:27:45.000000000 +0100
+++ linux-3.6.11/mm/memory.c	2013-04-06 15:17:46.000000000 +0200
@@ -56,6 +56,7 @@
 #include <linux/kallsyms.h>
 #include <linux/swapops.h>
 #include <linux/elf.h>
+#include <clondike/tcmi/tcmi_dbg.h>
 #include <linux/gfp.h>
 
 #include <asm/io.h>
@@ -3438,6 +3439,11 @@
 	pte_t entry;
 	spinlock_t *ptl;
 
+	TCMI_ON_DEBUG {
+		printk(KERN_DEBUG "Handling pte fault at %lx, write_access = %d\n", 
+		       address, (flags & FAULT_FLAG_WRITE));
+	}	
+
 	entry = *pte;
 	if (!pte_present(entry)) {
 		if (pte_none(entry)) {
diff -Naur linux-3.6.11_original/linux-3.6.11/mm/mmap.c linux-3.6.11/mm/mmap.c
--- linux-3.6.11_original/linux-3.6.11/mm/mmap.c	2012-12-17 18:27:45.000000000 +0100
+++ linux-3.6.11/mm/mmap.c	2013-04-06 15:18:29.000000000 +0200
@@ -2531,6 +2531,7 @@
 	kmem_cache_free(vm_area_cachep, vma);
 	return ret;
 }
+EXPORT_SYMBOL(install_special_mapping);
 
 static DEFINE_MUTEX(mm_all_locks_mutex);
 
diff -Naur linux-3.6.11_original/linux-3.6.11/scripts/Makefile linux-3.6.11/scripts/Makefile
--- linux-3.6.11_original/linux-3.6.11/scripts/Makefile	2012-12-17 18:27:45.000000000 +0100
+++ linux-3.6.11/scripts/Makefile	2013-04-06 15:18:46.000000000 +0200
@@ -16,6 +16,7 @@
 hostprogs-$(CONFIG_IKCONFIG)     += bin2c
 hostprogs-$(BUILD_C_RECORDMCOUNT) += recordmcount
 hostprogs-$(CONFIG_BUILDTIME_EXTABLE_SORT) += sortextable
+hostprogs-$(CONFIG_TCMI)	+= ../clondike/src/scripts/dbgenv
 
 HOSTCFLAGS_sortextable.o = -I$(srctree)/tools/include
 
