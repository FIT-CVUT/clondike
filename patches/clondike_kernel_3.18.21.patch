diff -Naur linux-3.18.21-vanilla/arch/x86/Kconfig linux-3.18.21/arch/x86/Kconfig
--- linux-3.18.21-vanilla/arch/x86/Kconfig	2015-12-14 07:28:13.655627461 +0100
+++ linux-3.18.21/arch/x86/Kconfig	2015-10-09 15:50:15.000000000 +0200
@@ -2513,3 +2513,5 @@
 source "arch/x86/kvm/Kconfig"
 
 source "lib/Kconfig"
+
+source "clondike/Kconfig"
diff -Naur linux-3.18.21-vanilla/arch/x86/kernel/entry_64.S linux-3.18.21/arch/x86/kernel/entry_64.S
--- linux-3.18.21-vanilla/arch/x86/kernel/entry_64.S	2015-12-14 07:28:13.659627485 +0100
+++ linux-3.18.21/arch/x86/kernel/entry_64.S	2015-12-13 10:48:52.776605396 +0100
@@ -642,7 +642,7 @@
 	CFI_ENDPROC
 END(ptregscall_common)
 
-ENTRY(stub_execve)
+ENTRY(stub_execve_clondike)
 	CFI_STARTPROC
 	addq $8, %rsp
 	PARTIAL_FRAME 0
@@ -650,10 +650,19 @@
 	FIXUP_TOP_OF_STACK %r11
 	call sys_execve
 	movq %rax,RAX(%rsp)
+	testq %rax,%rax
+	jnz failedexec
+	/*CLONDIKE modify -  After we've checked return value, we set rax to value of orig rax */
+	movq ORIG_RAX(%rsp), %rax
+	/*CLONDIKE modify -  And in addition we need to set eax to RAX pt regs to correctly survive args restore */
+	movq %rax, RAX(%rsp)
 	RESTORE_REST
 	jmp int_ret_from_sys_call
+failedexec:
+	RESTORE_REST
 	CFI_ENDPROC
-END(stub_execve)
+END(stub_execve_clondike)
+
 
 /*
  * sigreturn is special because it needs to restore all registers on return.
@@ -672,6 +681,20 @@
 	CFI_ENDPROC
 END(stub_rt_sigreturn)
 
+
+ENTRY(stub_execve)
+	CFI_STARTPROC
+	addq $8, %rsp
+	PARTIAL_FRAME 0
+	SAVE_REST                                                                                                  
+	FIXUP_TOP_OF_STACK %r11                                                                                    
+	call sys_execve                                                                                           
+	movq %rax,RAX(%rsp)                                                                                      
+	RESTORE_REST                                                                                             
+	jmp int_ret_from_sys_call                                                                               
+	CFI_ENDPROC                                                                                         
+END(stub_execve)                                                                                           
+
 #ifdef CONFIG_X86_X32_ABI
 ENTRY(stub_x32_rt_sigreturn)
 	CFI_STARTPROC
@@ -1119,6 +1142,36 @@
 	jmp  2b
 	.previous
 
+ /* 
+ In clondike version of we set orig rax value into the register, instead of rax value of pt_regs. 
+ This way, we are able to restore non-zero values, as rax must be zero after successful sys_execve.. 
+ */
+ENTRY(clondike_execve)
+	CFI_STARTPROC
+	FAKE_STACK_FRAME $0
+	SAVE_ALL	
+	movq %rsp,%rcx
+	call sys_execve	
+	movq %rax, RAX(%rsp)
+	testq %rax,%rax
+	jnz failedexecve
+	/* After we've checked return value, we set rax to value of orig rax */
+	movq ORIG_RAX(%rsp), %rax
+	/* And in addition we need to set eax to RAX pt regs to correctly survive args restore */
+	movq %rax, RAX(%rsp)
+
+	RESTORE_REST	
+	jmp int_ret_from_sys_call
+failedexecve:
+	RESTORE_REST	
+	RESTORE_ARGS
+	UNFAKE_STACK_FRAME
+	ret
+	CFI_ENDPROC
+ENDPROC(clondike_execve)
+
+
+
 /* Call softirq on interrupt stack. Interrupts are off. */
 ENTRY(do_softirq_own_stack)
 	CFI_STARTPROC
diff -Naur linux-3.18.21-vanilla/arch/x86/kernel/process_64.c linux-3.18.21/arch/x86/kernel/process_64.c
--- linux-3.18.21-vanilla/arch/x86/kernel/process_64.c	2015-12-14 07:28:13.659627485 +0100
+++ linux-3.18.21/arch/x86/kernel/process_64.c	2015-09-14 10:45:05.000000000 +0200
@@ -250,6 +250,7 @@
 	start_thread_common(regs, new_ip, new_sp,
 			    __USER_CS, __USER_DS, 0);
 }
+EXPORT_SYMBOL_GPL(start_thread);
 
 #ifdef CONFIG_IA32_EMULATION
 void start_thread_ia32(struct pt_regs *regs, u32 new_ip, u32 new_sp)
diff -Naur linux-3.18.21-vanilla/arch/x86/kernel/x8664_ksyms_64.c linux-3.18.21/arch/x86/kernel/x8664_ksyms_64.c
--- linux-3.18.21-vanilla/arch/x86/kernel/x8664_ksyms_64.c	2015-12-14 07:28:13.663627509 +0100
+++ linux-3.18.21/arch/x86/kernel/x8664_ksyms_64.c	2015-12-13 10:49:02.648673098 +0100
@@ -42,6 +42,12 @@
 
 EXPORT_SYMBOL(csum_partial);
 
+int stub_execve_clondike(const char *filename, char *const argv[], char *const envp[]);
+EXPORT_SYMBOL(stub_execve_clondike);
+
+int clondike_execve(const char *filename, char *const argv[], char *const envp[]);
+EXPORT_SYMBOL(clondike_execve);
+
 /*
  * Export string functions. We normally rely on gcc builtin for most of these,
  * but gcc sometimes decides not to inline them.
diff -Naur linux-3.18.21-vanilla/arch/x86/mm/fault.c linux-3.18.21/arch/x86/mm/fault.c
--- linux-3.18.21-vanilla/arch/x86/mm/fault.c	2015-12-14 07:28:13.671627557 +0100
+++ linux-3.18.21/arch/x86/mm/fault.c	2015-12-14 13:42:21.100748062 +0100
@@ -10,6 +10,7 @@
 #include <linux/kprobes.h>		/* NOKPROBE_SYMBOL, ...		*/
 #include <linux/mmiotrace.h>		/* kmmio_handler, ...		*/
 #include <linux/perf_event.h>		/* perf_sw_event		*/
+#include <clondike/tcmi/tcmi_dbg.h>
 #include <linux/hugetlb.h>		/* hstate_index_to_shift	*/
 #include <linux/prefetch.h>		/* prefetchw			*/
 #include <linux/context_tracking.h>	/* exception_enter(), ...	*/
@@ -822,7 +823,11 @@
 	 * Fix it, but check if it's kernel or user first..
 	 */
 	up_read(&mm->mmap_sem);
-
+	
+	TCMI_ON_DEBUG {
+		printk(KERN_DEBUG "Sending SIGSEGV - bad area at %lx, PID: %d\n", address, current->pid);
+		// dump_stack();
+	}
 	__bad_area_nosemaphore(regs, error_code, address, si_code);
 }
 
@@ -985,6 +990,11 @@
 	if (!ret)
 		return 0;
 
+	 /* TCMI testing */
+  TCMI_ON_DEBUG {
+  	printk(KERN_INFO "Begin page fault at %lx\n", address);
+  }
+
 	/*
 	 * Make sure we have permissions in PMD.
 	 * If not, then there's a bug in the page tables:
@@ -1100,6 +1110,12 @@
 		if (spurious_fault(error_code, address))
 			return;
 
+		/* TCMI testing */
+	   	TCMI_ON_DEBUG {
+  			printk(KERN_INFO "Not in kernel space - page fault at %lx \n", address);
+   		}
+
+
 		/* kprobes don't want to hook the spurious faults: */
 		if (kprobes_fault(regs))
 			return;
@@ -1129,6 +1145,10 @@
 	 * in an atomic region then we must not take the fault:
 	 */
 	if (unlikely(in_atomic() || !mm)) {
+		/* TCMI testing */
+		TCMI_ON_DEBUG {
+			printk(KERN_INFO "going to no sem in atomic=%d, mm=%p, page fault at %lx\n", in_atomic(), mm, address);
+		}
 		bad_area_nosemaphore(regs, error_code, address);
 		return;
 	}
@@ -1189,12 +1209,25 @@
 
 	vma = find_vma(mm, address);
 	if (unlikely(!vma)) {
+		TCMI_ON_DEBUG {
+			printk(KERN_DEBUG "Can't find VMA for address %lx\n", address);
+		}
 		bad_area(regs, error_code, address);
 		return;
 	}
-	if (likely(vma->vm_start <= address))
+	if (likely(vma->vm_start <= address)) {
+		/* TCMI testing */
+		TCMI_ON_DEBUG {
+			printk(KERN_DEBUG "Address (%lx) in vm area, good area\n", address);
+		}	
 		goto good_area;
+    }
 	if (unlikely(!(vma->vm_flags & VM_GROWSDOWN))) {
+		/* TCMI testing */
+		TCMI_ON_DEBUG {
+			printk(KERN_DEBUG "Address (%lx) not in vm area, and area (start %lx) not VM_GROWSDOWN\n", 
+			       address, vma->vm_start);
+		}	 
 		bad_area(regs, error_code, address);
 		return;
 	}
@@ -1206,11 +1239,19 @@
 		 * 32 pointers and then decrements %sp by 65535.)
 		 */
 		if (unlikely(address + 65536 + 32 * sizeof(unsigned long) < regs->sp)) {
+			/* TCMI testing */
+			TCMI_ON_DEBUG {
+				printk(KERN_DEBUG "User space stack expansion at %lx\n", address);
+			}	
 			bad_area(regs, error_code, address);
 			return;
 		}
 	}
 	if (unlikely(expand_stack(vma, address))) {
+		/* TCMI testing */
+		TCMI_ON_DEBUG {
+			printk(KERN_DEBUG "Failed to expand stack at %lx\n", address);
+		}
 		bad_area(regs, error_code, address);
 		return;
 	}
@@ -1220,6 +1261,11 @@
 	 * we can handle it..
 	 */
 good_area:
+	/* TCMI testing */
+	TCMI_ON_DEBUG {
+		printk(KERN_DEBUG "Good area at %lx, error code was %lx\n", address, error_code);
+	}
+	
 	if (unlikely(access_error(error_code, vma))) {
 		bad_area_access_error(regs, error_code, address);
 		return;
@@ -1282,7 +1328,12 @@
 {
 	unsigned long address = read_cr2(); /* Get the faulting address */
 	enum ctx_state prev_state;
-
+	
+	/* TCMI testing */
+  	TCMI_ON_DEBUG {
+  		printk(KERN_INFO "Begin page fault at %lx\n", address);
+	}
+	
 	/*
 	 * We must have this function tagged with __kprobes, notrace and call
 	 * read_cr2() before calling anything else. To avoid calling any kind
diff -Naur linux-3.18.21-vanilla/arch/x86/vdso/vma.c linux-3.18.21/arch/x86/vdso/vma.c
--- linux-3.18.21-vanilla/arch/x86/vdso/vma.c	2015-09-01 00:19:23.000000000 +0200
+++ linux-3.18.21/arch/x86/vdso/vma.c	2015-10-09 16:36:25.000000000 +0200
@@ -219,6 +219,7 @@
 
 	return map_vdso(&vdso_image_64, true);
 }
+EXPORT_SYMBOL(arch_setup_additional_pages);
 
 #ifdef CONFIG_COMPAT
 int compat_arch_setup_additional_pages(struct linux_binprm *bprm,
@@ -243,6 +244,7 @@
 }
 #endif
 
+
 #ifdef CONFIG_X86_64
 static __init int vdso_setup(char *s)
 {
diff -Naur linux-3.18.21-vanilla/clondike/Kconfig linux-3.18.21/clondike/Kconfig
--- linux-3.18.21-vanilla/clondike/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.18.21/clondike/Kconfig	2015-12-13 11:43:59.397097818 +0100
@@ -0,0 +1,57 @@
+#
+# Clondike
+#
+
+menu "Clondike"
+
+config TCMI
+	tristate "Enable TCMI"
+	select TCMI_HOOKS
+	help
+	  Clondike is a clustering project started at FEE CTU Prague.
+	  To read more see project website at http://clondike.felk.cvut.cz
+	  Since 2012 is being developed at FIT CTU Prague, project website at https://github.com/FIT-CVUT/Clondike
+	  This option enables Task Checkpointing and Migration Infrastructure(TCMI) 
+	  support in the kernel. 
+	
+
+	  If unsure, say N.
+
+config TCMI_HOOKS
+	bool "TCMI hooks"
+	depends on TCMI
+	help
+	  This option enables kernel hooks used by Task Checkpointing
+	  and Migration Infrastructure(TCMI) to intercept various system
+	  calls and install migration mode handler. 
+
+
+config TCMI_CCN
+	bool "Enable TCMI CCN support"
+	depends on TCMI
+	help
+	  Enables Cluster Core Node (CCN) support in TCMI framework.
+
+
+	  If unsure, say N.
+
+config TCMI_PEN
+	bool "Enable TCMI PEN support"
+	depends on TCMI
+	help
+	  Enables Process Execution Node (PEN) support in TCMI framework.
+
+
+	  If unsure, say N.
+
+config TCMI_DEBUG
+	bool "Enable TCMI debug messages"
+	depends on TCMI
+	help
+	  Enables TCMI debug messages
+	
+	
+	  If unsure, say N.
+
+endmenu
+
diff -Naur linux-3.18.21-vanilla/clondike/Makefile linux-3.18.21/clondike/Makefile
--- linux-3.18.21-vanilla/clondike/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.18.21/clondike/Makefile	2015-12-13 11:43:59.397097818 +0100
@@ -0,0 +1,7 @@
+# Builds the Clondike system
+#
+#
+obj-y += tcmi/
+ifeq ($(CONFIG_TCMI),y)
+	obj-y += src/
+endif
diff -Naur linux-3.18.21-vanilla/clondike/tcmi/Makefile linux-3.18.21/clondike/tcmi/Makefile
--- linux-3.18.21-vanilla/clondike/tcmi/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.18.21/clondike/tcmi/Makefile	2015-12-13 11:43:59.397097818 +0100
@@ -0,0 +1,6 @@
+#
+# Makefile for TCMI components required to be built into kernel
+#
+# 
+
+obj-$(CONFIG_TCMI_HOOKS) :=	tcmi_hooks.o tcmi_dbg.o
diff -Naur linux-3.18.21-vanilla/clondike/tcmi/tcmi_dbg.c linux-3.18.21/clondike/tcmi/tcmi_dbg.c
--- linux-3.18.21-vanilla/clondike/tcmi/tcmi_dbg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.18.21/clondike/tcmi/tcmi_dbg.c	2015-12-13 11:43:59.397097818 +0100
@@ -0,0 +1,6 @@
+#include <clondike/tcmi/tcmi_dbg.h>
+#include <linux/cache.h>
+#include <linux/module.h>
+
+int tcmi_dbg __read_mostly = 1;
+EXPORT_SYMBOL_GPL(tcmi_dbg);
diff -Naur linux-3.18.21-vanilla/clondike/tcmi/tcmi_hooks.c linux-3.18.21/clondike/tcmi/tcmi_hooks.c
--- linux-3.18.21-vanilla/clondike/tcmi/tcmi_hooks.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.18.21/clondike/tcmi/tcmi_hooks.c	2015-12-13 11:43:59.397097818 +0100
@@ -0,0 +1,21 @@
+/**
+ * @file tcmi_hooks.c - Definition of all hooks in kernel requires only
+ *                      including the header file as private
+ * 
+ * 
+ * 
+ * 
+ * 
+ *
+ * Date: 04/21/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: linux-2.6.23-uml-clondike.patch,v 1.1 2009-01-20 14:22:16 andrep1 Exp $
+ *
+ * License....
+ */
+
+#define TCMI_HOOKS_FACTORY_PRIVATE
+#include <clondike/tcmi/tcmi_hooks.h>
+
+/*Mutex for access critical variable tcmi_parent*/
+DEFINE_SEMAPHORE(tcmi_parent_lock);
+
+struct semaphore* tcmi_parent_lock_get(void) {
+   return &tcmi_parent_lock;
+}
+
diff -Naur linux-3.18.21-vanilla/fs/9p/fid.c linux-3.18.21/fs/9p/fid.c
--- linux-3.18.21-vanilla/fs/9p/fid.c	2015-12-14 07:28:13.679627605 +0100
+++ linux-3.18.21/fs/9p/fid.c	2015-12-14 15:04:13.828639865 +0100
@@ -152,6 +152,11 @@
 		if (v9fs_proto_dotu(v9ses) || v9fs_proto_dotl(v9ses))
 				uname = NULL;
 		else
+            /* Anyway does not work with our npfs | by Jiri Rakosnik
+             * if (v9fs_proto_dotu(v9ses) || v9fs_proto_dotl(v9ses))
+             *     uname = NULL;
+             * else
+             */
 			uname = v9ses->uname;
 
 		fid = p9_client_attach(v9ses->clnt, NULL, uname, uid,
diff -Naur linux-3.18.21-vanilla/fs/9p/v9fs.c linux-3.18.21/fs/9p/v9fs.c
--- linux-3.18.21-vanilla/fs/9p/v9fs.c	2015-12-14 07:28:13.679627605 +0100
+++ linux-3.18.21/fs/9p/v9fs.c	2015-12-13 10:49:11.836736153 +0100
@@ -51,6 +51,9 @@
 enum {
 	/* Options that take integer arguments */
 	Opt_debug, Opt_dfltuid, Opt_dfltgid, Opt_afid,
+	/* This id will be alias with clondike user id (==999)... in stat this id will be present, but internally 999 user will be marked as owner to pass security checks */
+	Opt_clondike_uid, 
+	Opt_clondike_gid, 
 	/* String options */
 	Opt_uname, Opt_remotename, Opt_trans, Opt_cache, Opt_cachetag,
 	/* Options that take no arguments */
@@ -68,6 +71,8 @@
 	{Opt_dfltuid, "dfltuid=%u"},
 	{Opt_dfltgid, "dfltgid=%u"},
 	{Opt_afid, "afid=%u"},
+	{Opt_clondike_uid, "cuid=%x"},
+	{Opt_clondike_gid, "cgid=%x"},
 	{Opt_uname, "uname=%s"},
 	{Opt_remotename, "aname=%s"},
 	{Opt_nodevmap, "nodevmap"},
@@ -127,6 +132,12 @@
 	v9ses->cachetag = NULL;
 #endif
 
+	v9ses->cuid.val = 999; // By default clondike user id is used so that no aliasing is performed
+	v9ses->cgid.val = 999; // By default clondike group id is used so that no aliasing is performed
+
+	/* v9ses->cuid = 999; // By default clondike user id is used so that no aliasing is performed */
+	/* v9ses->cgid = 999; // By default clondike group id is used so that no aliasing is performed */
+
 	if (!opts)
 		return 0;
 
@@ -199,6 +210,14 @@
 			}
 			v9ses->afid = option;
 			break;
+		
+		case Opt_clondike_uid:
+			v9ses->cuid.val = option;
+			break;
+		case Opt_clondike_gid:
+			v9ses->cgid.val = option;
+			break;
+
 		case Opt_uname:
 			kfree(v9ses->uname);
 			v9ses->uname = match_strdup(&args[0]);
diff -Naur linux-3.18.21-vanilla/fs/9p/v9fs.h linux-3.18.21/fs/9p/v9fs.h
--- linux-3.18.21-vanilla/fs/9p/v9fs.h	2015-12-14 07:28:13.679627605 +0100
+++ linux-3.18.21/fs/9p/v9fs.h	2015-12-14 13:59:54.655584420 +0100
@@ -107,6 +107,10 @@
 	struct fscache_cookie *fscache;
 #endif
 
+
+	kuid_t cuid;	/* Clondike aliased user id */
+  	kgid_t cgid;	/* Clondike aliased group id */
+
 	char *uname;		/* user name to mount as */
 	char *aname;		/* name of remote hierarchy being mounted */
 	unsigned int maxdata;	/* max data for client interface */
diff -Naur linux-3.18.21-vanilla/fs/9p/vfs_inode.c linux-3.18.21/fs/9p/vfs_inode.c
--- linux-3.18.21-vanilla/fs/9p/vfs_inode.c	2015-12-14 07:28:13.679627605 +0100
+++ linux-3.18.21/fs/9p/vfs_inode.c	2015-10-11 16:51:59.000000000 +0200
@@ -280,9 +280,6 @@
 	inode->i_mapping->a_ops = &v9fs_addr_operations;
 
 	switch (mode & S_IFMT) {
-	case S_IFIFO:
-	case S_IFBLK:
-	case S_IFCHR:
 	case S_IFSOCK:
 		if (v9fs_proto_dotl(v9ses)) {
 			inode->i_op = &v9fs_file_inode_operations_dotl;
@@ -296,6 +293,9 @@
 		}
 		init_special_inode(inode, inode->i_mode, inode->i_rdev);
 		break;
+	case S_IFIFO:
+	case S_IFBLK:
+	case S_IFCHR:
 	case S_IFREG:
 		if (v9fs_proto_dotl(v9ses)) {
 			inode->i_op = &v9fs_file_inode_operations_dotl;
@@ -381,7 +381,15 @@
 			__func__, task_pid_nr(current));
 		return ERR_PTR(-ENOMEM);
 	}
-	err = v9fs_init_inode(v9ses, inode, mode, rdev);
+	// Clondike fix for kernel 3.6.11 by Jiri Rakosnik
+	if ( inode->i_uid.val == v9ses->cuid.val )
+	// Make clondike aliasing
+		inode->i_uid.val = 999;
+	if ( inode->i_gid.val == v9ses->cgid.val )
+		// Make clondike aliasing
+		inode->i_gid.val = 999;
+	// End Clondike fix
+ 	err = v9fs_init_inode(v9ses, inode, mode, rdev);
 	if (err) {
 		iput(inode);
 		return ERR_PTR(err);
@@ -1073,6 +1081,13 @@
 
 	v9fs_stat2inode(st, dentry->d_inode, dentry->d_inode->i_sb);
 	generic_fillattr(dentry->d_inode, stat);
+	
+	// If we were aliased, do unaliasing here so that user sees stats as if on home node.
+	// TODO: Note that here we may unalias also files previously not aliased..
+	if ( dentry->d_inode->i_uid.val == 999 )
+		stat->uid = v9ses->cuid;
+	if ( dentry->d_inode->i_gid.val == 999 )
+		stat->gid = v9ses->cgid;	
 
 	p9stat_free(st);
 	kfree(st);
@@ -1176,6 +1191,17 @@
 		inode->i_uid = stat->n_uid;
 		inode->i_gid = stat->n_gid;
 	}
+
+	// Clondike fix by Jiri Rakosnik
+	if ( inode->i_uid.val == v9ses->cuid.val )
+		// Make clondike aliasing
+		inode->i_uid.val = 999;
+	if ( inode->i_gid.val == v9ses->cgid.val )
+		// Make clondike aliasing
+		inode->i_gid.val = 999;
+	// End Clondike fix
+
+
 	if ((S_ISREG(inode->i_mode)) || (S_ISDIR(inode->i_mode))) {
 		if (v9fs_proto_dotu(v9ses) && (stat->extension[0] != '\0')) {
 			/*
diff -Naur linux-3.18.21-vanilla/fs/exec.c linux-3.18.21/fs/exec.c
--- linux-3.18.21-vanilla/fs/exec.c	2015-12-14 07:28:13.679627605 +0100
+++ linux-3.18.21/fs/exec.c	2015-12-14 09:13:21.851989862 +0100
@@ -63,6 +63,7 @@
 
 #include <trace/events/task.h>
 #include "internal.h"
+#include <clondike/tcmi/tcmi_hooks.h>
 
 #include <trace/events/sched.h>
 
@@ -1473,6 +1474,9 @@
 		retval = -EAGAIN;
 		goto out_ret;
 	}
+	
+	// Clondike for kernel 3.18.21 fix this macro, convert type argv and regs by Zdenek Novy
+	TCMI_HOOKS_CALL(execve, filename->name, argv.ptr.native, envp.ptr.native, NULL); 	/* TCMI system call hook */
 
 	/* We're below the limit (still or again), so we don't want to make
 	 * further execve() calls fail. */
@@ -1569,6 +1573,8 @@
 	return retval;
 }
 
+EXPORT_SYMBOL(do_execve);
+
 int do_execve(struct filename *filename,
 	const char __user *const __user *__argv,
 	const char __user *const __user *__envp)
diff -Naur linux-3.18.21-vanilla/fs/file.c linux-3.18.21/fs/file.c
--- linux-3.18.21-vanilla/fs/file.c	2015-09-01 00:19:23.000000000 +0200
+++ linux-3.18.21/fs/file.c	2015-12-16 15:18:55.867097238 +0100
@@ -862,6 +862,7 @@
 	}
 	return sys_dup3(oldfd, newfd, 0);
 }
+EXPORT_SYMBOL(sys_dup2);
 
 SYSCALL_DEFINE1(dup, unsigned int, fildes)
 {
diff -Naur linux-3.18.21-vanilla/fs/namei.c linux-3.18.21/fs/namei.c
--- linux-3.18.21-vanilla/fs/namei.c	2015-12-14 07:28:13.683627629 +0100
+++ linux-3.18.21/fs/namei.c	2015-10-07 15:35:56.000000000 +0200
@@ -1603,7 +1603,7 @@
 
 	do {
 		struct path link = *path;
-		void *cookie;
+		void *cookie = NULL;
 
 		res = follow_link(&link, nd, &cookie);
 		if (res)
@@ -1960,7 +1960,7 @@
 	if (!err && !(flags & LOOKUP_PARENT)) {
 		err = lookup_last(nd, &path);
 		while (err > 0) {
-			void *cookie;
+			void *cookie = NULL;
 			struct path link = path;
 			err = may_follow_link(&link, nd);
 			if (unlikely(err))
@@ -2313,7 +2313,7 @@
 
 	err = mountpoint_last(&nd, path);
 	while (err > 0) {
-		void *cookie;
+		void *cookie = NULL;
 		struct path link = *path;
 		err = may_follow_link(&link, &nd);
 		if (unlikely(err))
@@ -3212,7 +3212,7 @@
 	error = do_last(nd, &path, file, op, &opened, pathname);
 	while (unlikely(error > 0)) { /* trailing symlink */
 		struct path link = path;
-		void *cookie;
+		void *cookie = NULL;
 		if (!(nd->flags & LOOKUP_FOLLOW)) {
 			path_put_conditional(&path, nd);
 			path_put(&nd->path);
@@ -4392,7 +4392,7 @@
 int generic_readlink(struct dentry *dentry, char __user *buffer, int buflen)
 {
 	struct nameidata nd;
-	void *cookie;
+	void *cookie = NULL;
 	int res;
 
 	nd.depth = 0;
diff -Naur linux-3.18.21-vanilla/fs/namespace.c linux-3.18.21/fs/namespace.c
--- linux-3.18.21-vanilla/fs/namespace.c	2015-12-14 07:28:13.683627629 +0100
+++ linux-3.18.21/fs/namespace.c	2015-10-07 15:44:26.000000000 +0200
@@ -1560,6 +1561,8 @@
 	return retval;
 }
 
+EXPORT_SYMBOL_GPL(sys_umount);
+
 #ifdef __ARCH_WANT_SYS_OLDUMOUNT
 
 /*
@@ -2659,6 +2662,8 @@
 	return retval;
 }
 
+EXPORT_SYMBOL(do_mount);
+
 static void free_mnt_ns(struct mnt_namespace *ns)
 {
 	proc_free_inum(ns->proc_inum);
diff -Naur linux-3.18.21-vanilla/fs/open.c linux-3.18.21/fs/open.c
--- linux-3.18.21-vanilla/fs/open.c	2015-12-14 07:28:13.687627653 +0100
+++ linux-3.18.21/fs/open.c	2015-10-07 15:45:11.000000000 +0200
@@ -1007,6 +1007,7 @@
 	putname(tmp);
 	return fd;
 }
+EXPORT_SYMBOL(do_sys_open);
 
 SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode)
 {
diff -Naur linux-3.18.21-vanilla/include/clondike/tcmi/tcmi_dbg.h linux-3.18.21/include/clondike/tcmi/tcmi_dbg.h
--- linux-3.18.21-vanilla/include/clondike/tcmi/tcmi_dbg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.18.21/include/clondike/tcmi/tcmi_dbg.h	2015-10-09 16:22:57.000000000 +0200
@@ -0,0 +1,32 @@
+/**
+* @file tcmi_dbg.h - Helper module when debugging TCMI tasks in kernel
+* 
+* 
+* 
+* 
+* 
+* 
+*
+* Date: 04/21/2005
+*
+* Author: Jan Capek
+*
+* $Id: linux-2.6.23-uml-clondike.patch,v 1.1 2009-01-20 14:22:16 andrep1 Exp $
+*
+* License....
+*/
+
+#ifndef _TCMI_DBG_H
+#define _TCMI_DBG_H
+
+
+extern int tcmi_dbg;
+
+#define TCMI_ON_DEBUG if (tcmi_dbg && current->tcmi.tcmi_task)
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_DBG_H */
+
diff -Naur linux-3.18.21-vanilla/include/clondike/tcmi/tcmi_hooks_factory.h linux-3.18.21/include/clondike/tcmi/tcmi_hooks_factory.h
--- linux-3.18.21-vanilla/include/clondike/tcmi/tcmi_hooks_factory.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.18.21/include/clondike/tcmi/tcmi_hooks_factory.h	2015-10-09 16:25:05.000000000 +0200
@@ -0,0 +1,125 @@
+/**
+ * @file tcmi_hooks_factory.h - Declaration of all a factory class that
+ *                              produces hooks declarations and definitions
+ * 
+ * 
+ * 
+ * 
+ * 
+ *
+ * Date: 04/21/2005
+ *
+ * Author: Jan Capek, based on lmmdefs.h by Martin Kacer
+ *
+ * $Id: linux-2.6.23-uml-clondike.patch,v 1.1 2009-01-20 14:22:16 andrep1 Exp $
+ *
+ * License....
+ */
+
+#ifndef _TCMI_HOOKS_FACTORY_H
+#define _TCMI_HOOKS_FACTORY_H
+
+
+/** @defgroup tcmi_hooks_factory_class tcmi_hooks_factory class 
+ * 
+ * This \<\<singleton\>\> class allows declaration and definition
+ * of new kernel hooks. A component that wants to create a new hook
+ * adds its definition in tcmi_hooks.h, using TCMI_HOOKS_DEFINE macro. 
+ * The hook method is then called using TCMI_HOOKS_CALL macro from
+ * appropriate place in the kernel. The parameters passed to the call
+ * must match the hook definition.
+ *
+ * Any module that wants to register a method that will always be
+ * called by the hook calls
+ * tcmi_hooks_register_NAME(custom_method). Where the NAME suffix is
+ * the identifier used in HOOK definition in tcmi_hooks.h.
+ * 
+ * The benefit of this solution, is that we have to export only one
+ * new symbol - the hook pointer. Everything else is handled by static
+ * inline methods or macros.
+ *
+ *
+ *@{
+ */
+
+/** 
+ * Defines a hook that requires:
+ *
+ * - declaration of new data type for the method that is to be
+ * registered. This method is then required as a parameter for the
+ * registration method.
+ *
+ * - declaration of registration/unregistration methods
+ * - declares the pointer to the hooks method
+ *
+ * In addition, since this file is also included by tcmi_hooks.c
+ * module it will define the registration and unregistration function,
+ * and a the default hook method - NULL
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+/* When used as private, we generate also definitions */
+#ifdef TCMI_HOOKS_FACTORY_PRIVATE
+/** 
+ * Following macro is used by the public TCMI_HOOKS_DEFINE to define the actual
+ * hook method pointer and export it. This is done in tcmi_hooks.c and the user
+ * doesn't have to worry about it anymore as it will get linked into the kernel.
+ */
+#define TCMI_HOOKS_DEFINE_PRIVATE(method, args...)					\
+tcmi_hooks_##method##_t *tcmi_hooks_##method = NULL;					\
+EXPORT_SYMBOL(tcmi_hooks_##method);					
+
+#else
+/* empty macro, when included from some place else*/
+#define TCMI_HOOKS_DEFINE_PRIVATE(method, args...)
+#endif /* TCMI_HOOKS_FACTORY_PRIVATE */
+
+/** 
+ * This macro is to declare the hook method pointer in tcmi_hooks.h.
+ * In the tcmi_hooks.c, it also defines the hook pointer.
+ */
+#define TCMI_HOOKS_DEFINE(method, args...)						\
+typedef long tcmi_hooks_##method##_t(args);						\
+extern tcmi_hooks_##method##_t *tcmi_hooks_##method;					\
+static inline void tcmi_hooks_register_##method(tcmi_hooks_##method##_t *method)	\
+{											\
+	tcmi_hooks_##method = method;							\
+}											\
+static inline void tcmi_hooks_unregister_##method(void)					\
+{											\
+	tcmi_hooks_##method = NULL;							\
+}											\
+TCMI_HOOKS_DEFINE_PRIVATE(method, args);
+
+
+
+/**
+ * Since each hook method returns an int, this macro generates an
+ * expression, that calls the hook method if one is defined.
+ * The value of the expression is 0, if no hook method has been registered.
+ * If there is a valid hook method registered, we get back the value
+ * returned by this method. 
+ *
+ * @param method - name of the method(e.g. exec) that
+ * is to be called
+ * @param args - arguments of the method
+ */
+#define TCMI_HOOKS_CALL(method, args...)		\
+({							\
+	int __tcmi_hook_ret = 0;			\
+ if (tcmi_hooks_##method != NULL)		\
+		__tcmi_hook_ret =			\
+			tcmi_hooks_##method(args);	\
+	__tcmi_hook_ret;				\
+})
+
+
+#define TCMI_TASK_GUEST if (current->tcmi.tcmi_task && current->tcmi.task_type == guest)
+
+/**
+ * @}
+ */
+ 
+#endif /* _TCMI_HOOKS_FACTORY_H */
+
diff -Naur linux-3.18.21-vanilla/include/clondike/tcmi/tcmi_hooks.h linux-3.18.21/include/clondike/tcmi/tcmi_hooks.h
--- linux-3.18.21-vanilla/include/clondike/tcmi/tcmi_hooks.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.18.21/include/clondike/tcmi/tcmi_hooks.h	2015-10-09 16:26:01.000000000 +0200
@@ -0,0 +1,107 @@
+/**
+ * @file tcmi_hooks.h - Declaration of all hooks that are to be used in the kernel.
+ * 
+ * 
+ * 
+ * 
+ * 
+ * 
+ *
+ * Date: 04/21/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: linux-2.6.23-uml-clondike.patch,v 1.1 2009-01-20 14:22:16 andrep1 Exp $
+ *
+ * License....
+ */
+
+#ifndef _TCMI_HOOKS_H
+#define _TCMI_HOOKS_H
+
+
+#include <clondike/tcmi/tcmi_hooks_factory.h>
+#include <asm/ptrace.h>
+#include <asm/siginfo.h>
+#include <linux/capability.h>
+#include <linux/resource.h>
+#include <linux/semaphore.h>
+
+/*For get global tcmi_parent_lock*/
+struct semaphore* tcmi_parent_lock_get(void);
+
+/** execve */
+TCMI_HOOKS_DEFINE(execve, const char *, const char * const*, const char * const*, struct pt_regs *);
+
+/** wait */
+TCMI_HOOKS_DEFINE(sys_wait4, pid_t, int __user *, int, struct rusage __user *);
+
+/** fork hooks */
+/** Called in the beginning of the fork */
+TCMI_HOOKS_DEFINE(pre_fork, unsigned long, unsigned long, struct pt_regs *, unsigned long, int __user *, int __user *);
+/** Called in the middle of fork (used to attach shadow/guest task to a newly forked task). Takes new child as a param */
+TCMI_HOOKS_DEFINE(in_fork, struct task_struct*);
+/** 
+ * Called in the end of the fork. Takes as param return value of fork, pid of process forked on associated CCN + result buffers (so that
+ * we can reset them, in case fork failed and we've filled them in prefork.
+ *
+ * The method is called after succesful fork, but befor the process is actually started
+ */
+TCMI_HOOKS_DEFINE(post_fork, struct task_struct*, long, pid_t, int __user *, int __user *);
+
+/** exit hook */
+TCMI_HOOKS_DEFINE(exit, long);
+
+/** syscalls **/
+/** signal */
+TCMI_HOOKS_DEFINE(sys_kill, int, int);
+TCMI_HOOKS_DEFINE(do_tkill, int, int, int);
+TCMI_HOOKS_DEFINE(sys_rt_sigqueueinfo, int, int, siginfo_t*);
+
+/** pid, gid and session manipulation */
+TCMI_HOOKS_DEFINE(sys_getpid, void);
+TCMI_HOOKS_DEFINE(sys_getppid, void);
+TCMI_HOOKS_DEFINE(sys_getpgid, pid_t);
+TCMI_HOOKS_DEFINE(sys_setpgid, pid_t, pid_t);
+TCMI_HOOKS_DEFINE(sys_getsid, pid_t);
+TCMI_HOOKS_DEFINE(sys_setsid, void);
+TCMI_HOOKS_DEFINE(sys_getpgrp, void);
+
+/** user identification */
+TCMI_HOOKS_DEFINE(sys_geteuid, void);
+TCMI_HOOKS_DEFINE(sys_getuid, void);
+TCMI_HOOKS_DEFINE(sys_getresuid, uid_t*, uid_t*, uid_t*);
+TCMI_HOOKS_DEFINE(sys_setresuid, uid_t, uid_t, uid_t);
+TCMI_HOOKS_DEFINE(sys_setuid, uid_t);
+TCMI_HOOKS_DEFINE(sys_setreuid, uid_t, uid_t);
+
+/** group identification */
+TCMI_HOOKS_DEFINE(sys_getegid, void);
+TCMI_HOOKS_DEFINE(sys_getgid, void);
+TCMI_HOOKS_DEFINE(sys_getgroups, int, gid_t *);
+TCMI_HOOKS_DEFINE(sys_getresgid, gid_t*, gid_t*, gid_t*);
+TCMI_HOOKS_DEFINE(sys_setgid, gid_t);
+TCMI_HOOKS_DEFINE(sys_setregid, gid_t, gid_t);
+TCMI_HOOKS_DEFINE(sys_setresgid, gid_t, gid_t, gid_t);
+TCMI_HOOKS_DEFINE(sys_setgroups, int, gid_t *);
+
+/** other */
+TCMI_HOOKS_DEFINE(sys_capget, cap_user_header_t, cap_user_data_t);
+
+
+/** SIGUNUSED default signal handler hook */
+TCMI_HOOKS_DEFINE(sig_unused, struct pt_regs*);
+TCMI_HOOKS_DEFINE(sig_deliver, int);
+TCMI_HOOKS_DEFINE(sig_delivered, int);
+TCMI_HOOKS_DEFINE(did_stop, int);
+TCMI_HOOKS_DEFINE(group_stop, int);
+TCMI_HOOKS_DEFINE(deq_sig, int);
+TCMI_HOOKS_DEFINE(send_sig, int);
+TCMI_HOOKS_DEFINE(doing_sigfatal, int, int);
+
+
+TCMI_HOOKS_DEFINE(replace_proc_self_file, const char*, const char**);
+
+
+#endif /* _TCMI_HOOKS_H */
+
diff -Naur linux-3.18.21-vanilla/include/clondike/tcmi/tcmi_struct.h linux-3.18.21/include/clondike/tcmi/tcmi_struct.h
--- linux-3.18.21-vanilla/include/clondike/tcmi/tcmi_struct.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.18.21/include/clondike/tcmi/tcmi_struct.h	2015-10-09 15:52:38.000000000 +0200
@@ -0,0 +1,58 @@
+/**
+ * @file tcmi_struct.h - Declaration of extension structure for task_struct
+ * 
+ * 
+ * 
+ * 
+ * 
+ * 
+ *
+ * Date: 04/26/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: linux-2.6.23-uml-clondike.patch,v 1.1 2009-01-20 14:22:16 andrep1 Exp $
+ *
+ * License....
+ */
+
+#ifndef _TCMI_STRUCT_H
+#define _TCMI_STRUCT_H
+
+/** handler method type - called when switching to migration mode. */
+typedef void mig_mode_handler_t(void);
+
+enum tcmi_task_type {
+	unresolved_type,
+	shadow,
+	shadow_detached, /** A task, that was shadow once, but it is now running on CCN and so it does not have remote guest */
+	guest
+};
+
+/** Compound structure that holds TCMI related information for
+ * shadow/stub tasks in the task_struct. There are 3 items:
+ * - migration mode handler - this allows the migration component to
+ * run a specific handler for each task. With this approach we can have
+ * CCN and PEN on the same node
+ * - data for the handler - contains a valid pointer to any data. It
+ * should be guaranteed by the component that performs task attaching,
+ * that the the process will retain an extra reference. 
+ * - tcmi_task - points to the tcmi task that describes either
+ * a shadow or a stub task. This data is interpreted by the migration
+ * mode handler.
+ */
+struct tcmi_struct {
+	/* migration mode handler */
+	mig_mode_handler_t *mig_mode_handler;
+	/* data for the handler */
+	void *data;
+	/* tcmi task associated with the handler */
+	void *tcmi_task;
+
+	enum tcmi_task_type task_type;
+};
+
+/**
+ * @}
+ */
+#endif /* _TCMI_STRUCT_H */
diff -Naur linux-3.18.21-vanilla/include/linux/init_task.h linux-3.18.21/include/linux/init_task.h
--- linux-3.18.21-vanilla/include/linux/init_task.h	2015-12-14 07:28:13.691627677 +0100
+++ linux-3.18.21/include/linux/init_task.h	2015-10-09 13:44:49.000000000 +0200
@@ -200,6 +200,8 @@
 	.parent		= &tsk,						\
 	.children	= LIST_HEAD_INIT(tsk.children),			\
 	.sibling	= LIST_HEAD_INIT(tsk.sibling),			\
+	.tcmi_parent	= NULL,						\
+	.nonmigratable	= 1,						\
 	.group_leader	= &tsk,						\
 	RCU_POINTER_INITIALIZER(real_cred, &init_cred),			\
 	RCU_POINTER_INITIALIZER(cred, &init_cred),			\
diff -Naur linux-3.18.21-vanilla/include/linux/sched.h linux-3.18.21/include/linux/sched.h
--- linux-3.18.21-vanilla/include/linux/sched.h	2015-12-14 07:28:13.691627677 +0100
+++ linux-3.18.21/include/linux/sched.h	2015-10-09 16:16:25.000000000 +0200
@@ -60,6 +60,7 @@
 #include <linux/magic.h>
 
 #include <asm/processor.h>
+#include <clondike/tcmi/tcmi_struct.h> /* TCMI extension */
 
 #define SCHED_ATTR_SIZE_VER0	48	/* sizeof first published struct */
 
@@ -1516,6 +1517,14 @@
 	int cpuset_mem_spread_rotor;
 	int cpuset_slab_spread_rotor;
 #endif
+
+#if defined CONFIG_TCMI || defined CONFIG_TCMI_MODULE
+	struct tcmi_struct tcmi;
+	unsigned long jiffies; /*Identifier of current task for Cassandra*/
+	struct task_struct __rcu *tcmi_parent; /*Pointer to parent original process from which was forked */
+	int nonmigratable;
+#endif
+
 #ifdef CONFIG_CGROUPS
 	/* Control Group info protected by css_set_lock */
 	struct css_set __rcu *cgroups;
diff -Naur linux-3.18.21-vanilla/include/linux/signal.h linux-3.18.21/include/linux/signal.h
--- linux-3.18.21-vanilla/include/linux/signal.h	2015-12-14 07:28:13.695627701 +0100
+++ linux-3.18.21/include/linux/signal.h	2015-10-09 17:35:57.000000000 +0200
@@ -389,17 +389,17 @@
 #define siginmask(sig, mask) (rt_sigmask(sig) & (mask))
 
 #define SIG_KERNEL_ONLY_MASK (\
-	rt_sigmask(SIGKILL)   |  rt_sigmask(SIGSTOP))
+	rt_sigmask(SIGKILL)   |  rt_sigmask(SIGSTOP)   |  rt_sigmask(SIGUNUSED))
 
 #define SIG_KERNEL_STOP_MASK (\
 	rt_sigmask(SIGSTOP)   |  rt_sigmask(SIGTSTP)   | \
-	rt_sigmask(SIGTTIN)   |  rt_sigmask(SIGTTOU)   )
+	rt_sigmask(SIGTTIN)   |  rt_sigmask(SIGTTOU)   |  rt_sigmask(SIGUNUSED))
 
 #define SIG_KERNEL_COREDUMP_MASK (\
         rt_sigmask(SIGQUIT)   |  rt_sigmask(SIGILL)    | \
 	rt_sigmask(SIGTRAP)   |  rt_sigmask(SIGABRT)   | \
         rt_sigmask(SIGFPE)    |  rt_sigmask(SIGSEGV)   | \
-	rt_sigmask(SIGBUS)    |  rt_sigmask(SIGSYS)    | \
+	rt_sigmask(SIGBUS)    |\
         rt_sigmask(SIGXCPU)   |  rt_sigmask(SIGXFSZ)   | \
 	SIGEMT_MASK				       )
 
diff -Naur linux-3.18.21-vanilla/kernel/capability.c linux-3.18.21/kernel/capability.c
--- linux-3.18.21-vanilla/kernel/capability.c	2015-12-14 07:28:13.695627701 +0100
+++ linux-3.18.21/kernel/capability.c	2015-10-09 13:52:05.000000000 +0200
@@ -18,6 +18,7 @@
 #include <linux/pid_namespace.h>
 #include <linux/user_namespace.h>
 #include <asm/uaccess.h>
+#include <clondike/tcmi/tcmi_hooks.h>
 
 /*
  * Leveraged for setting/resetting capabilities
@@ -155,7 +156,12 @@
 	ret = cap_validate_magic(header, &tocopy);
 	if ((dataptr == NULL) || (ret != 0))
 		return ((dataptr == NULL) && (ret == -EINVAL)) ? 0 : ret;
-
+	
+	TCMI_TASK_GUEST{
+	     printk(KERN_INFO "Forwading sys_capget()\n");
+             return TCMI_HOOKS_CALL(sys_capget, header, dataptr);
+ 	}
+	
 	if (get_user(pid, &header->pid))
 		return -EFAULT;
 
diff -Naur linux-3.18.21-vanilla/kernel/exit.c linux-3.18.21/kernel/exit.c
--- linux-3.18.21-vanilla/kernel/exit.c	2015-12-14 07:28:13.695627701 +0100
+++ linux-3.18.21/kernel/exit.c	2015-10-09 13:54:45.000000000 +0200
@@ -58,6 +58,7 @@
 #include <asm/unistd.h>
 #include <asm/pgtable.h>
 #include <asm/mmu_context.h>
+#include <clondike/tcmi/tcmi_hooks.h>
 
 static void exit_mm(struct task_struct *tsk);
 
@@ -668,8 +669,10 @@
 {
 	struct task_struct *tsk = current;
 	int group_dead;
-	TASKS_RCU(int tasks_rcu_i);
 
+	TCMI_HOOKS_CALL(exit, code); 	/* TCMI system call hook */
+	TASKS_RCU(int tasks_rcu_i);
+	
 	profile_task_exit(tsk);
 
 	WARN_ON(blk_needs_flush_plug(tsk));
@@ -1609,6 +1612,11 @@
 			__WNOTHREAD|__WCLONE|__WALL))
 		return -EINVAL;
 
+	TCMI_TASK_GUEST{
+		printk(KERN_INFO "Forwading sys_wait4()\n");
+		return TCMI_HOOKS_CALL(sys_wait4, upid, stat_addr, options, ru);
+	}
+
 	if (upid == -1)
 		type = PIDTYPE_MAX;
 	else if (upid < 0) {
@@ -1633,7 +1641,7 @@
 
 	return ret;
 }
-
+EXPORT_SYMBOL(sys_wait4);
 #ifdef __ARCH_WANT_SYS_WAITPID
 
 /*
diff -Naur linux-3.18.21-vanilla/kernel/fork.c linux-3.18.21/kernel/fork.c
--- linux-3.18.21-vanilla/kernel/fork.c	2015-12-14 07:28:13.695627701 +0100
+++ linux-3.18.21/kernel/fork.c	2015-10-09 17:11:54.000000000 +0200
@@ -86,6 +86,7 @@
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/task.h>
+#include <clondike/tcmi/tcmi_hooks.h>
 
 /*
  * Protected counters by write_lock_irq(&tasklist_lock)
@@ -1474,8 +1475,17 @@
 		p->real_parent = current;
 		p->parent_exec_id = current->self_exec_id;
 	}
+	
 
+	retval = TCMI_HOOKS_CALL(in_fork, p);
+	if ( retval ) {
+		spin_unlock(&current->sighand->siglock);
+		write_unlock_irq(&tasklist_lock);
+		goto bad_fork_free_pid;
+	}
+	
 	spin_lock(&current->sighand->siglock);
+	
 
 	/*
 	 * Copy seccomp details explicitly here, in case they were changed
@@ -1629,6 +1639,12 @@
 	struct task_struct *p;
 	int trace = 0;
 	long nr;
+	long tcmi_res;
+
+	// regs replaced by NULL, regs is not already used - kernel 3.18 by Jiri Rakosnik 
+	tcmi_res = TCMI_HOOKS_CALL(pre_fork, clone_flags, stack_start, NULL, stack_size, parent_tidptr, child_tidptr);
+	if ( tcmi_res < 0 )
+		return tcmi_res;
 
 	/*
 	 * Determine whether and which event to report to ptracer.  When
@@ -1650,6 +1666,10 @@
 
 	p = copy_process(clone_flags, stack_start, stack_size,
 			 child_tidptr, NULL, trace);
+
+	// TODO: Check if call to ..._vnr is correct
+	tcmi_res = TCMI_HOOKS_CALL(post_fork, p, IS_ERR(p) ? PTR_ERR(p) : task_pid_vnr(p), tcmi_res, parent_tidptr, child_tidptr);
+
 	/*
 	 * Do this prior waking up the new thread - the thread pointer
 	 * might get invalid after that point, if the thread exits quickly.
@@ -1684,12 +1704,15 @@
 		}
 
 		put_pid(pid);
+		if ( tcmi_res )	nr = tcmi_res;
 	} else {
 		nr = PTR_ERR(p);
 	}
 	return nr;
 }
 
+EXPORT_SYMBOL(do_fork);
+
 /*
  * Create a kernel thread.
  */
diff -Naur linux-3.18.21-vanilla/kernel/groups.c linux-3.18.21/kernel/groups.c
--- linux-3.18.21-vanilla/kernel/groups.c	2015-12-14 07:28:13.699627724 +0100
+++ linux-3.18.21/kernel/groups.c	2015-12-14 14:10:07.523563322 +0100
@@ -213,6 +213,7 @@
 out:
 	return i;
 }
+EXPORT_SYMBOL(sys_getgroups);
 
 bool may_setgroups(void)
 {
@@ -251,7 +252,7 @@
 
 	return retval;
 }
-
+EXPORT_SYMBOL(sys_setgroups);
 /*
  * Check whether we're fsgid/egid or in the supplemental group..
  */
+EXPORT_SYMBOL(sys_setgroups);
+
 /*
  * Check whether we're fsgid/egid or in the supplemental group..
  */
diff -Naur linux-3.18.21-vanilla/kernel/sched/core.c linux-3.18.21/kernel/sched/core.c
--- linux-3.18.21-vanilla/kernel/sched/core.c	2015-09-01 00:19:23.000000000 +0200
+++ linux-3.18.21/kernel/sched/core.c	2015-10-09 14:15:12.000000000 +0200
@@ -8269,3 +8269,5 @@
 	pr_info("Task dump for CPU %d:\n", cpu);
 	sched_show_task(cpu_curr(cpu));
 }
+
+EXPORT_SYMBOL(tasklist_lock);
diff -Naur linux-3.18.21-vanilla/kernel/signal.c linux-3.18.21/kernel/signal.c
--- linux-3.18.21-vanilla/kernel/signal.c	2015-12-14 07:28:13.703627748 +0100
+++ linux-3.18.21/kernel/signal.c	2015-10-28 21:51:44.000000000 +0100
@@ -44,6 +44,7 @@
 #include <asm/siginfo.h>
 #include <asm/cacheflush.h>
 #include "audit.h"	/* audit_signal_info() */
+#include <clondike/tcmi/tcmi_hooks.h>
 
 /*
  * SLAB caches for signal bits.
@@ -963,6 +964,9 @@
 	    !(signal->flags & (SIGNAL_UNKILLABLE | SIGNAL_GROUP_EXIT)) &&
 	    !sigismember(&t->real_blocked, sig) &&
 	    (sig == SIGKILL || !t->ptrace)) {
+		
+		TCMI_HOOKS_CALL(doing_sigfatal, sig, sig_kernel_coredump(sig));
+		
 		/*
 		 * This signal will be fatal to the whole group.
 		 */
@@ -1129,6 +1133,8 @@
 {
 	int from_ancestor_ns = 0;
 
+	TCMI_HOOKS_CALL(send_sig, sig);	
+
 #ifdef CONFIG_PID_NS
 	from_ancestor_ns = si_fromuser(info) &&
 			   !task_pid_nr_ns(current, task_active_pid_ns(t));
@@ -2245,11 +2251,18 @@
 		if (!signr)
 			break; /* will return 0 */
 
+		TCMI_HOOKS_CALL(deq_sig, signr);
+
 		if (unlikely(current->ptrace) && signr != SIGKILL) {
 			signr = ptrace_signal(signr, &ksig->info);
 			if (!signr)
 				continue;
 		}
+		else{
+	      		// Clondike fix for patch 3.6.11 by Jiri Rakosnik
+      			// Add only else part
+    	  		TCMI_HOOKS_CALL(group_stop, current->signal->group_stop_count);
+ 	  	}
 
 		ka = &sighand->action[signr-1];
 
@@ -2287,6 +2300,14 @@
 		if (unlikely(signal->flags & SIGNAL_UNKILLABLE) &&
 				!sig_kernel_only(signr))
 			continue;
+		
+		/* TCMI - SIGUNUSED is reserved for TCMI handling - switching to migration mode */
+		/* regs replaced by NULL - regs is not already used by Jiri Rakosnik */
+		if (signr == SIGUNUSED) {
+			spin_unlock_irq(&current->sighand->siglock);
+			TCMI_HOOKS_CALL(sig_unused, NULL);
+			goto relock;
+		}		
 
 		if (sig_kernel_stop(signr)) {
 			/*
@@ -2311,6 +2332,7 @@
 			}
 
 			if (likely(do_signal_stop(ksig->info.si_signo))) {
+				TCMI_HOOKS_CALL(did_stop, signr);
 				/* It released the siglock.  */
 				goto relock;
 			}
@@ -2351,7 +2373,7 @@
 		/* NOTREACHED */
 	}
 	spin_unlock_irq(&sighand->siglock);
-
+	TCMI_HOOKS_CALL(sig_delivered, signr);
 	ksig->sig = signr;
 	return ksig->sig > 0;
 }
@@ -2888,6 +2910,11 @@
 {
 	struct siginfo info;
 
+    TCMI_TASK_GUEST{
+        printk(KERN_INFO "Forwading sys_kill(pid=%d, sig=%d)\n", pid, sig);
+        return TCMI_HOOKS_CALL(sys_kill, pid, sig);
+    } 
+
 	info.si_signo = sig;
 	info.si_errno = 0;
 	info.si_code = SI_USER;
@@ -2896,6 +2918,7 @@
 
 	return kill_something_info(sig, &info, pid);
 }
+EXPORT_SYMBOL(sys_kill);
 
 static int
 do_send_specific(pid_t tgid, pid_t pid, int sig, struct siginfo *info)
@@ -2927,7 +2950,7 @@
 	return error;
 }
 
-static int do_tkill(pid_t tgid, pid_t pid, int sig)
+int do_tkill(pid_t tgid, pid_t pid, int sig)
 {
 	struct siginfo info = {};
 
@@ -2939,6 +2962,7 @@
 
 	return do_send_specific(tgid, pid, sig, &info);
 }
+EXPORT_SYMBOL(do_tkill);
 
 /**
  *  sys_tgkill - send signal to one specific thread
@@ -2991,6 +3015,7 @@
 	/* POSIX.1b doesn't mention process groups.  */
 	return kill_proc_info(sig, info, pid);
 }
+EXPORT_SYMBOL(sys_rt_sigqueueinfo);
 
 /**
  *  sys_rt_sigqueueinfo - send signal information to a signal
@@ -3130,6 +3157,7 @@
 	spin_unlock_irq(&p->sighand->siglock);
 	return 0;
 }
+EXPORT_SYMBOL(do_sigaction);
 
 static int
 do_sigaltstack (const stack_t __user *uss, stack_t __user *uoss, unsigned long sp)
diff -Naur linux-3.18.21-vanilla/kernel/sys.c linux-3.18.21/kernel/sys.c
--- linux-3.18.21-vanilla/kernel/sys.c	2015-12-14 07:28:13.707627772 +0100
+++ linux-3.18.21/kernel/sys.c	2015-10-09 15:35:48.000000000 +0200
@@ -60,6 +60,7 @@
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/unistd.h>
+#include <clondike/tcmi/tcmi_hooks.h>
 
 #ifndef SET_UNALIGN_CTL
 # define SET_UNALIGN_CTL(a, b)	(-EINVAL)
@@ -223,6 +224,7 @@
 out:
 	return error;
 }
+EXPORT_SYMBOL(sys_setpriority);
 
 /*
  * Ugh. To avoid negative return values, "getpriority()" will
@@ -294,6 +296,7 @@
 
 	return retval;
 }
+EXPORT_SYMBOL(sys_getpriority);
 
 /*
  * Unprivileged users may change the real gid to the effective gid
@@ -364,6 +367,7 @@
 	abort_creds(new);
 	return retval;
 }
+EXPORT_SYMBOL(sys_setregid);
 
 /*
  * setgid() is implemented like SysV w/ SAVED_IDS
@@ -401,6 +405,7 @@
 	abort_creds(new);
 	return retval;
 }
+EXPORT_SYMBOL(sys_setgid);
 
 /*
  * change the user struct in a credentials set to match the new UID
@@ -505,6 +510,7 @@
 	abort_creds(new);
 	return retval;
 }
+EXPORT_SYMBOL(sys_setreuid);
 
 /*
  * setuid() is implemented like SysV with SAVED_IDS
@@ -558,7 +564,7 @@
 	abort_creds(new);
 	return retval;
 }
-
+EXPORT_SYMBOL(sys_setuid);
 
 /*
  * This function implements a generic ability to update ruid, euid,
@@ -628,6 +634,7 @@
 	abort_creds(new);
 	return retval;
 }
+EXPORT_SYMBOL(sys_setresuid);
 
 SYSCALL_DEFINE3(getresuid, uid_t __user *, ruidp, uid_t __user *, euidp, uid_t __user *, suidp)
 {
@@ -647,6 +654,7 @@
 	}
 	return retval;
 }
+EXPORT_SYMBOL(sys_getresuid);
 
 /*
  * Same as above, but for rgid, egid, sgid.
@@ -722,6 +730,7 @@
 
 	return retval;
 }
+EXPORT_SYMBOL(sys_getresgid);
 
 
 /*
@@ -765,6 +774,7 @@
 	commit_creds(new);
 	return old_fsuid;
 }
+EXPORT_SYMBOL(sys_setfsuid);
 
 /*
  * Samma pÃ¥ svenska..
@@ -803,6 +813,7 @@
 	commit_creds(new);
 	return old_fsgid;
 }
+EXPORT_SYMBOL(sys_setfsgid);
 
 /**
  * sys_getpid - return the thread group id of the current process
@@ -815,14 +826,19 @@
  */
 SYSCALL_DEFINE0(getpid)
 {
+	TCMI_TASK_GUEST{
+		return TCMI_HOOKS_CALL(sys_getpid);
+	}
 	return task_tgid_vnr(current);
 }
+EXPORT_SYMBOL(sys_getpid);
 
 /* Thread ID - the internal kernel "pid" */
 SYSCALL_DEFINE0(gettid)
 {
 	return task_pid_vnr(current);
 }
+EXPORT_SYMBOL(sys_gettid);
 
 /*
  * Accessing ->real_parent is not SMP-safe, it could
@@ -833,37 +849,57 @@
 SYSCALL_DEFINE0(getppid)
 {
 	int pid;
-
+	
+	TCMI_TASK_GUEST{
+		return TCMI_HOOKS_CALL(sys_getppid);
+	}
 	rcu_read_lock();
 	pid = task_tgid_vnr(rcu_dereference(current->real_parent));
 	rcu_read_unlock();
 
 	return pid;
 }
+EXPORT_SYMBOL(sys_getppid);
 
 SYSCALL_DEFINE0(getuid)
 {
+	TCMI_TASK_GUEST{
+		return TCMI_HOOKS_CALL(sys_getgid);
+	}
 	/* Only we change this so SMP safe */
 	return from_kuid_munged(current_user_ns(), current_uid());
 }
+EXPORT_SYMBOL(sys_getuid);
 
 SYSCALL_DEFINE0(geteuid)
 {
+	TCMI_TASK_GUEST{
+		return TCMI_HOOKS_CALL(sys_geteuid);
+	}
 	/* Only we change this so SMP safe */
 	return from_kuid_munged(current_user_ns(), current_euid());
 }
+EXPORT_SYMBOL(sys_geteuid);
 
 SYSCALL_DEFINE0(getgid)
 {
+	TCMI_TASK_GUEST{
+		return TCMI_HOOKS_CALL(sys_getgid);
+	}
 	/* Only we change this so SMP safe */
 	return from_kgid_munged(current_user_ns(), current_gid());
 }
+EXPORT_SYMBOL(sys_getgid);
 
 SYSCALL_DEFINE0(getegid)
 {
+	TCMI_TASK_GUEST{
+		return TCMI_HOOKS_CALL(sys_getgid);
+	}
 	/* Only we change this so SMP safe */
 	return from_kgid_munged(current_user_ns(), current_egid());
 }
+EXPORT_SYMBOL(sys_getegid);
 
 void do_sys_times(struct tms *tms)
 {
@@ -890,6 +926,7 @@
 	force_successful_syscall_return();
 	return (long) jiffies_64_to_clock_t(get_jiffies_64());
 }
+EXPORT_SYMBOL(sys_times);
 
 /*
  * This needs some heavy checking ...
@@ -972,6 +1009,7 @@
 	rcu_read_unlock();
 	return err;
 }
+EXPORT_SYMBOL(sys_setpgid);
 
 SYSCALL_DEFINE1(getpgid, pid_t, pid)
 {
@@ -1000,6 +1038,7 @@
 	rcu_read_unlock();
 	return retval;
 }
+EXPORT_SYMBOL(sys_getpgid);
 
 #ifdef __ARCH_WANT_SYS_GETPGRP
 
@@ -1007,7 +1046,7 @@
 {
 	return sys_getpgid(0);
 }
-
+EXPORT_SYMBOL(sys_getpgrp);
 #endif
 
 SYSCALL_DEFINE1(getsid, pid_t, pid)
@@ -1016,6 +1055,10 @@
 	struct pid *sid;
 	int retval;
 
+	TCMI_TASK_GUEST{
+		return TCMI_HOOKS_CALL(sys_getsid, pid);
+	}
+
 	rcu_read_lock();
 	if (!pid)
 		sid = task_session(current);
@@ -1037,6 +1080,7 @@
 	rcu_read_unlock();
 	return retval;
 }
+EXPORT_SYMBOL(sys_getsid);
 
 static void set_special_pids(struct pid *pid)
 {
@@ -1055,7 +1099,10 @@
 	struct pid *sid = task_pid(group_leader);
 	pid_t session = pid_vnr(sid);
 	int err = -EPERM;
-
+	
+	TCMI_TASK_GUEST{
+		return TCMI_HOOKS_CALL(sys_setsid);
+	}
 	write_lock_irq(&tasklist_lock);
 	/* Fail if I am already a session leader */
 	if (group_leader->signal->leader)
@@ -1081,7 +1128,7 @@
 	}
 	return err;
 }
-
+EXPORT_SYMBOL(sys_setsid);
 DECLARE_RWSEM(uts_sem);
 
 #ifdef COMPAT_UTS_MACHINE
@@ -1138,6 +1185,7 @@
 		errno = -EFAULT;
 	return errno;
 }
+EXPORT_SYMBOL(sys_newuname);
 
 #ifdef __ARCH_WANT_SYS_OLD_UNAME
 /*
@@ -1220,6 +1268,7 @@
 	up_write(&uts_sem);
 	return errno;
 }
+EXPORT_SYMBOL(sys_sethostname);
 
 #ifdef __ARCH_WANT_SYS_GETHOSTNAME
 
@@ -1227,6 +1276,8 @@
 {
 	int i, errno;
 	struct new_utsname *u;
+	
+	// TODO: Forward this call to home node?
 
 	if (len < 0)
 		return -EINVAL;
@@ -1241,6 +1292,7 @@
 	up_read(&uts_sem);
 	return errno;
 }
+EXPORT_SYMBOL(sys_gethostname);
 
 #endif
 
@@ -1271,6 +1323,7 @@
 	up_write(&uts_sem);
 	return errno;
 }
+EXPORT_SYMBOL(sys_setdomainname);
 
 SYSCALL_DEFINE2(getrlimit, unsigned int, resource, struct rlimit __user *, rlim)
 {
@@ -1283,6 +1336,7 @@
 
 	return ret;
 }
+EXPORT_SYMBOL(sys_getrlimit);
 
 #ifdef __ARCH_WANT_SYS_OLD_GETRLIMIT
 
@@ -1480,6 +1534,7 @@
 		return -EFAULT;
 	return do_prlimit(current, resource, &new_rlim, NULL);
 }
+EXPORT_SYMBOL(sys_setrlimit);
 
 /*
  * It would make sense to put struct rusage in the task_struct,
@@ -1606,6 +1661,7 @@
 	return copy_to_user(ru, &r, sizeof(r)) ? -EFAULT : 0;
 }
 
+EXPORT_SYMBOL(getrusage);
 SYSCALL_DEFINE2(getrusage, int, who, struct rusage __user *, ru)
 {
 	if (who != RUSAGE_SELF && who != RUSAGE_CHILDREN &&
@@ -1613,6 +1669,7 @@
 		return -EINVAL;
 	return getrusage(current, who, ru);
 }
+EXPORT_SYMBOL(sys_getrusage);
 
 #ifdef CONFIG_COMPAT
 COMPAT_SYSCALL_DEFINE2(getrusage, int, who, struct compat_rusage __user *, ru)
@@ -1633,6 +1690,7 @@
 	mask = xchg(&current->fs->umask, mask & S_IRWXUGO);
 	return mask;
 }
+EXPORT_SYMBOL(sys_umask);
 
 static int prctl_set_mm_exe_file_locked(struct mm_struct *mm, unsigned int fd)
 {
@@ -2209,6 +2267,7 @@
 	}
 	return error;
 }
+EXPORT_SYMBOL(sys_prctl);
 
 SYSCALL_DEFINE3(getcpu, unsigned __user *, cpup, unsigned __user *, nodep,
 		struct getcpu_cache __user *, unused)
@@ -2222,6 +2281,7 @@
 		err |= put_user(cpu_to_node(cpu), nodep);
 	return err ? -EFAULT : 0;
 }
+EXPORT_SYMBOL(sys_getcpu);
 
 /**
  * do_sysinfo - fill in sysinfo struct
@@ -2300,6 +2360,7 @@
 
 	return 0;
 }
+EXPORT_SYMBOL(sys_sysinfo);
 
 #ifdef CONFIG_COMPAT
 struct compat_sysinfo {
diff -Naur linux-3.18.21-vanilla/kernel/time/timer.c linux-3.18.21/kernel/time/timer.c
--- linux-3.18.21-vanilla/kernel/time/timer.c	2015-09-01 00:19:23.000000000 +0200
+++ linux-3.18.21/kernel/time/timer.c	2015-10-09 15:28:17.000000000 +0200
@@ -48,6 +48,7 @@
 #include <asm/div64.h>
 #include <asm/timex.h>
 #include <asm/io.h>
+#include <clondike/tcmi/tcmi_hooks.h>
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/timer.h>
@@ -1423,6 +1424,7 @@
 {
 	return alarm_setitimer(seconds);
 }
+EXPORT_SYMBOL(sys_alarm);
 
 #endif
 
diff -Naur linux-3.18.21-vanilla/Makefile linux-3.18.21/Makefile
--- linux-3.18.21-vanilla/Makefile	2015-09-01 00:19:23.000000000 +0200
+++ linux-3.18.21/Makefile	2015-12-14 14:23:28.744770622 +0100
@@ -556,7 +556,7 @@
 
 # Objects we will link into vmlinux / subdirs we need to visit
 init-y		:= init/
-drivers-y	:= drivers/ sound/ firmware/
+drivers-y	:= drivers/ sound/ firmware/ clondike/
 net-y		:= net/
 libs-y		:= lib/
 core-y		:= usr/
@@ -605,7 +605,7 @@
 # command line.
 # This allow a user to issue only 'make' to build a kernel including modules
 # Defaults to vmlinux, but the arch makefile usually adds further targets
-all: vmlinux
+all: clondike_symlink vmlinux
 
 include $(srctree)/arch/$(SRCARCH)/Makefile
 
@@ -1594,3 +1594,7 @@
 # Declare the contents of the .PHONY variable as phony.  We keep that
 # information in a variable so we can use it in if_changed and friends.
 .PHONY: $(PHONY)
+
+clondike_symlink:
+		(ln -fsn $(ARCH) clondike/src/arch/current)
+
diff -Naur linux-3.18.21-vanilla/mm/memory.c linux-3.18.21/mm/memory.c
--- linux-3.18.21-vanilla/mm/memory.c	2015-09-01 00:19:23.000000000 +0200
+++ linux-3.18.21/mm/memory.c	2015-10-09 15:42:06.000000000 +0200
@@ -56,6 +56,7 @@
 #include <linux/kallsyms.h>
 #include <linux/swapops.h>
 #include <linux/elf.h>
+#include <clondike/tcmi/tcmi_dbg.h>
 #include <linux/gfp.h>
 #include <linux/migrate.h>
 #include <linux/string.h>
@@ -3194,6 +3195,11 @@
 {
 	pte_t entry;
 	spinlock_t *ptl;
+	
+	TCMI_ON_DEBUG {
+		printk(KERN_DEBUG "Handling pte fault at %lx, write_access = %d\n", 
+		       address, (flags & FAULT_FLAG_WRITE));
+	}	
 
 	entry = ACCESS_ONCE(*pte);
 	if (!pte_present(entry)) {
diff -Naur linux-3.18.21-vanilla/mm/mmap.c linux-3.18.21/mm/mmap.c
--- linux-3.18.21-vanilla/mm/mmap.c	2015-09-01 00:19:23.000000000 +0200
+++ linux-3.18.21/mm/mmap.c	2015-12-13 10:49:17.976778531 +0100
@@ -2786,8 +2787,9 @@
 	}
 	vm_unacct_memory(nr_accounted);
 
-	WARN_ON(atomic_long_read(&mm->nr_ptes) >
-			(FIRST_USER_ADDRESS+PMD_SIZE-1)>>PMD_SHIFT);
+	/* Fixed by Zdenek Novy (not in newer kernels) */
+	/*WARN_ON(atomic_long_read(&mm->nr_ptes) >
+				(FIRST_USER_ADDRESS+PMD_SIZE-1)>>PMD_SHIFT);*/
 }
 
 /* Insert vm structure into process list sorted by address
@@ -3047,6 +3049,7 @@
 
 	return PTR_ERR_OR_ZERO(vma);
 }
+EXPORT_SYMBOL(install_special_mapping);
 
 static DEFINE_MUTEX(mm_all_locks_mutex);
 
diff -Naur linux-3.18.21-vanilla/scripts/Makefile linux-3.18.21/scripts/Makefile
--- linux-3.18.21-vanilla/scripts/Makefile	2015-09-01 00:19:23.000000000 +0200
+++ linux-3.18.21/scripts/Makefile	2015-10-09 15:43:56.000000000 +0200
@@ -16,6 +16,7 @@
 hostprogs-$(BUILD_C_RECORDMCOUNT) += recordmcount
 hostprogs-$(CONFIG_BUILDTIME_EXTABLE_SORT) += sortextable
 hostprogs-$(CONFIG_ASN1)	 += asn1_compiler
+hostprogs-$(CONFIG_TCMI)	+= ../clondike/src/scripts/dbgenv
 
 HOSTCFLAGS_sortextable.o = -I$(srctree)/tools/include
 HOSTCFLAGS_asn1_compiler.o = -I$(srctree)/include
