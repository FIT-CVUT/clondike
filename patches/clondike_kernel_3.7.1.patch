diff -Naur linux-3.7.1_original/linux-3.7.1//arch/um/Kconfig.rest linux-3.7.1/arch/um/Kconfig.rest
--- linux-3.7.1_original/linux-3.7.1//arch/um/Kconfig.rest	2012-12-17 20:14:54.000000000 +0100
+++ linux-3.7.1/arch/um/Kconfig.rest	2013-01-10 23:55:32.000000000 +0100
@@ -6,6 +6,12 @@
 
 source "drivers/Kconfig"
 
+source "clondike/Kconfig"
+
+if BROKEN
+ 	source "drivers/mtd/Kconfig"
+endif
+
 source "net/Kconfig"
 
 source "arch/um/Kconfig.net"
diff -Naur linux-3.7.1_original/linux-3.7.1//arch/um/kernel/skas/clone.c linux-3.7.1/arch/um/kernel/skas/clone.c
--- linux-3.7.1_original/linux-3.7.1//arch/um/kernel/skas/clone.c	2012-12-17 20:14:54.000000000 +0100
+++ linux-3.7.1/arch/um/kernel/skas/clone.c	2013-01-15 13:53:30.000000000 +0100
@@ -6,6 +6,7 @@
 #include <signal.h>
 #include <sched.h>
 #include <asm/unistd.h>
+#include <asm/page.h>
 #include <sys/time.h>
 #include <as-layout.h>
 #include <ptrace_user.h>
diff -Naur linux-3.7.1_original/linux-3.7.1//arch/um/kernel/skas/syscall.c linux-3.7.1/arch/um/kernel/skas/syscall.c
--- linux-3.7.1_original/linux-3.7.1//arch/um/kernel/skas/syscall.c	2012-12-17 20:14:54.000000000 +0100
+++ linux-3.7.1/arch/um/kernel/skas/syscall.c	2013-01-15 13:56:59.000000000 +0100
@@ -8,6 +8,10 @@
 #include <kern_util.h>
 #include <sysdep/ptrace.h>
 #include <sysdep/syscalls.h>
+#include "linux/module.h"
+#include "longjmp.h"
+#include <clondike/tcmi/tcmi_dbg.h>
+
 
 extern int syscall_table_size;
 #define NR_SYSCALLS (syscall_table_size / sizeof(void *))
@@ -38,3 +42,38 @@
 
 	syscall_trace_leave(regs);
 }
+
+int clondike_kernel_execve(const char *filename, char *const argv[], char *const envp[])
+{
+        int ret = 0;
+        jmp_buf buf;
+        int n;
+
+        TCMI_ON_DEBUG
+        {
+         printk("clondike_kernel_execve: %s %p\n",filename,current->thread.exec_buf);
+        }
+
+        if(current->thread.exec_buf)
+        {
+                return kernel_execve(filename,argv,envp);
+        }
+
+        current->thread.exec_buf = &buf;
+        n = UML_SETJMP(&buf);
+        TCMI_ON_DEBUG
+        {
+         printk("clondike_kernel_execve - setjmp %d\n",n);
+        }
+        if(n == 0)kernel_execve(filename,argv,envp);
+        interrupt_end();
+        userspace(&current->thread.regs.regs);
+        TCMI_ON_DEBUG
+        {
+         printk("clondike_kernel_execve: %s ret: %d\n",filename,ret);
+        }
+        return ret;
+
+}
+
+EXPORT_SYMBOL(clondike_kernel_execve);
\ No newline at end of file
diff -Naur linux-3.7.1_original/linux-3.7.1//arch/x86/Kconfig linux-3.7.1/arch/x86/Kconfig
--- linux-3.7.1_original/linux-3.7.1//arch/x86/Kconfig	2012-12-17 20:14:54.000000000 +0100
+++ linux-3.7.1/arch/x86/Kconfig	2013-01-15 13:59:09.000000000 +0100
@@ -2255,3 +2255,5 @@
 source "arch/x86/kvm/Kconfig"
 
 source "lib/Kconfig"
+
+source "clondike/Kconfig"
diff -Naur linux-3.7.1_original/linux-3.7.1//arch/x86/kernel/entry_64.S linux-3.7.1/arch/x86/kernel/entry_64.S
--- linux-3.7.1_original/linux-3.7.1//arch/x86/kernel/entry_64.S	2012-12-17 20:14:54.000000000 +0100
+++ linux-3.7.1/arch/x86/kernel/entry_64.S	2013-03-12 14:20:33.000000000 +0100
@@ -1324,6 +1324,34 @@
 	jmp  2b
 	.previous
 
+ /* 
+ In clondike version of we set orig rax value into the register, instead of rax value of pt_regs. 
+ This way, we are able to restore non-zero values, as rax must be zero after successful sys_execve.. 
+ */
+ENTRY(clondike_execve)
+	CFI_STARTPROC
+	FAKE_STACK_FRAME $0
+	SAVE_ALL	
+	movq %rsp,%rcx
+	call sys_execve	
+	movq %rax, RAX(%rsp)
+	testq %rax,%rax
+	jnz failedexec
+	/* After we've checked return value, we set rax to value of orig rax */
+	movq ORIG_RAX(%rsp), %rax
+	/* And in addition we need to set eax to RAX pt regs to correctly survive args restore */
+	movq %rax, RAX(%rsp)
+
+	RESTORE_REST	
+	jmp int_ret_from_sys_call
+failedexec:
+	RESTORE_REST	
+	RESTORE_ARGS
+	UNFAKE_STACK_FRAME
+	ret
+	CFI_ENDPROC
+ENDPROC(clondike_execve)
+
 /* Call softirq on interrupt stack. Interrupts are off. */
 ENTRY(call_softirq)
 	CFI_STARTPROC
diff -Naur linux-3.7.1_original/linux-3.7.1//arch/x86/kernel/process_64.c linux-3.7.1/arch/x86/kernel/process_64.c
--- linux-3.7.1_original/linux-3.7.1//arch/x86/kernel/process_64.c	2012-12-17 20:14:54.000000000 +0100
+++ linux-3.7.1/arch/x86/kernel/process_64.c	2013-01-15 14:06:16.000000000 +0100
@@ -247,6 +247,7 @@
 	start_thread_common(regs, new_ip, new_sp,
 			    __USER_CS, __USER_DS, 0);
 }
+EXPORT_SYMBOL_GPL(start_thread);
 
 #ifdef CONFIG_IA32_EMULATION
 void start_thread_ia32(struct pt_regs *regs, u32 new_ip, u32 new_sp)
diff -Naur linux-3.7.1_original/linux-3.7.1//arch/x86/kernel/x8664_ksyms_64.c linux-3.7.1/arch/x86/kernel/x8664_ksyms_64.c
--- linux-3.7.1_original/linux-3.7.1//arch/x86/kernel/x8664_ksyms_64.c	2012-12-17 20:14:54.000000000 +0100
+++ linux-3.7.1/arch/x86/kernel/x8664_ksyms_64.c	2013-03-12 14:32:09.000000000 +0100
@@ -12,6 +12,8 @@
 #include <asm/desc.h>
 #include <asm/ftrace.h>
 
+#include <asm/desc.h>
+
 #ifdef CONFIG_FUNCTION_TRACER
 /* mcount and __fentry__ are defined in assembly */
 #ifdef CC_USING_FENTRY
@@ -42,6 +44,10 @@
 
 EXPORT_SYMBOL(csum_partial);
 
+int clondike_execve(const char *filename, char *const argv[], char *const envp[]);
+EXPORT_SYMBOL(clondike_execve);
+
+
 /*
  * Export string functions. We normally rely on gcc builtin for most of these,
  * but gcc sometimes decides not to inline them.
diff -Naur linux-3.7.1_original/linux-3.7.1//arch/x86/mm/fault.c linux-3.7.1/arch/x86/mm/fault.c
--- linux-3.7.1_original/linux-3.7.1//arch/x86/mm/fault.c	2012-12-17 20:14:54.000000000 +0100
+++ linux-3.7.1/arch/x86/mm/fault.c	2013-01-15 14:26:01.000000000 +0100
@@ -11,6 +11,7 @@
 #include <linux/kprobes.h>		/* __kprobes, ...		*/
 #include <linux/mmiotrace.h>		/* kmmio_handler, ...		*/
 #include <linux/perf_event.h>		/* perf_sw_event		*/
+#include <clondike/tcmi/tcmi_dbg.h> 
 #include <linux/hugetlb.h>		/* hstate_index_to_shift	*/
 #include <linux/prefetch.h>		/* prefetchw			*/
 
@@ -786,6 +787,11 @@
 	 * Fix it, but check if it's kernel or user first..
 	 */
 	up_read(&mm->mmap_sem);
+  
+  TCMI_ON_DEBUG {
+		printk(KERN_DEBUG "Sending SIGSEGV - bad area at %lx, PID: %d\n", address, current->pid);
+		// dump_stack();
+	}
 
 	__bad_area_nosemaphore(regs, error_code, address, si_code);
 }
@@ -1030,6 +1036,11 @@
 	/* Get the faulting address: */
 	address = read_cr2();
 
+  /* TCMI testing */
+  TCMI_ON_DEBUG {
+  	printk(KERN_INFO "Begin page fault at %lx\n", address);
+  }
+
 	/*
 	 * Detect and handle instructions that would cause a page fault for
 	 * both a tracked kernel page and a userspace page.
@@ -1078,6 +1089,11 @@
 
 		return;
 	}
+   /* TCMI testing */
+   TCMI_ON_DEBUG {
+  	printk(KERN_INFO "Not in kernel space - page fault at %lx \n", address);
+   }
+
 
 	/* kprobes don't want to hook the spurious faults: */
 	if (unlikely(notify_page_fault(regs)))
@@ -1114,6 +1130,11 @@
 	 * in an atomic region then we must not take the fault:
 	 */
 	if (unlikely(in_atomic() || !mm)) {
+    /* TCMI testing */
+		TCMI_ON_DEBUG {
+			printk(KERN_INFO "going to no sem in atomic=%d, mm=%p, page fault at %lx\n", in_atomic(), mm, address);
+		}
+  
 		bad_area_nosemaphore(regs, error_code, address);
 		return;
 	}
@@ -1153,13 +1174,27 @@
 
 	vma = find_vma(mm, address);
 	if (unlikely(!vma)) {
+    TCMI_ON_DEBUG {
+			printk(KERN_DEBUG "Can't find VMA for address %lx\n", address);
+		}
+  
 		bad_area(regs, error_code, address);
 		return;
 	}
-	if (likely(vma->vm_start <= address))
+	if (likely(vma->vm_start <= address)){
+    /* TCMI testing */
+		TCMI_ON_DEBUG {
+			printk(KERN_DEBUG "Address (%lx) in vm area, good area\n", address);
+		}
 		goto good_area;
+  }
 	if (unlikely(!(vma->vm_flags & VM_GROWSDOWN))) {
-		bad_area(regs, error_code, address);
+		/* TCMI testing */
+		TCMI_ON_DEBUG {
+			printk(KERN_DEBUG "Address (%lx) not in vm area, and area (start %lx) not VM_GROWSDOWN\n", 
+			       address, vma->vm_start);
+		}	  
+    bad_area(regs, error_code, address);
 		return;
 	}
 	if (error_code & PF_USER) {
@@ -1170,12 +1205,20 @@
 		 * 32 pointers and then decrements %sp by 65535.)
 		 */
 		if (unlikely(address + 65536 + 32 * sizeof(unsigned long) < regs->sp)) {
-			bad_area(regs, error_code, address);
+			/* TCMI testing */
+			TCMI_ON_DEBUG {
+				printk(KERN_DEBUG "User space stack expansion at %lx\n", address);
+			}		  
+      bad_area(regs, error_code, address);
 			return;
 		}
 	}
 	if (unlikely(expand_stack(vma, address))) {
-		bad_area(regs, error_code, address);
+		/* TCMI testing */
+		TCMI_ON_DEBUG {
+			printk(KERN_DEBUG "Failed to expand stack at %lx\n", address);
+		}
+    bad_area(regs, error_code, address);
 		return;
 	}
 
@@ -1184,7 +1227,13 @@
 	 * we can handle it..
 	 */
 good_area:
-	if (unlikely(access_error(error_code, vma))) {
+	
+  /* TCMI testing */
+	TCMI_ON_DEBUG {
+		printk(KERN_DEBUG "Good area at %lx, error code was %lx\n", address, error_code);
+	}	
+  
+  if (unlikely(access_error(error_code, vma))) {
 		bad_area_access_error(regs, error_code, address);
 		return;
 	}
diff -Naur linux-3.7.1_original/linux-3.7.1//arch/x86/um/shared/sysdep/syscalls_64.h linux-3.7.1/arch/x86/um/shared/sysdep/syscalls_64.h
--- linux-3.7.1_original/linux-3.7.1//arch/x86/um/shared/sysdep/syscalls_64.h	2012-12-17 20:14:54.000000000 +0100
+++ linux-3.7.1/arch/x86/um/shared/sysdep/syscalls_64.h	2013-03-19 11:38:22.000000000 +0100
@@ -12,6 +12,8 @@
 
 typedef long syscall_handler_t(void);
 
+int clondike_kernel_execve(const char *filename, char *const argv[], char *const envp[]); //Added for Clondike execve by Jiri Rakosnik
+
 extern syscall_handler_t *sys_call_table[];
 
 #define EXECUTE_SYSCALL(syscall, regs) \
diff -Naur linux-3.7.1_original/linux-3.7.1//arch/x86/vdso/vdso32-setup.c linux-3.7.1/arch/x86/vdso/vdso32-setup.c
--- linux-3.7.1_original/linux-3.7.1//arch/x86/vdso/vdso32-setup.c	2012-12-17 20:14:54.000000000 +0100
+++ linux-3.7.1/arch/x86/vdso/vdso32-setup.c	2013-01-15 14:27:25.000000000 +0100
@@ -364,6 +364,8 @@
 	return ret;
 }
 
+EXPORT_SYMBOL(arch_setup_additional_pages);
+
 #ifdef CONFIG_X86_64
 
 subsys_initcall(sysenter_setup);
diff -Naur linux-3.7.1_original/linux-3.7.1//clondike/Kconfig linux-3.7.1/clondike/Kconfig
--- linux-3.7.1_original/linux-3.7.1//clondike/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1/clondike/Kconfig	2013-03-28 22:04:28.000000000 +0100
@@ -0,0 +1,57 @@
+#
+# Clondike
+#
+
+menu "Clondike"
+
+config TCMI
+	tristate "Enable TCMI"
+	select TCMI_HOOKS
+	help
+	  Clondike is a clustering project started at FEE CTU Prague.
+	  To read more see project website at http://clondike.felk.cvut.cz
+	  Since 2012 is being developed at FIT CTU Prague, project website at https://github.com/FIT-CVUT/Clondike
+	  This option enables Task Checkpointing and Migration Infrastructure(TCMI) 
+	  support in the kernel. 
+	
+
+	  If unsure, say N.
+
+config TCMI_HOOKS
+	bool "TCMI hooks"
+	depends on TCMI
+	help
+	  This option enables kernel hooks used by Task Checkpointing
+	  and Migration Infrastructure(TCMI) to intercept various system
+	  calls and install migration mode handler. 
+
+
+config TCMI_CCN
+	bool "Enable TCMI CCN support"
+	depends on TCMI
+	help
+	  Enables Cluster Core Node (CCN) support in TCMI framework.
+
+
+	  If unsure, say N.
+
+config TCMI_PEN
+	bool "Enable TCMI PEN support"
+	depends on TCMI
+	help
+	  Enables Process Execution Node (PEN) support in TCMI framework.
+
+
+	  If unsure, say N.
+
+config TCMI_DEBUG
+	bool "Enable TCMI debug messages"
+	depends on TCMI
+	help
+	  Enables TCMI debug messages
+	
+	
+	  If unsure, say N.
+
+endmenu
+
diff -Naur linux-3.7.1_original/linux-3.7.1//clondike/Makefile linux-3.7.1/clondike/Makefile
--- linux-3.7.1_original/linux-3.7.1//clondike/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1/clondike/Makefile	2013-01-07 11:22:45.000000000 +0100
@@ -0,0 +1,7 @@
+# Builds the Clondike system
+#
+#
+obj-y += tcmi/
+ifeq ($(CONFIG_TCMI),y)
+	obj-y += src/
+endif
diff -Naur linux-3.7.1_original/linux-3.7.1//clondike/tcmi/Makefile linux-3.7.1/clondike/tcmi/Makefile
--- linux-3.7.1_original/linux-3.7.1//clondike/tcmi/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1/clondike/tcmi/Makefile	2013-01-07 11:22:45.000000000 +0100
@@ -0,0 +1,6 @@
+#
+# Makefile for TCMI components required to be built into kernel
+#
+# 
+
+obj-$(CONFIG_TCMI_HOOKS) :=	tcmi_hooks.o tcmi_dbg.o
diff -Naur linux-3.7.1_original/linux-3.7.1//clondike/tcmi/tcmi_dbg.c linux-3.7.1/clondike/tcmi/tcmi_dbg.c
--- linux-3.7.1_original/linux-3.7.1//clondike/tcmi/tcmi_dbg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1/clondike/tcmi/tcmi_dbg.c	2013-01-07 11:22:45.000000000 +0100
@@ -0,0 +1,6 @@
+#include <clondike/tcmi/tcmi_dbg.h>
+#include <linux/cache.h>
+#include <linux/module.h>
+
+int tcmi_dbg __read_mostly = 1;
+EXPORT_SYMBOL_GPL(tcmi_dbg);
diff -Naur linux-3.7.1_original/linux-3.7.1//clondike/tcmi/tcmi_hooks.c linux-3.7.1/clondike/tcmi/tcmi_hooks.c
--- linux-3.7.1_original/linux-3.7.1//clondike/tcmi/tcmi_hooks.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1/clondike/tcmi/tcmi_hooks.c	2013-01-07 11:22:45.000000000 +0100
@@ -0,0 +1,21 @@
+/**
+ * @file tcmi_hooks.c - Definition of all hooks in kernel requires only
+ *                      including the header file as private
+ * 
+ * 
+ * 
+ * 
+ * 
+ *
+ * Date: 04/21/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: linux-2.6.23-uml-clondike.patch,v 1.1 2009-01-20 14:22:16 andrep1 Exp $
+ *
+ * License....
+ */
+
+#define TCMI_HOOKS_FACTORY_PRIVATE
+#include <clondike/tcmi/tcmi_hooks.h>
+
diff -Naur linux-3.7.1_original/linux-3.7.1//fs/9p/fid.c linux-3.7.1/fs/9p/fid.c
--- linux-3.7.1_original/linux-3.7.1//fs/9p/fid.c	2012-12-17 20:14:54.000000000 +0100
+++ linux-3.7.1/fs/9p/fid.c	2013-03-27 12:24:15.000000000 +0100
@@ -161,9 +161,11 @@
 		if (access == V9FS_ACCESS_SINGLE)
 			return ERR_PTR(-EPERM);
 
+		/*	WTF?? Anyway does not work with our npfs | by Jiri Rakosnik
 		if (v9fs_proto_dotu(v9ses) || v9fs_proto_dotl(v9ses))
 				uname = NULL;
 		else
+		*/
 			uname = v9ses->uname;
 
 		fid = p9_client_attach(v9ses->clnt, NULL, uname, uid,
diff -Naur linux-3.7.1_original/linux-3.7.1//fs/9p/v9fs.c linux-3.7.1/fs/9p/v9fs.c
--- linux-3.7.1_original/linux-3.7.1//fs/9p/v9fs.c	2012-12-17 20:14:54.000000000 +0100
+++ linux-3.7.1/fs/9p/v9fs.c	2013-03-27 12:06:16.000000000 +0100
@@ -51,6 +51,9 @@
 enum {
 	/* Options that take integer arguments */
 	Opt_debug, Opt_dfltuid, Opt_dfltgid, Opt_afid,
+  /* This id will be alias with clondike user id (==999)... in stat this id will be present, but internally 999 user will be marked as owner to pass security checks */
+	Opt_clondike_uid, 
+	Opt_clondike_gid, 	
 	/* String options */
 	Opt_uname, Opt_remotename, Opt_trans, Opt_cache, Opt_cachetag,
 	/* Options that take no arguments */
@@ -68,6 +71,8 @@
 	{Opt_dfltuid, "dfltuid=%u"},
 	{Opt_dfltgid, "dfltgid=%u"},
 	{Opt_afid, "afid=%u"},
+  {Opt_clondike_uid, "cuid=%x"},
+  {Opt_clondike_gid, "cgid=%x"},
 	{Opt_uname, "uname=%s"},
 	{Opt_remotename, "aname=%s"},
 	{Opt_nodevmap, "nodevmap"},
@@ -123,6 +128,9 @@
 	v9ses->cachetag = NULL;
 #endif
 
+	v9ses->cuid = 999; // By default clondike user id is used so that no aliasing is performed
+	v9ses->cgid = 999; // By default clondike group id is used so that no aliasing is performed
+
 	if (!opts)
 		return 0;
 
@@ -183,6 +191,12 @@
 			}
 			v9ses->afid = option;
 			break;
+    case Opt_clondike_uid:
+			v9ses->cuid = option;
+			break;
+		case Opt_clondike_gid:
+			v9ses->cgid = option;
+			break;
 		case Opt_uname:
 			kfree(v9ses->uname);
 			v9ses->uname = match_strdup(&args[0]);
diff -Naur linux-3.7.1_original/linux-3.7.1//fs/9p/v9fs.h linux-3.7.1/fs/9p/v9fs.h
--- linux-3.7.1_original/linux-3.7.1//fs/9p/v9fs.h	2012-12-17 20:14:54.000000000 +0100
+++ linux-3.7.1/fs/9p/v9fs.h	2013-03-27 12:07:06.000000000 +0100
@@ -106,6 +106,9 @@
 	struct fscache_cookie *fscache;
 #endif
 
+  	unsigned int cuid;	/* Clondike aliased user id */
+  	unsigned int cgid;	/* Clondike aliased group id */
+
 	char *uname;		/* user name to mount as */
 	char *aname;		/* name of remote hierarchy being mounted */
 	unsigned int maxdata;	/* max data for client interface */
diff -Naur linux-3.7.1_original/linux-3.7.1//fs/9p/vfs_inode.c linux-3.7.1/fs/9p/vfs_inode.c
--- linux-3.7.1_original/linux-3.7.1//fs/9p/vfs_inode.c	2012-12-17 20:14:54.000000000 +0100
+++ linux-3.7.1/fs/9p/vfs_inode.c	2013-03-27 18:51:09.000000000 +0100
@@ -283,9 +283,6 @@
 	inode->i_mapping->a_ops = &v9fs_addr_operations;
 
 	switch (mode & S_IFMT) {
-	case S_IFIFO:
-	case S_IFBLK:
-	case S_IFCHR:
 	case S_IFSOCK:
 		if (v9fs_proto_dotl(v9ses)) {
 			inode->i_op = &v9fs_file_inode_operations_dotl;
@@ -299,6 +296,10 @@
 		}
 		init_special_inode(inode, inode->i_mode, inode->i_rdev);
 		break;
+	
+	case S_IFIFO:
+	case S_IFBLK:
+	case S_IFCHR:
 	case S_IFREG:
 		if (v9fs_proto_dotl(v9ses)) {
 			inode->i_op = &v9fs_file_inode_operations_dotl;
@@ -372,12 +373,20 @@
 	p9_debug(P9_DEBUG_VFS, "super block: %p mode: %ho\n", sb, mode);
 
 	inode = new_inode(sb);
-	if (!inode) {
+  if (!inode) {
 		pr_warn("%s (%d): Problem allocating inode\n",
 			__func__, task_pid_nr(current));
 		return ERR_PTR(-ENOMEM);
 	}
-	err = v9fs_init_inode(v9ses, inode, mode, rdev);
+  // Clondike fix for kernel 3.7.1 by Jiri Rakosnik
+	if ( inode->i_uid == v9ses->cuid )
+	// Make clondike aliasing
+		inode->i_uid = 999;
+	if ( inode->i_gid == v9ses->cgid )
+		// Make clondike aliasing
+		inode->i_gid = 999;
+	// End Clondike fix
+  err = v9fs_init_inode(v9ses, inode, mode, rdev);
 	if (err) {
 		iput(inode);
 		return ERR_PTR(err);
@@ -1092,6 +1101,13 @@
 	v9fs_stat2inode(st, dentry->d_inode, dentry->d_inode->i_sb);
 	generic_fillattr(dentry->d_inode, stat);
 
+  // If we were aliased, do unaliasing here so that user sees stats as if on home node.
+	// TODO: Note that here we may unalias also files previously not aliased..
+	if ( dentry->d_inode->i_uid == 999 )
+		stat->uid = v9ses->cuid;
+	if ( dentry->d_inode->i_gid == 999 )
+		stat->gid = v9ses->cgid;
+
 	p9stat_free(st);
 	kfree(st);
 	return 0;
@@ -1194,6 +1210,14 @@
 		inode->i_uid = stat->n_uid;
 		inode->i_gid = stat->n_gid;
 	}
+	// Clondike fix by Jiri Rakosnik
+	if ( inode->i_uid == v9ses->cuid )
+		// Make clondike aliasing
+		inode->i_uid = 999;
+	if ( inode->i_gid == v9ses->cgid )
+		// Make clondike aliasing
+		inode->i_gid = 999;
+	// End Clondike fix
 	if ((S_ISREG(inode->i_mode)) || (S_ISDIR(inode->i_mode))) {
 		if (v9fs_proto_dotu(v9ses) && (stat->extension[0] != '\0')) {
 			/*
diff -Naur linux-3.7.1_original/linux-3.7.1//fs/exec.c linux-3.7.1/fs/exec.c
--- linux-3.7.1_original/linux-3.7.1//fs/exec.c	2012-12-17 20:14:54.000000000 +0100
+++ linux-3.7.1/fs/exec.c	2013-03-12 18:33:58.000000000 +0100
@@ -62,6 +62,7 @@
 
 #include <trace/events/task.h>
 #include "internal.h"
+#include <clondike/tcmi/tcmi_hooks.h>
 #include "coredump.h"
 
 #include <trace/events/sched.h>
@@ -1468,6 +1469,8 @@
 	retval = unshare_files(&displaced);
 	if (retval)
 		goto out_ret;
+    // Clondike for kernel 3.7.1 fix this macro, convert type argv and regs by Jiri Rakosnik
+    TCMI_HOOKS_CALL(execve, filename, argv.ptr.native, envp.ptr.native, regs); 	/* TCMI system call hook */
 
 	retval = -ENOMEM;
 	bprm = kzalloc(sizeof(*bprm), GFP_KERNEL);
@@ -1564,6 +1567,8 @@
 	return retval;
 }
 
+EXPORT_SYMBOL(do_execve);
+
 int do_execve(const char *filename,
 	const char __user *const __user *__argv,
 	const char __user *const __user *__envp,
diff -Naur linux-3.7.1_original/linux-3.7.1//fs/fcntl.c linux-3.7.1/fs/fcntl.c
--- linux-3.7.1_original/linux-3.7.1//fs/fcntl.c	2012-12-17 20:14:54.000000000 +0100
+++ linux-3.7.1/fs/fcntl.c	2013-01-31 10:10:51.000000000 +0100
@@ -369,6 +369,8 @@
 	return err;
 }
 
+EXPORT_SYMBOL(sys_dup2);
+
 #if BITS_PER_LONG == 32
 SYSCALL_DEFINE3(fcntl64, unsigned int, fd, unsigned int, cmd,
 		unsigned long, arg)
diff -Naur linux-3.7.1_original/linux-3.7.1//fs/namespace.c linux-3.7.1/fs/namespace.c
--- linux-3.7.1_original/linux-3.7.1//fs/namespace.c	2012-12-17 20:14:54.000000000 +0100
+++ linux-3.7.1/fs/namespace.c	2013-01-31 10:13:13.000000000 +0100
@@ -1278,6 +1278,8 @@
 	return retval;
 }
 
+EXPORT_SYMBOL_GPL(sys_umount);
+
 #ifdef __ARCH_WANT_SYS_OLDUMOUNT
 
 /*
@@ -2260,7 +2262,7 @@
 	path_put(&path);
 	return retval;
 }
-
+EXPORT_SYMBOL(do_mount);
 static struct mnt_namespace *alloc_mnt_ns(void)
 {
 	struct mnt_namespace *new_ns;
diff -Naur linux-3.7.1_original/linux-3.7.1//fs/open.c linux-3.7.1/fs/open.c
--- linux-3.7.1_original/linux-3.7.1//fs/open.c	2012-12-17 20:14:54.000000000 +0100
+++ linux-3.7.1/fs/open.c	2013-01-31 10:14:37.000000000 +0100
@@ -931,6 +931,7 @@
 	}
 	return fd;
 }
+EXPORT_SYMBOL(do_sys_open);
 
 SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode)
 {
diff -Naur linux-3.7.1_original/linux-3.7.1//include/clondike/tcmi/tcmi_dbg.h linux-3.7.1/include/clondike/tcmi/tcmi_dbg.h
--- linux-3.7.1_original/linux-3.7.1//include/clondike/tcmi/tcmi_dbg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1/include/clondike/tcmi/tcmi_dbg.h	2013-01-31 10:18:05.000000000 +0100
@@ -0,0 +1,31 @@
+/**
+* @file tcmi_dbg.h - Helper module when debugging TCMI tasks in kernel
+* 
+* 
+* 
+* 
+* 
+* 
+*
+* Date: 04/21/2005
+*
+* Author: Jan Capek
+*
+* $Id: linux-2.6.23-uml-clondike.patch,v 1.1 2009-01-20 14:22:16 andrep1 Exp $
+*
+* License....
+*/
+
+#ifndef _TCMI_DBG_H
+#define _TCMI_DBG_H
+
+
+extern int tcmi_dbg;
+
+#define TCMI_ON_DEBUG if (tcmi_dbg && current->tcmi.tcmi_task)
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_DBG_H */
\ No newline at end of file
diff -Naur linux-3.7.1_original/linux-3.7.1//include/clondike/tcmi/tcmi_hooks_factory.h linux-3.7.1/include/clondike/tcmi/tcmi_hooks_factory.h
--- linux-3.7.1_original/linux-3.7.1//include/clondike/tcmi/tcmi_hooks_factory.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1/include/clondike/tcmi/tcmi_hooks_factory.h	2013-02-20 12:47:16.000000000 +0100
@@ -0,0 +1,125 @@
+/**
+ * @file tcmi_hooks_factory.h - Declaration of all a factory class that
+ *                              produces hooks declarations and definitions
+ * 
+ * 
+ * 
+ * 
+ * 
+ *
+ * Date: 04/21/2005
+ *
+ * Author: Jan Capek, based on lmmdefs.h by Martin Kacer
+ *
+ * $Id: linux-2.6.23-uml-clondike.patch,v 1.1 2009-01-20 14:22:16 andrep1 Exp $
+ *
+ * License....
+ */
+
+#ifndef _TCMI_HOOKS_FACTORY_H
+#define _TCMI_HOOKS_FACTORY_H
+
+
+/** @defgroup tcmi_hooks_factory_class tcmi_hooks_factory class 
+ * 
+ * This \<\<singleton\>\> class allows declaration and definition
+ * of new kernel hooks. A component that wants to create a new hook
+ * adds its definition in tcmi_hooks.h, using TCMI_HOOKS_DEFINE macro. 
+ * The hook method is then called using TCMI_HOOKS_CALL macro from
+ * appropriate place in the kernel. The parameters passed to the call
+ * must match the hook definition.
+ *
+ * Any module that wants to register a method that will always be
+ * called by the hook calls
+ * tcmi_hooks_register_NAME(custom_method). Where the NAME suffix is
+ * the identifier used in HOOK definition in tcmi_hooks.h.
+ * 
+ * The benefit of this solution, is that we have to export only one
+ * new symbol - the hook pointer. Everything else is handled by static
+ * inline methods or macros.
+ *
+ *
+ *@{
+ */
+
+/** 
+ * Defines a hook that requires:
+ *
+ * - declaration of new data type for the method that is to be
+ * registered. This method is then required as a parameter for the
+ * registration method.
+ *
+ * - declaration of registration/unregistration methods
+ * - declares the pointer to the hooks method
+ *
+ * In addition, since this file is also included by tcmi_hooks.c
+ * module it will define the registration and unregistration function,
+ * and a the default hook method - NULL
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+/* When used as private, we generate also definitions */
+#ifdef TCMI_HOOKS_FACTORY_PRIVATE
+/** 
+ * Following macro is used by the public TCMI_HOOKS_DEFINE to define the actual
+ * hook method pointer and export it. This is done in tcmi_hooks.c and the user
+ * doesn't have to worry about it anymore as it will get linked into the kernel.
+ */
+#define TCMI_HOOKS_DEFINE_PRIVATE(method, args...)					\
+tcmi_hooks_##method##_t *tcmi_hooks_##method = NULL;					\
+EXPORT_SYMBOL(tcmi_hooks_##method);					
+
+#else
+/* empty macro, when included from some place else*/
+#define TCMI_HOOKS_DEFINE_PRIVATE(method, args...)
+#endif /* TCMI_HOOKS_FACTORY_PRIVATE */
+
+/** 
+ * This macro is to declare the hook method pointer in tcmi_hooks.h.
+ * In the tcmi_hooks.c, it also defines the hook pointer.
+ */
+#define TCMI_HOOKS_DEFINE(method, args...)						\
+typedef long tcmi_hooks_##method##_t(args);						\
+extern tcmi_hooks_##method##_t *tcmi_hooks_##method;					\
+static inline void tcmi_hooks_register_##method(tcmi_hooks_##method##_t *method)	\
+{											\
+	tcmi_hooks_##method = method;							\
+}											\
+static inline void tcmi_hooks_unregister_##method(void)					\
+{											\
+	tcmi_hooks_##method = NULL;							\
+}											\
+TCMI_HOOKS_DEFINE_PRIVATE(method, args);
+
+
+
+/**
+ * Since each hook method returns an int, this macro generates an
+ * expression, that calls the hook method if one is defined.
+ * The value of the expression is 0, if no hook method has been registered.
+ * If there is a valid hook method registered, we get back the value
+ * returned by this method. 
+ *
+ * @param method - name of the method(e.g. exec) that
+ * is to be called
+ * @param args - arguments of the method
+ */
+#define TCMI_HOOKS_CALL(method, args...)		\
+({							\
+	int __tcmi_hook_ret = 0;			\
+ if (tcmi_hooks_##method != NULL)		\
+		__tcmi_hook_ret =			\
+			tcmi_hooks_##method(args);	\
+	__tcmi_hook_ret;				\
+})
+
+
+#define TCMI_TASK_GUEST if (current->tcmi.tcmi_task && current->tcmi.task_type == guest)
+
+/**
+ * @}
+ */
+ 
+#endif /* _TCMI_HOOKS_FACTORY_H */
\ No newline at end of file
diff -Naur linux-3.7.1_original/linux-3.7.1//include/clondike/tcmi/tcmi_hooks.h linux-3.7.1/include/clondike/tcmi/tcmi_hooks.h
--- linux-3.7.1_original/linux-3.7.1//include/clondike/tcmi/tcmi_hooks.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1/include/clondike/tcmi/tcmi_hooks.h	2013-03-12 18:55:27.000000000 +0100
@@ -0,0 +1,104 @@
+/**
+ * @file tcmi_hooks.h - Declaration of all hooks that are to be used in the kernel.
+ * 
+ * 
+ * 
+ * 
+ * 
+ * 
+ *
+ * Date: 04/21/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: linux-2.6.23-uml-clondike.patch,v 1.1 2009-01-20 14:22:16 andrep1 Exp $
+ *
+ * License....
+ */
+
+#ifndef _TCMI_HOOKS_H
+#define _TCMI_HOOKS_H
+
+#include <clondike/tcmi/tcmi_hooks_factory.h>
+#include <asm/ptrace.h>
+#include <asm/siginfo.h>
+#include <linux/capability.h>
+#include <linux/resource.h>
+
+/** execve */
+TCMI_HOOKS_DEFINE(execve, const char *, const char * const*, const char * const*, struct pt_regs *);
+
+/** wait */
+TCMI_HOOKS_DEFINE(sys_wait4, pid_t, int __user *, int, struct rusage __user *);
+
+/** fork hooks */
+/** Called in the beginning of the fork */
+TCMI_HOOKS_DEFINE(pre_fork, unsigned long, unsigned long, struct pt_regs *, unsigned long, int __user *, int __user *);
+/** Called in the middle of fork (used to attach shadow/guest task to a newly forked task). Takes new child as a param */
+TCMI_HOOKS_DEFINE(in_fork, struct task_struct*);
+/** 
+ * Called in the end of the fork. Takes as param return value of fork, pid of process forked on associated CCN + result buffers (so that
+ * we can reset them, in case fork failed and we've filled them in prefork.
+ *
+ * The method is called after succesful fork, but befor the process is actually started
+ */
+TCMI_HOOKS_DEFINE(post_fork, struct task_struct*, long, pid_t, int __user *, int __user *);
+
+/** exit hook */
+TCMI_HOOKS_DEFINE(exit, long);
+
+/** syscalls **/
+/** signal */
+TCMI_HOOKS_DEFINE(sys_kill, int, int);
+TCMI_HOOKS_DEFINE(do_tkill, int, int, int);
+TCMI_HOOKS_DEFINE(sys_rt_sigqueueinfo, int, int, siginfo_t*);
+
+/** pid, gid and session manipulation */
+TCMI_HOOKS_DEFINE(sys_getpid, void);
+TCMI_HOOKS_DEFINE(sys_getppid, void);
+TCMI_HOOKS_DEFINE(sys_getpgid, pid_t);
+TCMI_HOOKS_DEFINE(sys_setpgid, pid_t, pid_t);
+TCMI_HOOKS_DEFINE(sys_getsid, pid_t);
+TCMI_HOOKS_DEFINE(sys_setsid, void);
+TCMI_HOOKS_DEFINE(sys_getpgrp, void);
+
+/** user identification */
+TCMI_HOOKS_DEFINE(sys_geteuid, void);
+TCMI_HOOKS_DEFINE(sys_getuid, void);
+TCMI_HOOKS_DEFINE(sys_getresuid, uid_t*, uid_t*, uid_t*);
+TCMI_HOOKS_DEFINE(sys_setresuid, uid_t, uid_t, uid_t);
+TCMI_HOOKS_DEFINE(sys_setuid, uid_t);
+TCMI_HOOKS_DEFINE(sys_setreuid, uid_t, uid_t);
+
+/** group identification */
+TCMI_HOOKS_DEFINE(sys_getegid, void);
+TCMI_HOOKS_DEFINE(sys_getgid, void);
+TCMI_HOOKS_DEFINE(sys_getgroups, int, gid_t *);
+TCMI_HOOKS_DEFINE(sys_getresgid, gid_t*, gid_t*, gid_t*);
+TCMI_HOOKS_DEFINE(sys_setgid, gid_t);
+TCMI_HOOKS_DEFINE(sys_setregid, gid_t, gid_t);
+TCMI_HOOKS_DEFINE(sys_setresgid, gid_t, gid_t, gid_t);
+TCMI_HOOKS_DEFINE(sys_setgroups, int, gid_t *);
+
+/** other */
+TCMI_HOOKS_DEFINE(sys_capget, cap_user_header_t, cap_user_data_t);
+
+
+/** SIGUNUSED default signal handler hook */
+TCMI_HOOKS_DEFINE(sig_unused, struct pt_regs*);
+TCMI_HOOKS_DEFINE(sig_deliver, int);
+TCMI_HOOKS_DEFINE(sig_delivered, int);
+TCMI_HOOKS_DEFINE(did_stop, int);
+TCMI_HOOKS_DEFINE(group_stop, int);
+TCMI_HOOKS_DEFINE(deq_sig, int);
+TCMI_HOOKS_DEFINE(send_sig, int);
+TCMI_HOOKS_DEFINE(doing_sigfatal, int, int);
+
+
+TCMI_HOOKS_DEFINE(replace_proc_self_file, const char*, const char**);
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_HOOKS_H */
\ No newline at end of file
diff -Naur linux-3.7.1_original/linux-3.7.1//include/clondike/tcmi/tcmi_struct.h linux-3.7.1/include/clondike/tcmi/tcmi_struct.h
--- linux-3.7.1_original/linux-3.7.1//include/clondike/tcmi/tcmi_struct.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1/include/clondike/tcmi/tcmi_struct.h	2013-03-26 13:35:11.000000000 +0100
@@ -0,0 +1,58 @@
+/**
+ * @file tcmi_struct.h - Declaration of extension structure for task_struct
+ * 
+ * 
+ * 
+ * 
+ * 
+ * 
+ *
+ * Date: 04/26/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: linux-2.6.23-uml-clondike.patch,v 1.1 2009-01-20 14:22:16 andrep1 Exp $
+ *
+ * License....
+ */
+
+#ifndef _TCMI_STRUCT_H
+#define _TCMI_STRUCT_H
+
+/** handler method type - called when switching to migration mode. */
+typedef void mig_mode_handler_t(void);
+
+enum tcmi_task_type {
+	unresolved_type,
+	shadow,
+	shadow_detached, /** A task, that was shadow once, but it is now running on CCN and so it does not have remote guest */
+	guest
+};
+
+/** Compound structure that holds TCMI related information for
+ * shadow/stub tasks in the task_struct. There are 3 items:
+ * - migration mode handler - this allows the migration component to
+ * run a specific handler for each task. With this approach we can have
+ * CCN and PEN on the same node
+ * - data for the handler - contains a valid pointer to any data. It
+ * should be guaranteed by the component that performs task attaching,
+ * that the the process will retain an extra reference. 
+ * - tcmi_task - points to the tcmi task that describes either
+ * a shadow or a stub task. This data is interpreted by the migration
+ * mode handler.
+ */
+struct tcmi_struct {
+	/* migration mode handler */
+	mig_mode_handler_t *mig_mode_handler;
+	/* data for the handler */
+	void *data;
+	/* tcmi task associated with the handler */
+	void *tcmi_task;
+
+	enum tcmi_task_type task_type;
+};
+
+/**
+ * @}
+ */
+#endif /* _TCMI_STRUCT_H */
\ No newline at end of file
diff -Naur linux-3.7.1_original/linux-3.7.1//include/linux/namei.h linux-3.7.1/include/linux/namei.h
--- linux-3.7.1_original/linux-3.7.1//include/linux/namei.h	2012-12-17 20:14:54.000000000 +0100
+++ linux-3.7.1/include/linux/namei.h	2013-03-22 21:06:53.000000000 +0100
@@ -64,7 +64,6 @@
 	user_path_at(AT_FDCWD, name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, path)
 
 extern int kern_path(const char *, unsigned, struct path *);
-
 extern struct dentry *kern_path_create(int, const char *, struct path *, int);
 extern struct dentry *user_path_create(int, const char __user *, struct path *, int);
 extern void done_path_create(struct path *, struct dentry *);
diff -Naur linux-3.7.1_original/linux-3.7.1//include/linux/sched.h linux-3.7.1/include/linux/sched.h
--- linux-3.7.1_original/linux-3.7.1//include/linux/sched.h	2012-12-17 20:14:54.000000000 +0100
+++ linux-3.7.1/include/linux/sched.h	2013-01-31 11:59:35.000000000 +0100
@@ -54,6 +54,8 @@
 
 #include <asm/processor.h>
 
+#include <clondike/tcmi/tcmi_struct.h> /* TCMI extension */
+
 struct exec_domain;
 struct futex_pi_state;
 struct robust_list_head;
@@ -1455,6 +1457,11 @@
 	int cpuset_mem_spread_rotor;
 	int cpuset_slab_spread_rotor;
 #endif
+
+#if defined CONFIG_TCMI || defined CONFIG_TCMI_MODULE
+ struct tcmi_struct tcmi;
+#endif
+
 #ifdef CONFIG_CGROUPS
 	/* Control Group info protected by css_set_lock */
 	struct css_set __rcu *cgroups;
diff -Naur linux-3.7.1_original/linux-3.7.1//include/linux/signal.h linux-3.7.1/include/linux/signal.h
--- linux-3.7.1_original/linux-3.7.1//include/linux/signal.h	2012-12-17 20:14:54.000000000 +0100
+++ linux-3.7.1/include/linux/signal.h	2013-01-31 12:03:22.000000000 +0100
@@ -348,17 +348,18 @@
 #define siginmask(sig, mask) (rt_sigmask(sig) & (mask))
 
 #define SIG_KERNEL_ONLY_MASK (\
-	rt_sigmask(SIGKILL)   |  rt_sigmask(SIGSTOP))
+	rt_sigmask(SIGKILL)   |  rt_sigmask(SIGSTOP)   |  rt_sigmask(SIGUNUSED))
 
 #define SIG_KERNEL_STOP_MASK (\
 	rt_sigmask(SIGSTOP)   |  rt_sigmask(SIGTSTP)   | \
-	rt_sigmask(SIGTTIN)   |  rt_sigmask(SIGTTOU)   )
+	rt_sigmask(SIGTTIN)   |  rt_sigmask(SIGTTOU)   |  rt_sigmask(SIGUNUSED))
 
+// TODO: Why is SIGSYS removed here? It was in original TCMI patch
 #define SIG_KERNEL_COREDUMP_MASK (\
         rt_sigmask(SIGQUIT)   |  rt_sigmask(SIGILL)    | \
 	rt_sigmask(SIGTRAP)   |  rt_sigmask(SIGABRT)   | \
         rt_sigmask(SIGFPE)    |  rt_sigmask(SIGSEGV)   | \
-	rt_sigmask(SIGBUS)    |  rt_sigmask(SIGSYS)    | \
+	rt_sigmask(SIGBUS)    | \
         rt_sigmask(SIGXCPU)   |  rt_sigmask(SIGXFSZ)   | \
 	SIGEMT_MASK				       )
 

diff -Naur linux-3.7.1_original/linux-3.7.1//kernel/capability.c linux-3.7.1/kernel/capability.c
--- linux-3.7.1_original/linux-3.7.1//kernel/capability.c	2012-12-17 20:14:54.000000000 +0100
+++ linux-3.7.1/kernel/capability.c	2013-01-31 12:06:03.000000000 +0100
@@ -16,6 +16,7 @@
 #include <linux/pid_namespace.h>
 #include <linux/user_namespace.h>
 #include <asm/uaccess.h>
+#include <clondike/tcmi/tcmi_hooks.h>
 
 /*
  * Leveraged for setting/resetting capabilities
@@ -166,6 +167,11 @@
 	if ((dataptr == NULL) || (ret != 0))
 		return ((dataptr == NULL) && (ret == -EINVAL)) ? 0 : ret;
 
+  TCMI_TASK_GUEST{
+	     printk(KERN_INFO "Forwading sys_capget()\n");
+             return TCMI_HOOKS_CALL(sys_capget, header, dataptr);
+ 	}
+
 	if (get_user(pid, &header->pid))
 		return -EFAULT;
 
diff -Naur linux-3.7.1_original/linux-3.7.1//kernel/exit.c linux-3.7.1/kernel/exit.c
--- linux-3.7.1_original/linux-3.7.1//kernel/exit.c	2012-12-17 20:14:54.000000000 +0100
+++ linux-3.7.1/kernel/exit.c	2013-01-31 12:09:30.000000000 +0100
@@ -58,6 +58,7 @@
 #include <asm/unistd.h>
 #include <asm/pgtable.h>
 #include <asm/mmu_context.h>
+#include <clondike/tcmi/tcmi_hooks.h>
 
 static void exit_mm(struct task_struct * tsk);
 
@@ -811,6 +812,8 @@
 {
 	struct task_struct *tsk = current;
 	int group_dead;
+  
+  TCMI_HOOKS_CALL(exit, code); 	/* TCMI system call hook */
 
 	profile_task_exit(tsk);
 
@@ -1748,6 +1751,11 @@
 	if (options & ~(WNOHANG|WUNTRACED|WCONTINUED|
 			__WNOTHREAD|__WCLONE|__WALL))
 		return -EINVAL;
+    
+  TCMI_TASK_GUEST{
+		printk(KERN_INFO "Forwading sys_wait4()\n");
+		return TCMI_HOOKS_CALL(sys_wait4, upid, stat_addr, options, ru);
+	}
 
 	if (upid == -1)
 		type = PIDTYPE_MAX;
@@ -1775,6 +1783,7 @@
 	asmlinkage_protect(4, ret, upid, stat_addr, options, ru);
 	return ret;
 }
+EXPORT_SYMBOL(sys_wait4);
 
 #ifdef __ARCH_WANT_SYS_WAITPID
 
diff -Naur linux-3.7.1_original/linux-3.7.1//kernel/fork.c linux-3.7.1/kernel/fork.c
--- linux-3.7.1_original/linux-3.7.1//kernel/fork.c	2012-12-17 20:14:54.000000000 +0100
+++ linux-3.7.1/kernel/fork.c	2013-01-31 12:18:10.000000000 +0100
@@ -82,6 +82,7 @@
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/task.h>
+#include <clondike/tcmi/tcmi_hooks.h>
 
 /*
  * Protected counters by write_lock_irq(&tasklist_lock)
@@ -1411,6 +1412,13 @@
 		p->parent_exec_id = current->self_exec_id;
 	}
 
+  retval = TCMI_HOOKS_CALL(in_fork, p);
+  if ( retval ) {
+		spin_unlock(&current->sighand->siglock);
+		write_unlock_irq(&tasklist_lock);
+		goto bad_fork_free_pid;
+	}
+
 	spin_lock(&current->sighand->siglock);
 
 	/*
@@ -1562,6 +1570,11 @@
 	struct task_struct *p;
 	int trace = 0;
 	long nr;
+  long tcmi_res;
+
+	tcmi_res = TCMI_HOOKS_CALL(pre_fork, clone_flags, stack_start, regs, stack_size, parent_tidptr, child_tidptr);
+	if ( tcmi_res < 0 )
+		return tcmi_res;
 
 	/*
 	 * Do some preliminary argument and permissions checking before we
@@ -1598,6 +1611,10 @@
 
 	p = copy_process(clone_flags, stack_start, regs, stack_size,
 			 child_tidptr, NULL, trace);
+       
+  // TODO: Check if call to ..._vnr is correct
+  tcmi_res = TCMI_HOOKS_CALL(post_fork, p, IS_ERR(p) ? PTR_ERR(p) : task_pid_vnr(p), tcmi_res, parent_tidptr, child_tidptr);
+			 
 	/*
 	 * Do this prior waking up the new thread - the thread pointer
 	 * might get invalid after that point, if the thread exits quickly.
@@ -1628,12 +1645,18 @@
 			if (!wait_for_vfork_done(p, &vfork))
 				ptrace_event(PTRACE_EVENT_VFORK_DONE, nr);
 		}
-	} else {
+	   
+     if ( tcmi_res )
+       nr = tcmi_res;
+  
+  } else {
 		nr = PTR_ERR(p);
 	}
 	return nr;
 }
 
+EXPORT_SYMBOL(do_fork);
+
 #ifdef CONFIG_GENERIC_KERNEL_THREAD
 /*
  * Create a kernel thread.
diff -Naur linux-3.7.1_original/linux-3.7.1//kernel/groups.c linux-3.7.1/kernel/groups.c
--- linux-3.7.1_original/linux-3.7.1//kernel/groups.c	2012-12-17 20:14:54.000000000 +0100
+++ linux-3.7.1/kernel/groups.c	2013-01-31 12:20:38.000000000 +0100
@@ -223,6 +223,8 @@
 	return i;
 }
 
+EXPORT_SYMBOL(sys_getgroups);
+
 /*
  *	SMP: Our groups are copy-on-write. We can set them safely
  *	without another task interfering.
@@ -253,6 +255,8 @@
 	return retval;
 }
 
+EXPORT_SYMBOL(sys_setgroups);
+
 /*
  * Check whether we're fsgid/egid or in the supplemental group..
  */
diff -Naur linux-3.7.1_original/linux-3.7.1//kernel/sched/core.c linux-3.7.1/kernel/sched/core.c
--- linux-3.7.1_original/linux-3.7.1//kernel/sched/core.c	2012-12-17 20:14:54.000000000 +0100
+++ linux-3.7.1/kernel/sched/core.c	2013-01-31 12:25:57.000000000 +0100
@@ -8076,3 +8076,4 @@
 	.base_cftypes = files,
 };
 #endif	/* CONFIG_CGROUP_CPUACCT */
+EXPORT_SYMBOL(tasklist_lock);
diff -Naur linux-3.7.1_original/linux-3.7.1//kernel/signal.c linux-3.7.1/kernel/signal.c
--- linux-3.7.1_original/linux-3.7.1//kernel/signal.c	2012-12-17 20:14:54.000000000 +0100
+++ linux-3.7.1/kernel/signal.c	2013-02-19 18:53:34.000000000 +0100
@@ -40,6 +40,7 @@
 #include <asm/siginfo.h>
 #include <asm/cacheflush.h>
 #include "audit.h"	/* audit_signal_info() */
+#include <clondike/tcmi/tcmi_hooks.h>
 
 /*
  * SLAB caches for signal bits.
@@ -985,6 +986,7 @@
 	    !(signal->flags & (SIGNAL_UNKILLABLE | SIGNAL_GROUP_EXIT)) &&
 	    !sigismember(&t->real_blocked, sig) &&
 	    (sig == SIGKILL || !t->ptrace)) {
+      TCMI_HOOKS_CALL(doing_sigfatal, sig, sig_kernel_coredump(sig));
 		/*
 		 * This signal will be fatal to the whole group.
 		 */
@@ -1150,6 +1152,8 @@
 			int group)
 {
 	int from_ancestor_ns = 0;
+  
+  TCMI_HOOKS_CALL(send_sig, sig);	
 
 #ifdef CONFIG_PID_NS
 	from_ancestor_ns = si_fromuser(info) &&
@@ -2264,12 +2268,20 @@
 		if (!signr)
 			break; /* will return 0 */
 
+    TCMI_HOOKS_CALL(deq_sig, signr);
+
 		if (unlikely(current->ptrace) && signr != SIGKILL) {
 			signr = ptrace_signal(signr, info,
 					      regs, cookie);
 			if (!signr)
 				continue;
 		}
+    else{
+      // Clondike fix for patch 3.7.1 by Jiri Rakosnik
+      // Add only else part
+      TCMI_HOOKS_CALL(group_stop, current->signal->group_stop_count);
+    
+    }
 
 		ka = &sighand->action[signr-1];
 
@@ -2307,6 +2319,13 @@
 		if (unlikely(signal->flags & SIGNAL_UNKILLABLE) &&
 				!sig_kernel_only(signr))
 			continue;
+      
+    /* TCMI - SIGUNUSED is reserved for TCMI handling - switching to migration mode */
+		if (signr == SIGUNUSED) {
+			spin_unlock_irq(&current->sighand->siglock);
+			TCMI_HOOKS_CALL(sig_unused, regs);
+			goto relock;
+		}
 
 		if (sig_kernel_stop(signr)) {
 			/*
@@ -2331,7 +2350,8 @@
 			}
 
 			if (likely(do_signal_stop(info->si_signo))) {
-				/* It released the siglock.  */
+				TCMI_HOOKS_CALL(did_stop, signr);
+ 				/* It released the siglock.  */
 				goto relock;
 			}
 
@@ -2341,7 +2361,7 @@
 			 */
 			continue;
 		}
-
+    TCMI_HOOKS_CALL(sig_deliver, signr); 
 		spin_unlock_irq(&sighand->siglock);
 
 		/*
@@ -2370,7 +2390,8 @@
 		/* NOTREACHED */
 	}
 	spin_unlock_irq(&sighand->siglock);
-	return signr;
+	TCMI_HOOKS_CALL(sig_delivered, signr);	
+  return signr;
 }
 
 /**
@@ -2848,6 +2869,11 @@
 {
 	struct siginfo info;
 
+  TCMI_TASK_GUEST{
+		printk(KERN_INFO "Forwading sys_kill(pid=%d, sig=%d)\n", pid, sig);
+		return TCMI_HOOKS_CALL(sys_kill, pid, sig);
+	}	
+
 	info.si_signo = sig;
 	info.si_errno = 0;
 	info.si_code = SI_USER;
@@ -2857,6 +2883,8 @@
 	return kill_something_info(sig, &info, pid);
 }
 
+EXPORT_SYMBOL(sys_kill);
+
 static int
 do_send_specific(pid_t tgid, pid_t pid, int sig, struct siginfo *info)
 {
@@ -2887,7 +2915,7 @@
 	return error;
 }
 
-static int do_tkill(pid_t tgid, pid_t pid, int sig)
+int do_tkill(pid_t tgid, pid_t pid, int sig)
 {
 	struct siginfo info;
 
@@ -2900,6 +2928,8 @@
 	return do_send_specific(tgid, pid, sig, &info);
 }
 
+EXPORT_SYMBOL(do_tkill);
+
 /**
  *  sys_tgkill - send signal to one specific thread
  *  @tgid: the thread group ID of the thread
@@ -2963,6 +2993,8 @@
 	return kill_proc_info(sig, &info, pid);
 }
 
+EXPORT_SYMBOL(sys_rt_sigqueueinfo);
+
 long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t *info)
 {
 	/* This is only valid for single tasks */
@@ -3038,6 +3070,8 @@
 	return 0;
 }
 
+EXPORT_SYMBOL(do_sigaction);
+
 int 
 do_sigaltstack (const stack_t __user *uss, stack_t __user *uoss, unsigned long sp)
 {
diff -Naur linux-3.7.1_original/linux-3.7.1//kernel/sys.c linux-3.7.1/kernel/sys.c
--- linux-3.7.1_original/linux-3.7.1//kernel/sys.c	2012-12-17 20:14:54.000000000 +0100
+++ linux-3.7.1/kernel/sys.c	2013-01-31 13:13:39.000000000 +0100
@@ -55,6 +55,7 @@
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/unistd.h>
+#include <clondike/tcmi/tcmi_hooks.h>
 
 #ifndef SET_UNALIGN_CTL
 # define SET_UNALIGN_CTL(a,b)	(-EINVAL)
@@ -232,6 +233,8 @@
 	return error;
 }
 
+EXPORT_SYMBOL(sys_setpriority);
+
 /*
  * Ugh. To avoid negative return values, "getpriority()" will
  * not return the normal nice-value, but a negated value that
@@ -302,6 +305,8 @@
 	return retval;
 }
 
+EXPORT_SYMBOL(sys_getpriority);
+
 /**
  *	emergency_restart - reboot the system
  *
@@ -607,6 +612,8 @@
 	return retval;
 }
 
+EXPORT_SYMBOL(sys_setregid);
+
 /*
  * setgid() is implemented like SysV w/ SAVED_IDS 
  *
@@ -644,6 +651,8 @@
 	return retval;
 }
 
+EXPORT_SYMBOL(sys_setgid);
+
 /*
  * change the user struct in a credentials set to match the new UID
  */
@@ -747,6 +756,8 @@
 	abort_creds(new);
 	return retval;
 }
+
+EXPORT_SYMBOL(sys_setreuid);
 		
 /*
  * setuid() is implemented like SysV with SAVED_IDS 
@@ -801,6 +812,7 @@
 	return retval;
 }
 
+EXPORT_SYMBOL(sys_setuid);
 
 /*
  * This function implements a generic ability to update ruid, euid,
@@ -888,6 +900,8 @@
 	return retval;
 }
 
+EXPORT_SYMBOL(sys_getresuid);
+
 /*
  * Same as above, but for rgid, egid, sgid.
  */
@@ -943,6 +957,8 @@
 	return retval;
 }
 
+EXPORT_SYMBOL(sys_setresuid);
+
 SYSCALL_DEFINE3(getresgid, gid_t __user *, rgidp, gid_t __user *, egidp, gid_t __user *, sgidp)
 {
 	const struct cred *cred = current_cred();
@@ -960,6 +976,7 @@
 	return retval;
 }
 
+EXPORT_SYMBOL(sys_getresgid);
 
 /*
  * "setfsuid()" sets the fsuid - the uid used for filesystem checks. This
@@ -1003,6 +1020,8 @@
 	return old_fsuid;
 }
 
+EXPORT_SYMBOL(sys_setfsuid);
+
 /*
  * Samma pÃ¥ svenska..
  */
@@ -1041,6 +1060,8 @@
 	return old_fsgid;
 }
 
+EXPORT_SYMBOL(sys_setfsgid);
+
 void do_sys_times(struct tms *tms)
 {
 	cputime_t tgutime, tgstime, cutime, cstime;
@@ -1069,6 +1090,8 @@
 	return (long) jiffies_64_to_clock_t(get_jiffies_64());
 }
 
+EXPORT_SYMBOL(sys_times);
+
 /*
  * This needs some heavy checking ...
  * I just haven't the stomach for it. I also don't fully
@@ -1152,6 +1175,8 @@
 	return err;
 }
 
+EXPORT_SYMBOL(sys_setpgid);
+
 SYSCALL_DEFINE1(getpgid, pid_t, pid)
 {
 	struct task_struct *p;
@@ -1180,13 +1205,15 @@
 	return retval;
 }
 
+EXPORT_SYMBOL(sys_getpgid);
+
 #ifdef __ARCH_WANT_SYS_GETPGRP
 
 SYSCALL_DEFINE0(getpgrp)
 {
 	return sys_getpgid(0);
 }
-
+EXPORT_SYMBOL(sys_getpgrp);
 #endif
 
 SYSCALL_DEFINE1(getsid, pid_t, pid)
@@ -1194,6 +1221,10 @@
 	struct task_struct *p;
 	struct pid *sid;
 	int retval;
+  
+  TCMI_TASK_GUEST{
+		return TCMI_HOOKS_CALL(sys_getsid, pid);
+	}
 
 	rcu_read_lock();
 	if (!pid)
@@ -1217,12 +1248,18 @@
 	return retval;
 }
 
+EXPORT_SYMBOL(sys_getsid);
+
 SYSCALL_DEFINE0(setsid)
 {
 	struct task_struct *group_leader = current->group_leader;
 	struct pid *sid = task_pid(group_leader);
 	pid_t session = pid_vnr(sid);
 	int err = -EPERM;
+  
+  TCMI_TASK_GUEST{
+		return TCMI_HOOKS_CALL(sys_setsid);
+	}
 
 	write_lock_irq(&tasklist_lock);
 	/* Fail if I am already a session leader */
@@ -1250,6 +1287,8 @@
 	return err;
 }
 
+EXPORT_SYMBOL(sys_setsid);
+
 DECLARE_RWSEM(uts_sem);
 
 #ifdef COMPAT_UTS_MACHINE
@@ -1306,7 +1345,7 @@
 		errno = -EFAULT;
 	return errno;
 }
-
+EXPORT_SYMBOL(sys_newuname);
 #ifdef __ARCH_WANT_SYS_OLD_UNAME
 /*
  * Old cruft
@@ -1389,6 +1428,8 @@
 	return errno;
 }
 
+EXPORT_SYMBOL(sys_sethostname);
+
 #ifdef __ARCH_WANT_SYS_GETHOSTNAME
 
 SYSCALL_DEFINE2(gethostname, char __user *, name, int, len)
@@ -1396,6 +1437,8 @@
 	int i, errno;
 	struct new_utsname *u;
 
+  // TODO: Forward this call to home node?
+
 	if (len < 0)
 		return -EINVAL;
 	down_read(&uts_sem);
@@ -1410,6 +1453,8 @@
 	return errno;
 }
 
+EXPORT_SYMBOL(sys_gethostname);
+
 #endif
 
 /*
@@ -1440,6 +1485,8 @@
 	return errno;
 }
 
+EXPORT_SYMBOL(sys_setdomainname);
+
 SYSCALL_DEFINE2(getrlimit, unsigned int, resource, struct rlimit __user *, rlim)
 {
 	struct rlimit value;
@@ -1452,6 +1499,8 @@
 	return ret;
 }
 
+EXPORT_SYMBOL(sys_getrlimit);
+
 #ifdef __ARCH_WANT_SYS_OLD_GETRLIMIT
 
 /*
@@ -1650,6 +1699,8 @@
 	return do_prlimit(current, resource, &new_rlim, NULL);
 }
 
+EXPORT_SYMBOL(sys_setrlimit);
+
 /*
  * It would make sense to put struct rusage in the task_struct,
  * except that would make the task_struct be *really big*.  After
@@ -1774,6 +1825,8 @@
 	return copy_to_user(ru, &r, sizeof(r)) ? -EFAULT : 0;
 }
 
+EXPORT_SYMBOL(getrusage);
+
 SYSCALL_DEFINE2(getrusage, int, who, struct rusage __user *, ru)
 {
 	if (who != RUSAGE_SELF && who != RUSAGE_CHILDREN &&
@@ -1782,12 +1835,16 @@
 	return getrusage(current, who, ru);
 }
 
+EXPORT_SYMBOL(sys_getrusage);
+
 SYSCALL_DEFINE1(umask, int, mask)
 {
 	mask = xchg(&current->fs->umask, mask & S_IRWXUGO);
 	return mask;
 }
 
+EXPORT_SYMBOL(sys_umask);
+
 #ifdef CONFIG_CHECKPOINT_RESTORE
 static int prctl_set_mm_exe_file(struct mm_struct *mm, unsigned int fd)
 {
@@ -2170,6 +2227,8 @@
 	return error;
 }
 
+EXPORT_SYMBOL(sys_prctl);
+
 SYSCALL_DEFINE3(getcpu, unsigned __user *, cpup, unsigned __user *, nodep,
 		struct getcpu_cache __user *, unused)
 {
@@ -2182,6 +2241,8 @@
 	return err ? -EFAULT : 0;
 }
 
+EXPORT_SYMBOL(sys_getcpu);
+
 char poweroff_cmd[POWEROFF_CMD_PATH_LEN] = "/sbin/poweroff";
 
 static void argv_cleanup(struct subprocess_info *info)
diff -Naur linux-3.7.1_original/linux-3.7.1//kernel/timer.c linux-3.7.1/kernel/timer.c
--- linux-3.7.1_original/linux-3.7.1//kernel/timer.c	2012-12-17 20:14:54.000000000 +0100
+++ linux-3.7.1/kernel/timer.c	2013-01-31 13:23:50.000000000 +0100
@@ -46,6 +46,7 @@
 #include <asm/div64.h>
 #include <asm/timex.h>
 #include <asm/io.h>
+#include <clondike/tcmi/tcmi_hooks.h>
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/timer.h>
@@ -1393,6 +1394,8 @@
 	return alarm_setitimer(seconds);
 }
 
+EXPORT_SYMBOL(sys_alarm);
+
 #endif
 
 /**
@@ -1406,9 +1409,15 @@
  */
 SYSCALL_DEFINE0(getpid)
 {
-	return task_tgid_vnr(current);
+	TCMI_TASK_GUEST{
+		return TCMI_HOOKS_CALL(sys_getpid);
+	}
+  
+  return task_tgid_vnr(current);
 }
 
+EXPORT_SYMBOL(sys_getpid);
+
 /*
  * Accessing ->real_parent is not SMP-safe, it could
  * change from under us. However, we can use a stale
@@ -1419,6 +1428,10 @@
 {
 	int pid;
 
+  TCMI_TASK_GUEST{
+		return TCMI_HOOKS_CALL(sys_getppid);
+	}	
+
 	rcu_read_lock();
 	pid = task_tgid_vnr(rcu_dereference(current->real_parent));
 	rcu_read_unlock();
@@ -1426,30 +1439,53 @@
 	return pid;
 }
 
+EXPORT_SYMBOL(sys_getppid);
+
 SYSCALL_DEFINE0(getuid)
 {
-	/* Only we change this so SMP safe */
+	TCMI_TASK_GUEST{
+		return TCMI_HOOKS_CALL(sys_getuid);
+	}
+  
+  /* Only we change this so SMP safe */
 	return from_kuid_munged(current_user_ns(), current_uid());
 }
 
+EXPORT_SYMBOL(sys_getuid);
+
 SYSCALL_DEFINE0(geteuid)
 {
-	/* Only we change this so SMP safe */
+	TCMI_TASK_GUEST{
+		return TCMI_HOOKS_CALL(sys_geteuid);
+	}
+  /* Only we change this so SMP safe */
 	return from_kuid_munged(current_user_ns(), current_euid());
 }
 
+EXPORT_SYMBOL(sys_geteuid);
+
 SYSCALL_DEFINE0(getgid)
 {
-	/* Only we change this so SMP safe */
+	TCMI_TASK_GUEST{
+		return TCMI_HOOKS_CALL(sys_getgid);
+	}
+  /* Only we change this so SMP safe */
 	return from_kgid_munged(current_user_ns(), current_gid());
 }
 
+EXPORT_SYMBOL(sys_getgid);
+
 SYSCALL_DEFINE0(getegid)
 {
-	/* Only we change this so SMP safe */
+	TCMI_TASK_GUEST{
+		return TCMI_HOOKS_CALL(sys_getegid);
+	}
+  /* Only we change this so SMP safe */
 	return from_kgid_munged(current_user_ns(), current_egid());
 }
 
+EXPORT_SYMBOL(sys_getegid);
+
 static void process_timeout(unsigned long __data)
 {
 	wake_up_process((struct task_struct *)__data);
@@ -1630,6 +1666,8 @@
 	return 0;
 }
 
+EXPORT_SYMBOL(sys_gettid);
+
 SYSCALL_DEFINE1(sysinfo, struct sysinfo __user *, info)
 {
 	struct sysinfo val;
@@ -1642,6 +1680,8 @@
 	return 0;
 }
 
+EXPORT_SYMBOL(sys_sysinfo);
+
 static int __cpuinit init_timers_cpu(int cpu)
 {
 	int j;
diff -Naur linux-3.7.1_original/linux-3.7.1//Makefile linux-3.7.1/Makefile
--- linux-3.7.1_original/linux-3.7.1//Makefile	2012-12-17 20:14:54.000000000 +0100
+++ linux-3.7.1/Makefile	2013-03-28 21:33:32.000000000 +0100
@@ -518,7 +518,7 @@
 
 # Objects we will link into vmlinux / subdirs we need to visit
 init-y		:= init/
-drivers-y	:= drivers/ sound/ firmware/
+drivers-y	:= drivers/ sound/ firmware/ clondike/
 net-y		:= net/
 libs-y		:= lib/
 core-y		:= usr/
@@ -567,7 +567,7 @@
 # command line.
 # This allow a user to issue only 'make' to build a kernel including modules
 # Defaults to vmlinux, but the arch makefile usually adds further targets
-all: vmlinux
+all: clondike_symlink vmlinux
 
 ifdef CONFIG_CC_OPTIMIZE_FOR_SIZE
 KBUILD_CFLAGS	+= -Os
@@ -1419,3 +1419,6 @@
 # Declare the contents of the .PHONY variable as phony.  We keep that
 # information in a variable so we can use it in if_changed and friends.
 .PHONY: $(PHONY)
+
+clondike_symlink:
+	(ln -fsn $(ARCH) clondike/src/arch/current)
\ No newline at end of file
diff -Naur linux-3.7.1_original/linux-3.7.1//mm/memory.c linux-3.7.1/mm/memory.c
--- linux-3.7.1_original/linux-3.7.1//mm/memory.c	2012-12-17 20:14:54.000000000 +0100
+++ linux-3.7.1/mm/memory.c	2013-01-31 13:27:19.000000000 +0100
@@ -56,6 +56,7 @@
 #include <linux/kallsyms.h>
 #include <linux/swapops.h>
 #include <linux/elf.h>
+#include <clondike/tcmi/tcmi_dbg.h>
 #include <linux/gfp.h>
 
 #include <asm/io.h>
@@ -3451,6 +3452,12 @@
 	pte_t entry;
 	spinlock_t *ptl;
 
+  TCMI_ON_DEBUG {
+		printk(KERN_DEBUG "Handling pte fault at %lx, write_access = %d\n", 
+		       address, (flags & FAULT_FLAG_WRITE));
+	}		
+
+
 	entry = *pte;
 	if (!pte_present(entry)) {
 		if (pte_none(entry)) {
diff -Naur linux-3.7.1_original/linux-3.7.1//mm/mmap.c linux-3.7.1/mm/mmap.c
--- linux-3.7.1_original/linux-3.7.1//mm/mmap.c	2012-12-17 20:14:54.000000000 +0100
+++ linux-3.7.1/mm/mmap.c	2013-01-31 13:29:17.000000000 +0100
@@ -2552,6 +2552,8 @@
 	return ret;
 }
 
+EXPORT_SYMBOL(install_special_mapping);
+
 static DEFINE_MUTEX(mm_all_locks_mutex);
 
 static void vm_lock_anon_vma(struct mm_struct *mm, struct anon_vma *anon_vma)
diff -Naur linux-3.7.1_original/linux-3.7.1//scripts/Makefile linux-3.7.1/scripts/Makefile
--- linux-3.7.1_original/linux-3.7.1//scripts/Makefile	2012-12-17 20:14:54.000000000 +0100
+++ linux-3.7.1/scripts/Makefile	2013-03-28 21:32:06.000000000 +0100
@@ -17,6 +17,7 @@
 hostprogs-$(BUILD_C_RECORDMCOUNT) += recordmcount
 hostprogs-$(CONFIG_BUILDTIME_EXTABLE_SORT) += sortextable
 hostprogs-$(CONFIG_ASN1)	 += asn1_compiler
+hostprogs-$(CONFIG_TCMI)	+= ../clondike/src/scripts/dbgenv
 
 HOSTCFLAGS_sortextable.o = -I$(srctree)/tools/include
 HOSTCFLAGS_asn1_compiler.o = -I$(srctree)/include
