--- linux-3.7.1_original/clondike/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/Makefile	2013-01-07 11:22:45.000000000 +0100
@@ -0,0 +1,7 @@
+# Builds the Clondike system
+#
+#
+obj-y += tcmi/
+ifeq ($(CONFIG_TCMI),y)
+	obj-y += src/
+endif
--- linux-3.7.1_original/clondike/tcmi/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/tcmi/Makefile	2013-01-07 11:22:45.000000000 +0100
@@ -0,0 +1,6 @@
+#
+# Makefile for TCMI components required to be built into kernel
+#
+# 
+
+obj-$(CONFIG_TCMI_HOOKS) :=	tcmi_hooks.o tcmi_dbg.o
--- linux-3.7.1_original/clondike/tcmi/tcmi_dbg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/tcmi/tcmi_dbg.c	2013-01-07 11:22:45.000000000 +0100
@@ -0,0 +1,6 @@
+#include <clondike/tcmi/tcmi_dbg.h>
+#include <linux/cache.h>
+#include <linux/module.h>
+
+int tcmi_dbg __read_mostly = 1;
+EXPORT_SYMBOL_GPL(tcmi_dbg);
--- linux-3.7.1_original/clondike/tcmi/tcmi_hooks.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/tcmi/tcmi_hooks.c	2013-01-07 11:22:45.000000000 +0100
@@ -0,0 +1,21 @@
+/**
+ * @file tcmi_hooks.c - Definition of all hooks in kernel requires only
+ *                      including the header file as private
+ * 
+ * 
+ * 
+ * 
+ * 
+ *
+ * Date: 04/21/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: linux-2.6.23-uml-clondike.patch,v 1.1 2009-01-20 14:22:16 andrep1 Exp $
+ *
+ * License....
+ */
+
+#define TCMI_HOOKS_FACTORY_PRIVATE
+#include <clondike/tcmi/tcmi_hooks.h>
+
--- linux-3.7.1_original/clondike/src/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/Makefile	2013-03-12 14:23:44.000000000 +0100
@@ -0,0 +1,51 @@
+##############################################################################
+# @file Makefile - Main Clondike sources makefile
+#
+# Author: Petr Malat
+#
+# This file is part of Clondike.
+#
+# Clondike is free software: you can redistribute it and/or modify it under 
+# the terms of the GNU General Public License version 2 as published by 
+# the Free Software Foundation.
+#
+# Clondike is distributed in the hope that it will be useful, but WITHOUT ANY
+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
+# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more 
+# details.
+# 
+# You should have received a copy of the GNU General Public License along with 
+# Clondike. If not, see http://www.gnu.org/licenses/.
+##############################################################################
+
+ifeq ($(KERNELRELEASE),)
+
+
+.PHONY: all prepare clean
+
+#KDIR ?= /home/petr/projects/clondike3/linux-2.6.33.1/ # symlink to the kernel source
+KDIR ?= /usr/src/linux-2.6.33.1
+ARCH := $(shell uname -m | sed -e s/i.86/i386/     -e s/sun4u/sparc64/ \
+		               -e s/arm.*/arm/ 	   -e s/sa110/arm/ \
+		               -e s/s390x/s390/    -e s/parisc64/parisc/ \
+			       -e s/ppc.*/powerpc/ -e s/mips.*/mips/ )
+
+NPWD := $(shell pwd)
+
+all: prepare	
+	$(MAKE) -C $(KDIR) M=$(NPWD)
+clean:
+	$(MAKE) -C $(KDIR) M=$(NPWD) clean
+prepare:
+	(cd scripts; gcc dbgenv.c -o dbgenv)
+	ln -fsn $(ARCH) arch/current
+else
+
+include $(src)/debug.make
+export PATH := $(PATH):$(NPWD)/$(src)/scripts:$(src)/scripts
+
+subdir-ccflags-y   := -I$(src) 
+obj-$(CONFIG_TCMI) := kkc/ director/ ccfs/ proxyfs/ tcmi/ 
+
+endif
+
--- linux-3.7.1_original/clondike/src/ccfs/read_write.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/ccfs/read_write.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,104 @@
+#include <linux/fs.h>
+#include <linux/pagemap.h>
+#include "ccfs.h"
+
+#include <dbg.h>
+
+int ccfs_write_lower(struct inode *ccfsinode, char *data,
+			 loff_t offset, size_t size)
+{
+	struct ccfs_inode *inode_info;
+	ssize_t octets_written;
+	mm_segment_t fs_save;
+	int rc = 0;
+
+	inode_info = ccfs_inode_to_private(ccfsinode);
+	mutex_lock(&inode_info->lower_file_mutex);
+	BUG_ON(!inode_info->lower_file);
+	inode_info->lower_file->f_pos = offset;
+	mdbg(INFO3, "Inode %p has lower file: %p (%ld)", ccfsinode, inode_info->lower_file, atomic_long_read(&inode_info->lower_file->f_count));
+	
+	fs_save = get_fs();
+	set_fs(get_ds());
+	octets_written = vfs_write(inode_info->lower_file, data, size,
+				   &inode_info->lower_file->f_pos);
+	set_fs(fs_save);
+	if (octets_written < 0) {
+	  	mdbg(INFO3, "Error writing. Written %d, size %d", octets_written, size);
+		rc = -EINVAL;
+	}	
+	mutex_unlock(&inode_info->lower_file_mutex);
+	mark_inode_dirty_sync(ccfsinode);
+	return rc;
+}
+
+int ccfs_write_lower_page_segment(struct inode *ccfsinode,
+				      struct page *page_for_lower,
+				      size_t offset_in_page, size_t size)
+{
+	struct ccfs_inode *inode_info;
+	char *virt;
+	loff_t offset;
+	int rc;
+	inode_info = ccfs_inode_to_private(ccfsinode);
+
+	mdbg(INFO3, "Inode %p has lower file: %p (%ld)", ccfsinode, inode_info->lower_file, atomic_long_read(&inode_info->lower_file->f_count));
+	
+	offset = ((((loff_t)page_for_lower->index) << PAGE_CACHE_SHIFT)
+		  + offset_in_page);
+	virt = kmap(page_for_lower);
+	rc = ccfs_write_lower(ccfsinode, virt, offset, size);
+	kunmap(page_for_lower);
+	return rc;
+}
+
+int ccfs_read_lower(char *data, loff_t offset, size_t size,
+			struct inode *ccfsinode)
+{
+	struct ccfs_inode *inode_info =
+		ccfs_inode_to_private(ccfsinode);
+	ssize_t octets_read;
+	mm_segment_t fs_save;
+	int rc = 0;
+
+	BUG_ON(!inode_info);
+			
+	mutex_lock(&inode_info->lower_file_mutex);
+	mdbg(INFO3, "Inode %p has lower file: %p (%ld)", ccfsinode, inode_info->lower_file, atomic_long_read(&inode_info->lower_file->f_count));
+	
+	BUG_ON(!inode_info->lower_file);
+	inode_info->lower_file->f_pos = offset;
+	fs_save = get_fs();
+	set_fs(get_ds());
+	octets_read = vfs_read(inode_info->lower_file, data, size,
+			       &inode_info->lower_file->f_pos);
+	set_fs(fs_save);
+	if (octets_read < 0) {
+		printk(KERN_ERR "%s: octets_read = [%td]; "
+		       "expected [%td]\n", __FUNCTION__, octets_read, size);
+		rc = -EINVAL;
+	}
+	mutex_unlock(&inode_info->lower_file_mutex);
+	return rc;
+}
+
+int ccfs_read_lower_page_segment(struct page *page_for_ccfs,
+				     pgoff_t page_index,
+				     size_t offset_in_page, size_t size,
+				     struct inode *ccfsinode)
+{
+	char *virt;
+	loff_t offset;
+	int rc;
+	struct ccfs_inode *inode_info =
+		ccfs_inode_to_private(ccfsinode);
+		
+	mdbg(INFO3, "Inode %p has lower file: %p (%ld)", ccfsinode, inode_info->lower_file, atomic_long_read(&inode_info->lower_file->f_count));	
+
+	offset = ((((loff_t)page_index) << PAGE_CACHE_SHIFT) + offset_in_page);
+	virt = kmap(page_for_ccfs);
+	rc = ccfs_read_lower(virt, offset, size, ccfsinode);
+	kunmap(page_for_ccfs);
+	flush_dcache_page(page_for_ccfs);
+	return rc;
+}
--- linux-3.7.1_original/clondike/src/ccfs/super.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/ccfs/super.c	2013-02-28 14:59:15.000000000 +0100
@@ -0,0 +1,152 @@
+#include <linux/fs.h>
+#include <linux/mount.h>
+#include <linux/key.h>
+#include <linux/seq_file.h>
+#include <linux/file.h>
+#include <linux/crypto.h>
+#include "ccfs.h"
+
+#include <dbg.h>
+
+struct kmem_cache *ccfs_inode_cache;
+
+static struct inode *ccfs_alloc_inode(struct super_block *sb)
+{
+	struct ccfs_inode *c_inode;
+	struct inode *inode = NULL;
+
+	c_inode = kmem_cache_alloc(ccfs_inode_cache, GFP_KERNEL);
+	mdbg(INFO3,  "Allocated inode: %p", c_inode);
+	if (unlikely(!c_inode))
+		goto out;
+
+	mutex_init(&c_inode->lower_file_mutex);
+	c_inode->lower_file = NULL;
+	inode = &c_inode->vfs_inode;
+	c_inode->link = NULL;
+	c_inode->stat = NULL;
+out:
+	return inode;
+}
+
+static void ccfs_destroy_inode(struct inode *inode)
+{
+	struct ccfs_inode *c_inode;
+
+	c_inode = ccfs_inode_to_private(inode);
+	mdbg(INFO3,  "Destroying inode: %p Lower file: %p", c_inode, c_inode->lower_file);
+	mutex_lock(&c_inode->lower_file_mutex);
+	if (c_inode->lower_file) {
+		struct dentry *lower_dentry =
+			c_inode->lower_file->f_dentry;
+
+		BUG_ON(!lower_dentry);
+		mdbg(INFO3,  "Destroying nested dentry: %s", lower_dentry->d_iname);
+		if (lower_dentry->d_inode) {
+			mdbg(INFO3,  "Puting lower file: %p (%ld)", c_inode->lower_file, atomic_long_read(&c_inode->lower_file->f_count));
+			fput(c_inode->lower_file);
+			c_inode->lower_file = NULL;
+			//d_drop(lower_dentry); This is likely not neccesary, but worse it is a race as the lower dentry is not held at this time
+		}
+
+		kfree(c_inode->link);
+		kfree(c_inode->stat);
+	}
+	mutex_unlock(&c_inode->lower_file_mutex);
+	kmem_cache_free(ccfs_inode_cache, c_inode);
+	mdbg(INFO3, "Destroy done");
+}
+
+void ccfs_init_inode(struct inode *inode, struct inode *lower_inode)
+{
+	mdbg(INFO3, "Initializing inode: %p with lower inode: %p", inode, lower_inode);
+	ccfs_set_nested_inode(inode, lower_inode);
+	inode->i_ino = lower_inode->i_ino;
+	inode->i_version++;
+	inode->i_op = &ccfs_main_iops;
+	inode->i_fop = &ccfs_main_fops;
+	inode->i_mapping->a_ops = &ccfs_aops;
+	ccfs_inode_to_private(inode)->cacheable = 1;	
+}
+
+static void ccfs_put_super(struct super_block *sb)
+{
+	struct ccfs_super *sb_info = ccfs_superblock_to_private(sb);
+
+	destroy_filter(sb_info->cacheable_filter);
+	kmem_cache_free(ccfs_sb_cache, sb_info);
+	ccfs_set_superblock_private(sb, NULL);
+}
+
+static int ccfs_statfs(struct dentry *dentry, struct kstatfs *buf)
+{
+	// Fix Clondike for kernel 3.7.1 add define struct path and fill path.dentry = original dentry which is returned by ccfs_get_nested_dentry
+	// When calling vfs_statfs with address other parameter ccfs_path which contains of record pointer to original dentry
+	// This fix was applied because function vfs_statfs has a different type of parameter 
+	struct path ccfs_path;
+	ccfs_get_nested_dentry(dentry);
+	ccfs_path.dentry = dentry;
+	return vfs_statfs(&ccfs_path, buf);
+}
+/*
+Commented because structure super_operations doesn't contain of it
+static void ccfs_clear_inode(struct inode *inode)
+{
+	mdbg(INFO3, "Clearing inode: %p", inode);
+	iput(ccfs_get_nested_inode(inode));
+}
+*/
+
+// Change return type from void to int and add return 0 by Jiri Rakosnik
+static int ccfs_drop_inode(struct inode *inode)
+{
+	if ( !ccfs_is_inode_cacheable(inode) ) {
+		mdbg(INFO3, "Dropping non-cacheable inode: %p", inode);
+		generic_delete_inode(inode);		
+	} else {
+		generic_drop_inode(inode);		
+	} 	
+	return 0;
+}
+
+// Change type of second parametr from vfsmount to dentry and in function dentry->d_sb for getting superblock
+// This fix is for kernel 3.7.1 by Jiri Rakosnik
+static int ccfs_show_options(struct seq_file *m, struct dentry *dentry)
+{
+	struct super_block *sb = dentry->d_sb;
+	struct dentry *lower_root_dentry = ccfs_get_nested_dentry(sb->s_root);
+	struct vfsmount *lower_mnt = ccfs_dentry_to_nested_mnt(sb->s_root);
+	struct path tmp_path;
+	char *tmp_page;
+	char *path;
+	int rc = 0;
+
+	tmp_path.dentry = lower_root_dentry;
+	tmp_path.mnt = lower_mnt;
+
+	tmp_page = (char *)__get_free_page(GFP_KERNEL);
+	if (!tmp_page) {
+		rc = -ENOMEM;
+		goto out;
+	}
+	path = d_path(&tmp_path, tmp_page, PAGE_SIZE);
+	if (IS_ERR(path)) {
+		rc = PTR_ERR(path);
+		goto out;
+	}
+	seq_printf(m, ",dir=%s", path);
+	free_page((unsigned long)tmp_page);
+out:
+	return rc;
+}
+
+const struct super_operations ccfs_sops = {
+	.alloc_inode = ccfs_alloc_inode,
+	.destroy_inode = ccfs_destroy_inode,
+	.drop_inode = ccfs_drop_inode, // generic_delete_inode,
+	.put_super = ccfs_put_super,
+	.statfs = ccfs_statfs,
+	.remount_fs = NULL,
+	//.clear_inode = ccfs_clear_inode,
+	.show_options = ccfs_show_options
+};
--- linux-3.7.1_original/clondike/src/ccfs/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/ccfs/Makefile	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,24 @@
+##############################################################################
+# @file Makefile - Builds CCFS
+#
+# Author: Petr Malat
+#
+# This file is part of Clondike.
+#
+# Clondike is free software: you can redistribute it and/or modify it under 
+# the terms of the GNU General Public License version 2 as published by 
+# the Free Software Foundation.
+#
+# Clondike is distributed in the hope that it will be useful, but WITHOUT ANY
+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
+# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more 
+# details.
+# 
+# You should have received a copy of the GNU General Public License along with 
+# Clondike. If not, see http://www.gnu.org/licenses/.
+##############################################################################
+
+ccflags-y = `dbgenv $<`
+
+obj-$(CONFIG_TCMI) := ccfs.o
+ccfs-objs          := dentry.o inode.o mmap.o main.o file.o super.o read_write.o prefetcher.o filter.o
--- linux-3.7.1_original/clondike/src/ccfs/file.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/ccfs/file.c	2013-02-28 14:20:05.000000000 +0100
@@ -0,0 +1,239 @@
+#include <linux/file.h>
+#include <linux/poll.h>
+#include <linux/mount.h>
+#include <linux/pagemap.h>
+#include <linux/security.h>
+#include <linux/compat.h>
+#include <linux/fs_stack.h>
+#include "ccfs.h"
+#include "prefetcher.h"
+
+#include <dbg.h>
+
+struct kmem_cache *ccfs_file_cache;
+
+int ccfs_readdir (struct file *filp, void *dirent, filldir_t filldir) {
+	int rc;
+	struct file *lower_file;
+	struct inode *inode;
+
+	lower_file = ccfs_get_nested_file(filp);
+	mdbg(INFO3, "Read filp %p with lower file: %p Pos: %lu (Upper pos: %lu)", filp, lower_file, (unsigned long)lower_file->f_pos, (unsigned long)filp->f_pos);
+	lower_file->f_pos = filp->f_pos;
+	inode = filp->f_path.dentry->d_inode;
+	rc = vfs_readdir(lower_file, filldir, dirent);
+	mdbg(INFO3, "Read return code: %d", rc);
+	filp->f_pos = lower_file->f_pos;	
+	if (rc >= 0)
+		fsstack_copy_attr_atime(inode, lower_file->f_path.dentry->d_inode);
+
+	// The following does not seem to be true at least with kernel 2.6.33.1, so we leave dirs cacheable again
+	// We need to disable file caching after readdir, as some filesystems (9P) are not able to repear readdirs on a same file!
+	//ccfs_inode_to_private(inode)->cacheable = 0;
+
+	return rc;
+}
+/*
+static int ccfs_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+	       unsigned long arg)
+{
+	int rc = 0;
+	struct file *lower_file = NULL;
+
+	if (ccfs_get_nested_file(file))
+		lower_file = ccfs_get_nested_file(file);
+	if (lower_file && lower_file->f_op && lower_file->f_op->ioctl)
+		rc = lower_file->f_op->ioctl(ccfs_get_nested_inode(inode),
+					     lower_file, cmd, arg);
+	else
+		rc = -ENOTTY;
+	return rc;
+}
+*/
+
+int ccfs_close_lower_file(struct file *lower_file)
+{
+	mdbg(INFO3,"Closing lower file file %p", lower_file);
+	fput(lower_file);
+	return 0;
+}
+
+static int ccfs_open(struct inode *inode, struct file *file)
+{
+	struct file *lower_file = NULL;	
+	struct ccfs_file* file_info = NULL;
+	int rc = 0;
+	struct ccfs_super* sb_info = ccfs_superblock_to_private(inode->i_sb);
+
+	file_info = kmem_cache_zalloc(ccfs_file_cache, GFP_KERNEL);
+	if ( !file_info ) {
+		rc = -ENOMEM;
+		goto out;
+	}
+	
+	ccfs_set_file_private(file, file_info);
+
+	if ( !ccfs_inode_to_private(inode)->cacheable ) {
+		// Haven't found a reason why would we reopen file here, we just wait let the file close and invalidate when nobody is using it. It is not 100% correct thing in cases of races
+		// but since this is just a toy FS for experimental measurements, we can leave it as it is (unless we want to measure something with races in FS;)
+	  
+		// TODO: This is a hack to reopen "root" dentry, it is not required for other entries. Moreover, we can now reset cacheable flag, but do we need to?
+		// TODO: The comment above is really cryptic and not sure what I was trying to say :(... Generally, the files are refreshed when they are non-cacheable and
+		// last reference to them is dropped which seems like a safe behaviour.. my suspition is, the comment was saying it does not happen for root node, which is always
+		// held, but not sure.. for now disable due to caused races and if I find what is the real reason for this call I'll update this code/comment
+		// ccfs_reopen_persistent_file(file->f_path.dentry, inode);
+		
+//		if ( !invalidate_inode_pages2(inode->i_mapping) ) {
+//		    minfo(ERR3, "Cache invalidation has failed");
+//		}
+	}	
+
+	lower_file = ccfs_inode_to_private(inode)->lower_file;
+	mdbg(INFO3, "Opening inode %p (file %p) associated with lower file: %p (dname: [%s]) - cacheable: %d", inode, file, lower_file, file->f_dentry->d_name.name, ccfs_inode_to_private(inode)->cacheable);
+	if ( !lower_file ) {
+		minfo(ERR3, "Assertion failed! Lower file does not exist!");
+		kmem_cache_free(ccfs_file_cache, file_info);
+		rc = -ENOENT;
+		goto out;		
+	}
+
+	ccfs_set_nested_file(file, lower_file);
+
+	if ( sb_info->prefetch && S_ISREG(inode->i_mode) ) { // TODO: Schedule this only on first open of file?
+		mdbg(INFO3,"Scheduling prefetch for inode %p", inode);
+		// TODO: Uncommented as there seems to be some problem with prefetcher.. on freeing pages we usually got 
+		// General protection fault.. it is probably caused by allocation of pages in context of a different proces?
+		
+		//atomic_inc(&file->f_count); // Get reference that'll be freed by prefetcher after the prefetch is done
+		//submit_for_prefetch(file);
+	}
+out:
+	return rc;	
+}
+
+static int ccfs_release(struct inode *inode, struct file *file)
+{
+	struct ccfs_file *file_info = ccfs_get_file_private(file);
+
+	mdbg(INFO3,"Release file %p", file);
+	ccfs_set_nested_file(file, NULL); // Improve error catching ;)
+
+	kmem_cache_free(ccfs_file_cache, file_info);
+	return 0;
+}
+
+static int ccfs_flush(struct file *file, fl_owner_t td)
+{
+	int rc = 0;
+	struct file *lower_file = NULL;
+
+	mdbg(INFO3,"Flush file %p", file);
+	lower_file = ccfs_get_nested_file(file);
+	mdbg(INFO3,"Flush lower file %p (%ld)", lower_file, atomic_long_read(&lower_file->f_count));
+	
+	BUG_ON(!lower_file);
+	
+	if (lower_file->f_op && lower_file->f_op->flush)
+		rc = lower_file->f_op->flush(lower_file, td);
+	return rc;
+}
+
+static int
+ccfs_fsync(struct file *file, loff_t start, loff_t end, int datasync)
+{
+	struct file *lower_file = ccfs_get_nested_file(file);
+	//struct dentry *lower_dentry = ccfs_get_nested_dentry(dentry);			 Commented for kernel 3.7.1 by Jiri Rakosnik
+	//struct inode *lower_inode = lower_dentry != NULL ? lower_dentry->d_inode : NULL;
+	struct inode *lower_inode = NULL;
+	int rc = -EINVAL;
+	
+	//BUG_ON(!lower_dentry);
+	BUG_ON(!lower_inode);	
+	
+	mdbg(INFO3,"Fsync file %p", file);
+	
+	if (lower_inode->i_fop->fsync) {
+		mutex_lock(&lower_inode->i_mutex);
+		rc = lower_inode->i_fop->fsync(lower_file, 0, 0,
+					       datasync);
+		mutex_unlock(&lower_inode->i_mutex);
+	}
+	return rc;
+}
+
+static int ccfs_fasync(int fd, struct file *file, int flag)
+{
+	int rc = 0;
+	struct file *lower_file = NULL;
+
+	mdbg(INFO3,"Fasync file %p", file);
+	
+	lower_file = ccfs_get_nested_file(file);
+	if (lower_file->f_op && lower_file->f_op->fasync)
+		rc = lower_file->f_op->fasync(fd, lower_file, flag);
+	return rc;
+}
+
+static ssize_t ccfs_splice_read(struct file *file, loff_t * ppos,
+				    struct pipe_inode_info *pipe, size_t count,
+				    unsigned int flags)
+{
+	struct file *lower_file = NULL;
+	int rc = -EINVAL;
+
+	lower_file = ccfs_get_nested_file(file);
+	if (lower_file->f_op && lower_file->f_op->splice_read)
+		rc = lower_file->f_op->splice_read(lower_file, ppos, pipe,
+						count, flags);
+
+	return rc;
+}
+
+static int ccfs_file_mmap(struct file * file, struct vm_area_struct * vma) {
+	mdbg(INFO3,"Mmap file %p [%s]", file, file->f_dentry->d_name.name);
+  
+	return generic_file_mmap(file, vma);
+}
+
+static ssize_t ccfs_do_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos) {
+  ssize_t res;
+  res = do_sync_read(filp, buf, len, ppos);
+  mdbg(INFO3,"Read file %p [%s] -> Len: %ld, Res: %ld", filp, filp->f_dentry->d_name.name, len, res);  
+  return res;
+}
+
+static ssize_t ccfs_generic_file_aio_read(struct kiocb *iocb, const struct iovec *iov, unsigned long nr_segs, loff_t pos) {
+  ssize_t res;
+  res = generic_file_aio_read(iocb, iov, nr_segs, pos);
+  mdbg(INFO3,"Async Read ... Pos: %ld, Res: %ld", pos, res);  
+  return res;
+}
+
+const struct file_operations ccfs_dir_fops = {
+	.readdir = ccfs_readdir,
+	//.ioctl = ccfs_ioctl,			fix for kernel 3.7.1 by Jiri Rakosnik
+	.mmap = ccfs_file_mmap,
+	.open = ccfs_open,
+	.flush = ccfs_flush,
+	.release = ccfs_release,
+	.fsync = ccfs_fsync,
+	.fasync = ccfs_fasync,
+	.splice_read = ccfs_splice_read,
+};
+
+const struct file_operations ccfs_main_fops = {
+	.llseek = generic_file_llseek,
+	.read = ccfs_do_sync_read,
+	.aio_read = ccfs_generic_file_aio_read,
+	.write = do_sync_write,
+	.aio_write = generic_file_aio_write,
+	.readdir = ccfs_readdir,
+	//.ioctl = ccfs_ioctl,			fix for kernel 3.7.1 by Jiri Rakosnik
+	.mmap = ccfs_file_mmap,
+	.open = ccfs_open,
+	.flush = ccfs_flush,
+	.release = ccfs_release,
+	.fsync = ccfs_fsync,
+	.fasync = ccfs_fasync,
+	.splice_read = ccfs_splice_read,
+};
--- linux-3.7.1_original/clondike/src/ccfs/main.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/ccfs/main.c	2013-02-28 13:19:46.000000000 +0100
@@ -0,0 +1,477 @@
+#include <linux/dcache.h>
+#include <linux/file.h>
+#include <linux/module.h>
+#include <linux/namei.h>
+#include <linux/skbuff.h>
+#include <linux/crypto.h>
+#include <linux/netlink.h>
+#include <linux/mount.h>
+#include <linux/pagemap.h>
+#include <linux/key.h>
+#include <linux/parser.h>
+#include <linux/fs_stack.h>
+#include "ccfs.h"
+#include "prefetcher.h"
+
+#include <dbg.h>
+
+static int ccfs_init_persistent_file_unlocked(struct dentry *ccfsdentry, struct inode* ccfsinode) {
+  	struct path ccfs_path;   //Fix Clondike for kernel 3.7.1 add struct ccfs_path contains *lower_dentry and *lower_mnt  by Jiri Rakosnik
+    struct ccfs_inode *inode_info =
+		ccfs_inode_to_private(ccfsinode);
+	int rc = 0;
+
+  	if (!inode_info->lower_file) {
+		struct dentry *lower_dentry;
+		struct vfsmount *lower_mnt = 	ccfs_dentry_to_nested_mnt(ccfsdentry);
+		int try_write_mode = 0;
+    
+    ccfs_path.mnt = lower_mnt; // Set contain of struct ccfs_path
+    
+		lower_dentry = ccfs_get_nested_dentry(ccfsdentry);
+    
+    ccfs_path.dentry = lower_dentry; // Set contain of struct ccfs_path
+
+		dget(lower_dentry);
+		mntget(lower_mnt);
+
+		// TODO: Write mode is now attempted only for non-cacheable files
+		try_write_mode = !ccfs_is_inode_cacheable(ccfsinode);
+		// Fix function dentry_open for kernel 3.7.1 remove lower_mnt parametr because it is in ccfs_path
+    inode_info->lower_file = dentry_open(&ccfs_path,
+						     try_write_mode ? (O_RDWR | O_LARGEFILE) : (O_RDONLY | O_LARGEFILE),
+						     current_cred()		
+						     );
+		if (IS_ERR(inode_info->lower_file)) {
+			mdbg(INFO3, "Error opening lower persistent file for lower_dentry [0x%p] and lower_mnt [0x%p] in write mode. Will try read only mode.",
+			       lower_dentry, lower_mnt);
+			dget(lower_dentry);
+			mntget(lower_mnt);
+			// Fix function dentry_open for kernel 3.7.1 remove lower_mnt parametr because it is in ccfs_path
+      inode_info->lower_file = dentry_open(&ccfs_path,
+							     (O_RDONLY
+							      | O_LARGEFILE), current_cred());
+		}
+		mdbg(INFO3, "Inode %p (%p) initialized lower file: %p (%ld) - write mode: %d", ccfsdentry->d_inode, ccfsinode, inode_info->lower_file, atomic_long_read(&inode_info->lower_file->f_count), try_write_mode);
+		if (IS_ERR(inode_info->lower_file)) {
+			mdbg(INFO3, "Error opening lower persistent file for lower_dentry [0x%p] and lower_mnt [0x%p]",
+			       lower_dentry, lower_mnt);
+			rc = PTR_ERR(inode_info->lower_file);
+			inode_info->lower_file = NULL;
+		}
+	} else {
+		mdbg(INFO3, "Inode %p (%p) was already initialized initialized lower file: %p (%ld)", ccfsdentry->d_inode, ccfsinode, inode_info->lower_file, atomic_long_read(&inode_info->lower_file->f_count));
+	}
+	
+	return rc;
+}
+
+static int ccfs_init_persistent_file(struct dentry *ccfsdentry, struct inode* ccfsinode)
+{
+	struct ccfs_inode *inode_info =
+		ccfs_inode_to_private(ccfsinode);
+	int rc = 0;
+
+	mutex_lock(&inode_info->lower_file_mutex);
+	rc = ccfs_init_persistent_file_unlocked(ccfsdentry, ccfsinode);
+	mutex_unlock(&inode_info->lower_file_mutex);
+	return rc;
+}
+
+int ccfs_reopen_persistent_file(struct dentry *ccfsdentry, struct inode* ccfsinode) {
+	struct ccfs_inode *inode_info;
+	int rc = 0;
+
+	mdbg(INFO3, "Inode %p reopen requested", ccfsdentry->d_inode);
+
+	if ( !ccfsdentry || !ccfsinode )
+		return -EINVAL;
+
+	inode_info = ccfs_inode_to_private(ccfsinode);
+
+	mdbg(INFO3, "Inode %p (%p) with lower file: %p being reopened", ccfsdentry->d_inode, ccfsinode, inode_info->lower_file);
+
+	mutex_lock(&inode_info->lower_file_mutex);
+	if ( inode_info->lower_file )	{
+		mdbg(INFO3, "Inode %p file release (%p -> %ld)", ccfsdentry->d_inode, inode_info->lower_file, atomic_long_read(&inode_info->lower_file->f_count));
+		fput(inode_info->lower_file);		
+		mdbg(INFO3, "Inode file release done");
+		inode_info->lower_file = NULL;		
+	}
+	
+	rc = ccfs_init_persistent_file_unlocked(ccfsdentry, ccfsinode);
+	mutex_unlock(&inode_info->lower_file_mutex);
+
+	return rc;
+}
+
+int ccfs_interpose(struct dentry *lower_dentry, struct dentry *dentry,
+		       struct super_block *sb, int flag)
+{
+	struct inode *lower_inode;
+	struct inode *inode;
+	int rc = 0;
+	int matches;
+	struct filter* filter;
+
+	mdbg(INFO3, "Inode %p being interposed", dentry->d_inode);
+
+	lower_inode = lower_dentry->d_inode;
+	if (lower_inode->i_sb != ccfs_superblock_to_lower(sb)) {
+		mdbg(ERR3, "Dentry %s EXDEV", dentry->d_name.name);
+		rc = -EXDEV;
+		goto out;
+	}
+	if (!igrab(lower_inode)) {
+		mdbg(ERR3, "Dentry %s STALE", dentry->d_name.name);
+		rc = -ESTALE;
+		goto out;
+	}
+	inode = iget5_locked(sb, (unsigned long)lower_inode,
+			     ccfs_inode_test, ccfs_inode_set,
+			     lower_inode);
+	if (!inode) {
+	      mdbg(ERR3, "Dentry %s No access", dentry->d_name.name);
+		rc = -EACCES;
+		iput(lower_inode);
+		goto out;
+	}
+
+	if (S_ISLNK(lower_inode->i_mode))
+		inode->i_op = &ccfs_symlink_iops;
+	else if (S_ISDIR(lower_inode->i_mode))
+		inode->i_op = &ccfs_dir_iops;
+	if (S_ISDIR(lower_inode->i_mode))
+		inode->i_fop = &ccfs_dir_fops;
+	if (special_file(lower_inode->i_mode))
+		init_special_inode(inode, lower_inode->i_mode,
+				   lower_inode->i_rdev);
+	dentry->d_op = &ccfs_dops;
+	fsstack_copy_attr_all(inode, lower_inode);
+	fsstack_copy_inode_size(inode, lower_inode);
+
+	inode->i_uid = lower_inode->i_uid;
+	inode->i_gid = lower_inode->i_gid;
+
+	// TODO: Only first time!
+	filter = ccfs_superblock_to_private(inode->i_sb)->cacheable_filter;	
+	matches = filter_matches(filter, dentry->d_name.name, dentry->d_name.len, &inode->i_ctime, inode->i_mode);
+	if ( !matches )
+		ccfs_inode_to_private(inode)->cacheable = 0;	
+	
+	mdbg(INFO3, "Dentry %s matches pattern: %d. Cacheable: %d", dentry->d_name.name, matches, ccfs_inode_to_private(inode)->cacheable);
+
+	
+	rc = ccfs_init_persistent_file(dentry, inode);
+
+	// Must be done AFTER the inner file is initialized! 
+	if (flag)
+		d_add(dentry, inode);
+	else
+		d_instantiate(dentry, inode);
+
+	if (rc) {
+		mdbg(INFO3, "%s: Error attempting to initialize the "
+		       "persistent file for the dentry with name [%s]; "
+		       "rc = [%d]", __FUNCTION__, dentry->d_name.name, rc);
+		goto out; // TODO: Release something?
+	}
+
+	// Must be done AFTER the inner file is initialized! 
+	if (inode->i_state & I_NEW)
+		unlock_new_inode(inode);
+	else 
+		iput(lower_inode); // TODO: Comment why release only on new
+	
+out:
+	return rc;
+}
+
+struct kmem_cache *ccfs_sb_cache;
+
+static int ccfs_fill_super(struct super_block *sb, void *raw_data, int silent)
+{
+	int rc = 0;
+
+	ccfs_set_superblock_private(sb,
+					kmem_cache_zalloc(ccfs_sb_cache,
+							 GFP_KERNEL));
+	if (!ccfs_superblock_to_private(sb)) {
+		printk(KERN_WARNING "Out of memory\n");
+		rc = -ENOMEM;
+		goto out;
+	}
+	sb->s_op = &ccfs_sops;
+	/* Released through deactivate_super(sb) from get_sb_nodev */
+	sb->s_root = d_alloc(NULL, &(const struct qstr) {{{.hash = 0, .len = 1}} ,.name = "/"});
+	if (!sb->s_root) {
+		printk(KERN_ERR "d_alloc failed\n");
+		rc = -ENOMEM;
+		goto out;
+	}
+	sb->s_root->d_op = &ccfs_dops;
+	sb->s_root->d_sb = sb;
+	sb->s_root->d_parent = sb->s_root;
+	/* Released in d_release when dput(sb->s_root) is called */
+	/* through deactivate_super(sb) from get_sb_nodev() */
+	ccfs_set_dentry_private(sb->s_root,
+				    kmem_cache_zalloc(ccfs_dentry_cache,
+						     GFP_KERNEL));
+	if (!ccfs_dentry_to_private(sb->s_root)) {
+		printk(KERN_ERR
+				"dentry_info_cache alloc failed\n");
+		rc = -ENOMEM;
+		goto out;
+	}
+	rc = 0;
+out:
+	/* Should be able to rely on deactivate_super called from
+	 * get_sb_nodev */
+	return rc;
+}
+
+static int ccfs_read_super(struct super_block *sb, const char *dev_name)
+{
+	int rc;
+	struct nameidata nd;
+	struct dentry *lower_root;
+	struct vfsmount *lower_mnt;
+
+	// Fix for kernel 3.7.1 substitute function path_lookup to do_path_lookup by Jiri Rakosnik
+
+	memset(&nd, 0, sizeof(struct nameidata));
+	rc = do_path_lookup(AT_FDCWD, dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &nd);  
+	if (rc) {
+		printk(KERN_WARNING "path_lookup() failed\n");
+		goto out;
+	}
+	lower_root = nd.path.dentry;
+	lower_mnt = nd.path.mnt;
+	ccfs_set_superblock_lower(sb, lower_root->d_sb);
+	sb->s_maxbytes = lower_root->d_sb->s_maxbytes;
+	sb->s_blocksize = lower_root->d_sb->s_blocksize;
+	ccfs_set_nested_dentry(sb->s_root, lower_root);
+	ccfs_set_dentry_nested_mnt(sb->s_root, lower_mnt);
+	rc = ccfs_interpose(lower_root, sb->s_root, sb, 0);
+	if (rc)
+		goto out_free;
+	rc = 0;
+	goto out;
+out_free:
+	path_put(&nd.path);
+out:
+	return rc;
+}
+
+enum { ccfs_opt_prefetch, ccfs_opt_cacheable_filter, ccfs_opt_err };
+
+static match_table_t tokens = {
+	{ccfs_opt_prefetch, "prefetch"},
+	{ccfs_opt_cacheable_filter, "cache_filter=%s"},
+	{ccfs_opt_err, NULL},
+};
+
+static int ccfs_parse_options(struct super_block *sb, char *options) {
+	int rc = 0;
+	substring_t args[MAX_OPT_ARGS];
+	int token;
+	char* p;
+	char tmp[1000];
+	struct ccfs_super* ccfssuper = ccfs_superblock_to_private(sb);
+
+	ccfssuper->prefetch = 0;
+	ccfssuper->cacheable_filter = NULL;
+
+	if (!options) {
+		goto out;
+	}
+
+	while ((p = strsep(&options, ",")) != NULL) {
+		if (!*p)
+			continue;
+		token = match_token(p, tokens, args);
+		switch (token) {
+			case ccfs_opt_prefetch:
+				ccfssuper->prefetch = 1;
+				break;
+			case ccfs_opt_cacheable_filter:
+				ccfssuper->cacheable_filter = create_filter();
+				match_strlcpy(tmp, &args[0], PATH_MAX);
+				parse_filter(ccfssuper->cacheable_filter, tmp);
+				break;
+			default:
+				printk(KERN_WARNING
+					"ccfs: unrecognized option '%s'\n",
+					p);
+		}
+
+	}
+	
+out:
+	return rc;
+}
+//This function renamed from ccfs_get_sb to ccfs_mount and deleted last parameter struct vfsmount *mnt for kernel 3.7.1 by Jiri Rakosnik
+//Instead of vfsmount *mnt is use return type struct dentry * and it is root dentry, which contain of d_sb = super_block structure
+
+static struct dentry * ccfs_mount(struct file_system_type *fs_type, int flags,
+			const char *dev_name, void *raw_data)
+{
+	struct dentry *root;
+	int rc = 0;
+  // Substitute name function get_sb_nodev for mount_nodev and delete last parameter mnt (kernel 3.7.1)
+  root = mount_nodev(fs_type, flags, raw_data, ccfs_fill_super);
+	if ((void*)root < 0) {
+		printk(KERN_ERR "Mount failed");
+		goto out;
+	}
+	
+  rc = ccfs_parse_options(root->d_sb, raw_data);
+	if (rc) {
+		printk(KERN_ERR "Error parsing options; rc = [%d]\n", rc);
+		goto out_abort;
+	}
+
+	rc = ccfs_read_super(root->d_sb, dev_name);
+	if (rc) {
+		printk(KERN_ERR "Reading sb failed; rc = [%d]\n", rc);
+		goto out_abort;
+	}
+	goto out;
+out_abort:
+	dput(root->d_sb->s_root);
+	up_write(&root->d_sb->s_umount);
+	deactivate_super(root->d_sb);
+out:
+	return root;
+}
+
+static void ccfs_kill_block_super(struct super_block *sb)
+{
+	generic_shutdown_super(sb);
+}
+
+// Substitute get_sb to mount for fix kernel 3.7.1 by Jiri Rakosnik
+static struct file_system_type ccfs_fs_type = {
+	.owner = THIS_MODULE,
+	.name = "ccfs",
+	.mount = ccfs_mount,            
+	.kill_sb = ccfs_kill_block_super,
+	.fs_flags = 0,
+};
+
+static void
+ccfs_inode_init_once(void *vptr)
+{
+	struct ccfs_inode *ccfs_inode = (struct ccfs_inode*)vptr;
+
+	inode_init_once(&ccfs_inode->vfs_inode);
+}
+
+static struct ccfs_cache {
+	struct kmem_cache **cache;
+	const char *name;
+	size_t size;
+	//void (*ctor)(struct kmem_cache *cache, void *obj);
+	void (*ctor)(void*);
+} ccfs_caches[] = {
+	{
+		.cache = &ccfs_file_cache,
+		.name = "ccfs_file_cache",
+		.size = sizeof(struct ccfs_file),
+	},
+	{
+		.cache = &ccfs_dentry_cache,
+		.name = "ccfs_dentry_cache",
+		.size = sizeof(struct ccfs_dentry),
+	},
+	{
+		.cache = &ccfs_inode_cache,
+		.name = "ccfs_inode_cache",
+		.size = sizeof(struct ccfs_inode),
+		.ctor = ccfs_inode_init_once,
+	},
+	{
+		.cache = &ccfs_sb_cache,
+		.name = "ccfs_sb_cache",
+		.size = sizeof(struct ccfs_super),
+	},
+};
+
+static void ccfs_free_kmem_caches(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(ccfs_caches); i++) {
+		struct ccfs_cache *info;
+
+		info = &ccfs_caches[i];
+		if (*(info->cache))
+			kmem_cache_destroy(*(info->cache));
+	}
+}
+
+static int ccfs_init_kmem_caches(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(ccfs_caches); i++) {
+		struct ccfs_cache *info;
+
+		info = &ccfs_caches[i];
+		*(info->cache) = kmem_cache_create(info->name, info->size,
+				0, SLAB_HWCACHE_ALIGN, info->ctor);
+		if (!*(info->cache)) {
+			ccfs_free_kmem_caches();
+			printk(KERN_WARNING "%s: "
+					"kmem_cache_create failed\n",
+					info->name);
+			return -ENOMEM;
+		}
+	}
+	return 0;
+}
+
+
+static int __init ccfs_init(void)
+{
+	int rc;
+
+	rc = ccfs_init_kmem_caches();
+	if (rc) {
+		printk(KERN_ERR
+		       "Failed to allocate one or more kmem_cache objects\n");
+		goto out;
+	}
+	rc = register_filesystem(&ccfs_fs_type);
+	if (rc) {
+		printk(KERN_ERR "Failed to register filesystem\n");
+		goto out_free_kmem_caches;
+	}
+
+	rc = initialize_prefetcher();
+	if (rc) {
+		printk(KERN_ERR "Failed to start prefetcher\n");
+		goto out_free_kmem_caches;
+	}
+
+	goto out;
+	
+out_free_kmem_caches:
+	ccfs_free_kmem_caches();
+out:
+	return rc;
+}
+
+static void __exit ccfs_exit(void)
+{
+	finalize_prefetcher();
+	unregister_filesystem(&ccfs_fs_type);
+	ccfs_free_kmem_caches();
+}
+
+MODULE_DESCRIPTION("ccfs");
+
+MODULE_LICENSE("GPL");
+
+module_init(ccfs_init)
+module_exit(ccfs_exit)
--- linux-3.7.1_original/clondike/src/ccfs/prefetcher.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/ccfs/prefetcher.c	2013-02-28 15:07:02.000000000 +0100
@@ -0,0 +1,212 @@
+#include <linux/spinlock.h>
+#include <linux/list.h>
+#include <linux/kernel.h>
+#include <linux/err.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <asm/page.h>
+#include <linux/sched.h>
+#include <linux/kthread.h>
+#include <linux/wait.h>
+#include <linux/pagemap.h>
+#include <linux/pagevec.h>
+#include <linux/slab.h>			// Added for unknown identificator kfree kmalloc by Jiri Rakosnik
+
+#include "prefetcher.h"
+#include <dbg.h>
+
+struct prefetcher_data {
+	/** Reference to current prefetcher thread, if there is any */
+	struct task_struct* prefetcher_thread;
+	/** For waiting on the prefetch requests */
+	wait_queue_head_t request_wait;
+	/** Lock guarding prefetch enqueing */
+	spinlock_t enqueue_lock;
+	/** Requests for prefetching */
+	struct list_head requests;
+};
+
+static struct prefetcher_data* prefetcher = NULL;
+
+/** Queued info about files prefetching */
+struct prefetch_info {
+	/** File to be prefetched */
+	struct file* filp;
+	/** Used to enqueue into the requests list */
+	struct list_head head;
+};
+
+static inline int is_prefetch_requested(void) {
+	int empty;
+
+	spin_lock(&prefetcher->enqueue_lock);
+	empty = list_empty(&prefetcher->requests);
+	spin_unlock(&prefetcher->enqueue_lock);
+
+	return empty == 0;
+}
+
+static struct prefetch_info* get_next_prefetch_info(void) {
+	struct prefetch_info* info = NULL;
+	wait_event_interruptible( prefetcher->request_wait, is_prefetch_requested() || kthread_should_stop());
+
+	spin_lock(&prefetcher->enqueue_lock);
+	if ( !list_empty(&prefetcher->requests) ) {
+		struct list_head* first = prefetcher->requests.next;
+		list_del(first);
+		info = list_entry(first, struct prefetch_info, head);
+	}
+	spin_unlock(&prefetcher->enqueue_lock);
+	
+	return info;
+}
+
+#define list_to_page(head) (list_entry((head)->prev, struct page, lru))
+/** Copied from kernel */
+static int read_pages(struct address_space *mapping, struct file *filp,
+                struct list_head *pages, unsigned nr_pages)
+  {
+	unsigned page_idx;
+	int ret;
+
+	if (mapping->a_ops->readpages) {
+		ret = mapping->a_ops->readpages(filp, mapping, pages, nr_pages);
+		/* Clean up the remaining pages */
+		put_pages_list(pages);
+		goto out;
+	}
+
+	for (page_idx = 0; page_idx < nr_pages; page_idx++) {
+		struct page *page = list_to_page(pages);
+		list_del(&page->lru);
+		if (!add_to_page_cache_lru(page, mapping,
+					page->index, GFP_KERNEL)) {
+			mapping->a_ops->readpage(filp, page);
+		}
+		page_cache_release(page);
+	}
+	ret = 0;
+out:
+	return ret;
+}
+
+/** TODO: This is now +- copy of kernel readahead code. We may either use kernel code here, or better rewrite this to do some sort
+ of paralelized prefetched! */
+static void do_file_prefetch(struct file* filp) {
+	struct address_space* mapping = filp->f_mapping;
+	struct inode *inode = mapping->host;
+	struct page* page;
+	loff_t isize = i_size_read(inode);
+	unsigned long end_index = ((isize - 1) >> PAGE_CACHE_SHIFT);
+	unsigned long index = 0;
+	int pool_size = 0;
+	LIST_HEAD(page_pool);
+
+	printk(KERN_DEBUG "File %p prefetching %lu pages\n", filp, end_index);
+
+	spin_lock_irq(&mapping->tree_lock);
+	for ( ; index < end_index; index++ ) {
+		pgoff_t page_offset = index;
+		page = radix_tree_lookup(&mapping->page_tree, page_offset);
+ 	        if (page) // Already exists?
+ 	            	continue;
+
+ 		spin_unlock_irq(&mapping->tree_lock);
+ 	        page = page_cache_alloc_cold(mapping);
+ 	        spin_lock_irq(&mapping->tree_lock);
+ 	        if (!page)
+ 	        	break;
+ 	        
+		pool_size++;
+		page->index = page_offset;
+ 	        list_add(&page->lru, &page_pool);
+	}
+	spin_unlock_irq(&mapping->tree_lock);
+
+	read_pages(mapping, filp, &page_pool, pool_size);
+}
+
+static void perform_prefetch(struct prefetch_info* info) {
+	do_file_prefetch(info->filp);
+	mdbg(INFO3,  "Puting lower file: %p (%ld)", info->filp, atomic_long_read(&info->filp->f_count));
+	fput(info->filp);
+	kfree(info);
+}
+
+static int prefetcher_run(void* data){
+	printk(KERN_DEBUG "Prefetcher thread started\n");
+	while(!kthread_should_stop()) {
+		// Read from prefetch queue
+		struct prefetch_info* info = get_next_prefetch_info();
+		if ( !info )
+			break;
+
+		// Do prefetch of a single element
+		perform_prefetch(info);
+		printk(KERN_DEBUG "Prefetch done\n");
+	}
+
+	printk(KERN_DEBUG "Prefetcher thread done\n");
+
+	return 0;
+}
+
+int initialize_prefetcher(void) {	
+	struct task_struct* new_thread = NULL;
+
+	if ( prefetcher )
+		return -EINVAL;
+
+	prefetcher = kmalloc(sizeof(struct prefetcher_data), GFP_KERNEL);
+	if ( !prefetcher ) {
+		return -EINVAL;
+	}
+
+	prefetcher->prefetcher_thread = new_thread;
+	INIT_LIST_HEAD( & prefetcher->requests );
+	spin_lock_init(&prefetcher->enqueue_lock);
+	init_waitqueue_head( & prefetcher->request_wait );
+
+	new_thread = kthread_run(prefetcher_run, NULL, "ccfs prefetching thread");
+	if( IS_ERR(new_thread) ) {		
+		kfree(prefetcher);
+		prefetcher = NULL;
+		return PTR_ERR(new_thread);
+	}
+
+	prefetcher->prefetcher_thread = new_thread;
+
+	return 0;
+}
+
+void finalize_prefetcher(void) {
+	int rc;
+
+	if ( !prefetcher )
+		return;
+
+	rc = kthread_stop(prefetcher->prefetcher_thread);
+	if ( rc ) {
+		printk(KERN_ERR "Prefetcher stop failed with err %d\n", rc);
+	}
+
+	prefetcher->prefetcher_thread = NULL;
+	kfree(prefetcher);
+	prefetcher = NULL;
+}
+
+void submit_for_prefetch(struct file* filp) {
+	struct prefetch_info* info = kmalloc(sizeof(struct prefetch_info), GFP_KERNEL);
+	if ( !info ) {
+		fput(filp);
+		// We can ignore no-mem on prefetch, we simply do not prefetch..
+		return;
+	}
+
+	info->filp = filp;
+	spin_lock(&prefetcher->enqueue_lock);
+	list_add(&info->head, &prefetcher->requests);
+	spin_unlock(&prefetcher->enqueue_lock);
+
+	wake_up(&prefetcher->request_wait);
+}
--- linux-3.7.1_original/clondike/src/ccfs/ccfs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/ccfs/ccfs.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,190 @@
+#ifndef CCFS_H
+#define CCFS_H
+
+#include <linux/fs.h>
+#include <linux/fs_stack.h>
+#include <linux/namei.h>
+#include <linux/scatterlist.h>
+#include <linux/hash.h>
+
+#include "filter.h"
+
+/** Super block */
+struct ccfs_super {
+	struct super_block* nested_superblock;
+	/** Is aggressive file prefech enabled? */
+	int prefetch;
+	/** Filter of cacheable files. If null, all files are cacheable */
+	struct filter* cacheable_filter;
+};
+
+/** File struct */
+struct ccfs_file {
+	/** File in the backing store */
+	struct file* nested_file;
+};
+
+struct ccfs_inode {
+	/** This inode data */
+	struct inode vfs_inode;
+	/** Reference to nested inode */
+	struct inode *nested_inode;
+	struct file *lower_file;
+	struct mutex lower_file_mutex;	
+	/** Is this inode cacheable? */
+	int cacheable;
+	/** Cached link pointer of this inode (in case it is a symlink) */
+	char* link;
+	/** Cached stats of file */
+	struct kstat* stat;
+};
+
+/** Dentry */
+struct ccfs_dentry {
+	/** Lower dentry & its path */
+	struct path lower_path;
+};
+
+/*********** File ops *****************/
+static inline void ccfs_set_nested_file(struct file* ccfsfile, struct file* nested_file) {
+	((struct ccfs_file*)ccfsfile->private_data)->nested_file = nested_file;
+}
+
+static inline struct file* ccfs_get_nested_file(struct file* ccfsfile) {
+	return ((struct ccfs_file*)ccfsfile->private_data)->nested_file;
+}
+
+static inline void ccfs_set_file_private(struct file* ccfsfile, struct ccfs_file* priv) {
+	ccfsfile->private_data = priv;
+}
+
+static inline struct ccfs_file* ccfs_get_file_private(struct file* ccfsfile) {
+	return (struct ccfs_file*)ccfsfile->private_data;
+}
+
+/*********** Dentry ops *******************/
+static inline struct ccfs_dentry *
+ccfs_dentry_to_private(struct dentry *dentry)
+{
+	return (struct ccfs_dentry *)dentry->d_fsdata;
+}
+
+static inline void
+ccfs_set_dentry_private(struct dentry *dentry,
+			    struct ccfs_dentry *dentry_priv)
+{
+	dentry->d_fsdata = dentry_priv;
+}
+
+static inline struct dentry *
+ccfs_get_nested_dentry(struct dentry *dentry)
+{
+	return ((struct ccfs_dentry *)dentry->d_fsdata)->lower_path.dentry;
+}
+
+static inline void
+ccfs_set_nested_dentry(struct dentry *dentry, struct dentry *lower_dentry)
+{
+	((struct ccfs_dentry *)dentry->d_fsdata)->lower_path.dentry =
+		lower_dentry;
+}
+
+static inline struct vfsmount *
+ccfs_dentry_to_nested_mnt(struct dentry *dentry)
+{
+	return ((struct ccfs_dentry *)dentry->d_fsdata)->lower_path.mnt;
+}
+
+static inline void
+ccfs_set_dentry_nested_mnt(struct dentry *dentry, struct vfsmount *lower_mnt)
+{
+	((struct ccfs_dentry *)dentry->d_fsdata)->lower_path.mnt =
+		lower_mnt;
+}
+
+/************* Inode ops ****************/
+static inline struct ccfs_inode * ccfs_inode_to_private(struct inode *inode)
+{
+	return container_of(inode, struct ccfs_inode, vfs_inode);
+}
+
+static inline struct inode *ccfs_get_nested_inode(struct inode *inode)
+{
+	return ccfs_inode_to_private(inode)->nested_inode;
+}
+
+static inline void
+ccfs_set_nested_inode(struct inode *inode, struct inode *lower_inode)
+{
+	ccfs_inode_to_private(inode)->nested_inode = lower_inode;
+}
+
+static inline int ccfs_is_inode_cacheable(struct inode* inode) {
+	return ccfs_inode_to_private(inode)->cacheable;
+}
+
+
+/************ Superblock ops ************/
+
+static inline struct ccfs_super * ccfs_superblock_to_private(struct super_block *sb)
+{
+	return (struct ccfs_super *)sb->s_fs_info;
+}
+
+static inline void ccfs_set_superblock_private(struct super_block *sb,
+				struct ccfs_super *sb_info)
+{
+	sb->s_fs_info = sb_info;
+}
+
+static inline struct super_block * ccfs_superblock_to_lower(struct super_block *sb)
+{
+	return ((struct ccfs_super *)sb->s_fs_info)->nested_superblock;
+}
+
+static inline void ccfs_set_superblock_lower(struct super_block *sb,
+			      struct super_block *lower_sb)
+{
+	((struct ccfs_super *)sb->s_fs_info)->nested_superblock = lower_sb;
+}
+
+/************* VFS ops *************************/
+extern const struct file_operations ccfs_main_fops;
+extern const struct file_operations ccfs_dir_fops;
+extern const struct inode_operations ccfs_main_iops;
+extern const struct inode_operations ccfs_dir_iops;
+extern const struct inode_operations ccfs_symlink_iops;
+extern const struct super_operations ccfs_sops;
+extern struct dentry_operations ccfs_dops;
+extern struct address_space_operations ccfs_aops;
+
+/************** Caches *************************/
+extern struct kmem_cache *ccfs_file_cache;
+extern struct kmem_cache *ccfs_dentry_cache;
+extern struct kmem_cache *ccfs_inode_cache;
+extern struct kmem_cache *ccfs_sb_cache;
+extern struct kmem_cache *ccfs_lower_page_cache;
+
+
+
+/********* General funcs ***********************/
+int ccfs_interpose(struct dentry *lower_dentry, struct dentry *dentry,
+		       struct super_block *sb, int flag);
+
+int ccfs_reopen_persistent_file(struct dentry *ccfsdentry, struct inode* ccfsinode);
+
+void ccfs_init_inode(struct inode *inode, struct inode *lower_inode);
+
+int ccfs_read_lower_page_segment(struct page *page_for_ccfs,
+				     pgoff_t page_index,
+				     size_t offset_in_page, size_t size,
+				     struct inode *ccfsinode);
+
+int ccfs_write_lower_page_segment(struct inode *ccfsinode,
+				      struct page *page_for_lower,
+				      size_t offset_in_page, size_t size);
+
+int ccfs_inode_test(struct inode *inode, void *candidate_lower_inode);
+
+int ccfs_inode_set(struct inode *inode, void *lower_inode);
+#endif
--- linux-3.7.1_original/clondike/src/ccfs/filter.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/ccfs/filter.c	2013-03-01 10:55:38.000000000 +0100
@@ -0,0 +1,135 @@
+#include <linux/spinlock.h>
+#include <linux/list.h>
+#include <linux/kernel.h>
+#include <linux/err.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <asm/page.h>
+#include <linux/sched.h>
+#include <linux/kthread.h>
+#include <linux/wait.h>
+#include <linux/pagemap.h>
+#include <linux/pagevec.h>
+#include <linux/slab.h>
+
+#include <dbg.h>
+
+#include "filter.h"
+
+struct filter_pattern {
+	/** For enlistment */
+	struct list_head head;
+	/** Pattern itself */
+	char* pattern;
+	int pattern_length;
+	/** Files creation data has to be older than this time */
+	struct timespec older_than;
+};
+
+struct filter* create_filter(void) {
+	struct filter* filter = kmalloc(sizeof(struct filter), GFP_KERNEL);
+	if ( !filter )
+		return NULL;
+
+	INIT_LIST_HEAD(&filter->patterns);
+
+	return filter;
+}
+
+void destroy_filter(struct filter* filter) {
+	struct filter_pattern *head, *tmp;
+	if ( !filter )
+		return;
+
+        list_for_each_entry_safe(head, tmp, &filter->patterns, head) {			
+                list_del(&head->head);
+		kfree(head);
+		 
+	}
+
+	kfree(filter);
+}
+
+void parse_filter(struct filter* filter, char* definition) {
+	char* p;
+
+	while ((p = strsep(&definition, ":")) != NULL) {
+		if (!*p)
+			continue;
+
+		add_filter_pattern(filter, p, strcspn(p, ":"));
+	}
+	
+}
+
+int add_filter_pattern(struct filter* filter, const char* pattern, int pattern_length) {
+	struct filter_pattern* filter_pattern = kmalloc(sizeof(struct filter_pattern), GFP_KERNEL);
+
+	printk("Adding filter pattern: %s (%d)\n", pattern, pattern_length);
+	if ( !filter_pattern )
+		return -ENOMEM;
+
+	if ( strcmp(pattern, "OLD") == 0 ) {
+	  filter_pattern->pattern = NULL;
+	  filter_pattern->older_than = CURRENT_TIME;
+	  // Consider also files created in last hour to be new files.. as we may assume they may change again soon (not realy smart but should be good enough for our purposes)	 
+	  filter_pattern->older_than.tv_sec = filter_pattern->older_than.tv_sec - 3600;
+	} else {	
+	  filter_pattern->pattern = kmalloc(pattern_length, GFP_KERNEL);
+	  if ( !filter_pattern->pattern ) {
+		  kfree(filter_pattern);
+		  return -ENOMEM;
+	  }
+	  
+	  memcpy(filter_pattern->pattern, pattern, pattern_length);
+	  filter_pattern->pattern_length = pattern_length;		  
+	}
+
+	list_add(&filter_pattern->head, &filter->patterns);
+
+	return 0;
+}
+
+static int pattern_matches(struct filter_pattern* filter_pattern, const char* name, int name_length, struct timespec* ctime, umode_t umode) {
+	int name_index = name_length - 1;
+	int pattern_index = filter_pattern->pattern_length - 1;
+	const char* pattern = filter_pattern->pattern;
+
+	if ( filter_pattern->pattern == NULL ) {
+	  /* Match time pattern. Do not check age for dir, they can be always cached since readdir is uncached anyway */
+	  mdbg(INFO3, "Date compare: %d vs %d", &filter_pattern->older_than.tv_sec, ctime->tv_sec);
+	  return S_ISDIR(umode) || timespec_compare(&filter_pattern->older_than, ctime) > 0;
+	} else {		  	
+	  /* Match string pattern */
+	  while ( name_index > -1 && pattern_index > -1 ) {
+		  if ( pattern[pattern_index] == '*' ) {
+			  if ( pattern_index != 0 ) {
+				  printk(KERN_WARNING "Illegal pattern '%s'! Pattern must have * only at the beggining!\n", filter_pattern->pattern);
+			  }
+			  return 1;
+		  } else if ( pattern[pattern_index] != name[name_index] ) {
+			  return 0;
+		  }
+
+		  name_index--;
+		  pattern_index--;
+	  }
+	}
+
+	return name_index == pattern_index;
+}
+
+/** Returns 1, if name matches any of the filter patterns. 0 otherwise */
+int filter_matches(struct filter* filter, const char* name, int name_length, struct timespec *ctime, umode_t umode) {
+	struct filter_pattern *head;
+
+	if ( !filter )
+		return 1;
+
+        list_for_each_entry(head, &filter->patterns, head) {			
+		 if ( pattern_matches(head, name, name_length, ctime, umode) )
+			return 1;
+	}
+
+	return 0;
+}
--- linux-3.7.1_original/clondike/src/ccfs/prefetcher.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/ccfs/prefetcher.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,17 @@
+#ifndef PREFETCHER_H
+#define PREFETCHER_H
+
+/** Initializes prefetching service, returns 0 upon success */
+int initialize_prefetcher(void);
+
+/** Synchronously terminates prefetching service */
+void finalize_prefetcher(void);
+
+/** 
+ * Submits file, whose content should be fully prefetched.
+ * One file reference should be hold by the caller and this reference should be left to the prefetcher,
+ * who will free it after it is done with the prefetch.
+ */
+void submit_for_prefetch(struct file* filp);
+
+#endif
--- linux-3.7.1_original/clondike/src/ccfs/mmap.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/ccfs/mmap.c	2013-02-28 12:47:16.000000000 +0100
@@ -0,0 +1,157 @@
+#include <linux/pagemap.h>
+#include <linux/writeback.h>
+#include <linux/page-flags.h>
+#include <linux/mount.h>
+#include <linux/file.h>
+#include <linux/crypto.h>
+#include <linux/scatterlist.h>
+#include "ccfs.h"
+
+#include <dbg.h>
+
+// TODO: Unused
+struct kmem_cache *ccfs_lower_page_cache;
+
+struct page *ccfs_get_locked_page(struct file *file, loff_t index)
+{
+	struct dentry *dentry;
+	struct inode *inode;
+	struct address_space *mapping;
+	struct page *page;
+
+	dentry = file->f_path.dentry;
+	inode = dentry->d_inode;
+	mapping = inode->i_mapping;
+	page = read_mapping_page(mapping, index, (void *)file);
+	if (!IS_ERR(page))
+		lock_page(page);
+	return page;
+}
+/*
+static int ccfs_writepage(struct page *page, struct writeback_control *wbc)
+{
+	int rc = 0;
+
+	mdbg(INFO3,"Write page index: %lu (%p)", (unsigned long)page->index, page);
+
+	// TODO: Write to lower FS.. but we do not support writeback for this fs yet!
+	SetPageUptodate(page);
+	unlock_page(page);
+
+	return rc;
+}
+*/
+
+static int ccfs_readpage(struct file *file, struct page *page)
+{
+	int rc = 0;
+
+	mdbg(INFO3,
+			"Reading page index: %lu (%p)", (unsigned long)page->index, page);
+	rc = ccfs_read_lower_page_segment(page, page->index, 0,
+						PAGE_CACHE_SIZE,
+						page->mapping->host);
+
+	if (rc) {
+		ClearPageUptodate(page);
+	} else {
+		mdbg(INFO3, "Setting page up to date");
+		//flush_dcache_page(page);
+		SetPageUptodate(page);
+	}
+	mdbg(INFO3, "Unlocking page with index = [0x%.16x]",
+			(u16)page->index);
+	unlock_page(page);
+	return rc;
+}
+
+
+static int ccfs_write_begin(
+			struct file *file,
+			struct address_space *mapping,
+			loff_t pos, unsigned len, unsigned flags,
+			struct page **pagep, void **fsdata)
+{
+	int rc = 0;
+	loff_t prev_page_end_size;
+	pgoff_t index = pos >> PAGE_CACHE_SHIFT;
+	struct page *page;
+
+	page = grab_cache_page_write_begin(mapping, index, flags);
+	if (!page)
+		return -ENOMEM;
+	*pagep = page;
+
+	mdbg(INFO3, "Prepare write for file: %p page index: %lu", file, (unsigned long)page->index);
+
+	if (!PageUptodate(page)) {
+		rc = ccfs_read_lower_page_segment(page, index, 0,
+						      PAGE_CACHE_SIZE,
+						      mapping->host);
+		if (rc) {
+			printk(KERN_ERR "%s: Error attemping to read lower "
+			       "page segment; rc = [%d]\n", __FUNCTION__, rc);
+			ClearPageUptodate(page);
+			goto out;
+		} else
+			SetPageUptodate(page);
+	}
+
+	prev_page_end_size = ((loff_t)page->index << PAGE_CACHE_SHIFT);
+
+out:
+	return rc;
+}
+
+static int ccfs_write_end(struct file *file,
+			struct address_space *mapping,
+			loff_t pos, unsigned len, unsigned copied,
+			struct page *page, void *fsdata)
+{
+	struct inode *ccfsinode = mapping->host;
+	//pgoff_t index = pos >> PAGE_CACHE_SHIFT;
+	unsigned from = pos & (PAGE_CACHE_SIZE - 1);
+	unsigned to = from + copied;
+	int rc = 0;
+
+	mdbg(INFO3,"Commit write for file: %p page index: %lu (From: %lu To: %lu)", file, (unsigned long)page->index, (unsigned long)from, (unsigned long)to);
+
+	rc = ccfs_write_lower_page_segment(ccfsinode, page, from, to);
+
+	//pos = (((loff_t)page->index) << PAGE_CACHE_SHIFT) + to;
+	if (pos + copied > i_size_read(ccfsinode)) {
+		// TODO: DO we need to update lower file metadata?
+		i_size_write(ccfsinode, pos + copied);
+		//printk(KERN_DEBUG "Expanded file size to "
+		//		"[0x%.16x], required (%lld)\n", (u16)i_size_read(ccfsinode), pos + copied);
+	}
+
+	unlock_page(page);
+	page_cache_release(page);
+
+	return copied;
+}
+
+static sector_t ccfs_bmap(struct address_space *mapping, sector_t block)
+{
+	int rc = 0;
+	struct inode *inode;
+	struct inode *lower_inode;
+
+	inode = (struct inode *)mapping->host;
+	lower_inode = ccfs_get_nested_inode(inode);
+	if (lower_inode->i_mapping->a_ops->bmap)
+		rc = lower_inode->i_mapping->a_ops->bmap(lower_inode->i_mapping,
+							 block);
+	return rc;
+}
+
+
+// TODO: Well, now write seems to work at least sometimes, though not sure it is really implemented correctly
+struct address_space_operations ccfs_aops = {
+	//.writepage = ccfs_writepage,
+	.readpage = ccfs_readpage,
+	.write_begin = ccfs_write_begin,
+	.write_end = ccfs_write_end,
+	.bmap = ccfs_bmap,
+};
--- linux-3.7.1_original/clondike/src/ccfs/filter.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/ccfs/filter.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,27 @@
+#ifndef FILTER_H
+#define FILTER_H
+
+
+/**
+ * Container of filters. Used for pattern matching of cacheable files.
+ */
+struct filter {
+	/** 
+         * Pattterns, that can be matched.
+	 * Currently only full name or * wildcard at the beginning are supported.
+         */
+	struct list_head patterns;
+};
+
+struct filter* create_filter(void);
+void destroy_filter(struct filter* filter);
+/** Registers a new patter to the filter. Returns 0 upon succes, error code otherwise */
+int add_filter_pattern(struct filter* filter, const char* pattern, int pattern_length);
+
+/** Parses filter definition. Expects colon separated patterns */
+void parse_filter(struct filter* filter, char* definition);
+
+/** Returns 1, if name matches any of the filter patterns. 0 otherwise */
+int filter_matches(struct filter* filter, const char* name, int name_length, struct timespec *ctime, umode_t umode);
+
+#endif
--- linux-3.7.1_original/clondike/src/ccfs/inode.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/ccfs/inode.c	2013-02-21 12:53:37.000000000 +0100
@@ -0,0 +1,752 @@
+#include <linux/file.h>
+#include <linux/vmalloc.h>
+#include <linux/pagemap.h>
+#include <linux/dcache.h>
+#include <linux/namei.h>
+#include <linux/mount.h>
+#include <linux/crypto.h>
+#include <linux/fs_stack.h>
+#include "ccfs.h"
+
+#include <dbg.h>
+
+static struct dentry *lock_parent(struct dentry *dentry)
+{
+	struct dentry *dir;
+
+	dir = dget(dentry->d_parent);
+	mutex_lock_nested(&(dir->d_inode->i_mutex), I_MUTEX_PARENT);
+	return dir;
+}
+
+static void unlock_parent(struct dentry *dentry)
+{
+	mutex_unlock(&(dentry->d_parent->d_inode->i_mutex));
+	dput(dentry->d_parent);
+}
+
+static void unlock_dir(struct dentry *dir)
+{
+	mutex_unlock(&dir->d_inode->i_mutex);
+	dput(dir);
+}
+
+static int
+ccfs_create_underlying_file(struct inode *lower_dir_inode,
+				struct dentry *dentry, int mode,
+				struct nameidata *nd)
+{
+	struct dentry *lower_dentry = ccfs_get_nested_dentry(dentry);
+	struct vfsmount *lower_mnt = ccfs_dentry_to_nested_mnt(dentry);
+	struct dentry *dentry_save;
+	struct vfsmount *vfsmount_save;
+	int rc;
+
+	dentry_save = nd->path.dentry;
+	vfsmount_save = nd->path.mnt;
+	nd->path.dentry = lower_dentry;
+	nd->path.mnt = lower_mnt;
+	
+	mdbg(INFO3,"Create file w/ lower_dentry->d_name.name = [%s] -> [%s] ", lower_dentry->d_name.name, nd->path.dentry->d_name.name);
+	rc = vfs_create(lower_dir_inode, lower_dentry, mode, nd);
+	nd->path.dentry = dentry_save;
+	nd->path.mnt = vfsmount_save;
+	return rc;
+}
+
+static int ccfs_do_create(struct inode *directory_inode,
+		   struct dentry *ecryptfs_dentry, int mode,
+		   struct nameidata *nd)
+{
+	int rc;
+	struct dentry *lower_dentry;
+	struct dentry *lower_dir_dentry;
+
+	lower_dentry = ccfs_get_nested_dentry(ecryptfs_dentry);
+	lower_dir_dentry = lock_parent(lower_dentry);
+	if (unlikely(IS_ERR(lower_dir_dentry))) {
+		mdbg(ERR1, "Error locking directory of "
+				"dentry");
+		rc = PTR_ERR(lower_dir_dentry);
+		goto out;
+	}
+	rc = ccfs_create_underlying_file(lower_dir_dentry->d_inode,
+					     ecryptfs_dentry, mode, nd);
+	if (unlikely(rc)) {
+		mdbg(ERR1,
+				"Failure to create underlying file");
+		goto out_lock;
+	}
+	rc = ccfs_interpose(lower_dentry, ecryptfs_dentry,
+				directory_inode->i_sb, 0);
+	if (rc) {
+		mdbg(ERR1, "Failure in ccfs_interpose");
+		goto out_lock;
+	}
+	fsstack_copy_attr_times(directory_inode, lower_dir_dentry->d_inode);
+	fsstack_copy_inode_size(directory_inode, lower_dir_dentry->d_inode);
+out_lock:
+	unlock_dir(lower_dir_dentry);
+out:
+	return rc;
+}
+
+static int ccfs_create(struct inode *directory_inode, struct dentry *ccfs_dentry,
+		int mode, struct nameidata *nd)
+{
+	int rc;
+
+	rc = ccfs_do_create(directory_inode, ccfs_dentry, mode, nd);
+	if (unlikely(rc)) {
+		printk(KERN_WARNING "Failed to create file in"
+				"lower filesystem\n");
+		goto out;
+	}
+
+	// TODO: Initialize
+	//rc = ecryptfs_initialize_file(ecryptfs_dentry);
+out:
+	return rc;
+}
+
+static struct dentry *ccfs_lookup(struct inode *dir, struct dentry *dentry,
+				      struct nameidata *nd)
+{
+	int rc = 0;
+	struct dentry *lower_dir_dentry;
+	struct dentry *lower_dentry;
+	struct vfsmount *lower_mnt;
+	struct inode *lower_inode;	
+	
+
+	lower_dir_dentry = ccfs_get_nested_dentry(dentry->d_parent);
+	dentry->d_op = &ccfs_dops;
+	if ((dentry->d_name.len == 1 && !strcmp(dentry->d_name.name, "."))
+	    || (dentry->d_name.len == 2
+		&& !strcmp(dentry->d_name.name, ".."))) {
+		d_drop(dentry);
+		goto out;
+	}
+
+
+	mutex_lock(&lower_dir_dentry->d_inode->i_mutex);
+	lower_dentry = lookup_one_len(dentry->d_name.name, lower_dir_dentry,
+				      dentry->d_name.len);
+	mutex_unlock(&lower_dir_dentry->d_inode->i_mutex);
+
+	if (IS_ERR(lower_dentry)) {
+		mdbg(INFO3,"Error in lower dentry lookup");
+		rc = PTR_ERR(lower_dentry);
+		d_drop(dentry);
+		goto out;
+	}
+
+	lower_mnt = mntget(ccfs_dentry_to_nested_mnt(dentry->d_parent));
+
+	lower_inode = lower_dentry->d_inode;
+
+	mdbg(INFO3,"lower_dentry (lower_inode, dir_inode) = [%p] (%p, %p); lower_dentry->"
+       		"d_name.name = [%s]", lower_dentry, lower_inode, dir, 
+		lower_dentry->d_name.name);
+
+	fsstack_copy_attr_atime(dir, lower_dir_dentry->d_inode);
+	BUG_ON(!atomic_read(&lower_dentry->d_count));
+
+	ccfs_set_dentry_private(dentry,
+				    kmem_cache_alloc(ccfs_dentry_cache,
+						     GFP_KERNEL));
+	if (!ccfs_dentry_to_private(dentry)) {
+		rc = -ENOMEM;
+		minfo(ERR1, "Out of memory whilst attempting to allocate ccfs_dentry_info struct");
+		goto out_dput;
+	}
+	ccfs_set_nested_dentry(dentry, lower_dentry);
+	ccfs_set_dentry_nested_mnt(dentry, lower_mnt);
+	if (!lower_dentry->d_inode) {
+		/* We want to add because we couldn't find in lower */
+		d_add(dentry, NULL);
+		goto out;
+	}
+	rc = ccfs_interpose(lower_dentry, dentry, dir->i_sb, 1);
+	if (rc) {
+	  	minfo(ERR1, "Error interposing inode: %d", rc);
+		goto out_dput;
+	}
+	if (S_ISDIR(lower_inode->i_mode)) {
+		mdbg(INFO3, "Is a directory; returning");
+		goto out;
+	}
+	if (S_ISLNK(lower_inode->i_mode)) {
+		mdbg(INFO3, "Is a symlink; returning");
+		goto out;
+	}
+	if (special_file(lower_inode->i_mode)) {
+		mdbg(INFO3, "Is a special file; returning");
+		goto out;
+	}
+	if (!nd) {
+		mdbg(INFO3,"We have a NULL nd, just leave"
+				"as we *think* we are about to unlink");
+		goto out;
+	}
+
+
+	goto out;
+out_dput:
+	mdbg(INFO3,"lookup PUT done with res: %d (dentry inode: %p name: %s)", rc, dentry->d_inode, dentry->d_name.name);
+	dput(lower_dentry);
+	d_drop(dentry);
+	return ERR_PTR(rc);
+	
+out:
+	mdbg(INFO3,"lookup done with res: %d (dentry inode: %p name: %s dir cacheable: %d)", rc, dentry->d_inode, dentry->d_name.name, ccfs_inode_to_private(dir)->cacheable);
+	return ERR_PTR(rc);
+}
+
+static int ccfs_link(struct dentry *old_dentry, struct inode *dir,
+			 struct dentry *new_dentry)
+{
+	struct dentry *lower_old_dentry;
+	struct dentry *lower_new_dentry;
+	struct dentry *lower_dir_dentry;
+	u64 file_size_save;
+	int rc;
+	
+// TODO: Update cached link
+	file_size_save = i_size_read(old_dentry->d_inode);
+	lower_old_dentry = ccfs_get_nested_dentry(old_dentry);
+	lower_new_dentry = ccfs_get_nested_dentry(new_dentry);	
+	dget(lower_old_dentry);
+	dget(lower_new_dentry);
+	
+	mdbg(INFO3,"Link w/ lower_dentry->d_name.name = [%s] Link = [%s]", lower_old_dentry->d_name.name, lower_new_dentry->d_name.name);
+	lower_dir_dentry = lock_parent(lower_new_dentry);
+	rc = vfs_link(lower_old_dentry, lower_dir_dentry->d_inode,
+		      lower_new_dentry);
+	if (rc || !lower_new_dentry->d_inode)
+		goto out_lock;
+	rc = ccfs_interpose(lower_new_dentry, new_dentry, dir->i_sb, 0);
+	if (rc)
+		goto out_lock;
+	fsstack_copy_attr_times(dir, lower_new_dentry->d_inode);
+	fsstack_copy_inode_size(dir, lower_new_dentry->d_inode);
+	set_nlink(old_dentry->d_inode, ccfs_get_nested_inode(old_dentry->d_inode)->i_nlink); //Fix for kernel 3.7.1 use function set_nlink by Jiri Rakosnik
+	i_size_write(new_dentry->d_inode, file_size_save);
+out_lock:
+	unlock_dir(lower_dir_dentry);
+	dput(lower_new_dentry);
+	dput(lower_old_dentry);
+	d_drop(lower_old_dentry);
+	d_drop(new_dentry);
+	d_drop(old_dentry);
+	return rc;
+}
+
+static int ccfs_unlink(struct inode *dir, struct dentry *dentry)
+{
+	int rc = 0;
+	struct dentry *lower_dentry = ccfs_get_nested_dentry(dentry);
+	struct inode *lower_dir_inode = ccfs_get_nested_inode(dir);
+// TODO: Update cached link
+	mdbg(INFO3,"Unlink w/ lower_dentry->d_name.name = [%s]", lower_dentry->d_name.name);
+	lock_parent(lower_dentry);
+	rc = vfs_unlink(lower_dir_inode, lower_dentry);
+	if (rc) {
+		printk(KERN_ERR "Error in vfs_unlink; rc = [%d]\n", rc);
+		goto out_unlock;
+	}
+	fsstack_copy_attr_times(dir, lower_dir_inode);
+	set_nlink(dentry->d_inode, ccfs_get_nested_inode(dentry->d_inode)->i_nlink); //Fix for kernel 3.7.1 use function set_nlink by Jiri Rakosnik
+	dentry->d_inode->i_ctime = dir->i_ctime;
+	d_drop(dentry);
+out_unlock:
+	unlock_parent(lower_dentry);
+	return rc;
+}
+
+static int ccfs_symlink(struct inode *dir, struct dentry *dentry,
+			    const char *symname)
+{
+	int rc;
+	struct dentry *lower_dentry;
+	struct dentry *lower_dir_dentry;
+	umode_t mode;
+// TODO: Update cached link
+	lower_dentry = ccfs_get_nested_dentry(dentry);		
+	dget(lower_dentry);
+	
+	mdbg(INFO3,"Symlink w/ lower_dentry->d_name.name = [%s] Link = [%s]", lower_dentry->d_name.name, symname);
+	lower_dir_dentry = lock_parent(lower_dentry);
+	mode = S_IALLUGO;
+
+	rc = vfs_symlink(lower_dir_dentry->d_inode, lower_dentry,
+			 symname);
+	
+	if (rc || !lower_dentry->d_inode)
+		goto out_lock;
+	rc = ccfs_interpose(lower_dentry, dentry, dir->i_sb, 0);
+	if (rc)
+		goto out_lock;
+	fsstack_copy_attr_times(dir, lower_dir_dentry->d_inode);
+	fsstack_copy_inode_size(dir, lower_dir_dentry->d_inode);
+out_lock:
+	unlock_dir(lower_dir_dentry);
+	dput(lower_dentry);
+	if (!dentry->d_inode)
+		d_drop(dentry);
+	return rc;
+}
+
+static int ccfs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+{
+	int rc;
+	struct dentry *lower_dentry;
+	struct dentry *lower_dir_dentry;
+
+	lower_dentry = ccfs_get_nested_dentry(dentry);
+	lower_dir_dentry = lock_parent(lower_dentry);
+	
+	mdbg(INFO3,"MKDIR w/ lower_dentry->d_name.name = [%s] DIR = [%s]", lower_dentry->d_name.name, lower_dir_dentry->d_name.name);
+	rc = vfs_mkdir(lower_dir_dentry->d_inode, lower_dentry, mode);
+	if (rc || !lower_dentry->d_inode)
+		goto out;
+	rc = ccfs_interpose(lower_dentry, dentry, dir->i_sb, 0);
+	if (rc)
+		goto out;
+	fsstack_copy_attr_times(dir, lower_dir_dentry->d_inode);
+	fsstack_copy_inode_size(dir, lower_dir_dentry->d_inode);
+	set_nlink(dir, lower_dir_dentry->d_inode->i_nlink);   //Fix for kernel 3.7.1 use function set_nlink by Jiri Rakosnik
+out:
+	unlock_dir(lower_dir_dentry);
+	if (!dentry->d_inode)
+		d_drop(dentry);
+	return rc;
+}
+
+static int ccfs_rmdir(struct inode *dir, struct dentry *dentry)
+{
+	struct dentry *lower_dentry;
+	struct dentry *lower_dir_dentry;
+	int rc;
+
+	lower_dentry = ccfs_get_nested_dentry(dentry);
+	
+	mdbg(INFO3,"RMDIR w/ lower_dentry->d_name.name = [%s]", lower_dentry->d_name.name);
+	
+	dget(dentry);
+	lower_dir_dentry = lock_parent(lower_dentry);
+	dget(lower_dentry);
+	rc = vfs_rmdir(lower_dir_dentry->d_inode, lower_dentry);
+	dput(lower_dentry);
+	if (!rc)
+		d_delete(lower_dentry);
+	fsstack_copy_attr_times(dir, lower_dir_dentry->d_inode);
+	set_nlink(dir, lower_dir_dentry->d_inode->i_nlink); //Fix for kernel 3.7.1 use function set_nlink by Jiri Rakosnik
+	unlock_dir(lower_dir_dentry);
+	if (!rc)
+		d_drop(dentry);
+	dput(dentry);
+	return rc;
+}
+
+static int ccfs_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t dev)
+{
+	int rc;
+	struct dentry *lower_dentry;
+	struct dentry *lower_dir_dentry;
+		
+	lower_dentry = ccfs_get_nested_dentry(dentry);
+	lower_dir_dentry = lock_parent(lower_dentry);
+	
+	mdbg(INFO3,"MKNOD w/ lower_dentry->d_name.name = [%s]", lower_dentry->d_name.name);
+	
+	rc = vfs_mknod(lower_dir_dentry->d_inode, lower_dentry, mode, dev);
+	if (rc || !lower_dentry->d_inode)
+		goto out;
+	rc = ccfs_interpose(lower_dentry, dentry, dir->i_sb, 0);
+	if (rc)
+		goto out;
+	fsstack_copy_attr_times(dir, lower_dir_dentry->d_inode);
+	fsstack_copy_inode_size(dir, lower_dir_dentry->d_inode);
+out:
+	unlock_dir(lower_dir_dentry);
+	if (!dentry->d_inode)
+		d_drop(dentry);
+	return rc;
+}
+
+static int ccfs_rename(struct inode *old_dir, struct dentry *old_dentry,
+		struct inode *new_dir, struct dentry *new_dentry)
+{
+	int rc;
+	struct dentry *lower_old_dentry;
+	struct dentry *lower_new_dentry;
+	struct dentry *lower_old_dir_dentry;
+	struct dentry *lower_new_dir_dentry;
+
+	lower_old_dentry = ccfs_get_nested_dentry(old_dentry);
+	lower_new_dentry = ccfs_get_nested_dentry(new_dentry);
+	dget(lower_old_dentry);
+	dget(lower_new_dentry);
+	lower_old_dir_dentry = dget_parent(lower_old_dentry);
+	lower_new_dir_dentry = dget_parent(lower_new_dentry);
+	lock_rename(lower_old_dir_dentry, lower_new_dir_dentry);
+	rc = vfs_rename(lower_old_dir_dentry->d_inode, lower_old_dentry,
+			lower_new_dir_dentry->d_inode, lower_new_dentry);
+	if (rc)
+		goto out_lock;
+	fsstack_copy_attr_all(new_dir, lower_new_dir_dentry->d_inode);
+	if (new_dir != old_dir)
+		fsstack_copy_attr_all(old_dir, lower_old_dir_dentry->d_inode);
+out_lock:
+	unlock_rename(lower_old_dir_dentry, lower_new_dir_dentry);
+	dput(lower_new_dentry->d_parent);
+	dput(lower_old_dentry->d_parent);
+	dput(lower_new_dentry);
+	dput(lower_old_dentry);
+	return rc;
+}
+
+static int ccfs_readlink(struct dentry *dentry, char __user * buf, int bufsiz)
+{
+	int rc = 0;
+	struct dentry *lower_dentry;
+	char *lower_buf;
+	mm_segment_t old_fs;
+
+	struct ccfs_inode* inode = ccfs_inode_to_private(dentry->d_inode);
+
+
+	lower_dentry = ccfs_get_nested_dentry(dentry);
+	if (!lower_dentry->d_inode->i_op ||
+	    !lower_dentry->d_inode->i_op->readlink) {
+		rc = -EINVAL;
+		goto out;
+	}
+
+	// Do we have link cached?
+	if ( inode->link ) {
+		rc = strlen(inode->link);
+		if (copy_to_user(buf, inode->link, rc)) {
+			rc = -EFAULT;
+		}
+		fsstack_copy_attr_atime(dentry->d_inode,
+					lower_dentry->d_inode);
+
+		mdbg(INFO3, "Resolved cached link => [%s:%d]", inode->link, rc);
+
+		goto out;
+	}
+
+
+	/* Released in this function */
+	lower_buf = kmalloc(bufsiz, GFP_KERNEL);
+	if (lower_buf == NULL) {
+		printk(KERN_ERR "Out of memory\n");
+		rc = -ENOMEM;
+		goto out;
+	}
+
+	old_fs = get_fs();
+	set_fs(get_ds());
+	mdbg(INFO3,"Calling readlink w/ "
+			"lower_dentry->d_name.name = [%s]",
+			lower_dentry->d_name.name);
+	rc = lower_dentry->d_inode->i_op->readlink(lower_dentry,
+						   (char __user *)lower_buf,
+						   bufsiz);
+	set_fs(old_fs);
+	if (rc >= 0) {	
+		// Cache symlinks
+		if ( !inode->link ) {
+			char* link = kmalloc(rc + 1, GFP_KERNEL);			
+			if ( link ) { // Ignore no memory.. we simply do not cache in that case
+				memcpy(link, lower_buf, rc);
+				inode->link = link;
+				inode->link[rc] = '\0';
+			}
+		}
+
+		if (copy_to_user(buf, lower_buf, rc)) {
+			rc = -EFAULT;
+		}
+		fsstack_copy_attr_atime(dentry->d_inode,
+					lower_dentry->d_inode);
+	}
+
+	kfree(lower_buf);
+out:
+	return rc;
+}
+
+static void *ccfs_follow_link(struct dentry *dentry, struct nameidata *nd)
+{
+	char *buf;
+	int len = PAGE_SIZE, rc;
+	mm_segment_t old_fs;
+
+	/* Released in ecryptfs_put_link(); only release here on error */
+	buf = kmalloc(len, GFP_KERNEL);
+	if (!buf) {
+		rc = -ENOMEM;
+		goto out;
+	}
+	old_fs = get_fs();
+	set_fs(get_ds());
+	mdbg(INFO3, "Calling followlink w/ "
+			"dentry->d_name.name = [%s]", dentry->d_name.name);
+	rc = dentry->d_inode->i_op->readlink(dentry, (char __user *)buf, len);
+	buf[rc] = '\0';
+	set_fs(old_fs);
+	if (rc < 0)
+		goto out_free;
+	rc = 0;
+	nd_set_link(nd, buf);
+	goto out;
+out_free:
+	kfree(buf);
+out:
+	return ERR_PTR(rc);
+}
+
+static void ccfs_put_link(struct dentry *dentry, struct nameidata *nd, void *ptr)
+{
+	/* Free the char* */
+	kfree(nd_get_link(nd));
+}
+
+
+int ccfs_truncate(struct dentry *dentry, loff_t new_length)
+{
+	int rc = 0;
+	struct inode *inode = dentry->d_inode;
+	struct dentry *lower_dentry;
+	loff_t i_size = i_size_read(inode);
+
+	if (unlikely((new_length == i_size)))
+		goto out;
+
+	lower_dentry = ccfs_get_nested_dentry(dentry);
+
+	vmtruncate(inode, new_length);
+	vmtruncate(lower_dentry->d_inode,
+			new_length);
+out:
+	return rc;
+}
+
+static int ccfs_permission(struct inode *inode, int mask)
+{
+	int rc = inode_permission(ccfs_get_nested_inode(inode), mask);
+
+	mdbg(INFO3,"Permission check for inode %p [%ld] returned [%d]", inode, inode->i_ino, rc);
+
+	return rc;
+}
+
+static int ccfs_setattr(struct dentry *dentry, struct iattr *ia)
+{
+	int rc = 0;
+	struct dentry *lower_dentry;
+	struct inode *inode;
+	struct inode *lower_inode;
+
+	inode = dentry->d_inode;
+	lower_inode = ccfs_get_nested_inode(inode);
+	lower_dentry = ccfs_get_nested_dentry(dentry);
+	
+	if (ia->ia_valid & ATTR_SIZE) {
+		mdbg(INFO3,
+				"ia->ia_valid = [0x%x] ATTR_SIZE" " = [0x%x]",
+				ia->ia_valid, ATTR_SIZE);
+		rc = ccfs_truncate(dentry, ia->ia_size);
+		ia->ia_valid &= ~ATTR_SIZE;
+		mdbg(INFO3,"ia->ia_valid = [%x]",
+				ia->ia_valid);
+		if (rc < 0)
+			goto out;
+	}
+
+	/*
+	 * mode change is for clearing setuid/setgid bits. Allow lower fs
+	 * to interpret this in its own way.
+	 */
+	if (ia->ia_valid & (ATTR_KILL_SUID | ATTR_KILL_SGID))
+		ia->ia_valid &= ~ATTR_MODE;
+
+	rc = notify_change(lower_dentry, ia);
+out:
+	fsstack_copy_attr_all(inode, lower_inode);
+	return rc;
+}
+
+static int ccfs_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
+{
+	int rc = 0;
+	struct dentry *lower_dentry;	
+	struct ccfs_inode* inode = ccfs_inode_to_private(dentry->d_inode);
+	struct vfsmount *lower_mnt = ccfs_dentry_to_nested_mnt(dentry);
+	lower_dentry = ccfs_get_nested_dentry(dentry);
+
+	if ( inode->stat ) {
+		*stat = *inode->stat;
+		return 0;
+	}
+
+	mutex_lock(&lower_dentry->d_inode->i_mutex);
+	rc = vfs_getattr(lower_mnt, lower_dentry, stat);
+	mutex_unlock(&lower_dentry->d_inode->i_mutex);
+
+	if ( !rc && inode->cacheable) {
+		inode->stat = kmalloc(sizeof(struct kstat), GFP_KERNEL);
+		if ( inode->stat ) {
+			*(inode->stat) = *stat;
+		}
+	}
+
+	mdbg(INFO3, "Get stat returned res: %d uid %d gid %d", rc, stat->uid, stat->gid);
+
+	return rc;
+
+}
+
+int ccfs_setxattr(struct dentry *dentry, const char *name, const void *value,
+		  size_t size, int flags)
+{
+	int rc = 0;
+	struct dentry *lower_dentry;
+
+	lower_dentry = ccfs_get_nested_dentry(dentry);
+	if (!lower_dentry->d_inode->i_op->setxattr) {
+		rc = -EOPNOTSUPP;
+		goto out;
+	}
+	mutex_lock(&lower_dentry->d_inode->i_mutex);
+	rc = lower_dentry->d_inode->i_op->setxattr(lower_dentry, name, value,
+						   size, flags);
+	mutex_unlock(&lower_dentry->d_inode->i_mutex);
+out:
+	return rc;
+}
+
+ssize_t
+ccfs_getxattr_lower(struct dentry *lower_dentry, const char *name,
+			void *value, size_t size)
+{
+	int rc = 0;
+
+	if (!lower_dentry->d_inode->i_op->getxattr) {
+		rc = -EOPNOTSUPP;
+		goto out;
+	}
+	mutex_lock(&lower_dentry->d_inode->i_mutex);
+	rc = lower_dentry->d_inode->i_op->getxattr(lower_dentry, name, value,
+						   size);
+	mutex_unlock(&lower_dentry->d_inode->i_mutex);
+out:
+	return rc;
+}
+
+ssize_t
+ccfs_getxattr(struct dentry *dentry, const char *name, void *value,
+		  size_t size)
+{
+	return ccfs_getxattr_lower(ccfs_get_nested_dentry(dentry), name,
+				       value, size);
+}
+
+static ssize_t
+ccfs_listxattr(struct dentry *dentry, char *list, size_t size)
+{
+	int rc = 0;
+	struct dentry *lower_dentry;
+
+	lower_dentry = ccfs_get_nested_dentry(dentry);
+	if (!lower_dentry->d_inode->i_op->listxattr) {
+		rc = -EOPNOTSUPP;
+		goto out;
+	}
+	mutex_lock(&lower_dentry->d_inode->i_mutex);
+	rc = lower_dentry->d_inode->i_op->listxattr(lower_dentry, list, size);
+	mutex_unlock(&lower_dentry->d_inode->i_mutex);
+out:
+	return rc;
+}
+
+static int ccfs_removexattr(struct dentry *dentry, const char *name)
+{
+	int rc = 0;
+	struct dentry *lower_dentry;
+
+	lower_dentry = ccfs_get_nested_dentry(dentry);
+	if (!lower_dentry->d_inode->i_op->removexattr) {
+		rc = -EOPNOTSUPP;
+		goto out;
+	}
+	mutex_lock(&lower_dentry->d_inode->i_mutex);
+	rc = lower_dentry->d_inode->i_op->removexattr(lower_dentry, name);
+	mutex_unlock(&lower_dentry->d_inode->i_mutex);
+out:
+	return rc;
+}
+
+int ccfs_inode_test(struct inode *inode, void *candidate_lower_inode)
+{
+	if ((ccfs_get_nested_inode(inode)
+	     == (struct inode *)candidate_lower_inode)) {
+		mdbg(INFO3,"Search matched: %p -> %p", inode, candidate_lower_inode);
+		return 1;
+	} else {
+		return 0;
+	}
+}
+
+int ccfs_inode_set(struct inode *inode, void *lower_inode)
+{
+	ccfs_init_inode(inode, (struct inode *)lower_inode);
+	return 0;
+}
+
+
+
+const struct inode_operations ccfs_symlink_iops = {
+	.readlink = ccfs_readlink,
+	.follow_link = ccfs_follow_link,
+	.put_link = ccfs_put_link,
+	.permission = ccfs_permission,
+	.setattr = ccfs_setattr,
+	.getattr = ccfs_getattr,
+	.setxattr = ccfs_setxattr,
+	.getxattr = ccfs_getxattr,
+	.listxattr = ccfs_listxattr,
+	.removexattr = ccfs_removexattr
+};
+
+const struct inode_operations ccfs_dir_iops = {
+	.create = ccfs_create,
+	.lookup = ccfs_lookup,
+	.link = ccfs_link,
+	.unlink = ccfs_unlink,
+	.symlink = ccfs_symlink,
+	.mkdir = ccfs_mkdir,
+	.rmdir = ccfs_rmdir,
+	.mknod = ccfs_mknod,
+	.rename = ccfs_rename,
+	.permission = ccfs_permission,
+	.setattr = ccfs_setattr,
+	.getattr = ccfs_getattr,
+	.setxattr = ccfs_setxattr,
+	.getxattr = ccfs_getxattr,
+	.listxattr = ccfs_listxattr,
+	.removexattr = ccfs_removexattr
+};
+
+const struct inode_operations ccfs_main_iops = {
+	.permission = ccfs_permission,
+	.setattr = ccfs_setattr,
+	.getattr = ccfs_getattr,
+	.setxattr = ccfs_setxattr,
+	.getxattr = ccfs_getxattr,
+	.listxattr = ccfs_listxattr,
+	.removexattr = ccfs_removexattr
+};
--- linux-3.7.1_original/clondike/src/ccfs/dentry.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/ccfs/dentry.c	2013-02-20 16:13:17.000000000 +0100
@@ -0,0 +1,93 @@
+#include <linux/dcache.h>
+#include <linux/namei.h>
+#include <linux/mount.h>
+#include <linux/fs_stack.h>
+#include <linux/slab.h>
+#include "ccfs.h"
+
+#include <dbg.h>
+
+static int ccfs_d_revalidate(struct dentry *dentry, struct nameidata *nd)
+{
+	struct dentry *lower_dentry = ccfs_get_nested_dentry(dentry);
+	struct vfsmount *lower_mnt = ccfs_dentry_to_nested_mnt(dentry);
+	struct dentry *dentry_save;
+	struct vfsmount *vfsmount_save;
+	int rc = 1;	
+
+	mdbg(INFO3,"Revalidating dentry: (%s) %p", dentry->d_iname, dentry);
+	
+	// Do not cache negative dentries or uncachable dentries
+	if ( !dentry->d_inode ) {		
+		mdbg(INFO3,"Inodeless dentry -> invalid");
+		return 0;
+	}
+	
+
+	if (!lower_dentry->d_op || !lower_dentry->d_op->d_revalidate)
+		goto out;
+
+	dentry_save = nd->path.dentry;
+	vfsmount_save = nd->path.mnt;
+	nd->path.dentry = lower_dentry;
+	nd->path.mnt = lower_mnt;
+	rc = lower_dentry->d_op->d_revalidate(lower_dentry, nd->flags);
+	nd->path.dentry = dentry_save;
+	nd->path.mnt = vfsmount_save;
+	if (dentry->d_inode) {
+		struct inode *lower_inode =
+			ccfs_get_nested_inode(dentry->d_inode);
+
+		fsstack_copy_attr_all(dentry->d_inode, lower_inode);
+	}
+out:
+
+	
+/*      
+    No special handling of non-cacheable nodes.. if the dentry is still in cache, we just let lower FS to revalidate the dentry. If we return 0 here, some operations may break as some
+    FS actions would failed even though they are valid.
+    if ( !ccfs_inode_to_private(dentry->d_inode)->cacheable ) {
+	    mdbg(INFO3,"Non-cacheable inode -> invalid");
+	    return 0;
+	}
+*/	
+		
+	mdbg(INFO3,"Revalidation result: %d", rc);
+	
+	return rc;
+}
+
+struct kmem_cache *ccfs_dentry_cache;
+
+static void ccfs_d_release(struct dentry *dentry)
+{
+	mdbg(INFO3,"Releasing dentry: (%s) %p", dentry->d_iname, dentry);
+	if (ccfs_dentry_to_private(dentry)) {		
+		if (ccfs_get_nested_dentry(dentry)) {
+			mntput(ccfs_dentry_to_nested_mnt(dentry));
+			dput(ccfs_get_nested_dentry(dentry));
+		}
+		kmem_cache_free(ccfs_dentry_cache,
+				ccfs_dentry_to_private(dentry));
+	}
+	mdbg(INFO3,"Releasing dentry done");
+	return;
+}
+
+static int ccfs_d_delete(const struct dentry *dentry)
+{
+	
+	if (dentry->d_inode) {
+		mdbg(INFO3,"Delete dentry: (%s) %d", dentry->d_iname, ccfs_is_inode_cacheable(dentry->d_inode));
+		return !ccfs_is_inode_cacheable(dentry->d_inode);
+	}
+
+	return 1;
+}
+
+
+struct dentry_operations ccfs_dops = {
+	.d_delete = ccfs_d_delete,
+	.d_revalidate = ccfs_d_revalidate,
+	.d_release = ccfs_d_release,
+};
--- linux-3.7.1_original/clondike/src/tcmi/tcmi_module.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/tcmi_module.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,196 @@
+/**
+ * @file tcmi_module.c - main TCMI module
+ *                      - on module init:
+ *                         initializes the TCMI CCN manager component
+ *                         initializes the TCMI PEN manager component
+ *                      - on module unload: 
+ *                         shutsdown the TCMI CCN manager component
+ *                         shutsdown the TCMI PEN manager component
+ *
+ * Date: 05/05/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_module.c,v 1.4 2008/05/02 19:59:20 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/module.h>
+
+#include <tcmi/ctlfs/tcmi_ctlfs.h>
+#include <tcmi/manager/tcmi_ccnman.h>
+#include <tcmi/manager/tcmi_penman.h>
+#include <tcmi/task/tcmi_taskhelper.h>
+
+#include <tcmi/syscall/tcmi_syscallhooks.h>
+#include <tcmi/migration/tcmi_mighooks.h>
+
+#include <director/director.h>
+
+#include <dbg.h>
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Jan Capek, Petr Malat");
+
+/** @defgroup tcmi_module_class TCMI
+ *
+ * This \<\<singleton\>\> class is the base of the infrastructure and
+ * is responsible for initialization/shutdown of TCMI. The
+ * initializition requires notifying CCN and/or PEN manager resp. 
+ *
+ * Initialized TCMI provides control in user space to:
+ * - migrate a process from a CCN to a PEN
+ * - migrate a process home from a PEN to a CCN
+ * - display information about migrated processes
+ * - connect a PEN to CCN
+ * - setup interfaces where CCN listens for incoming connections from
+ * PEN's
+ * - shutdown the whole infrastructure
+ * @{
+ */
+
+
+/** Ctl FS file for setting/reading of debug settings */
+static struct tcmi_ctlfs_entry *debug_file = NULL;
+
+/**
+ * Method to set debug flag via a ctlfs file
+ */
+static int tcmi_debug_set(void *obj, void *data)
+{
+	int new_debug = *((int *)data);
+
+	minfo(INFO3, "Setting TCMI debug to %d", new_debug);
+
+	tcmi_dbg = new_debug;
+	return 0;
+}
+
+ 
+/**
+ * Reader of debug state from ctlfs file
+ */
+static int tcmi_debug_get(void *obj, void *data)
+{
+	*((int *)data) = tcmi_dbg;
+	return 0;
+}
+
+
+static int tcmi_send_generic_user_message_handler(int is_core_slot, int target_slot_index, int user_data_size, char* user_data) {
+	if ( is_core_slot ) {
+		return tcmi_man_send_generic_user_message(TCMI_MAN(tcmi_ccnman_get_instance()), target_slot_index, user_data_size, user_data);
+	} else {
+		return tcmi_man_send_generic_user_message(TCMI_MAN(tcmi_penman_get_instance()), target_slot_index, user_data_size, user_data);
+	}
+}
+
+static void tcmi_register_director_user_message_handler(void) {
+	director_register_send_generic_user_message_handler(tcmi_send_generic_user_message_handler);
+}
+
+
+/**
+ * Module initialization.
+ * Initializes 3 core components:
+ * - tcmi hooks in kernel
+ * - CCN manager - (when enabled in kernel)
+ * - PEN manager - (when enabled in kernel)
+ *
+ * The resulting node setup depends how TCMI has been configured in
+ * kernel.
+ *
+ * @return 0 upon successfull initialization
+ */
+static int __init tcmi_module_init(void)
+{
+	struct tcmi_ctlfs_entry *root;
+	minfo(INFO1, "Loading the TCMI framework");
+	tcmi_dbg = 1; // Enable debug temporarily at least for startup time
+
+ 	root = tcmi_ctlfs_get_root();
+
+	tcmi_mighooks_init();
+	tcmi_syscall_hooks_init();
+	tcmi_register_director_user_message_handler();
+
+	if (tcmi_ccnman_init(root) < 0) {
+		minfo(ERR1, "Failed initializing TCMI CCN manager");
+		goto exit0;
+	}
+	if (tcmi_penman_init(root) < 0) {
+		minfo(ERR1, "Failed initializing TCMI PEN manager");
+		goto exit1;
+	}
+
+        debug_file = tcmi_ctlfs_intfile_new(root, TCMI_PERMS_FILE_RW,
+			     NULL, tcmi_debug_get, tcmi_debug_set,
+			     sizeof(int), "debug");
+	if ( !debug_file ) {
+		minfo(ERR1, "Failed to create debug control file");
+		goto exit2;
+	}
+
+
+	minfo(INFO1, "TCMI framework loaded");
+	tcmi_dbg = 0; // Startup succeeded, disable debug, it can be reenabled via ctlfs
+	return 0;
+
+	/* error handling */
+ exit2:
+	tcmi_penman_shutdown();
+ exit1:
+	tcmi_ccnman_shutdown();
+ exit0:
+	return -EINVAL;
+}
+
+/**
+ * Module cleanup
+ */
+static void __exit tcmi_module_exit(void)
+{
+
+	minfo(INFO1, "Unloading TCMI framework");
+
+	/* Managers must be shutdown first, because they may need other parts of infrastructure to proceed with migration back */
+	tcmi_penman_shutdown();
+	tcmi_ccnman_shutdown();
+	
+	tcmi_mighooks_exit();
+	tcmi_syscall_hooks_exit();
+
+	tcmi_ctlfs_file_unregister(debug_file);
+	tcmi_ctlfs_entry_put(debug_file);
+
+	tcmi_ctlfs_put_root();
+
+	minfo(INFO1, "TCMI framework unloaded");
+}
+ /**
+ * @}
+ */
+
+
+module_init(tcmi_module_init);
+module_exit(tcmi_module_exit);
+
+
+
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_guest_fork_rpc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_guest_fork_rpc.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,70 @@
+/**
+ * @file tcmi_guest_fork_rpc.c - guest side part of fork syscall
+ */
+
+#include <dbg.h>
+#include <tcmi/comm/tcmi_rpcresp_procmsg.h>
+#include <linux/uaccess.h>
+
+#include <arch/types.h>
+#include "tcmi_guest_fork_rpc.h"
+
+/** 
+ * All version of system call based on fork RPC 
+ * Called in the beginning of do_fork method
+ *
+ * @param rpc_num - RPC number
+ * @param params  - pointer to array with RPC parameters - clone_flags, stack_start, regs, stack_size, parent_tidptr, child_tidptr
+ *
+ * @return RPC return value
+ * */
+TCMI_GUEST_RPC_CALL_DEF(fork)
+{
+	struct tcmi_msg *r; 
+	long rtn;
+	// platform independend params
+	uint64_t clone_flags, stack_start, stack_size;
+
+	// Real results
+	int parent_tid, child_tid;
+
+	clone_flags = params[0];
+	stack_start = params[1];
+	stack_size  = params[3];
+
+	mdbg(INFO3, "Forwarding fork syscall. Ptid filled: %d Ctid filled: %d", (void*)params[4] != NULL, (void*)params[5] != NULL);
+
+	r = tcmi_rpcresp_procmsg_get_response(rpc_num, 
+			sizeof(uint64_t), &clone_flags, 
+			sizeof(uint64_t), &stack_start, 
+			sizeof(uint64_t), &stack_size, 
+			(size_t)0); 
+
+	if(r == NULL){
+		mdbg(ERR3, "Response message hasn't arrived");
+		return -EAGAIN;
+	}
+	
+	// Extracts results in platform independ form and convert them
+	parent_tid = *(int32_t*)tcmi_rpcresp_procmsg_data_base( TCMI_RPCRESP_PROCMSG(r), 0);
+	child_tid = *(int32_t*)tcmi_rpcresp_procmsg_data_base( TCMI_RPCRESP_PROCMSG(r), 1);	
+
+	rtn = tcmi_rpcresp_procmsg_rtn( TCMI_RPCRESP_PROCMSG(r) );
+
+	if ( rtn > 0 ) { // Perform this only in case fork succeeded!		
+		// Copies them to a user space provided buffer	
+/* TODO: THis is not correct think to do.. the value needs to be set "lazily"
+		if ( (void*)params[4] != NULL ) {
+			put_user(parent_tid, (int __user*)params[4]);		
+		}	
+		if ( (void*)params[5] != NULL ) {
+			put_user(child_tid, (int __user*)params[5]);
+		}	
+*/
+	}
+	
+	tcmi_msg_put(r);
+
+	mdbg(INFO3, "Fork syscall returned: %ld. Parent tid: %d Child tid: %d", rtn, parent_tid, child_tid);
+	return rtn;
+}
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_guest_wait_rpc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_guest_wait_rpc.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,39 @@
+/**
+ * @file tcmi_guest_wait_rpc.h - a RPC class used by guest process for processing wait syscall
+ *
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef _TCMI_GUEST_RPC_WAIT_H
+#define _TCMI_GUEST_RPC_WAIT_H
+
+#include "tcmi_guest_rpc.h"
+/** @defgroup tcmi_guest_rpc_wait_class Wait syscall
+ *
+ * @ingroup tcmi_guest_wait_class
+ *
+ * A \<\<singleton\>\> class that is executing RPC on PEN side.
+ * 
+ * @{
+ */
+
+TCMI_GUEST_RPC_CALL_DEF(wait4);
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_GUEST_RPC_FORK_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_guest_generic_rpc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_guest_generic_rpc.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,66 @@
+/**
+ * @file tcmi_guest_generic_rpc.h - a RPC class used by guest process .
+ *
+ * Date: 3/08/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: tcmi_guest_generic_rpc.h,v 1.1 2007/09/02 12:09:55 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef _TCMI_GUEST_RPC_GENERIC_H
+#define _TCMI_GUEST_RPC_GENERIC_H
+
+#include "tcmi_guest_rpc.h"
+/** @defgroup tcmi_guest_rpc_generic_class Generic RPCs 
+ *
+ * @ingroup tcmi_guest_rpc_class
+ *
+ * A \<\<singleton\>\> class that is executing RPC on PEN side.
+ * 
+ * @{
+ */
+
+/** Creates declaration for default RPC (which takes only long arguments and return
+ * only one value 
+ *
+ * param num - Number of arguments
+ */
+#define TCMI_GUEST_RPC_SYS_N_DEF(num) \
+long tcmi_guest_rpc_sys_##num(unsigned, long params[TCMI_RPC_MAXPARAMS])
+
+/** Generic guest RPC method for call with no parameters */
+TCMI_GUEST_RPC_SYS_N_DEF(0);
+
+/** Generic guest RPC method for call with one parameters */
+TCMI_GUEST_RPC_SYS_N_DEF(1);
+
+/** Generic guest RPC method for call with two parameters */
+TCMI_GUEST_RPC_SYS_N_DEF(2);
+
+/** Generic guest RPC method for call with three parameters */
+TCMI_GUEST_RPC_SYS_N_DEF(3);
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_GUEST_RPC_GENERIC_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_shadow_userident_rpc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_shadow_userident_rpc.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,64 @@
+/**
+ * @file tcmi_shadow_rpc_userident.h - a RPC class used by shadow process .
+ *
+ * Date: 7/06/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: tcmi_shadow_userident_rpc.h,v 1.1 2007/09/02 12:09:55 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef _TCMI_SHADOW_RPC_USERIDENT_H
+#define _TCMI_SHADOW_RPC_USERIDENT_H
+
+#include "tcmi_shadow_rpc.h"
+
+/** @defgroup tcmi_shadow_rpc_userident_class User identification 
+ *  @ingroup tcmi_shadow_rpc_class
+ *
+ * A part of tcmi_shadow_rpc with RPCs for user identification
+ * 
+ * @{
+ */
+
+/** Setuid() system call */
+TCMI_SHADOW_RPC_GENERIC_CALL_DEF(setuid);
+
+/** Setreuid() system call */
+TCMI_SHADOW_RPC_GENERIC_CALL_DEF(setreuid);
+
+/** Setresuid() system call */
+TCMI_SHADOW_RPC_GENERIC_CALL_DEF(setresuid);
+
+/** Geteuid() system call */
+TCMI_SHADOW_RPC_GENERIC_CALL_DEF(geteuid);
+
+/** Getuid() system call */
+TCMI_SHADOW_RPC_GENERIC_CALL_DEF(getuid);
+
+/** Getresuid() system call */
+TCMI_SHADOW_RPC_GENERIC_CALL_DEF(getresuid);
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_SHADOW_RPC_USERIDENT_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_syscallhooks_other.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_syscallhooks_other.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,169 @@
+/**
+ * @file tcmi_syscallhooks_other.c - other syscalls hooks.
+ *                      
+ * 
+ *
+ *
+ * Date: 13/06/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: tcmi_syscallhooks_other.c,v 1.5 2008/01/17 14:36:44 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <linux/capability.h>
+#include <clondike/tcmi/tcmi_hooks.h>
+
+#include <dbg.h>
+#include <tcmi/syscall/tcmi_guest_rpc.h>
+
+#define TCMI_SYSCALLHOOKS_OTHER_PRIVATE
+#include "tcmi_syscallhooks_other.h"
+
+#include <tcmi/manager/tcmi_man.h>
+#include <tcmi/manager/tcmi_penman.h>
+#include <tcmi/manager/tcmi_ccnman.h>
+#include <tcmi/task/tcmi_guesttask.h>
+
+#include <proxyfs/proxyfs_server.h>
+#include <director/director.h>
+
+#include <asm/uaccess.h>
+#include <linux/err.h>
+
+/** 
+ * \<\<public\>\> Registers all syscalls hooks with the kernel.
+ *
+ * @return 0 upon success
+ */
+int tcmi_syscall_hooks_other_init(void)
+{
+	minfo(INFO1, "Registering TCMI other syscalls hooks\n"
+			"(wait)");
+	tcmi_hooks_register_sys_wait4(tcmi_syscall_hooks_sys_wait4);
+	tcmi_hooks_register_pre_fork(tcmi_syscall_hooks_pre_fork);
+	tcmi_hooks_register_in_fork(tcmi_syscall_hooks_in_fork);
+	tcmi_hooks_register_post_fork(tcmi_syscall_hooks_post_fork);
+	
+	return 0;
+}
+
+/** 
+ * \<\<public\>\> Unregisters all syscalls hooks.
+ */
+void tcmi_syscall_hooks_other_exit(void)
+{
+	minfo(INFO1, "Unregistering TCMI other syscalls hooks"
+			"(wait)");
+	tcmi_hooks_unregister_sys_wait4();
+	tcmi_hooks_unregister_pre_fork();
+	tcmi_hooks_unregister_in_fork();
+	tcmi_hooks_unregister_post_fork();
+}
+
+/** @addtogroup tcmi_syscallhooks_class
+ *
+ * @{
+ */
+
+/**
+ * \<\<private\>\> sys_wait4 system call hook.  
+ */
+static long tcmi_syscall_hooks_sys_wait4(pid_t pid, int __user *stat_addr, int options, struct rusage __user *ru) {
+	return tcmi_rpc_call4(tcmi_guest_rpc, TCMI_RPC_SYS_WAIT4, pid, (unsigned long)stat_addr, options, (unsigned long)ru);
+};
+
+
+/**
+ * \<\<private\>\> pre-fork
+ */
+static long tcmi_syscall_hooks_pre_fork(unsigned long clone_flags, unsigned long stack_start, 
+					struct pt_regs *regs, unsigned long stack_size, 
+					int __user *parent_tidptr, int __user *child_tidptr
+) {
+	// Pre-fork is hooked only on DN, on CN we fork normally
+	if ( current->tcmi.task_type == guest ) {
+		return tcmi_rpc_call6(tcmi_guest_rpc, TCMI_RPC_SYS_FORK, clone_flags, stack_start, (unsigned long)regs, stack_size, (unsigned long)parent_tidptr, (unsigned long)child_tidptr);
+	}
+
+	return 0;
+};
+
+/**
+ * \<\<private\>\> in-fork... performs attachement of guest/shadow task to TCMI
+ */
+static long tcmi_syscall_hooks_in_fork(struct task_struct* child) {
+	if ( current->tcmi.task_type == guest ) {
+		// Parent task is guest => child will be guest
+		struct tcmi_penman* pen_man = tcmi_penman_get_instance();
+
+		return tcmi_man_fork(TCMI_MAN(pen_man), current, child);
+	} else if ( current->tcmi.task_type == shadow ) {
+		// Parent task is shadow => child should be shadow 
+		struct tcmi_ccnman* ccn_man = tcmi_ccnman_get_instance();
+		
+		return tcmi_man_fork(TCMI_MAN(ccn_man), current, child);
+	}
+
+	return 0;	
+}
+
+/**
+ * \<\<private\>\> post-fork
+ */
+static long tcmi_syscall_hooks_post_fork(struct task_struct* child, long res, pid_t remote_pid, 
+					int __user *parent_tidptr, int __user *child_tidptr) 
+{
+	if ( current->tcmi.task_type == guest ) {
+		// Guest task hook
+		struct tcmi_task* child_task = NULL;
+		if ( IS_ERR((void*)res) ) {			
+			mdbg(INFO3, "Resetting fork return values due to error");	
+			if ( parent_tidptr != NULL )
+				//put_user((int)-1, parent_tidptr);
+			if ( child_tidptr != NULL ) {				
+				//put_user((int)-1, child_tidptr);
+			}
+		} else {
+			child_task = TCMI_TASK(child->tcmi.tcmi_task);
+		}
+
+		tcmi_guesttask_post_fork(TCMI_TASK(current->tcmi.tcmi_task), child_task, res, remote_pid);
+
+		return remote_pid;
+	} else if ( current->tcmi.task_type == shadow ) {
+		// Shadow task hook
+
+		// We have to duplicate all proxyfs file references for child.. this way we are in a same situation as
+		// if the fork happend on CCN before the migration
+		if (!IS_ERR((void*)res) ) {			
+			proxyfs_server_duplicate_all_parent(current, child);
+		}
+	}
+
+	director_task_fork(res, current->pid);
+
+	return res;
+};
+
+
+/**
+ * @}
+ */
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_guest_groupident_rpc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_guest_groupident_rpc.c	2013-03-12 11:23:50.000000000 +0100
@@ -0,0 +1,126 @@
+/**
+ * @file tcmi_guest_rpc_useridnt.c - shadow part of proxyfs rpc
+ *
+ * Date: 7/06/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: tcmi_guest_groupident_rpc.c,v 1.2 2007/09/02 13:54:30 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <dbg.h>
+#include <tcmi/comm/tcmi_rpcresp_procmsg.h>
+#include <linux/uaccess.h>
+
+#include "tcmi_guest_groupident_rpc.h"
+
+
+/** Definition of tcmi_shadow_rpc_sys_getgroups() 
+ * @param rpc_num  - RPC number (TCMI_RPC_SYS_GETGROUPS)
+ * @param params[] - [0] Buffer size <br> - [1] Pointer to buffer in userspace with checked access
+ *
+ * @return bytes written
+ *
+ */
+TCMI_GUEST_RPC_CALL_DEF(getgroups)
+{
+	struct tcmi_msg *r; long rtn; long size;
+  unsigned long err = 0;        //Added for warning ignore return value __copy_to_user | by Jiri Rakosnik
+
+	r = tcmi_rpcresp_procmsg_get_response(
+			rpc_num, sizeof(long), params, 0);
+
+	if(r == NULL){
+		mdbg(ERR3, "Response message hasn't arrived");
+		return -EAGAIN;
+	}
+
+	rtn = tcmi_rpcresp_procmsg_rtn( TCMI_RPCRESP_PROCMSG(r) );
+	if( rtn > 0 && params[0] > 0 ){
+		size = tcmi_rpcresp_procmsg_data_size( TCMI_RPCRESP_PROCMSG(r), 0 );
+		err = __copy_to_user((void*)params[1], tcmi_rpcresp_procmsg_data_base( TCMI_RPCRESP_PROCMSG(r), 0 ), 
+				size*sizeof(gid_t));
+	}
+	tcmi_msg_put(r);
+	return rtn;
+}
+
+/** Definition of tcmi_shadow_rpc_sys_setgroups() 
+ * @param rpc_num  - RPC number (TCMI_RPC_SYS_GETGROUPS)
+ * @param params[] - [0] Buffer size <br> - [1] Pointer to buffer in userspace with checked access
+ *
+ * @return bytes written
+ *
+ */
+TCMI_GUEST_RPC_CALL_DEF(setgroups)
+{
+	struct tcmi_msg *r; long rtn, size;
+	void *ker_buf;
+  unsigned long err = 0;        //Added for warning ignore return value __copy_to_user | by Jiri Rakosnik
+
+	size = sizeof(gid_t) * params[0];
+
+	if( (ker_buf = kmalloc( size, GFP_KERNEL )) == NULL ){
+		mdbg(ERR3, "Buffer allocation failed");
+		return -EAGAIN;
+	}
+
+	err = __copy_from_user( ker_buf, (void*)params[1], size );
+	r = tcmi_rpcresp_procmsg_get_response(
+			rpc_num, sizeof(long), params, size, ker_buf, 0);
+
+	if(r == NULL){
+		mdbg(ERR3, "Response message hasn't arrived");
+		return -EAGAIN;
+	}
+
+	rtn = tcmi_rpcresp_procmsg_rtn( TCMI_RPCRESP_PROCMSG(r) );
+	tcmi_msg_put(r);
+	return rtn;
+}
+
+/** Definition of tcmi_shadow_rpc_sys_setresgid() 
+ * @param rpc_num   - RPC number (TCMI_RPC_SYS_GETRESGID)
+ * @param params[] - [0] Pointer to rgid <br> - [1] Pointer to egid <br> - [2] Pointer to sgid
+ *
+ * @return zero on success
+ * */
+TCMI_GUEST_RPC_CALL_DEF(getresgid)
+{
+	struct tcmi_msg *r; long rtn, *resp_data;
+	r = tcmi_rpcresp_procmsg_get_response(
+			rpc_num, 0);
+
+	if(r == NULL){
+		mdbg(ERR3, "Response message hasn't arrived");
+		return -EAGAIN;
+	}
+
+	rtn = tcmi_rpcresp_procmsg_rtn( TCMI_RPCRESP_PROCMSG(r) );
+	if( rtn == 0 ){
+		resp_data = tcmi_rpcresp_procmsg_data_base( TCMI_RPCRESP_PROCMSG(r), 0 );
+		put_user( (gid_t)resp_data[0], (gid_t*)params[0] );
+		put_user( (gid_t)resp_data[1], (gid_t*)params[1] );
+		put_user( (gid_t)resp_data[2], (gid_t*)params[2] );
+	}
+	tcmi_msg_put(r);
+	return rtn;
+}
+
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_syscallhooks_pidman.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_syscallhooks_pidman.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,83 @@
+/**
+ * @file tcmi_syscallhooks_pidman.h - syscalls hooks for proces identification manipulation.
+ *                      
+ * 
+ *
+ *
+ * Date: 13/06/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: tcmi_syscallhooks_pidman.h,v 1.2 2007/09/02 12:09:55 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#ifndef _TCMI_SYSCALLHOOKS_PIDMAN_H
+#define _TCMI_SYSCALLHOOKS_PIDMAN_H
+
+/** @defgroup tcmi_syscallhooks_pidman_class PID & GID manipulation 
+ *
+ * @ingroup tcmi_syscallhooks_class
+ *
+ * A \<\<singleton\>\> class that installs PID manipulation syscalls 
+ * hooks into the kernel.
+ * 
+ * @{
+ */
+
+/** \<\<public\>\> Registers all PID manipolation hooks with the kernel. */
+int tcmi_syscall_hooks_pidman_init(void);
+
+/** \<\<public\>\> Unregisters all PID manipolation hooks. */
+void tcmi_syscall_hooks_pidman_exit(void);
+
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_SYSCALLHOOKS_PIDMAN_PRIVATE
+
+/** \<\<private\>\> Getppid system call hook */
+static long tcmi_syscall_hooks_sys_getppid(void);
+
+/** \<\<private\>\> Getpid system call hook */
+static long tcmi_syscall_hooks_sys_getpid(void);
+
+/** \<\<private\>\> Getpgid system call hook */
+static long tcmi_syscall_hooks_sys_getpgid(pid_t pid);
+
+/** \<\<private\>\> Setpgid system call hook */
+static long tcmi_syscall_hooks_sys_setpgid(pid_t pid, pid_t pgid);
+
+/** \<\<private\>\> Getsid system call hook */
+static long tcmi_syscall_hooks_sys_getsid(pid_t pid);
+
+/** \<\<private\>\> Setsid system call hook */
+static long tcmi_syscall_hooks_sys_setsid(void);
+
+/** \<\<private\>\> Getpgrp system call hook */
+static long tcmi_syscall_hooks_sys_getpgrp(void);
+
+#endif /* TCMI_SYSCALLHOOKS_PIDMAN_PRIVATE */
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_SYSCALLHOOKS_PIDMAN_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_rpc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_rpc.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,61 @@
+/**
+ * @file tcmi_rpc.c - .
+ *                      
+ * 
+ *
+ *
+ * Date: 7/05/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: tcmi_rpc.c,v 1.2 2007/09/02 12:09:55 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <dbg.h>
+#include <linux/errno.h>
+
+#define TCMI_RPC_PRIVATE
+#include "tcmi_rpc.h"
+
+/** \<\<public\>\> Universal procedure to do RPC
+ * @param *self - pointer to this tcmi_rpc class instance
+ * @param rpc_num - Identification number of called procedure
+ * @param parameters[] - Array of RPCs parameters
+ *
+ * @return RPC return code
+ * */
+long tcmi_rpc_do(struct tcmi_rpc *self, unsigned int rpc_num, long parameters[TCMI_RPC_MAXPARAMS])
+{
+	long ret = -EPERM;
+	if( rpc_num > TCMI_MAX_RPC_NUM ){
+		mdbg(ERR3, "%d isn't number of procedure", rpc_num);
+	}
+	else if( self->calltable[rpc_num] != NULL){
+		mdbg(INFO2, "Calling RPC#%d(%lx, %lx, %lx, %lx, %lx) at %p", rpc_num,
+				parameters[0], parameters[1], parameters[2],
+				parameters[3], parameters[4], self->calltable[rpc_num]);
+		ret = self->calltable[rpc_num](rpc_num, parameters);
+		mdbg(INFO2, "RPC#%d returned %ld(%lx)", rpc_num, ret, ret);
+	}
+	else{
+		mdbg(ERR2, "No handler for RPC#%d", rpc_num);
+	}
+	return ret;
+}
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_shadow_fork_rpc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_shadow_fork_rpc.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,87 @@
+/**
+ * @file tcmi_shadow_fork_rpc.c - shadow part of fork syscall rpc
+ */
+#include <linux/syscalls.h>
+#include <linux/uaccess.h>
+#include <linux/resource.h>
+
+#include <arch/types.h>
+#include <dbg.h>
+
+#include "tcmi_shadow_fork_rpc.h"
+#include "exported_symbols.h"
+#include <arch/current/regs.h>
+
+TCMI_SHADOW_RPC_GENERIC_CALL_DEF(do_fork)
+{
+	struct tcmi_msg **resp, *m;
+	long rtn;
+	mm_segment_t old_fs;
+	// We can use current regs... it really does not matter as the process should immediately go to migration mode and if it ever get's out, it will use registers from a checkpoint
+	struct pt_regs *regs = task_pt_regs(current);
+
+	// Platform independend params
+	uint64_t clone_flags, stack_start, stack_size;
+
+	// Platform independend return values
+	int32_t* parent_tid_ind, *child_tid_ind;
+	// Return values	
+	int parent_tid, child_tid;
+	
+	mdbg(INFO3, "Forwarded fork syscall being processed");
+
+	m = (struct tcmi_msg*) params[0];
+	resp = (struct tcmi_msg**) params[1];
+	// Extract params
+	clone_flags = *(uint64_t*)tcmi_rpc_procmsg_data_base( TCMI_RPC_PROCMSG(m), 0);
+	stack_start = *(uint64_t*)tcmi_rpc_procmsg_data_base( TCMI_RPC_PROCMSG(m), 1);
+	stack_size = *(uint64_t*)tcmi_rpc_procmsg_data_base( TCMI_RPC_PROCMSG(m), 2);
+
+	// We disable VFORK clonning on core node.. detached node is waiting
+	// TODO: This is not really good solution, because when detached node child migrates away, the waiting is broken.
+	// We should introduce some rpc message VFORK done, and the guest parent should be waiting for that (Even if the parent
+	// itself migrates away and becomes another guest, or ordinary task on CCN, it should first wait for this VFORK done event)
+	clone_flags &= ~CLONE_VFORK;
+
+	mdbg(INFO3, "Forwarded fork params: Clone flags: %lx Start stack: %lx, Stack size: %lu", (unsigned long)clone_flags, (unsigned long)stack_start, (unsigned long)stack_size);
+
+	// Perform the call
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+	// TODO: Check if passing parent & child is correct here
+	rtn = do_fork(clone_flags, stack_start, regs, stack_size, &parent_tid, &child_tid);
+	set_fs(old_fs);
+
+	mdbg(INFO3, "Forwarded fork syscall finished.");
+
+	// Convert results to platform independend values
+	parent_tid_ind = kmalloc(sizeof(*parent_tid_ind), GFP_KERNEL);
+	if ( !parent_tid_ind ) {
+		return -ENOMEM;
+	}
+
+	child_tid_ind = kmalloc(sizeof(*child_tid_ind), GFP_KERNEL);
+	if ( !child_tid_ind ) {
+		kfree(parent_tid_ind);
+		return -ENOMEM;
+	}
+
+	*parent_tid_ind = parent_tid;
+	*child_tid_ind = child_tid;	
+	
+	// Create response with the results
+	*resp = tcmi_rpcresp_procmsg_create(m, rtn, sizeof(*parent_tid_ind), parent_tid_ind,
+						    sizeof(*child_tid_ind), child_tid_ind,
+						(size_t)0 );
+
+	if( *resp == NULL ) {
+		kfree(parent_tid_ind);
+		kfree(child_tid_ind);
+		return -1;
+	}
+
+	tcmi_rpcresp_procmsg_free_on_put( TCMI_RPCRESP_PROCMSG(*resp), 0, TCMI_RPCRESP_PROCMSG_KFREE );
+	tcmi_rpcresp_procmsg_free_on_put( TCMI_RPCRESP_PROCMSG(*resp), 1, TCMI_RPCRESP_PROCMSG_KFREE );
+
+	return 0;
+}
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_syscallhooks_groupident.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_syscallhooks_groupident.c	2013-03-12 11:16:07.000000000 +0100
@@ -0,0 +1,172 @@
+/**
+ * @file tcmi_syscallhooks_groupident.c - syscalls hooks for proces identification manipulation.
+ *                      
+ * 
+ *
+ *
+ * Date: 13/06/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: tcmi_syscallhooks_groupident.c,v 1.2 2007/09/02 13:54:30 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include <asm/uaccess.h>
+#include <linux/capability.h>
+#include <linux/limits.h>
+#include <clondike/tcmi/tcmi_hooks.h>
+
+#include <dbg.h>
+#include <tcmi/syscall/tcmi_guest_rpc.h>
+
+#define TCMI_SYSCALLHOOKS_GROUPIDENT_PRIVATE
+#include "tcmi_syscallhooks_groupident.h"
+
+/** 
+ * \<\<public\>\> Registers all user identification syscalls hooks with the kernel.
+ *
+ * @return 0 upon success
+ */
+int tcmi_syscall_hooks_groupident_init(void)
+{
+	minfo(INFO3, "Registering TCMI group identification syscalls hooks\n" 
+		     "For: getgid, setgid, getegid, setregid, setresgid, getgroups, setgroups");
+	tcmi_hooks_register_sys_getegid(   tcmi_syscall_hooks_sys_getegid   );
+	tcmi_hooks_register_sys_getgid(    tcmi_syscall_hooks_sys_getgid    );
+	tcmi_hooks_register_sys_setgid(    tcmi_syscall_hooks_sys_setgid    );
+	tcmi_hooks_register_sys_setregid(  tcmi_syscall_hooks_sys_setregid  );
+	tcmi_hooks_register_sys_setresgid( tcmi_syscall_hooks_sys_setresgid );
+	tcmi_hooks_register_sys_getresgid( tcmi_syscall_hooks_sys_getresgid );
+	tcmi_hooks_register_sys_getgroups( tcmi_syscall_hooks_sys_getgroups );
+	tcmi_hooks_register_sys_setgroups( tcmi_syscall_hooks_sys_setgroups );
+	return 0;
+}
+
+/** 
+ * \<\<public\>\> Unregisters all user identifikation syscalls hooks.
+ */
+void tcmi_syscall_hooks_groupident_exit(void)
+{
+	minfo(INFO3, "Unregistering TCMI group identification syscalls hooks");
+	tcmi_hooks_unregister_sys_getegid();
+	tcmi_hooks_unregister_sys_getgid();
+	tcmi_hooks_unregister_sys_setgid();
+	tcmi_hooks_unregister_sys_setregid();
+	tcmi_hooks_unregister_sys_setresgid();
+	tcmi_hooks_unregister_sys_getresgid();
+	tcmi_hooks_unregister_sys_getgroups();
+	tcmi_hooks_unregister_sys_setgroups();
+}
+
+/**
+ * \<\<private\>\> Getgid system call hook
+ *
+ * @return - the session ID of the calling process
+ */
+static long tcmi_syscall_hooks_sys_getgid(void)
+{
+	return tcmi_rpc_call0(tcmi_guest_rpc, TCMI_RPC_SYS_GETGID);
+}
+
+/**
+ * \<\<private\>\> Getegid system call hook
+ *
+ * @return effective group id
+ */
+static long tcmi_syscall_hooks_sys_getegid(void)
+{
+	return tcmi_rpc_call0(tcmi_guest_rpc, TCMI_RPC_SYS_GETEGID);
+}
+
+
+/**
+ * \<\<private\>\> Setgid system call hook
+ *
+ * @return  zero on success
+ */
+static long tcmi_syscall_hooks_sys_setgid(gid_t gid)
+{
+	return tcmi_rpc_call1(tcmi_guest_rpc, TCMI_RPC_SYS_SETGID, gid);
+}
+
+/**
+ * \<\<private\>\> Setregid system call hook
+ *
+ * @return  zero on success
+ */
+static long tcmi_syscall_hooks_sys_setregid(gid_t rgid, gid_t egid)
+{
+	return tcmi_rpc_call2(tcmi_guest_rpc, TCMI_RPC_SYS_SETREGID, rgid, egid);
+}
+
+/**
+ * \<\<private\>\> Getresgid system call hook
+ *
+ * @return  zero on success
+ */
+static long tcmi_syscall_hooks_sys_getresgid(gid_t *rgid, gid_t *egid, gid_t *sgid)
+{
+	return tcmi_rpc_call3(tcmi_guest_rpc, TCMI_RPC_SYS_GETRESGID, (unsigned long)rgid, (unsigned long)egid, (unsigned long)sgid);
+}
+
+/**
+ * \<\<private\>\> Setresgid system call hook
+ *
+ * @return  zero on success
+ */
+static long tcmi_syscall_hooks_sys_setresgid(gid_t rgid, gid_t egid, gid_t sgid)
+{
+	return tcmi_rpc_call3(tcmi_guest_rpc, TCMI_RPC_SYS_SETRESGID, rgid, egid, sgid);
+}
+
+/**
+ * \<\<private\>\> Getgroups system call hook
+ *
+ * @return the session ID of the calling process
+ */
+static long tcmi_syscall_hooks_sys_getgroups(int size, gid_t *groups)
+{
+	if( size == 0 )
+		return tcmi_rpc_call2(tcmi_guest_rpc, TCMI_RPC_SYS_GETGROUPS, 0, (unsigned long)NULL);
+	else{
+		if( !access_ok( VERIFY_WRITE, groups, size * sizeof(gid_t) ) )
+			return -EFAULT;
+		return tcmi_rpc_call2(tcmi_guest_rpc, TCMI_RPC_SYS_GETGROUPS, size, (unsigned long)groups);
+	}
+}
+
+/**
+ * \<\<private\>\> Setgroups system call hook
+ *
+ * @return the session ID of the calling process
+ */
+static long tcmi_syscall_hooks_sys_setgroups(int size, gid_t *groups)
+{
+	if( size > NGROUPS_MAX )
+		return -EINVAL;
+	else{
+		if( !access_ok(VERIFY_READ, groups, size * sizeof(gid_t)) )
+			return -EFAULT;
+		return tcmi_rpc_call2(tcmi_guest_rpc, TCMI_RPC_SYS_SETGROUPS, 
+				size, (unsigned long)groups );
+	}
+}
+
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_syscallhooks_signal.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_syscallhooks_signal.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,113 @@
+/**
+ * @file tcmi_syscallhooks_signal.c - other syscalls hooks.
+ *                      
+ * 
+ *
+ *
+ * Date: 13/06/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: tcmi_syscallhooks_signal.c,v 1.2 2007/09/02 13:54:30 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <linux/capability.h>
+#include <clondike/tcmi/tcmi_hooks.h>
+
+#include <dbg.h>
+#include <tcmi/syscall/tcmi_guest_rpc.h>
+
+#define TCMI_SYSCALLHOOKS_SIGNAL_PRIVATE
+#include <asm-generic/siginfo.h>
+#include "tcmi_syscallhooks_signal.h"
+
+/** 
+ * \<\<public\>\> Registers all syscalls hooks with the kernel.
+ *
+ * @return 0 upon success
+ */
+int tcmi_syscall_hooks_signal_init(void)
+{
+	minfo(INFO3, "Registering TCMI signal syscalls hooks\n"
+		     "For: kill, tkill, tgkill, sigqueue");
+	tcmi_hooks_register_sys_kill(tcmi_syscall_hooks_sys_kill);
+	tcmi_hooks_register_do_tkill(tcmi_syscall_hooks_do_tkill);
+	tcmi_hooks_register_sys_rt_sigqueueinfo( tcmi_syscall_hooks_sys_rt_sigqueueinfo );
+	return 0;
+}
+
+/** 
+ * \<\<public\>\> Unregisters all syscalls hooks.
+ */
+void tcmi_syscall_hooks_signal_exit(void)
+{
+	minfo(INFO3, "Unregistering TCMI signal syscalls hooks");
+	tcmi_hooks_unregister_sys_kill();
+	tcmi_hooks_unregister_do_tkill();
+	tcmi_hooks_unregister_sys_rt_sigqueueinfo();
+}
+
+/** @addtogroup tcmi_syscallhooks_class
+ *
+ * @{
+ */
+
+/**
+ * \<\<private\>\> Kill system call hook.  
+ *
+ * @param pid - PID of signal target
+ * @param sig - what signal
+ *
+ * @return - zero on sucess.
+ */
+static long tcmi_syscall_hooks_sys_kill(int pid, int sig)
+{
+	return tcmi_rpc_call2(tcmi_guest_rpc, TCMI_RPC_SYS_KILL, pid, sig);
+}
+
+/**
+ * \<\<private\>\> do_tkill hook. 
+ * Handles both tkill and tgkill system call
+ *
+ * @param tgid - the thread group ID of the thread
+ * @param pid - the PID of the thread
+ * @param sig - signal to be sent
+ *
+ * @return - zero on sucess.
+ */
+static long tcmi_syscall_hooks_do_tkill(int tgid, int pid, int sig)
+{
+	return tcmi_rpc_call3(tcmi_guest_rpc, TCMI_RPC_SYS_TKILL, tgid, pid, sig);
+}
+
+
+/**
+ * \<\<private\>\> sys_rt_sigqueueinfo hook. 
+ * @param pid - the PID of the thread
+ * @param sig - signal to be sent
+ * @param *info - pointer siginfo struct in kernel space
+ *
+ * @return - zero on sucess.
+ */
+static long tcmi_syscall_hooks_sys_rt_sigqueueinfo(int pid, int sig, siginfo_t *info)
+{
+	return tcmi_rpc_call3(tcmi_guest_rpc, TCMI_RPC_SYS_SIGQUEUE, pid, sig, (unsigned long)info);
+}
+
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_shadow_signal_rpc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_shadow_signal_rpc.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,66 @@
+/**
+ * @file tcmi_shadow_signal_rpc.c - shadow part of rpc
+ *
+ * Date: 7/06/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: tcmi_shadow_signal_rpc.c,v 1.3 2007/10/11 21:00:26 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include <linux/syscalls.h>
+#include <linux/uaccess.h>
+
+static int errno;
+#include <arch/current/make_syscall.h>
+
+#include "tcmi_shadow_signal_rpc.h"
+#include "exported_symbols.h"
+
+static inline _syscall3(long, rt_sigqueueinfo, int, pid, int, sig, siginfo_t*, info);
+
+TCMI_SHADOW_RPC_GENERIC_CALL(2, sys_kill, true);
+TCMI_SHADOW_RPC_GENERIC_CALL(3, do_tkill, true);
+
+TCMI_SHADOW_RPC_GENERIC_CALL_DEF(rt_sigqueueinfo)
+{
+	struct tcmi_msg **resp, *m;
+	long* rpc_params, rtn;
+	void *ker_buf;
+	mm_segment_t old_fs;
+
+	m = (struct tcmi_msg*) params[0];
+	resp = (struct tcmi_msg**) params[1];
+	
+	rpc_params = (long*)tcmi_rpc_procmsg_data_base( TCMI_RPC_PROCMSG(m), 0);
+	ker_buf = (long*)tcmi_rpc_procmsg_data_base( TCMI_RPC_PROCMSG(m), 1);
+
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+	rtn = rt_sigqueueinfo(rpc_params[0], rpc_params[1], ker_buf);
+	set_fs(old_fs);
+	if( rtn == -1)
+		rtn = errno;
+	*resp = tcmi_rpcresp_procmsg_create(m, rtn, (size_t)0 );
+	if( *resp == NULL ) 
+		return -1;
+	return 0;
+
+}
+
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_shadow_groupident_rpc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_shadow_groupident_rpc.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,71 @@
+/**
+ * @file tcmi_shadow_rpc_groupident.h - a RPC class used by shadow process .
+ *
+ * Date: 7/06/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: tcmi_shadow_groupident_rpc.h,v 1.1 2007/09/02 12:09:55 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef _TCMI_SHADOW_RPC_GROUPIDENT_H
+#define _TCMI_SHADOW_RPC_GROUPIDENT_H
+
+#include "tcmi_shadow_rpc.h"
+
+/** @defgroup tcmi_shadow_rpc_groupident_class Group identification 
+ *  @ingroup tcmi_shadow_rpc_class
+ *
+ * A part of tcmi_shadow_rpc with RPCs for group identification
+ * 
+ * @{
+ */
+
+
+/** Getegid() system call */
+TCMI_SHADOW_RPC_GENERIC_CALL_DEF(getegid);
+
+/** Getgid() system call */
+TCMI_SHADOW_RPC_GENERIC_CALL_DEF(getgid);
+
+/** Getgroups() system call */
+TCMI_SHADOW_RPC_GENERIC_CALL_DEF(getgroups);
+
+/** Getresgid() system call */
+TCMI_SHADOW_RPC_GENERIC_CALL_DEF(getresgid);
+
+/** Setgid() system call */
+TCMI_SHADOW_RPC_GENERIC_CALL_DEF(setgid);
+
+/** Setgroups() system call */
+TCMI_SHADOW_RPC_GENERIC_CALL_DEF(setgroups);
+
+/** Setregid() system call */
+TCMI_SHADOW_RPC_GENERIC_CALL_DEF(setregid);
+
+/** Setresgid() system call */
+TCMI_SHADOW_RPC_GENERIC_CALL_DEF(setresgid);
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_SHADOW_RPC_GROUPIDENT_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_shadow_rpc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_shadow_rpc.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,41 @@
+/**
+ * @file tcmi_shadow_rpc.c - CCN part of RPCs
+ *
+ *
+ * Date: 7/05/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: tcmi_shadow_rpc.c,v 1.1 2007/09/02 12:09:55 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#define TCMI_SHADOW_RPC_PRIVATE
+#define TCMI_RPC_PRIVATE
+#include "tcmi_shadow_rpc.h"
+
+struct tcmi_rpc tcmi_shadow_rpc_struct = {
+	.calltable = tcmi_calltable_shadow,
+};
+
+struct tcmi_rpc *tcmi_shadow_rpc = &tcmi_shadow_rpc_struct;
+
+/**
+ * @}
+ */
+
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_shadow_rpc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_shadow_rpc.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,152 @@
+/**
+ * @file tcmi_shadow_rpc.h - a RPC class used by shadow process .
+ *
+ * Date: 7/05/2007
+ *
+ * Author: Petr Malat
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef _TCMI_SHADOW_RPC_H
+#define _TCMI_SHADOW_RPC_H
+
+#include "tcmi_rpc.h"
+#include <tcmi/task/tcmi_task.h>
+#include <tcmi/comm/tcmi_rpc_procmsg.h>
+#include <tcmi/comm/tcmi_rpcresp_procmsg.h>
+
+/** @defgroup tcmi_shadow_rpc_class tcmi_shadow_rpc class 
+ *
+ * @ingroup tcmi_rpc_class
+ *
+ * A \<\<singleton\>\> class that is executing RPC on CCN side.
+ * 
+ * @{
+ */
+
+/** Creates default RPC call for system call
+ *
+ * @param num       - number of parameters
+ * @param name      - name of system call
+ * @param use_errno - if true return errno when syscall returns -1
+ *
+ * @return system call return value
+ */
+#define TCMI_SHADOW_RPC_GENERIC_CALL(num, name, use_errno)\
+long tcmi_shadow_rpc_##name(unsigned rpc_num, long params[TCMI_RPC_MAXPARAMS]){\
+	struct tcmi_msg *m = (struct tcmi_msg*) params[0], **resp = (struct tcmi_msg**) params[1];\
+	long rtn; _TCMI_SHADOW_RPC_GENERIC_CALL##num(name); \
+	if( use_errno && rtn == -1) rtn = errno;\
+	*resp = tcmi_rpcresp_procmsg_create(m, rtn, (size_t)0 );\
+	if( *resp == NULL ) return -1;return 0;\
+}
+
+
+/** Used int #TCMI_SHADOW_RPC_GENERIC_CALL for defining rpc_params, if call works with them */
+#define _TCMI_SHADOW_RPC_GENERIC_CALL_PARAMS long* rpc_params = (long*)tcmi_rpc_procmsg_data_base( TCMI_RPC_PROCMSG(m), 0);
+
+/** Helper macro for #TCMI_SHADOW_RPC_GENERIC_CALL */
+#define _TCMI_SHADOW_RPC_GENERIC_CALL0(name) rtn = name();
+
+/** Helper macro for #TCMI_SHADOW_RPC_GENERIC_CALL */
+#define _TCMI_SHADOW_RPC_GENERIC_CALL1(name) _TCMI_SHADOW_RPC_GENERIC_CALL_PARAMS	\
+	rtn = name(rpc_params[0]);
+
+/** Helper macro for #TCMI_SHADOW_RPC_GENERIC_CALL */
+#define _TCMI_SHADOW_RPC_GENERIC_CALL2(name) _TCMI_SHADOW_RPC_GENERIC_CALL_PARAMS	\
+	rtn = name(rpc_params[0],rpc_params[1]);
+
+/** Helper macro for #TCMI_SHADOW_RPC_GENERIC_CALL */
+#define _TCMI_SHADOW_RPC_GENERIC_CALL3(name) _TCMI_SHADOW_RPC_GENERIC_CALL_PARAMS	\
+	rtn = name(rpc_params[0],rpc_params[1],rpc_params[2]);
+
+/** Helper macro for #TCMI_SHADOW_RPC_GENERIC_CALL */
+#define _TCMI_SHADOW_RPC_GENERIC_CALL4(name) _TCMI_SHADOW_RPC_GENERIC_CALL_PARAMS	\
+	rtn = name(rpc_params[0],rpc_params[1],rpc_params[2],rpc_params[3]);
+
+/** Helper macro for #TCMI_SHADOW_RPC_GENERIC_CALL */
+#define _TCMI_SHADOW_RPC_GENERIC_CALL5(name) _TCMI_SHADOW_RPC_GENERIC_CALL_PARAMS	\
+	rtn = name(rpc_params[0],rpc_params[1],rpc_params[2],rpc_params[3],rpc_params[4]);
+
+/** Helper macro for #TCMI_SHADOW_RPC_GENERIC_CALL */
+#define _TCMI_SHADOW_RPC_GENERIC_CALL6(name) _TCMI_SHADOW_RPC_GENERIC_CALL_PARAMS	\
+	rtn = name(rpc_params[0],rpc_params[1],rpc_params[2],rpc_params[3],rpc_params[4],rpc_params[5]);
+
+
+/** Creates default RPC call for system call declaration
+ *
+ * @param name - name of system call
+ */
+#define TCMI_SHADOW_RPC_GENERIC_CALL_DEF(name)\
+long tcmi_shadow_rpc_##name(unsigned rpc_num, long params[TCMI_RPC_MAXPARAMS])
+
+/** tcmi_shadow_rpc class declaration */
+extern struct tcmi_rpc *tcmi_shadow_rpc;
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_SHADOW_RPC_PRIVATE
+#include "tcmi_shadow_signal_rpc.h"
+#include "tcmi_shadow_wait_rpc.h"
+#include "tcmi_shadow_fork_rpc.h"
+#include "tcmi_shadow_pidman_rpc.h"
+#include "tcmi_shadow_userident_rpc.h"
+#include "tcmi_shadow_groupident_rpc.h"
+
+/** Table with RPC handlers */
+long (*tcmi_calltable_shadow[TCMI_MAX_RPC_NUM + 1])(unsigned,long[TCMI_MAX_RPC_NUM]) = {
+	/* Signal ********************************************/
+	[TCMI_RPC_SYS_KILL] 	= &tcmi_shadow_rpc_sys_kill,
+	[TCMI_RPC_SYS_TKILL] 	= &tcmi_shadow_rpc_do_tkill,
+	[TCMI_RPC_SYS_SIGQUEUE]	= &tcmi_shadow_rpc_rt_sigqueueinfo,
+
+	/* Pid, gid and session manipulation *****************/
+	[TCMI_RPC_SYS_GETPGID]	= &tcmi_shadow_rpc_sys_getpgid,
+	[TCMI_RPC_SYS_GETPGRP]	= &tcmi_shadow_rpc_sys_getpgrp,
+	[TCMI_RPC_SYS_GETPPID]	= &tcmi_shadow_rpc_sys_getppid,
+	[TCMI_RPC_SYS_GETSID]	= &tcmi_shadow_rpc_sys_getsid,
+	[TCMI_RPC_SYS_SETPGID]	= &tcmi_shadow_rpc_sys_setpgid,
+	[TCMI_RPC_SYS_SETSID]	= &tcmi_shadow_rpc_sys_setsid,
+
+	/* User identification *******************************/
+	[TCMI_RPC_SYS_GETUID]	= &tcmi_shadow_rpc_getuid,
+	[TCMI_RPC_SYS_GETEUID]	= &tcmi_shadow_rpc_geteuid,
+	[TCMI_RPC_SYS_GETRESUID]= &tcmi_shadow_rpc_getresuid,
+	[TCMI_RPC_SYS_SETUID]	= &tcmi_shadow_rpc_setuid,
+	[TCMI_RPC_SYS_SETREUID]	= &tcmi_shadow_rpc_setreuid,
+	[TCMI_RPC_SYS_SETRESUID]= &tcmi_shadow_rpc_setresuid,
+
+	/* Group identification ******************************/
+	[TCMI_RPC_SYS_GETGID]	= &tcmi_shadow_rpc_getgid,
+	[TCMI_RPC_SYS_GETEGID]	= &tcmi_shadow_rpc_getegid,
+	[TCMI_RPC_SYS_GETGROUPS]= &tcmi_shadow_rpc_getgroups,
+	[TCMI_RPC_SYS_GETRESGID]= &tcmi_shadow_rpc_getresgid,
+	[TCMI_RPC_SYS_SETGID]	= &tcmi_shadow_rpc_setgid,
+	[TCMI_RPC_SYS_SETGROUPS]= &tcmi_shadow_rpc_setgroups,
+	[TCMI_RPC_SYS_SETREGID]	= &tcmi_shadow_rpc_setregid,
+	[TCMI_RPC_SYS_SETRESGID]= &tcmi_shadow_rpc_setresgid,
+	
+	[TCMI_RPC_SYS_WAIT4]= &tcmi_shadow_rpc_sys_wait4,
+	[TCMI_RPC_SYS_FORK]= &tcmi_shadow_rpc_do_fork,
+};
+#endif /* TCMI_SHADOW_RPC_PRIVATE */
+/**
+ * @}
+ */
+
+#endif /* _TCMI_SHADOW_RPC_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_shadow_pidman_rpc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_shadow_pidman_rpc.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,40 @@
+/**
+ * @file tcmi_shadow_rpc_pidman.c - CCN part of RPCs
+ *
+ * Date: 7/06/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: tcmi_shadow_pidman_rpc.c,v 1.3 2007/10/20 14:24:20 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include "tcmi_shadow_pidman_rpc.h"
+
+#include <linux/syscalls.h>
+
+static int errno; // todo: remove this syscalls CANNOT be called from kernel on x86_64 anyway so we have to export them all...
+
+TCMI_SHADOW_RPC_GENERIC_CALL(0, sys_getpgrp, false);
+TCMI_SHADOW_RPC_GENERIC_CALL(0, sys_getppid, false);
+TCMI_SHADOW_RPC_GENERIC_CALL(0, sys_setsid,  false);
+TCMI_SHADOW_RPC_GENERIC_CALL(1, sys_getpgid, false);
+TCMI_SHADOW_RPC_GENERIC_CALL(1, sys_getsid,  false);
+TCMI_SHADOW_RPC_GENERIC_CALL(2, sys_setpgid, false);
+
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_guest_wait_rpc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_guest_wait_rpc.c	2013-03-12 11:25:59.000000000 +0100
@@ -0,0 +1,68 @@
+/**
+ * @file tcmi_guest_wait_rpc.c - guest side part of wait syscall
+ */
+
+#include <dbg.h>
+#include <tcmi/comm/tcmi_rpcresp_procmsg.h>
+#include <linux/uaccess.h>
+
+#include <arch/types.h>
+#include "tcmi_guest_wait_rpc.h"
+
+/** sys_wait4 system call RPC 
+ * @param rpc_num - RPC number
+ * @param params  - pointer to array with RPC parameters - pid, stat_addr, options, rusage
+ *
+ * @return RPC return value
+ * */
+TCMI_GUEST_RPC_CALL_DEF(wait4)
+{
+	struct tcmi_msg *r; long rtn;
+	// platform independend params
+	int32_t pid_ind, options_ind;
+	// Real results
+	struct rusage result_usage;
+	int result_stats;
+	// Platform independend results
+	struct rusage_ind* result_usage_ind;
+	int32_t result_stats_ind;
+  
+  unsigned long err = 0;        //Added for warning ignore return value __copy_to_user | by Jiri Rakosnik
+
+	pid_ind = params[0];
+	options_ind = params[2];
+
+	mdbg(INFO3, "Forwarding wait syscall. Wait pid: %d", pid_ind);
+
+	r = tcmi_rpcresp_procmsg_get_response(rpc_num, 
+			sizeof(int32_t), &pid_ind, // pid
+			sizeof(int32_t), &options_ind, // options
+			(size_t)0); 
+
+	if(r == NULL){
+		minfo(ERR3, "Response message hasn't arrived");
+		return -EAGAIN;
+	}
+	
+	// Extracts results in platform independed form
+	result_usage_ind = (struct rusage_ind*)tcmi_rpcresp_procmsg_data_base( TCMI_RPCRESP_PROCMSG(r), 0);
+	result_stats_ind = *(int32_t*)tcmi_rpcresp_procmsg_data_base( TCMI_RPCRESP_PROCMSG(r), 1);	
+
+	// Converts them to current platform
+	rusage_from_ind(result_usage_ind, &result_usage);
+	result_stats = result_stats_ind;
+
+	// Copies them to a user space provided buffer
+	if ( (int __user*)params[1] != NULL )
+		put_user(result_stats, (int __user*)params[1]);
+
+	if ( (void*)params[3] != NULL ) {
+	 err =	copy_to_user((struct rusage __user*)params[3], &result_usage, sizeof(result_usage));
+	}	
+
+	rtn = tcmi_rpcresp_procmsg_rtn( TCMI_RPCRESP_PROCMSG(r) );
+	tcmi_msg_put(r);
+
+	mdbg(INFO3, "Wait syscall returned: %ld. Status: %d (Independend: %d)", rtn, result_stats, result_stats_ind);
+	return rtn;
+}
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_shadow_pidman_rpc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_shadow_pidman_rpc.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,64 @@
+/**
+ * @file tcmi_shadow_rpc_pidman.h - a RPC class used by shadow process .
+ *
+ * Date: 7/06/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: tcmi_shadow_pidman_rpc.h,v 1.2 2007/10/20 14:24:20 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef _TCMI_SHADOW_RPC_PIDMAN_H
+#define _TCMI_SHADOW_RPC_PIDMAN_H
+
+#include "tcmi_shadow_rpc.h"
+
+/** @defgroup tcmi_shadow_rpc_pidman_class PID & GID manipulation 
+ *  @ingroup tcmi_shadow_rpc_class
+ *
+ * A part of tcmi_shadow_rpc with RPCs for PID and GID manipulation 
+ * 
+ * @{
+ */
+
+/** Declaration of tcmi_shadow_rpc_sys_getppid() */
+TCMI_SHADOW_RPC_GENERIC_CALL_DEF(sys_getppid);
+
+/** Declaration of tcmi_shadow_rpc_sys_setsid() */
+TCMI_SHADOW_RPC_GENERIC_CALL_DEF(sys_setsid);
+
+/** Declaration of tcmi_shadow_rpc_sys_getsid() */
+TCMI_SHADOW_RPC_GENERIC_CALL_DEF(sys_getsid);
+
+/** Declaration of tcmi_shadow_rpc_sys_setpgid() */
+TCMI_SHADOW_RPC_GENERIC_CALL_DEF(sys_setpgid);
+
+/** Declaration of tcmi_shadow_rpc_sys_getpgid() */
+TCMI_SHADOW_RPC_GENERIC_CALL_DEF(sys_getpgid);
+
+/** Declaration of tcmi_shadow_rpc_sys_getpgrp() */
+TCMI_SHADOW_RPC_GENERIC_CALL_DEF(sys_getpgrp);
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_SHADOW_RPC_PIDMAN_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/syscall/exported_symbols.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/exported_symbols.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,7 @@
+#ifndef _EXPORTED_SYMBOLS_H
+#define _EXPORTED_SYMBOLS_H
+
+int do_tkill(int tgid, int pid, int sig);
+asmlinkage long sys_wait4(pid_t pid, int __user *stat_addr, int options, struct rusage __user *ru);
+
+#endif // _EXPORTED_SYMBOLS_H
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_guest_userident_rpc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_guest_userident_rpc.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,60 @@
+/**
+ * @file tcmi_guest_rpc_useridnt.c - shadow part of proxyfs rpc
+ *
+ * Date: 7/06/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: tcmi_guest_userident_rpc.c,v 1.1 2007/09/02 12:09:55 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <dbg.h>
+#include <tcmi/comm/tcmi_rpcresp_procmsg.h>
+#include <linux/uaccess.h>
+
+#include "tcmi_guest_userident_rpc.h"
+
+/** Getresud system call RPC 
+ * @param rpc_num - RPC number
+ * @param params  - pointer to array with RPC parameters - three pointers to uid_t
+ *
+ * @return RPC return value
+ * */
+TCMI_GUEST_RPC_CALL_DEF(getresuid)
+{
+	struct tcmi_msg *r; long rtn, *resp_data;
+	r = tcmi_rpcresp_procmsg_get_response(
+			rpc_num, 0);
+
+	if(r == NULL){
+		mdbg(ERR3, "Response message hasn't arrived");
+		return -EAGAIN;
+	}
+
+	rtn = tcmi_rpcresp_procmsg_rtn( TCMI_RPCRESP_PROCMSG(r) );
+	if( rtn == 0 ){
+		resp_data = tcmi_rpcresp_procmsg_data_base( TCMI_RPCRESP_PROCMSG(r), 0 );
+		put_user( (uid_t)resp_data[0], (uid_t*)params[0] );
+		put_user( (uid_t)resp_data[1], (uid_t*)params[1] );
+		put_user( (uid_t)resp_data[2], (uid_t*)params[2] );
+	}
+	tcmi_msg_put(r);
+	return rtn;
+}
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_syscallhooks_pidman.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_syscallhooks_pidman.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,153 @@
+/**
+ * @file tcmi_syscallhooks_pidman.c - syscalls hooks for proces identification manipulation.
+ *                      
+ * 
+ *
+ *
+ * Date: 13/06/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: tcmi_syscallhooks_pidman.c,v 1.7 2007/10/20 14:24:20 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include <clondike/tcmi/tcmi_hooks.h>
+
+#include <dbg.h>
+#include <tcmi/syscall/tcmi_guest_rpc.h>
+#include <tcmi/task/tcmi_task.h>
+#include <arch/current/make_syscall.h>
+
+#define TCMI_SYSCALLHOOKS_PIDMAN_PRIVATE
+#include "tcmi_syscallhooks_pidman.h"
+
+/** 
+ * \<\<public\>\> Registers all PID manipulaton syscalls hooks with the kernel.
+ *
+ * @return 0 upon success
+ */
+int tcmi_syscall_hooks_pidman_init(void)
+{
+	minfo(INFO3, "Registering TCMI PID manipulation syscalls hooks\n"
+		     "For: getpid, getppid, getpgit, setpgit, getsid, setsid, getpgrp");
+	tcmi_hooks_register_sys_getppid( tcmi_syscall_hooks_sys_getppid );
+	tcmi_hooks_register_sys_getpid ( tcmi_syscall_hooks_sys_getpid  );
+	tcmi_hooks_register_sys_getpgid( tcmi_syscall_hooks_sys_getpgid );
+	tcmi_hooks_register_sys_setpgid( tcmi_syscall_hooks_sys_setpgid );
+	tcmi_hooks_register_sys_getsid ( tcmi_syscall_hooks_sys_getsid  );
+	tcmi_hooks_register_sys_setsid ( tcmi_syscall_hooks_sys_setsid  );
+	tcmi_hooks_register_sys_getpgrp( tcmi_syscall_hooks_sys_getpgrp );
+	return 0;
+}
+
+/** 
+ * \<\<public\>\> Unregisters all PID manipulation syscalls hooks.
+ */
+void tcmi_syscall_hooks_pidman_exit(void)
+{
+	minfo(INFO3, "Unregistering TCMI PID manipulation syscalls hooks\n");
+	tcmi_hooks_unregister_sys_getppid();
+	tcmi_hooks_unregister_sys_getpid();
+	tcmi_hooks_unregister_sys_getpgid();
+	tcmi_hooks_unregister_sys_setpgid();
+	tcmi_hooks_unregister_sys_getsid();
+	tcmi_hooks_unregister_sys_setsid();
+	tcmi_hooks_unregister_sys_getpgrp();
+}
+
+
+/**
+ * \<\<private\>\> Getppid system call hook
+ *
+ * @return pid of parent process.
+ */
+static long tcmi_syscall_hooks_sys_getppid(void)
+{	
+	return tcmi_rpc_call0(tcmi_guest_rpc, TCMI_RPC_SYS_GETPPID);
+}
+
+/**
+ * \<\<private\>\> Getpid system call hook
+ *
+ * @return pid of current process.
+ */
+static long tcmi_syscall_hooks_sys_getpid(void)
+{
+	mdbg(INFO3, "Getpid hook called. Returning via fast-path pid %d. Physical pid: %d",tcmi_task_remote_pid(current->tcmi.tcmi_task), current->pid);
+	/* Won't work with threads */
+	return tcmi_task_remote_pid(current->tcmi.tcmi_task);
+}
+
+/**
+ * \<\<private\>\> Getpgid system call hook
+ *
+ * @param pid - PID  
+ * @return the process group ID of the process specified by pid.
+ */
+static long tcmi_syscall_hooks_sys_getpgid(pid_t pid)
+{
+	return tcmi_rpc_call1(tcmi_guest_rpc, TCMI_RPC_SYS_GETPGID, pid);
+}
+
+/**
+ * \<\<private\>\> Setpgid system call hook
+ * @param pid - PID of affected process 
+ * @param sig - target group ID
+ *
+ * @return zero on sucess
+ */
+static long tcmi_syscall_hooks_sys_setpgid(pid_t pid, pid_t pgid)
+{
+	return tcmi_rpc_call2(tcmi_guest_rpc, TCMI_RPC_SYS_SETPGID, pid, pgid);
+}
+
+/**
+ * \<\<private\>\> Getsid system call hook
+ * @param pid - 
+ *
+ * @return the session ID of the process with process ID pid
+ */
+static long tcmi_syscall_hooks_sys_getsid(pid_t pid)
+{
+	return tcmi_rpc_call1(tcmi_guest_rpc, TCMI_RPC_SYS_GETSID, pid);
+}
+
+/**
+ * \<\<private\>\> Setsid system call hook
+ *
+ * @return the session ID of the calling process
+ */
+static long tcmi_syscall_hooks_sys_setsid(void)
+{
+	return tcmi_rpc_call0(tcmi_guest_rpc, TCMI_RPC_SYS_SETSID);
+}
+
+/**
+ * \<\<private\>\> Getpgrp system call hook
+ *
+ * @return current process group
+ */
+static long tcmi_syscall_hooks_sys_getpgrp(void)
+{
+	return tcmi_rpc_call0(tcmi_guest_rpc, TCMI_RPC_SYS_GETPGRP);
+}
+
+
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_guest_signal_rpc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_guest_signal_rpc.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,57 @@
+/**
+ * @file tcmi_guest_signal_rpc.c - shadow part of proxyfs rpc
+ *
+ * Date: 7/06/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: tcmi_guest_signal_rpc.c,v 1.2 2007/10/11 21:00:26 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <dbg.h>
+#include <tcmi/comm/tcmi_rpcresp_procmsg.h>
+#include <linux/uaccess.h>
+
+#include "tcmi_guest_signal_rpc.h"
+
+/** Rt_sigqueueinfo system call RPC 
+ * @param rpc_num - RPC number
+ * @param params  - pointer to array with RPC parameters - PID, signal and pointer to siginfo structure
+ *
+ * @return RPC return value
+ * */
+TCMI_GUEST_RPC_CALL_DEF(rt_sigqueueinfo)
+{
+	struct tcmi_msg *r; long rtn;
+	r = tcmi_rpcresp_procmsg_get_response(rpc_num, 
+			2*sizeof(long), params,
+			sizeof(siginfo_t), (void*)params[2], 0); // TODO: It was meant like that, not like below, right? (m.s.)
+			//sizeof(siginfo_t), (void*)params[3], 0);
+
+	if(r == NULL){
+		mdbg(ERR3, "Response message hasn't arrived");
+		return -EAGAIN;
+	}
+
+	rtn = tcmi_rpcresp_procmsg_rtn( TCMI_RPCRESP_PROCMSG(r) );
+	tcmi_msg_put(r);
+	return rtn;
+}
+
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_rpc_numbers.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_rpc_numbers.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,46 @@
+#ifndef TCMI_RPC_NUMBERS_H
+#define TCMI_RPC_NUMBERS_H
+
+/* Signal ********************************************/
+#define TCMI_RPC_SYS_KILL 		1
+#define TCMI_RPC_SYS_SIGQUEUE		2
+#define TCMI_RPC_SYS_TKILL 		3
+
+/* Pid, gid and session manipulation *****************/
+#define TCMI_RPC_SYS_GETPGID 		4
+#define TCMI_RPC_SYS_GETPID 		5
+#define TCMI_RPC_SYS_GETPPID 		6
+#define TCMI_RPC_SYS_GETSID 		7
+#define TCMI_RPC_SYS_SETPGID 		8
+#define TCMI_RPC_SYS_SETSID 		9
+#define TCMI_RPC_SYS_GETPGRP		10
+
+/* User identification *******************************/
+#define TCMI_RPC_SYS_GETEUID 		11
+#define TCMI_RPC_SYS_GETRESUID		12
+#define TCMI_RPC_SYS_GETUID 		13
+#define TCMI_RPC_SYS_SETRESUID 		14
+#define TCMI_RPC_SYS_SETREUID 		15
+#define TCMI_RPC_SYS_SETUID 		16
+
+/* Group identification ******************************/
+#define TCMI_RPC_SYS_GETEGID 		17
+#define TCMI_RPC_SYS_GETGID 		18
+#define TCMI_RPC_SYS_GETGROUPS		19
+#define TCMI_RPC_SYS_GETRESGID		20
+#define TCMI_RPC_SYS_SETGID 		21	
+#define TCMI_RPC_SYS_SETGROUPS		23
+#define TCMI_RPC_SYS_SETREGID		24
+#define TCMI_RPC_SYS_SETRESGID		25 
+
+
+/* Wait ***************/
+#define TCMI_RPC_SYS_WAIT4		26
+
+/* Fork ***************/
+#define TCMI_RPC_SYS_FORK		27
+
+/** The highest number used in RPC identification */
+#define TCMI_MAX_RPC_NUM 30
+
+#endif
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_guest_generic_rpc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_guest_generic_rpc.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,83 @@
+/**
+ * @file tcmi_guest_generic_rpc.c - PEN part of RPCs
+ *
+ *
+ * Date: 7/05/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: tcmi_guest_generic_rpc.c,v 1.2 2007/10/20 14:24:20 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include <dbg.h>
+#include <tcmi/comm/tcmi_rpc_procmsg.h>
+#include <tcmi/comm/tcmi_rpcresp_procmsg.h>
+
+#include "tcmi_guest_rpc.h"
+
+#define TCMI_GUEST_RPC_SYS_N(arg) \
+long tcmi_guest_rpc_sys_##arg(unsigned rpc_num, long params[TCMI_RPC_MAXPARAMS]){\
+	struct tcmi_msg *r; long ret;\
+	if(arg>0) r = tcmi_rpcresp_procmsg_get_response(rpc_num, (size_t)((arg)*sizeof(long)), params, (size_t)0);\
+	else r = tcmi_rpcresp_procmsg_get_response(rpc_num, (size_t)0);\
+	if ( r == NULL ) {\
+		mdbg(ERR3, "Response message hasn't arrived");\
+		return -EAGAIN;\
+	}\
+	ret = tcmi_rpcresp_procmsg_rtn(TCMI_RPCRESP_PROCMSG(r));\
+	tcmi_msg_put(r);\
+	return ret;\
+}
+
+/** Generic guest RPC method for call with no parameters 
+ * @param rpc_num - RPC number
+ * @param params  - pointer to array with RPC parameters
+ *
+ * @return RPC return value
+ * */
+TCMI_GUEST_RPC_SYS_N(0)
+
+/** Generic guest RPC method for call with one parameters 
+ * @param rpc_num - RPC number
+ * @param params  - pointer to array with RPC parameters
+ *
+ * @return RPC return value
+ * */
+TCMI_GUEST_RPC_SYS_N(1)
+
+/** Generic guest RPC method for call with two parameters 
+ * @param rpc_num - RPC number
+ * @param params  - pointer to array with RPC parameters
+ *
+ * @return RPC return value
+ * */
+TCMI_GUEST_RPC_SYS_N(2)
+
+/** Generic guest RPC method for call with three parameters 
+ * @param rpc_num - RPC number
+ * @param params  - pointer to array with RPC parameters
+ *
+ * @return RPC return value
+ * */
+TCMI_GUEST_RPC_SYS_N(3)
+
+/**
+ * @}
+ */
+
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_rpc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_rpc.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,174 @@
+/**
+ * @file tcmi_rpc.h - .
+ *                      
+ * 
+ *
+ *
+ * Date: 7/05/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: tcmi_rpc.h,v 1.5 2007/10/20 14:24:20 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef _TCMI_RPC_H
+#define _TCMI_RPC_H
+
+#include "tcmi_rpc_numbers.h"
+/** @defgroup tcmi_rpc_class tcmi_rpc class 
+ *
+ * @ingroup tcmi_syscall_group
+ *
+ * A \<\<virtual\>\> RPC class, used as parent for both guest and shadow side.
+ *
+ * This class is used for calling methods on shadow on guest request. If guest task calls RPC,
+ * the remote side is executed by coresponding shadow task. Communication is done using 
+ * \link tcmi_rpc_procmsg tcmi_rpc_procmsg class \endlink for RPC request and 
+ * \link tcmi_rpcresp_procmsg tcmi_rpcresp_procmsg class \endlink for response.
+ * 
+ * @{
+ */
+
+/** Max remote procedure call parameters */
+#define TCMI_RPC_MAXPARAMS 6
+
+struct tcmi_rpc;
+
+/** \<\<public\>\> Universal procedure to do RPC */
+long tcmi_rpc_do(struct tcmi_rpc *self, unsigned int rpc_num, long parameters[TCMI_RPC_MAXPARAMS]);
+
+/** \<\<public\>\> Do a rpc without parameters. 
+ * @param *self - pointer to this tcmi_rpc class instance
+ * @param rpc_num - Identification number of called procedure
+ *
+ * @return RPC return code
+ * */
+static inline long tcmi_rpc_call0(struct tcmi_rpc *self, unsigned int rpc_num)
+{
+	long parameters[TCMI_RPC_MAXPARAMS] = {0, 0, 0, 0, 0, 0};
+	return tcmi_rpc_do(self, rpc_num, parameters); 
+}
+
+/** \<\<public\>\> Do a rpc with 1 parameter. 
+ * @param *self - pointer to this tcmi_rpc class instance
+ * @param rpc_num - Identification number of called procedure
+ * @param param1  - First parametr of called procedure
+ *
+ * @return RPC return code
+ * */
+static inline long tcmi_rpc_call1(struct tcmi_rpc *self, unsigned int rpc_num, long param1)
+{
+	long parameters[TCMI_RPC_MAXPARAMS] = {0, 0, 0, 0, 0, 0};
+	parameters[0] = param1;
+	return tcmi_rpc_do(self, rpc_num, parameters); 
+}
+
+/** \<\<public\>\> Do a rpc with 2 parameters. 
+ * @param *self - pointer to this tcmi_rpc class instance
+ * @param rpc_num - Identification number of called procedure
+ * @param param1  - First parametr of called procedure
+ * @param param2  - Second parametr of called procedure
+ *
+ * @return RPC return code
+ * */
+static inline long tcmi_rpc_call2(struct tcmi_rpc *self, unsigned int rpc_num, long param1, long param2)
+{
+	long parameters[TCMI_RPC_MAXPARAMS] = {0, 0, 0, 0, 0, 0};
+	parameters[0] = param1;
+	parameters[1] = param2;
+	return tcmi_rpc_do(self, rpc_num, parameters); 
+}
+
+/** \<\<public\>\> Do a rpc with 3 parameters. 
+ * @param *self - pointer to this tcmi_rpc class instance
+ * @param rpc_num - Identification number of called procedure
+ * @param param1  - First parametr of called procedure
+ * @param param2  - Second parametr of called procedure
+ * @param param3  - Third parametr of called procedure
+ *
+ * @return RPC return code
+ * */
+static inline long tcmi_rpc_call3(struct tcmi_rpc *self, unsigned int rpc_num, long param1, long param2, long param3)
+{
+	long parameters[TCMI_RPC_MAXPARAMS] = {0, 0, 0, 0, 0, 0};
+	parameters[0] = param1;
+	parameters[1] = param2;
+	parameters[2] = param3;
+	return tcmi_rpc_do(self, rpc_num, parameters); 
+}
+
+/** \<\<public\>\> Do a rpc with 4 parameters. 
+ * @param *self - pointer to this tcmi_rpc class instance
+ * @param rpc_num - Identification number of called procedure
+ * @param param1  - First parametr of called procedure
+ * @param param2  - Second parametr of called procedure
+ * @param param3  - Third parametr of called procedure
+ * @param param4  - 4th parametr of called procedure
+ *
+ * @return RPC return code
+ * */
+static inline long tcmi_rpc_call4(struct tcmi_rpc *self, unsigned int rpc_num, long param1, long param2, long param3, long param4)
+{
+	long parameters[TCMI_RPC_MAXPARAMS] = {0, 0, 0, 0, 0, 0};
+	parameters[0] = param1;
+	parameters[1] = param2;
+	parameters[2] = param3;
+	parameters[3] = param4;
+	return tcmi_rpc_do(self, rpc_num, parameters); 
+}
+
+/** \<\<public\>\> Do a rpc with 4 parameters. 
+ * @param *self - pointer to this tcmi_rpc class instance
+ * @param rpc_num - Identification number of called procedure
+ * @param param1  - First parametr of called procedure
+ * @param param2  - Second parametr of called procedure
+ * @param param3  - Third parametr of called procedure
+ * @param param4  - 4th parametr of called procedure
+ * .....
+ *
+ * @return RPC return code
+ * */
+static inline long tcmi_rpc_call6(struct tcmi_rpc *self, unsigned int rpc_num, long param1, long param2, long param3, long param4, long param5, long param6)
+{
+	long parameters[TCMI_RPC_MAXPARAMS] = {0, 0, 0, 0, 0, 0};
+	parameters[0] = param1;
+	parameters[1] = param2;
+	parameters[2] = param3;
+	parameters[3] = param4;
+	parameters[4] = param5;
+	parameters[5] = param6;
+	return tcmi_rpc_do(self, rpc_num, parameters); 
+}
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_RPC_PRIVATE
+/** \<\<private\>\> Definition of tcmi_rpc class */
+struct tcmi_rpc
+{
+	/** Call table */
+	long (**calltable)(unsigned, long[TCMI_RPC_MAXPARAMS]);
+};
+#endif /* TCMI_RPC_PRIVATE */
+/**
+ * @}
+ */
+
+#endif /* _TCMI_RPC_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_guest_fork_rpc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_guest_fork_rpc.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,39 @@
+/**
+ * @file tcmi_guest_wait_rpc.h - a RPC class used by guest process for processing fork syscall
+ *
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef _TCMI_GUEST_RPC_FORK_H
+#define _TCMI_GUEST_RPC_FORK_H
+
+#include "tcmi_guest_rpc.h"
+/** @defgroup tcmi_guest_rpc_fork_class Fork syscall
+ *
+ * @ingroup tcmi_guest_fork_class
+ *
+ * A \<\<singleton\>\> class that is executing RPC on PEN side.
+ * 
+ * @{
+ */
+
+TCMI_GUEST_RPC_CALL_DEF(fork);
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_GUEST_RPC_FORK_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_syscallhooks_other.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_syscallhooks_other.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,75 @@
+/**
+ * @file tcmi_syscallhooks_other.h - other syscall hooks.
+ *                      
+ * 
+ *
+ *
+ * Date: 13/06/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: tcmi_syscallhooks_other.h,v 1.4 2007/10/20 14:24:20 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef _TCMI_SYSCALLHOOKS_OTHER_H
+#define _TCMI_SYSCALLHOOKS_OTHER_H
+
+/** @defgroup tcmi_syscallhooks_other_class tcmi_syscallhooks_other class 
+ *
+ * @ingroup tcmi_syscallhooks_class
+ *
+ * A \<\<singleton\>\> class that installs syscalls hooks into the kernel.
+ * 
+ * @{
+ */
+
+/** \<\<public\>\> Registers all hooks with the kernel. */
+int tcmi_syscall_hooks_other_init(void);
+
+/** \<\<public\>\> Unregisters all hooks. */
+void tcmi_syscall_hooks_other_exit(void);
+
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_SYSCALLHOOKS_OTHER_PRIVATE
+/** sys_wait4 hook */
+static long tcmi_syscall_hooks_sys_wait4(pid_t pid, int __user *stat_addr, int options, struct rusage __user *ru);
+
+static long tcmi_syscall_hooks_pre_fork(unsigned long clone_flags, unsigned long stack_start, 
+					struct pt_regs *regs, unsigned long stack_size, 
+					int __user *parent_tidptr, int __user *child_tidptr
+);
+
+static long tcmi_syscall_hooks_in_fork(struct task_struct* child);
+
+static long tcmi_syscall_hooks_post_fork(struct task_struct* child, long res, pid_t remote_pid, 
+					int __user *parent_tidptr, int __user *child_tidptr
+);
+
+
+#endif /* TCMI_SYSCALLHOOKS_OTHER_PRIVATE */
+
+/**
+ * @}
+ */
+
+
+#endif /* _TCMI_SYSCALLHOOKS_OTHER_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_shadow_signal_rpc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_shadow_signal_rpc.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,56 @@
+/**
+ * @file tcmi_shadow_signal_rpc.h - a RPC class used by shadow process .
+ *
+ * Date: 7/06/2007
+ *
+ * Author: Petr Malat
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2007  Petr Malat
+ *
+ * $Id: tcmi_shadow_signal_rpc.h,v 1.1 2007/09/02 12:09:55 malatp1 Exp $
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef _TCMI_SHADOW_RPC_SIGNAL_H
+#define _TCMI_SHADOW_RPC_SIGNAL_H
+
+#include "tcmi_shadow_rpc.h"
+
+/** @defgroup tcmi_shadow_rpc_signal_class Signal sending 
+ *
+ * @ingroup tcmi_shadow_rpc_class
+ *
+ * A \<\<singleton\>\> class that is executing RPC on CCN side.
+ * 
+ * @{
+ */
+
+/** Declaration of tcmi_shadow_rpc_sys_kill() */
+TCMI_SHADOW_RPC_GENERIC_CALL_DEF(sys_kill);
+
+/** Declaration of tcmi_shadow_rpc_do_tkill() */
+TCMI_SHADOW_RPC_GENERIC_CALL_DEF(do_tkill);
+
+/** Declaration of tcmi_shadow_rpc_rt_sigqueueinfo() */
+TCMI_SHADOW_RPC_GENERIC_CALL_DEF(rt_sigqueueinfo);
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_SHADOW_RPC_SIGNAL_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_shadow_wait_rpc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_shadow_wait_rpc.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,27 @@
+/**
+ * @file tcmi_shadow_wait_rpc.h - a RPC class used by shadow process for wait syscall
+ */
+
+#ifndef _TCMI_SHADOW_RPC_WAIT_H
+#define _TCMI_SHADOW_RPC_WAIT_H
+
+#include "tcmi_shadow_rpc.h"
+
+/** @defgroup tcmi_shadow_rpc_wait_class Processing sys_wait4
+ *
+ * @ingroup tcmi_shadow_rpc_class
+ *
+ * A \<\<singleton\>\> class that is executing RPC on CCN side.
+ * 
+ * @{
+ */
+
+/** Declaration of tcmi_shadow_rpc_sys_wait4() */
+TCMI_SHADOW_RPC_GENERIC_CALL_DEF(sys_wait4);
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_SHADOW_RPC_WAIT_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_syscallhooks_signal.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_syscallhooks_signal.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,69 @@
+/**
+ * @file tcmi_syscallhooks_signal.h - other syscall hooks.
+ *                      
+ * 
+ *
+ *
+ * Date: 13/06/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: tcmi_syscallhooks_signal.h,v 1.1 2007/09/02 12:09:55 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef _TCMI_SYSCALLHOOKS_SIGNAL_H
+#define _TCMI_SYSCALLHOOKS_SIGNAL_H
+
+/** @defgroup tcmi_syscallhooks_signal_class Signal sending 
+ *
+ * @ingroup tcmi_syscallhooks_class
+ *
+ * A \<\<singleton\>\> class that installs syscalls hooks into the kernel.
+ * 
+ * @{
+ */
+
+/** \<\<public\>\> Registers all hooks with the kernel. */
+int tcmi_syscall_hooks_signal_init(void);
+
+/** \<\<public\>\> Unregisters all hooks. */
+void tcmi_syscall_hooks_signal_exit(void);
+
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_SYSCALLHOOKS_SIGNAL_PRIVATE
+/** kill() system call hook */
+static long tcmi_syscall_hooks_sys_kill(int pid, int sig);
+
+/** do_tkill() hook */
+static long tcmi_syscall_hooks_do_tkill(int tgid, int pid, int sig);
+
+/** sys_rt_sigqueueinfo() hook */
+static long tcmi_syscall_hooks_sys_rt_sigqueueinfo(int pid, int sig, siginfo_t *info);
+
+#endif /* TCMI_SYSCALLHOOKS_SIGNAL_PRIVATE */
+
+/**
+ * @}
+ */
+
+
+#endif /* _TCMI_SYSCALLHOOKS_SIGNAL_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_guest_userident_rpc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_guest_userident_rpc.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,51 @@
+/**
+ * @file tcmi_guest_rpc_userident.h - a RPC class used by guest process .
+ *
+ * Date: 7/05/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: tcmi_guest_userident_rpc.h,v 1.1 2007/09/02 12:09:55 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef _TCMI_GUEST_RPC_USERIDENT_H
+#define _TCMI_GUEST_RPC_USERIDENT_H
+
+#include "tcmi_guest_rpc.h"
+/** @defgroup tcmi_guest_rpc_userident_class User identification 
+ *
+ * @ingroup tcmi_guest_rpc_class
+ *
+ * A \<\<singleton\>\> class that is executing RPC on PEN side.
+ * 
+ * @{
+ */
+
+
+/** Getresud system call RPC */
+TCMI_GUEST_RPC_CALL_DEF(getresuid);
+
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_GUEST_RPC_PROXYFS_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_syscallhooks_groupident.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_syscallhooks_groupident.h	2013-03-12 11:16:45.000000000 +0100
@@ -0,0 +1,86 @@
+/**
+ * @file tcmi_syscallhooks_groupident.h - 
+ *                      
+ * 
+ *
+ *
+ * Date: 25/06/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: tcmi_syscallhooks_groupident.h,v 1.1 2007/09/02 12:09:55 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#ifndef _TCMI_SYSCALLHOOKS_GROUPIDENT_H
+#define _TCMI_SYSCALLHOOKS_GROUPIDENT_H
+
+/** @defgroup tcmi_syscallhooks_groupident_class Group identification 
+ *
+ * @ingroup tcmi_syscallhooks_class
+ *
+ * A part of tcmi_syscallhooks class that installs group identity manipulation syscalls 
+ * hooks into the kernel.
+ * 
+ * @{
+ */
+
+/** \<\<public\>\> Registers all PID manipolation hooks with the kernel. */
+int tcmi_syscall_hooks_groupident_init(void);
+
+/** \<\<public\>\> Unregisters all PID manipolation hooks. */
+void tcmi_syscall_hooks_groupident_exit(void);
+
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_SYSCALLHOOKS_GROUPIDENT_PRIVATE
+
+/** \<\<private\>\> Getgid system call hook */
+static long tcmi_syscall_hooks_sys_getgid(void);
+
+/** \<\<private\>\> Setgid system call hook */
+static long tcmi_syscall_hooks_sys_setgid(gid_t);
+
+/** \<\<private\>\> Setregid system call hook */
+static long tcmi_syscall_hooks_sys_setregid(gid_t, gid_t);
+
+/** \<\<private\>\> Setresgid system call hook */
+static long tcmi_syscall_hooks_sys_setresgid(gid_t, gid_t, gid_t);
+
+/** \<\<private\>\> Getegid system call hook */
+static long tcmi_syscall_hooks_sys_getegid(void);
+
+/** \<\<private\>\> Getgroups system call hook */
+static long tcmi_syscall_hooks_sys_getgroups(int size, gid_t *groups);
+
+/** \<\<private\>\> Setgroups system call hook */
+static long tcmi_syscall_hooks_sys_setgroups(int size, gid_t *groups);
+
+/** \<\<private\>\> Getresgid system call hook */
+static long tcmi_syscall_hooks_sys_getresgid(gid_t *, gid_t *, gid_t *);
+
+#endif /* TCMI_SYSCALLHOOKS_GROUPIDENT_PRIVATE */
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_SYSCALLHOOKS_GROUPIDENT_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_guest_rpc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_guest_rpc.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,104 @@
+/**
+ * @file tcmi_guest_rpc.h - a RPC class used by guest process .
+ *
+ * Date: 7/05/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: tcmi_guest_rpc.h,v 1.3 2007/10/20 14:24:20 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef _TCMI_GUEST_RPC_H
+#define _TCMI_GUEST_RPC_H
+
+#include "tcmi_rpc.h"
+/** @defgroup tcmi_guest_rpc_class tcmi_guest_rpc class 
+ *
+ * @ingroup tcmi_rpc_class
+ *
+ * A \<\<singleton\>\> class that is executing RPC on PEN side.
+ * 
+ * @{
+ */
+
+/** tcmi_guest_rpc class declaration */
+extern struct tcmi_rpc *tcmi_guest_rpc;
+
+/** Creates default RPC call for system call declaration
+ *
+ * @param name - name of system call
+ */
+#define TCMI_GUEST_RPC_CALL_DEF(name)\
+long tcmi_guest_rpc_sys_##name(unsigned rpc_num, long params[TCMI_RPC_MAXPARAMS])
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_GUEST_RPC_PRIVATE
+#include "tcmi_guest_generic_rpc.h"
+#include "tcmi_guest_signal_rpc.h"
+#include "tcmi_guest_wait_rpc.h"
+#include "tcmi_guest_fork_rpc.h"
+#include "tcmi_guest_groupident_rpc.h"
+#include "tcmi_guest_userident_rpc.h"
+
+/** Guest RPC handlers */
+long (*tcmi_calltable_guest[TCMI_MAX_RPC_NUM + 1])(unsigned,long[TCMI_RPC_MAXPARAMS]) = {
+	/* Signal ********************************************/
+	[TCMI_RPC_SYS_KILL] 	= &tcmi_guest_rpc_sys_2,
+	[TCMI_RPC_SYS_SIGQUEUE] = &tcmi_guest_rpc_sys_rt_sigqueueinfo,
+	[TCMI_RPC_SYS_TKILL] 	= &tcmi_guest_rpc_sys_3,
+
+	/* Pid, gid and session manipulation *****************/
+	[TCMI_RPC_SYS_GETPPID]	= &tcmi_guest_rpc_sys_0,
+	[TCMI_RPC_SYS_GETSID]	= &tcmi_guest_rpc_sys_1,
+	[TCMI_RPC_SYS_SETSID]	= &tcmi_guest_rpc_sys_0,
+	[TCMI_RPC_SYS_GETPGRP]	= &tcmi_guest_rpc_sys_0,
+	[TCMI_RPC_SYS_GETPGID]	= &tcmi_guest_rpc_sys_1,
+	[TCMI_RPC_SYS_SETPGID]	= &tcmi_guest_rpc_sys_2,
+
+	/* User identification *******************************/
+	[TCMI_RPC_SYS_GETEUID]	= &tcmi_guest_rpc_sys_0,
+	[TCMI_RPC_SYS_GETRESUID]= &tcmi_guest_rpc_sys_getresuid,
+	[TCMI_RPC_SYS_GETUID]	= &tcmi_guest_rpc_sys_0,
+	[TCMI_RPC_SYS_SETRESUID]= &tcmi_guest_rpc_sys_3,
+	[TCMI_RPC_SYS_SETREUID]	= &tcmi_guest_rpc_sys_2,
+	[TCMI_RPC_SYS_SETUID]	= &tcmi_guest_rpc_sys_1,
+
+	/* Group identification ******************************/
+	[TCMI_RPC_SYS_GETEGID]	= &tcmi_guest_rpc_sys_0,
+	[TCMI_RPC_SYS_GETGID]	= &tcmi_guest_rpc_sys_0,
+	[TCMI_RPC_SYS_GETRESGID]= &tcmi_guest_rpc_sys_getresgid,
+	[TCMI_RPC_SYS_GETGROUPS]= &tcmi_guest_rpc_sys_getgroups,
+	[TCMI_RPC_SYS_SETGID]	= &tcmi_guest_rpc_sys_1,
+	[TCMI_RPC_SYS_SETREGID]	= &tcmi_guest_rpc_sys_2,
+	[TCMI_RPC_SYS_SETRESGID]= &tcmi_guest_rpc_sys_3,
+	[TCMI_RPC_SYS_SETGROUPS]= &tcmi_guest_rpc_sys_setgroups,
+
+	[TCMI_RPC_SYS_WAIT4]= &tcmi_guest_rpc_sys_wait4,
+
+	[TCMI_RPC_SYS_FORK]= &tcmi_guest_rpc_sys_fork,
+};
+
+#endif /* TCMI_GUEST_RPC_PRIVATE */
+/**
+ * @}
+ */
+
+#endif /* _TCMI_GUEST_RPC_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_guest_signal_rpc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_guest_signal_rpc.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,48 @@
+/**
+ * @file tcmi_guest_signal_rpc.h - a RPC class used by guest process .
+ *
+ * Date: 7/05/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: tcmi_guest_signal_rpc.h,v 1.1 2007/09/02 12:09:55 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef _TCMI_GUEST_RPC_SIGNAL_H
+#define _TCMI_GUEST_RPC_SIGNAL_H
+
+#include "tcmi_guest_rpc.h"
+/** @defgroup tcmi_guest_rpc_signal_class Signal sending 
+ *
+ * @ingroup tcmi_guest_rpc_class
+ *
+ * A \<\<singleton\>\> class that is executing RPC on PEN side.
+ * 
+ * @{
+ */
+
+TCMI_GUEST_RPC_CALL_DEF(rt_sigqueueinfo);
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_GUEST_RPC_SIGNAL_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_shadow_wait_rpc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_shadow_wait_rpc.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,87 @@
+/**
+ * @file tcmi_shadow_wait_rpc.c - shadow part of wait syscall rpc
+ */
+#include <linux/syscalls.h>
+#include <linux/uaccess.h>
+#include <linux/resource.h>
+
+#include <arch/types.h>
+#include <dbg.h>
+
+#include "tcmi_shadow_wait_rpc.h"
+#include "exported_symbols.h"
+
+TCMI_SHADOW_RPC_GENERIC_CALL_DEF(sys_wait4)
+{
+	struct tcmi_msg **resp, *m;
+	long rtn;
+	mm_segment_t old_fs;
+
+	// Platform independend params
+	int32_t pid;
+	int32_t options;
+	// Platform independend return values
+	struct rusage_ind* result_usage_ind;
+	int32_t* result_stats_ind;	
+	// Return values	
+	struct rusage* result_usage;
+	int result_stats;
+	
+	mdbg(INFO3, "Forwarded wait syscall being processed");
+
+	result_usage = kmalloc(sizeof(*result_usage), GFP_KERNEL);
+	if ( !result_usage )
+		return -ENOMEM;
+
+
+	m = (struct tcmi_msg*) params[0];
+	resp = (struct tcmi_msg**) params[1];
+	// Extract params
+	pid = *(int32_t*)tcmi_rpc_procmsg_data_base( TCMI_RPC_PROCMSG(m), 0);
+	options = *(int32_t*)tcmi_rpc_procmsg_data_base( TCMI_RPC_PROCMSG(m), 1);
+
+	mdbg(INFO3, "Waiting for pid: %d", pid);
+
+	// Perform the call
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+	rtn = sys_wait4(pid, &result_stats , options, result_usage);
+	set_fs(old_fs);
+
+	// Convert resuls to platform independend values
+	result_usage_ind = kmalloc(sizeof(*result_usage_ind), GFP_KERNEL);
+	if ( !result_usage_ind ) {
+		kfree(result_usage);
+		return -ENOMEM;
+	}
+
+	result_stats_ind = kmalloc(sizeof(int32_t), GFP_KERNEL);
+	if ( !result_stats_ind ) {
+		kfree(result_usage);
+		kfree(result_usage_ind);
+		return -ENOMEM;
+	}
+
+	rusage_to_ind(result_usage, result_usage_ind);
+	*result_stats_ind = result_stats;
+
+	mdbg(INFO3, "Forwarded wait syscall wait finished. Status: %d (ind: %d) res: %ld", result_stats, *result_stats_ind, rtn);
+	
+	// Create response with the results
+	*resp = tcmi_rpcresp_procmsg_create(m, rtn, sizeof(*result_usage_ind), result_usage_ind,
+						    sizeof(*result_stats_ind), result_stats_ind,
+						(size_t)0 );
+
+	kfree(result_usage);
+	if( *resp == NULL ) {
+		kfree(result_usage_ind);
+		kfree(result_stats_ind);
+		return -1;
+	}
+
+	tcmi_rpcresp_procmsg_free_on_put( TCMI_RPCRESP_PROCMSG(*resp), 0, TCMI_RPCRESP_PROCMSG_KFREE );
+	tcmi_rpcresp_procmsg_free_on_put( TCMI_RPCRESP_PROCMSG(*resp), 1, TCMI_RPCRESP_PROCMSG_KFREE );
+
+	return 0;
+}
+
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_syscallhooks_userident.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_syscallhooks_userident.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,139 @@
+/**
+ * @file tcmi_syscallhooks_userident.c - syscalls hooks for proces identification manipulation.
+ *                      
+ * 
+ *
+ *
+ * Date: 13/06/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: tcmi_syscallhooks_userident.c,v 1.3 2007/09/02 15:40:39 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include <asm/uaccess.h>
+#include <linux/capability.h>
+#include <clondike/tcmi/tcmi_hooks.h>
+
+#include <dbg.h>
+#include <tcmi/syscall/tcmi_guest_rpc.h>
+
+#define TCMI_SYSCALLHOOKS_USERIDENT_PRIVATE
+#include "tcmi_syscallhooks_userident.h"
+
+/** 
+ * \<\<public\>\> Registers all user identification syscalls hooks with the kernel.
+ *
+ * @return 0 upon success
+ */
+int tcmi_syscall_hooks_userident_init(void)
+{
+	minfo(INFO3, "Registering TCMI user identification syscalls hooks\n" 
+		     "For: getuid, geteuid, getresuid, setresuid, setuid" );
+	tcmi_hooks_register_sys_getuid(    tcmi_syscall_hooks_sys_getuid    );
+	tcmi_hooks_register_sys_setuid(    tcmi_syscall_hooks_sys_setuid    );
+	tcmi_hooks_register_sys_getresuid( tcmi_syscall_hooks_sys_getresuid );
+	tcmi_hooks_register_sys_setresuid( tcmi_syscall_hooks_sys_setresuid );
+	tcmi_hooks_register_sys_setreuid(  tcmi_syscall_hooks_sys_setreuid );
+	tcmi_hooks_register_sys_geteuid(   tcmi_syscall_hooks_sys_geteuid   );
+	return 0;
+}
+
+/** 
+ * \<\<public\>\> Unregisters all user identifikation syscalls hooks.
+ */
+void tcmi_syscall_hooks_userident_exit(void)
+{
+	minfo(INFO3, "Unregistering TCMI user identification syscalls hooks");
+	tcmi_hooks_unregister_sys_getuid();
+	tcmi_hooks_unregister_sys_setuid();
+	tcmi_hooks_unregister_sys_getresuid();
+	tcmi_hooks_unregister_sys_setresuid();
+	tcmi_hooks_unregister_sys_setreuid();
+	tcmi_hooks_unregister_sys_geteuid();
+}
+
+
+/**
+ * \<\<private\>\> Getuid system call hook
+ *
+ * @return - uid of current process
+ */
+static long tcmi_syscall_hooks_sys_getuid(void)
+{
+	return tcmi_rpc_call0(tcmi_guest_rpc, TCMI_RPC_SYS_GETUID);
+}
+
+/**
+ * \<\<private\>\> Setresuid system call hook
+ * @param ruid - real user id
+ * @param euid - efective user id
+ * @param suid - saved set-user id
+ *
+ * @return zero on success
+ */
+static long tcmi_syscall_hooks_sys_setresuid(uid_t ruid, uid_t euid, uid_t suid)
+{
+	return tcmi_rpc_call3(tcmi_guest_rpc, TCMI_RPC_SYS_SETRESUID, ruid, euid, suid);
+}
+
+/**
+ * \<\<private\>\> Geteuid system call hook
+ *
+ * @return efective uid of current process
+ */
+static long tcmi_syscall_hooks_sys_geteuid(void)
+{
+	return tcmi_rpc_call0(tcmi_guest_rpc, TCMI_RPC_SYS_GETEUID);
+}
+
+/** \<\<private\>\> Setuid system call hook 
+ * @param uid - efective user id
+ * 
+ * @return zero on success
+ */
+static long tcmi_syscall_hooks_sys_setuid(uid_t uid)
+{
+	return tcmi_rpc_call1(tcmi_guest_rpc, TCMI_RPC_SYS_SETUID, uid);
+}
+
+/** \<\<private\>\> Setreuid system call hook 
+ * @param ruid - real user id
+ * @param euid - efective user id
+ *
+ * @return zero on success
+ */
+static long tcmi_syscall_hooks_sys_setreuid(uid_t ruid, uid_t euid)
+{
+	return tcmi_rpc_call2(tcmi_guest_rpc, TCMI_RPC_SYS_SETREUID, ruid, euid);
+}
+
+/** \<\<private\>\> Getresuid system call hook (all pointers points to userspace)
+ * @param *ruid - pointer to uid_t for real user id
+ * @param *euid - pointer to uid_t for efective user id
+ * @param *suid - pointer to uid_t for saved set-user id
+ *
+ * @return zero on success
+ * */
+static long tcmi_syscall_hooks_sys_getresuid(uid_t* ruid, uid_t* euid, uid_t *suid)
+{
+	return tcmi_rpc_call3(tcmi_guest_rpc, TCMI_RPC_SYS_GETRESUID, (unsigned long)ruid, (unsigned long)euid, (unsigned long)suid);
+}
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_shadow_groupident_rpc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_shadow_groupident_rpc.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,152 @@
+/**
+ * @file tcmi_shadow_rpc_groupident.c - CCN part of RPCs
+ *
+ * Date: 7/06/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: tcmi_shadow_groupident_rpc.c,v 1.3 2007/10/11 21:00:26 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <asm/uaccess.h>
+
+static int errno;
+#include <arch/current/make_syscall.h>
+
+#include "tcmi_shadow_groupident_rpc.h"
+
+static inline _syscall0(gid_t, getegid    );
+static inline _syscall0(gid_t, getgid     );
+static inline _syscall1(long,  setgid,    gid_t, gid);
+static inline _syscall2(long,  getgroups, int, size, gid_t*, list);
+static inline _syscall2(long,  setgroups, int, size, const gid_t*, list);
+static inline _syscall2(long,  setregid,  gid_t, rgid, gid_t, egid);
+static inline _syscall3(long,  getresgid, gid_t*, rgid, gid_t*, egid, gid_t*, sgid);
+static inline _syscall3(long,  setresgid, gid_t, rgid, gid_t, egid, gid_t, sgid);
+
+TCMI_SHADOW_RPC_GENERIC_CALL(0, getegid,   false);
+TCMI_SHADOW_RPC_GENERIC_CALL(0, getgid,    false);
+TCMI_SHADOW_RPC_GENERIC_CALL(1, setgid,    true);
+TCMI_SHADOW_RPC_GENERIC_CALL(2, setregid,  true);
+TCMI_SHADOW_RPC_GENERIC_CALL(3, setresgid, true);
+
+TCMI_SHADOW_RPC_GENERIC_CALL_DEF(getresgid)
+{
+	struct tcmi_msg **resp, *m;
+	long rtn;
+	uid_t *gids;
+	mm_segment_t old_fs;
+
+	m = (struct tcmi_msg*) params[0];
+	resp = (struct tcmi_msg**) params[1];
+
+	if( (gids = kmalloc( 3 * sizeof(gid_t), GFP_KERNEL ) ) == NULL ){
+			mdbg(ERR3, "Buffer allocation failed");
+			return -1;
+	}
+	
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+	rtn = getresgid( gids, gids + 1, gids + 2 );
+	set_fs(old_fs);
+
+	if( rtn == -1) // Should be never true
+		rtn = errno;
+	else{
+		if( (*resp = tcmi_rpcresp_procmsg_create(m, rtn, 3 * sizeof(gid_t), gids, (size_t)0 )) == NULL ){
+			kfree( gids );
+			return -1;
+		}
+		tcmi_rpcresp_procmsg_free_on_put( TCMI_RPCRESP_PROCMSG(*resp), 0, TCMI_RPCRESP_PROCMSG_KFREE );
+	}
+	
+	return 0;
+}
+
+TCMI_SHADOW_RPC_GENERIC_CALL_DEF(setgroups)
+{
+	struct tcmi_msg **resp, *m;
+	long* rpc_params, rtn;
+	void *ker_buf;
+	mm_segment_t old_fs;
+
+	m = (struct tcmi_msg*) params[0];
+	resp = (struct tcmi_msg**) params[1];
+	
+	rpc_params = (long*)tcmi_rpc_procmsg_data_base( TCMI_RPC_PROCMSG(m), 0);
+	ker_buf = (long*)tcmi_rpc_procmsg_data_base( TCMI_RPC_PROCMSG(m), 1);
+
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+	rtn = setgroups( rpc_params[0], ker_buf );
+	set_fs(old_fs);
+	if( rtn == -1)
+		rtn = errno;
+	*resp = tcmi_rpcresp_procmsg_create(m, rtn, 0 );
+	if( *resp == NULL ) 
+		return -1;
+	return 0;
+}
+
+TCMI_SHADOW_RPC_GENERIC_CALL_DEF(getgroups)
+{
+	struct tcmi_msg **resp, *m;
+	long* rpc_params;
+	long rtn, numb_of_groups;
+	unsigned int i, count;
+	gid_t *ker_buf;
+
+	m = (struct tcmi_msg*) params[0];
+	resp = (struct tcmi_msg**) params[1];
+	
+	rpc_params = (long*)tcmi_rpc_procmsg_data_base( TCMI_RPC_PROCMSG(m), 0);
+
+	numb_of_groups = current_cred()->group_info->ngroups;
+	if( rpc_params[0] == 0 )
+		*resp = tcmi_rpcresp_procmsg_create(m, numb_of_groups, 0 );
+	else if( rpc_params[0] < numb_of_groups )
+		*resp = tcmi_rpcresp_procmsg_create(m, -EINVAL, 0 );
+	else{
+		if( (ker_buf = (gid_t*)kmalloc( numb_of_groups * sizeof(gid_t), GFP_KERNEL ) ) == NULL ){
+			mdbg(ERR3, "Buffer allocation failed");
+			return -1;
+		}
+
+		rtn = count = numb_of_groups;
+		for (i = 0; i < count; i++) {
+			int cp_count = min(NGROUPS_PER_BLOCK, count);
+			int off = i * NGROUPS_PER_BLOCK;
+			int len = cp_count * sizeof(*ker_buf);
+
+			memcpy(ker_buf+off, current_cred()->group_info->blocks[i], len);
+
+			count -= cp_count;
+		}
+
+		*resp = tcmi_rpcresp_procmsg_create(m, rtn, sizeof(gid_t)*numb_of_groups, ker_buf, 0 );
+		tcmi_rpcresp_procmsg_free_on_put( TCMI_RPCRESP_PROCMSG(*resp), 0, TCMI_RPCRESP_PROCMSG_KFREE );
+	}
+
+	if( *resp == NULL ) 
+		return -1;
+	return 0;
+}
+
+
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_guest_rpc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_guest_rpc.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,41 @@
+/**
+ * @file tcmi_guest_rpc.c - PEN part of RPCs
+ *
+ *
+ * Date: 7/05/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: tcmi_guest_rpc.c,v 1.1 2007/09/02 12:09:55 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#define TCMI_RPC_PRIVATE
+#define TCMI_GUEST_RPC_PRIVATE
+#include "tcmi_guest_rpc.h"
+
+struct tcmi_rpc tcmi_guest_rpc_struct = {
+	.calltable = tcmi_calltable_guest,
+};
+
+struct tcmi_rpc *tcmi_guest_rpc = &tcmi_guest_rpc_struct;
+
+/**
+ * @}
+ */
+
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_syscallhooks.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_syscallhooks.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,62 @@
+/**
+ * @file tcmi_syscallhooks.h - a separate module that install syscalls hooks into the kernel.
+ *                      
+ * 
+ *
+ *
+ * Date: 17/04/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: tcmi_syscallhooks.h,v 1.2 2007/09/02 12:09:55 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#ifndef _TCMI_SYSCALLHOOKS_H
+#define _TCMI_SYSCALLHOOKS_H
+
+/** @defgroup tcmi_syscallhooks_class tcmi_syscallhooks class 
+ *
+ * @ingroup tcmi_syscall_group
+ *
+ * A \<\<singleton\>\> class that installs syscalls hooks into the kernel.
+ * 
+ * @{
+ */
+
+/** \<\<public\>\> Registers all hooks with the kernel. */
+int tcmi_syscall_hooks_init(void);
+
+/** \<\<public\>\> Unregisters all hooks. */
+void tcmi_syscall_hooks_exit(void);
+
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_SYSCALLHOOKS_PRIVATE
+
+#endif /* TCMI_SYSCALLHOOKS_PRIVATE */
+
+/**
+ * @}
+ */
+
+
+#endif /* _TCMI_SYSCALLHOOKS_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_shadow_fork_rpc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_shadow_fork_rpc.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,27 @@
+/**
+ * @file tcmi_shadow_fork_rpc.h - a RPC class used by shadow process for fork syscall
+ */
+
+#ifndef _TCMI_SHADOW_RPC_FORK_H
+#define _TCMI_SHADOW_RPC_FORK_H
+
+#include "tcmi_shadow_rpc.h"
+
+/** @defgroup tcmi_shadow_rpc_fork_class Processing all fork based syscalls
+ *
+ * @ingroup tcmi_shadow_rpc_class
+ *
+ * A \<\<singleton\>\> class that is executing RPC on CCN side.
+ * 
+ * @{
+ */
+
+/** Declaration of tcmi_shadow_rpc_do_fork() */
+TCMI_SHADOW_RPC_GENERIC_CALL_DEF(do_fork);
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_SHADOW_RPC_WAIT_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_syscallhooks.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_syscallhooks.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,79 @@
+/**
+ * @file tcmi_syscallhooks.c - a separate module that install syscalls hooks into the kernel.
+ *                      
+ * 
+ *
+ *
+ * Date: 17/04/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: tcmi_syscallhooks.c,v 1.5 2007/10/11 21:00:26 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <dbg.h>
+#include "tcmi_syscallhooks_signal.h"
+#include "tcmi_syscallhooks_pidman.h"
+#include "tcmi_syscallhooks_userident.h"
+#include "tcmi_syscallhooks_groupident.h"
+#include "tcmi_syscallhooks_other.h"
+
+#define TCMI_SYSCALLHOOKS_PRIVATE
+#include "tcmi_syscallhooks.h"
+
+/** @addtogroup tcmi_syscallhooks_class
+ *
+ * @{
+ */
+
+/** 
+ * \<\<public\>\> Registers all syscalls hooks with the kernel.
+ *
+ * @return 0 upon success
+ */
+int tcmi_syscall_hooks_init(void)
+{
+	minfo(INFO1, "Registering TCMI syscalls hooks");
+	tcmi_syscall_hooks_signal_init();
+	tcmi_syscall_hooks_pidman_init();
+	tcmi_syscall_hooks_userident_init();
+	tcmi_syscall_hooks_groupident_init();
+	tcmi_syscall_hooks_other_init();
+	return 0;
+}
+
+/** 
+ * \<\<public\>\> Unregisters all syscalls hooks.
+ */
+void tcmi_syscall_hooks_exit(void)
+{
+	minfo(INFO1, "Unregistering TCMI syscalls hooks");
+	tcmi_syscall_hooks_signal_exit();
+	tcmi_syscall_hooks_pidman_exit();
+	tcmi_syscall_hooks_userident_exit();
+	tcmi_syscall_hooks_groupident_exit();
+	tcmi_syscall_hooks_other_exit();
+}
+
+
+
+/**
+ * @}
+ */
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_syscallhooks_userident.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_syscallhooks_userident.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,80 @@
+/**
+ * @file tcmi_syscallhooks_userident.h - 
+ *                      
+ * 
+ *
+ *
+ * Date: 25/06/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: tcmi_syscallhooks_userident.h,v 1.3 2007/09/02 13:54:30 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#ifndef _TCMI_SYSCALLHOOKS_USERIDENT_H
+#define _TCMI_SYSCALLHOOKS_USERIDENT_H
+
+/** @defgroup tcmi_syscallhooks_userident_class User identification 
+ *
+ * @ingroup tcmi_syscallhooks_class
+ *
+ * A \<\<singleton\>\> class that installs user identity manipulation syscalls 
+ * hooks into the kernel.
+ * 
+ * @{
+ */
+
+/** \<\<public\>\> Registers all PID manipolation hooks with the kernel. */
+int tcmi_syscall_hooks_userident_init(void);
+
+/** \<\<public\>\> Unregisters all PID manipolation hooks. */
+void tcmi_syscall_hooks_userident_exit(void);
+
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_SYSCALLHOOKS_USERIDENT_PRIVATE
+
+/** \<\<private\>\> Getuid system call hook */
+static long tcmi_syscall_hooks_sys_getuid(void);
+
+/** \<\<private\>\> Setuid system call hook */
+static long tcmi_syscall_hooks_sys_setuid(uid_t);
+
+/** \<\<private\>\> Setreuid system call hook */
+static long tcmi_syscall_hooks_sys_setreuid(uid_t, uid_t);
+
+/** \<\<private\>\> Geteuid system call hook */
+static long tcmi_syscall_hooks_sys_geteuid(void);
+
+/** \<\<private\>\> Setresuid system call hook */
+static long tcmi_syscall_hooks_sys_setresuid(uid_t ruid, uid_t euid, uid_t suid);
+
+/** \<\<private\>\> Getresuid system call hook */
+static long tcmi_syscall_hooks_sys_getresuid(uid_t* ruid, uid_t* euid, uid_t *suid);
+
+#endif /* TCMI_SYSCALLHOOKS_USERIDENT_PRIVATE */
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_SYSCALLHOOKS_USERIDENT_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_shadow_userident_rpc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_shadow_userident_rpc.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,100 @@
+/**
+ * @file tcmi_shadow_rpc_userident.c - CCN part of RPCs
+ *
+ * Date: 7/06/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: tcmi_shadow_userident_rpc.c,v 1.3 2007/10/11 21:00:26 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <asm/uaccess.h>
+
+static int errno;
+#include <arch/current/make_syscall.h>
+
+#include "tcmi_shadow_userident_rpc.h"
+
+static inline _syscall0(long, getuid     );
+static inline _syscall0(long, geteuid    );
+static inline _syscall1(long,  setuid,    uid_t, uid);
+static inline _syscall2(long,  setreuid,  uid_t, ruid, uid_t, euid);
+static inline _syscall3(long,  setresuid, uid_t, ruid, uid_t, euid, uid_t, suid);
+static inline _syscall3(long,  getresuid, uid_t*, ruid, uid_t*, euid, uid_t*, suid);
+
+TCMI_SHADOW_RPC_GENERIC_CALL(0, geteuid,   false);
+TCMI_SHADOW_RPC_GENERIC_CALL(0, getuid,    false);
+TCMI_SHADOW_RPC_GENERIC_CALL(1, setuid,    true );
+TCMI_SHADOW_RPC_GENERIC_CALL(2, setreuid,  true );
+TCMI_SHADOW_RPC_GENERIC_CALL(3, setresuid, true );
+
+
+/*
+long tcmi_shadow_rpc_getuid(unsigned rpc_num, long params[TCMI_RPC_MAXPARAMS]) {
+	mm_segment_t old_fs;
+	struct tcmi_msg *m = (struct tcmi_msg*) params[0], **resp = (struct tcmi_msg**) params[1];
+	long rtn; 
+
+
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+	rtn = sys_getuid();
+	set_fs(old_fs);
+
+	*resp = tcmi_rpcresp_procmsg_create(m, rtn, (size_t)0 );
+	if( *resp == NULL ) 
+		return -1;
+	return 0;
+}
+*/
+
+TCMI_SHADOW_RPC_GENERIC_CALL_DEF(getresuid)
+{
+	struct tcmi_msg **resp, *m;
+	long rtn;
+	uid_t *uids;
+	mm_segment_t old_fs;
+
+	m = (struct tcmi_msg*) params[0];
+	resp = (struct tcmi_msg**) params[1];
+
+	if( (uids = kmalloc( 3 * sizeof(uid_t), GFP_KERNEL ) ) == NULL ){
+			mdbg(ERR3, "Buffer allocation failed");
+			return -1;
+	}
+	
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+	rtn = getresuid( uids, uids + 1, uids + 2 );
+	set_fs(old_fs);
+
+	if( rtn == -1) // Should be never true
+		rtn = errno;
+	else{
+		if( (*resp = tcmi_rpcresp_procmsg_create(m, rtn, 3 * sizeof(uid_t), uids, (size_t)0 )) == NULL ){
+			kfree( uids );
+			return -1;
+		}
+		tcmi_rpcresp_procmsg_free_on_put( TCMI_RPCRESP_PROCMSG(*resp), 0, TCMI_RPCRESP_PROCMSG_KFREE );
+	}
+	
+	return 0;
+}
+
--- linux-3.7.1_original/clondike/src/tcmi/syscall/tcmi_guest_groupident_rpc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/syscall/tcmi_guest_groupident_rpc.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,56 @@
+/**
+ * @file tcmi_guest_rpc_groupident.h - a RPC class used by guest process .
+ *
+ * Date: 7/05/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: tcmi_guest_groupident_rpc.h,v 1.1 2007/09/02 12:09:55 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef _TCMI_GUEST_RPC_GROUPIDENT_H
+#define _TCMI_GUEST_RPC_GROUPIDENT_H
+
+#include "tcmi_guest_rpc.h"
+/** @defgroup tcmi_guest_rpc_groupident_class Group identification 
+ *
+ * @ingroup tcmi_guest_rpc_class
+ *
+ * A \<\<singleton\>\> class that is executing RPC on PEN side.
+ * 
+ * @{
+ */
+
+/** Declaration of tcmi_guest_rpc_sys_getgroups() */
+TCMI_GUEST_RPC_CALL_DEF(getgroups);
+
+/** Declaration of tcmi_guest_rpc_sys_setgroups() */
+TCMI_GUEST_RPC_CALL_DEF(setgroups);
+
+/** Declaration of tcmi_guest_rpc_sys_getresgid() */
+TCMI_GUEST_RPC_CALL_DEF(getresgid);
+
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_GUEST_RPC_GROUPIDENT_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/Makefile	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,55 @@
+##############################################################################
+# @file Makefile - Builds Task Checkpointing and Migration Infrastructure
+#
+# Author: Petr Malat
+#
+# This file is part of Clondike.
+#
+# Clondike is free software: you can redistribute it and/or modify it under 
+# the terms of the GNU General Public License version 2 as published by 
+# the Free Software Foundation.
+#
+# Clondike is distributed in the hope that it will be useful, but WITHOUT ANY
+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
+# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more 
+# details.
+# 
+# You should have received a copy of the GNU General Public License along with 
+# Clondike. If not, see http://www.gnu.org/licenses/.
+##############################################################################
+
+ccflags-y = `dbgenv $<`
+
+obj-$(CONFIG_TCMI) := ctlfs/ ckpt/ tcmi.o
+
+tcmi-objs := tcmi_module.o 
+########## Manager component
+tcmi-objs               += manager/tcmi_man.o manager/tcmi_migman.o
+tcmi-$(CONFIG_TCMI_CCN) += manager/tcmi_ccnman.o manager/tcmi_ccnmigman.o
+tcmi-$(CONFIG_TCMI_PEN) += manager/tcmi_penman.o manager/tcmi_penmigman.o 
+########## Task component
+tcmi-objs += task/tcmi_guesttask.o task/tcmi_shadowtask.o task/tcmi_task.o 
+########## Migration component
+tcmi-objs += migration/tcmi_migcom.o migration/tcmi_mighooks.o migration/tcmi_npm_params.o 
+tcmi-objs += migration/fs/fs_mounter_register.o migration/fs/9p_fs_global_mounter.o migration/fs/9p_fs_mounter.o
+########## Syscall component
+tcmi-objs += syscall/tcmi_rpc.o 
+tcmi-$(CONFIG_TCMI_CCN) += syscall/tcmi_shadow_rpc.o syscall/tcmi_shadow_pidman_rpc.o syscall/tcmi_shadow_signal_rpc.o \
+	syscall/tcmi_shadow_userident_rpc.o syscall/tcmi_shadow_groupident_rpc.o syscall/tcmi_shadow_wait_rpc.o \
+	syscall/tcmi_shadow_fork_rpc.o
+tcmi-$(CONFIG_TCMI_PEN) += syscall/tcmi_guest_rpc.o syscall/tcmi_guest_generic_rpc.o syscall/tcmi_guest_userident_rpc.o \
+	syscall/tcmi_guest_signal_rpc.o  syscall/tcmi_guest_groupident_rpc.o syscall/tcmi_syscallhooks.o \
+	syscall/tcmi_syscallhooks_pidman.o syscall/tcmi_syscallhooks_signal.o syscall/tcmi_syscallhooks_userident.o \
+       	syscall/tcmi_syscallhooks_groupident.o syscall/tcmi_syscallhooks_other.o syscall/tcmi_guest_wait_rpc.o \
+	syscall/tcmi_guest_fork_rpc.o
+########## Lib component
+tcmi-objs += lib/tcmi_sock.o lib/tcmi_slotvec.o
+########## Comm component
+tcmi-objs += comm/tcmi_comm.o comm/tcmi_msg.o comm/tcmi_procmsg.o comm/tcmi_transaction.o comm/tcmi_msg_factory.o \
+	comm/tcmi_skel_msg.o comm/tcmi_skelresp_msg.o comm/tcmi_skel_procmsg.o comm/tcmi_skelresp_procmsg.o \
+	comm/tcmi_err_msg.o comm/tcmi_err_procmsg.o comm/tcmi_vfork_done_procmsg.o comm/tcmi_exit_procmsg.o \
+	comm/tcmi_p_emigrate_msg.o comm/tcmi_guest_started_procmsg.o comm/tcmi_ppm_p_migr_back_guestreq_procmsg.o \
+	comm/tcmi_ppm_p_migr_back_shadowreq_procmsg.o comm/tcmi_rpc_procmsg.o comm/tcmi_rpcresp_procmsg.o \
+	comm/tcmi_authenticate_msg.o comm/tcmi_authenticate_resp_msg.o comm/tcmi_signal_msg.o \
+	comm/tcmi_generic_user_msg.o comm/tcmi_disconnect_msg.o
+
--- linux-3.7.1_original/clondike/src/tcmi/ckpt/tcmi_ckpt_vm_area.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/ckpt/tcmi_ckpt_vm_area.h	2013-03-11 09:25:43.000000000 +0100
@@ -0,0 +1,281 @@
+/**
+ * @file tcmi_ckpt_vm_area.h - a helper class that provides functionality to
+ *                     store a single VM area (memory regions)
+ *                      
+ * 
+ *
+ *
+ * Date: 05/01/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_ckpt_vm_area.h,v 1.3 2007/09/02 10:53:17 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_CKPT_VM_AREA_H
+#define _TCMI_CKPT_VM_AREA_H
+
+#include <linux/mm.h>
+#include <linux/mman.h>
+#include <linux/hardirq.h>
+
+#include "tcmi_ckpt.h"
+
+/** @defgroup tcmi_ckpt_vm_area_class tcmi_ckpt_vm_area class 
+ *
+ * @ingroup tcmi_ckpt_class
+ *
+ * This is a \<\<singleton\>\> that takes care of (re)storing a
+ * particular memory segment (VM area) into the checkpoint file.
+ *
+ * There are 2 modes supported:
+ * - heavy checkpoint mode - where the entire segment is dumped
+ * page by page into the checkpoint. 
+ * - light checkpoint mode - if the segment maps a file on disk
+ * and the segment is non-writable, only file pathname is dumped
+ * into the checkpoint. This decreases the resulting checkpoint 
+ * size dramatically. Also, when restoring such checkpoint parts,
+ * there is a big chance that the file is already mapped in memory.
+ * This typically happens with shared libraries and executable code.
+ *
+ * @{
+ */
+
+/** Describes the type of the vm area we store, see above. */
+typedef enum {
+	TCMI_CKPT_VM_AREA_LIGHT,
+	TCMI_CKPT_VM_AREA_HEAVY
+} tcmi_ckpt_vm_area_t;
+
+/** Compound structure describes a particular memory region. Very
+ * similar to vm_area_struct. We don't store the vm_page_prot
+ * flags as they can be derived from vm_flags */
+struct tcmi_ckpt_vm_area_hdr {
+	/** segment start address */
+	u_int64_t vm_start;
+	/** first linear address after the memory region */
+	u_int64_t vm_end;
+	/** flags of the region */
+	u_int64_t vm_flags;
+	/** Offset in mapped file, if any. */
+	u_int64_t vm_pgoff;
+	/** type of the area */
+	tcmi_ckpt_vm_area_t type;
+	/** pathname size in bytes, including trailing zero - for
+	 * light version only */
+	u_int32_t pathname_size;
+}  __attribute__((__packed__));
+
+
+/** \<\<public\>\> Writes a specified memory area into the checkpoint file. */
+extern int tcmi_ckpt_vm_area_write(struct tcmi_ckpt *ckpt, 
+				   struct vm_area_struct *vma, 
+				   tcmi_ckpt_vm_area_t type);
+
+/**\<\<public\>\>  Reads a memory area from the checkpoint file. */
+extern int tcmi_ckpt_vm_area_read(struct tcmi_ckpt *ckpt);
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_CKPT_VM_AREA_PRIVATE
+
+/** Reads a memory area from the checkpoint file - light version. */
+static int tcmi_ckpt_vm_area_read_l(struct tcmi_ckpt *ckpt, 
+				    struct tcmi_ckpt_vm_area_hdr *hdr);
+
+/** Reads a memory area from the checkpoint file - heavy version. */
+static int tcmi_ckpt_vm_area_read_h(struct tcmi_ckpt *ckpt, 
+				    struct tcmi_ckpt_vm_area_hdr *hdr);
+
+/** Writes a specified memory area into the checkpoint file - light
+ * version. */
+static int tcmi_ckpt_vm_area_write_l(struct tcmi_ckpt *ckpt, 
+				     struct vm_area_struct *vma, 
+				     struct tcmi_ckpt_vm_area_hdr *hdr);
+
+/** Writes a specified memory area into the checkpoint file - heavy
+ * version. */
+static int tcmi_ckpt_vm_area_write_h(struct tcmi_ckpt *ckpt, 
+				     struct vm_area_struct *vma, 
+				     struct tcmi_ckpt_vm_area_hdr *hdr);
+
+/** 
+ * \<\private\>\> Converts the VM area flags to mmap flags.
+ *
+ * Each mapping is marked fixed as that is the only way how to restart
+ * a process from the checkpoint (virtual addresses must match).
+ *
+ * VM_GROWSDOWN, VM_DENYWRITE flags directly match mmap
+ * flags, so only bit extraction needs to be done.  VM_GROWSDOWN flags
+ * is special as it marks the stack. Stack fixup is handled separate by
+ * tcmi_ckpt_vm_area_stack_fixup().
+ *
+ * VM_SHARED flag doesn't match the mmap flags directly, so a
+ * conditional check needs to be done: anything not shared is mmaped
+ * as private.
+ *
+ * @param vm_flags - flags to be converted
+ * @return mmap flags
+ */
+static inline unsigned long tcmi_ckpt_vm_area_to_mmap_flags(unsigned long vm_flags) 
+{
+  return MAP_FIXED |
+    (vm_flags & VM_SHARED ? MAP_SHARED : MAP_PRIVATE) |
+    (vm_flags & VM_GROWSDOWN) |
+    (vm_flags & VM_DENYWRITE);
+    //Remove  for kernel 3.7.x by Jiri Rakosnik
+}
+
+
+/**
+ * \<\private\>\> This is really stupid, but linux kernel doesn't
+ * export kmap/kunmap, so we had to duplicate the highmemory check..
+ *
+ * @param *page - page that is to be mapped into the linear address space
+ * @return linear address of the page
+ */
+static inline void* tcmi_ckpt_vm_area_kmap(struct page *page)
+{
+        might_sleep();
+
+	#if defined(__i386__)
+		if (!PageHighMem(page))
+			return page_address(page);
+		return kmap_high(page);
+	#else
+		return page_address(page);
+	#endif
+}
+
+
+/**
+ * \<\private\>\> Same problem is before..  We had to duplicate the
+ * highmemory check..
+ *
+ * @param *page - page that is to be unmapped
+ */
+static inline void tcmi_ckpt_vm_area_kunmap(struct page *page)
+{
+	if (in_interrupt())
+                BUG();
+
+	#if defined(__i386__)
+		if (!PageHighMem(page))
+			return;
+		kunmap_high(page);
+	#endif
+}
+
+/**
+ * \<\<private\>\> Helper method that provides a safe mechanism of
+ * copying a page from kernel into the address space of a process that
+ * is being restored. For some reason we can't perform a plain copy
+ * (e.g. using copy_to_user()). It fails on AMD, no idea why. The page
+ * fault handler should be able to put up with the generated
+ * exception. However on AMD, something makes the kernel atomic, which
+ * is a bad thing to have in pagefault handler (see
+ * arch/i386/mm/fault.c). Below is a sample oops that occurs on
+ * copying without this mechanism:
+ *
+ \verbatim
+ Unable to handle kernel paging request at virtual address bffeb000
+  printing eip:
+ c026be4f
+ *pde = 00000000
+ Oops: 0002 [#1]
+ PREEMPT
+ Modules linked in: coda tcmickptcom lp iptable_filter ipt_MASQUERADE ...
+ CPU:    0
+ EIP:    0060:[_mmx_memcpy+111/384]    Not tainted VLI
+ EFLAGS: 00010212   (2.6.11.7)
+ EIP is at _mmx_memcpy+0x6f/0x180
+ eax: bffeb000   ebx: 00000040   ecx: 00000001   edx: c9172000
+ esi: c901d000   edi: bffeb000   ebp: 00001000   esp: c9173dd4
+ ds: 007b   es: 007b   ss: 0068
+ Process testcheckpoint (pid: 3983, threadinfo=c9172000 task=c96706b0)
+ Stack: bffeb000 c0000000 c901d000 bffeb000 c9172000 d0dd1670 bffeb000 c901d000
+        00001000 c901d000 00000112 000bffeb c9172000 c0000000 c9173e6c c9695570
+        d0dd14d2 c9695570 c9173e6c 00000000 00000000 c9173e58 c017a448 c9b40e68
+ Call Trace:
+  [pg0+277272176/1068082176] tcmi_ckpt_vm_area_stack_fixup+0x170/0x204 [tcmickptcom]
+  [pg0+277271762/1068082176] tcmi_ckpt_vm_area_read_h+0x242/0x270 [tcmickptcom]
+  [vfs_read+184/288] vfs_read+0xb8/0x120
+  [pg0+277269799/1068082176] tcmi_ckpt_vm_area_read+0xe7/0x100 [tcmickptcom]
+  [pg0+277266764/1068082176] tcmi_ckpt_read_vmas+0x1c/0x40 [tcmickptcom]
+  [pg0+277264592/1068082176] tcmi_ckptcom_restart+0x300/0x630 [tcmickptcom]
+  [__alloc_pages+754/1120] __alloc_pages+0x2f2/0x460
+  [copy_from_user+106/176] copy_from_user+0x6a/0xb0
+  [pg0+277263824/1068082176] tcmi_ckptcom_restart+0x0/0x630 [tcmickptcom]
+  [search_binary_handler+406/752] search_binary_handler+0x196/0x2f0
+  [do_execve+401/560] do_execve+0x191/0x230
+  [sys_execve+61/512] sys_execve+0x3d/0x200
+  [syscall_call+7/11] syscall_call+0x7/0xb
+ Code: 86 c0 00 00 00 0f 0d 86 00 01 00 00 83 fb 05 7e 59 8b 44 24 18 0f 0d 86 40 01 00 00 0f 6f 06 0f 6f 4
+e 08 0f 6f 56 10 0f 6f 5e 18 <0f> 7f 00 0f 7f 48 08 0f 7f 50 10 0f 7f 58 18 0f 6f 46 20 0f 6f
+  <6>note: testcheckpoint[3983] exited with preempt_count 1
+ Debug: sleeping function called from invalid context at include/linux/rwsem.h:43
+ in_atomic():1, irqs_disabled():0
+ \endverbatim
+ *
+ * This happens when restoring the very first stack page (see
+ * tcmi_ckpt_vm_area_stack_fixup()). The area has been of course
+ * mmapped prior to issuing memcpy. Something has set the kernel
+ * atomic, that's why the pagefault handler oopses. It occurs on AMD
+ * (tested on a Duron laptop and an Athlon XP workstation)
+ *
+ *
+ * @param dst_addr - destination address in user space
+ * @param src_addr - source address in kernel space
+ * @return 0 upon success
+ * @todo Investigate the AMD related issue in page fault handler.
+ */
+static inline int tcmi_ckpt_vm_area_copy_page(unsigned long dst_addr, unsigned long src_addr)
+{
+	struct page *dst_page;
+	struct vm_area_struct *vma;
+	void *kaddr;
+
+	if (get_user_pages(current, current->mm, dst_addr, 1, 1, 1,
+			   &dst_page, &vma) <= 0) {
+		mdbg(ERR3, "Failed to get a user page at %08lx", dst_addr);
+		goto exit0;
+	} 
+	/* actual page, that needs to be written. */
+	kaddr = tcmi_ckpt_vm_area_kmap(dst_page);
+	memcpy(kaddr, (void*)src_addr, PAGE_SIZE);
+	tcmi_ckpt_vm_area_kunmap(dst_page);
+	return 0;
+	
+	/* error handling */
+ exit0:
+	return -EINVAL;
+}
+
+/** Performs a stack setup based on the area just read from the
+ * checkpoint file. */
+static int tcmi_ckpt_vm_area_stack_fixup(struct tcmi_ckpt *ckpt, 
+					 struct tcmi_ckpt_vm_area_hdr *hdr);
+
+#endif /* TCMI_CKPT_VM_AREA_PRIVATE */
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_CKPT_VM_AREA_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/ckpt/tcmi_ckpt_resources.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/ckpt/tcmi_ckpt_resources.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,95 @@
+/**
+ * @file tcmi_ckpt_resources.h - a helper class that provides functionality to checkpoint process rlimits
+ */
+#ifndef _TCMI_CKPT_RESOURCES_H
+#define _TCMI_CKPT_RESOURCES_H
+
+#include <asm/uaccess.h>
+#include <linux/resource.h>
+
+#include "tcmi_ckpt.h"
+
+struct tcmi_ckpt_rlimit {
+          u_int64_t   rlim_cur;
+          u_int64_t   rlim_max;
+}  __attribute__((__packed__));
+
+struct tcmi_ckpt_rlimits {
+	struct tcmi_ckpt_rlimit rlim[RLIM_NLIMITS];
+}  __attribute__((__packed__));
+
+/** 
+ * Writes a current process rlimits into the file
+ *
+ * @param *ckpt - checkpoint file where the area is to be stored
+ * @param *task - current task
+ * @return 0 upon success.
+ */
+static inline int tcmi_ckpt_write_rlimit(struct tcmi_ckpt *ckpt, struct task_struct* task)
+{	
+	struct tcmi_ckpt_rlimits rlims;
+	int i;	
+
+	for ( i=0; i < RLIM_NLIMITS; i++ ) {
+		rlims.rlim[i].rlim_cur = task->signal->rlim[i].rlim_cur;
+		rlims.rlim[i].rlim_max = task->signal->rlim[i].rlim_max;	
+	} 
+
+	if (tcmi_ckpt_write(ckpt, &rlims, sizeof(rlims)) < 0) {
+		mdbg(ERR3, "Error writing resource limits");
+		goto exit0;
+	}
+
+	mdbg(INFO4, "Written resouce limits.");
+
+	return 0;
+		
+	/* error handling */
+ exit0:
+	return -EINVAL;
+
+}
+
+/** 
+ * Reads a process rlimits
+ *
+ * @param *ckpt - checkpoint file where the area is stored
+ * @param *task - current task
+ * @return 0 upon success.
+ */
+static inline int tcmi_ckpt_read_rlimit(struct tcmi_ckpt *ckpt, struct task_struct* task)
+{
+	struct tcmi_ckpt_rlimits rlims;
+	int i;	
+
+	if (tcmi_ckpt_read(ckpt, &rlims, sizeof(rlims)) < 0) {
+		mdbg(ERR3, "Error reading process limits");
+		goto exit0;
+	}
+
+	for ( i=0; i < RLIM_NLIMITS; i++ ) {
+		task->signal->rlim[i].rlim_cur = CHECKED_UINT64_TO_ULONG(rlims.rlim[i].rlim_cur);
+		task->signal->rlim[i].rlim_max = CHECKED_UINT64_TO_ULONG(rlims.rlim[i].rlim_max);
+	} 
+
+	mdbg(INFO4, "Read process limits.");
+
+	return 0;
+		
+	/* error handling */
+ exit0:
+	return -EINVAL;
+}
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_CKPT_RESOURCES_PRIVATE
+
+
+#endif /* TCMI_CKPT_RESOURCES_PRIVATE */
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_CKPT_RESOURCES_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/ckpt/tcmi_ckptcom.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/ckpt/tcmi_ckptcom.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,79 @@
+/**
+ * @file tcmi_ckptcom.h - Process checkpointing component.
+ *                      
+ * 
+ *
+ *
+ * Date: 05/01/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_ckptcom.h,v 1.3 2007/09/02 21:49:42 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_CKPTCOM_H
+#define _TCMI_CKPTCOM_H
+
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/binfmts.h>
+
+struct tcmi_npm_params;
+
+/** @defgroup tcmi_ckptcom_class checkpointing component
+ *
+ * @ingroup tcmi_module_class
+ *
+ * \<\<Singleton\>\> class that creates a checkpoint of a process.
+ * It uses the checkpoint class as a temporary object to store
+ * the state of the process.
+ *
+ * It provides a simple interface that that allows:
+ * - creating a checkpoint into a specified file
+ * - restoring the checkpoint via a new bin_fmt handler that it
+ * registers in the kernel.
+ *
+ * While creating a checkpoint there are two types of checkpoints
+ * supported - heavy and light. See tcmi_ckptcom_checkpoint() for
+ * explanation.
+ *
+ * @{
+ */
+
+/** \<\<public\>\> Creates a preemptive process checkpoint. */
+extern int tcmi_ckptcom_checkpoint_ppm(struct file *file, struct pt_regs *regs, int heavy);
+/** \<\<public\>\> Creates a non-preemptive process checkpoint. */
+extern int tcmi_ckptcom_checkpoint_npm(struct file *file, struct pt_regs *regs, struct tcmi_npm_params* params);
+/** \<\<public\>\> Restarts a process from a checkpoint (new binfmt handler). */
+extern int tcmi_ckptcom_restart(struct linux_binprm *bprm, struct pt_regs *regs);
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_CKPTCOM_PRIVATE
+/** New checkpoint binary format for the kernel. */
+static struct linux_binfmt tcmi_ckptcom_format;
+
+#endif /* TCMI_CKPTCOM_PRIVATE */
+
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_CKPTCOM_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/ckpt/tcmi_ckpt_sig.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/ckpt/tcmi_ckpt_sig.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,172 @@
+/**
+ * @file tcmi_ckpt_sig.h - a class that provides functionality to
+ *                     store a signal settings
+ *                      
+ * 
+ *
+ *
+ * Date: 05/01/2005
+ *
+ * Author: Petr Malat
+ *
+ * $Id: tcmi_ckpt_sig.h,v 1.3 2007/09/03 01:17:58 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_CKPT_SIG_H
+#define _TCMI_CKPT_SIG_H
+
+#include <linux/sched.h>
+#include <linux/signal.h>
+
+#include "tcmi_ckpt.h"
+
+/** @defgroup tcmi_ckpt_mm_class tcmi_ckpt_mm class 
+ *
+ * @ingroup tcmi_ckpt_class
+ *
+ * This is a \<\<singleton\>\> that takes care of (re)storing a
+ * process memory descriptor.
+ *
+ *
+ * 
+ * @{
+ */
+
+struct tcmi_sigset {
+	u_int64_t sigs;
+} __attribute__((__packed__));
+
+
+struct tcmi_k_sigaction {
+	u_int64_t sa_handler;
+	u_int64_t sa_restorer;
+	u_int64_t sa_flags;	
+	struct tcmi_sigset sa_mask;
+} __attribute__((__packed__));
+
+/** Compound structure describes a process memory descriptor.
+ * Explanation if individual items is  e.g. in Understanding
+ * the Linux Kernel(chapter 8)
+ */
+struct tcmi_ckpt_sig_hdr {
+	/** Ponter to alternative signal handler stack */
+	u_int64_t sas_ss_sp;
+	/** Alternative signal handler stack size */
+	u_int64_t sas_ss_size;
+	/** Blocked signals */
+	struct tcmi_sigset blocked;
+	/** Blocked signals */
+	struct tcmi_sigset real_blocked;
+	/** Signal actions */
+	struct tcmi_k_sigaction action[_NSIG];
+} __attribute__((__packed__));
+
+
+/** 
+ * Writes a current process memory descriptor into the checkpoint file. 
+ *
+ * @param *ckpt - checkpoint file where the area is to be stored
+ * @return 0 upon success.
+ */
+static inline int tcmi_ckpt_sig_write(struct tcmi_ckpt *ckpt)
+{
+	struct tcmi_ckpt_sig_hdr sig_hdr;
+	int i;
+
+        /* Now we dump the memory mapping */
+        sig_hdr.sas_ss_sp   = current->sas_ss_sp;
+        sig_hdr.sas_ss_size = current->sas_ss_size;
+	//for(i = 0; i < _NSIG_WORDS; i++){ // Only few bytes
+	        sig_hdr.blocked.sigs       = *(u_int64_t*)(void*)&current->blocked;
+	        sig_hdr.real_blocked.sigs  = *(u_int64_t*)(void*)&current->real_blocked;
+	//}
+
+	// Add pending signals
+	for(i = 0; i < _NSIG; i++){
+		sig_hdr.action[i].sa_handler = (u_int64_t)(long)current->sighand->action[i].sa.sa_handler;
+		sig_hdr.action[i].sa_restorer = (u_int64_t)(long)current->sighand->action[i].sa.sa_restorer;
+		sig_hdr.action[i].sa_flags = current->sighand->action[i].sa.sa_flags;
+		sig_hdr.action[i].sa_mask.sigs = *(u_int64_t*)(void*)&current->sighand->action[i].sa.sa_mask;
+	}
+	
+
+	/* write the header into the checkpoint */
+	if (tcmi_ckpt_write(ckpt, &sig_hdr, sizeof(sig_hdr)) < 0) {
+		mdbg(ERR3, "Error writing signal header");
+		goto exit0;
+	}
+	mdbg(INFO4, "Written signal header");
+	return 0;
+		
+	/* error handling */
+ exit0:
+	return -EINVAL;
+
+}
+
+/** 
+ * Reads a memory area from the checkpoint file and sets the those in
+ * the memory descriptor. This also assumes that the old execution
+ * context has already been flushed by the caller.
+ *
+ * @param *ckpt - checkpoint file where the area is to be stored
+ * @return 0 upon success.
+ */
+static inline int tcmi_ckpt_sig_read(struct tcmi_ckpt *ckpt)
+{
+	struct tcmi_ckpt_sig_hdr sig_hdr;
+	int i;
+
+	/* write the header into the checkpoint */
+	if (tcmi_ckpt_read(ckpt, &sig_hdr, sizeof(sig_hdr)) < 0) {
+		mdbg(ERR3, "Error reading signals");
+		goto exit0;
+	}
+        current->sas_ss_sp   = sig_hdr.sas_ss_sp;
+        current->sas_ss_size = sig_hdr.sas_ss_size;
+	//for(i = 0; i < _NSIG_WORDS; i++){ // Only few bytes
+		current->blocked      = *(sigset_t*)&sig_hdr.blocked.sigs;
+		current->real_blocked = *(sigset_t*)&sig_hdr.real_blocked.sigs;
+	//}
+	// Signal actions
+	for(i = 0; i < _NSIG; i++){
+		current->sighand->action[i].sa.sa_handler = (__sighandler_t)(long)sig_hdr.action[i].sa_handler;
+		current->sighand->action[i].sa.sa_restorer = (__sigrestore_t)(long)sig_hdr.action[i].sa_restorer;
+		current->sighand->action[i].sa.sa_flags = sig_hdr.action[i].sa_flags;
+		current->sighand->action[i].sa.sa_mask = *(sigset_t*)&sig_hdr.action[i].sa_mask.sigs;
+	}
+	return 0;
+		
+	/* error handling */
+ exit0:
+	return -EINVAL;
+}
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_CKPT_SIG_PRIVATE
+
+
+#endif /* TCMI_CKPT_SIG_PRIVATE */
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_CKPT_SIG_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/ckpt/tcmi_ckptcom.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/ckpt/tcmi_ckptcom.c	2013-03-11 08:57:13.000000000 +0100
@@ -0,0 +1,434 @@
+/**
+ * @file tcmi_ckptcom.c - Process checkpointing component.
+ *                      
+ * 
+ *
+ *
+ * Date: 05/01/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_ckptcom.c,v 1.14 2008/01/17 14:36:44 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <linux/module.h>
+#include <linux/fs_struct.h>
+#include <linux/fdtable.h>
+
+#include "tcmi_ckpt.h"
+#include "tcmi_ckpt_mm.h"
+#include "tcmi_ckpt_regs.h"
+#include "tcmi_ckpt_thread.h"
+#include "tcmi_ckpt_fsstruct.h"
+#include "tcmi_ckpt_resources.h"
+
+#define TCMI_CKPTCOM_PRIVATE
+#include "tcmi_ckptcom.h"
+#include "tcmi_ckpt_sig.h"
+#include "tcmi_ckpt_npm_params.h"
+
+#include <arch/current/restart_fixup.h>
+#include <linux/vmalloc.h>
+
+/** 
+ * \<\<private\>\> Helper method that handles both PPM and NPM checkpoint creation
+ * 
+ * This consists of:
+ * - creating a new checkpoint instance 
+ * - writing a checkpoint header - might fail if the process can't be
+ * checkpointed (e.g. has open files or memory areas that are not
+ * supported)
+ * - writing open files
+ * - writing memory descriptor
+ * - writing memory areas along with pages
+ * - writing process state (registers)
+ * - writing signal handlers
+ *
+ * @param *file - file where the checkpoint is to be stored
+ * @param *regs - registers of the checkpointed process
+ * @param heavy - if set a full checkpoint of all process pages
+ * is made, all memory mapped files will be then restored
+ * from the checkpoint image. Setting this options yields
+ * a bigger checkpoint image size..
+ * @param npm_params - Non-preemptive checkpoint params, or null if we are doing PPM checkpoint
+ *
+ * @return 0 upon success
+ */
+static int tcmi_ckptcom_checkpoint(struct file *file, struct pt_regs *regs,
+			    int heavy, struct tcmi_npm_params* npm_params)
+{
+	struct tcmi_ckpt *ckpt;
+	int is_npm = npm_params != NULL;
+	u64 beg_time = 0, end_time = 0 ;
+	
+	beg_time = cpu_clock(smp_processor_id());
+
+	mdbg(INFO3, "Start checkpointing. Is_npm: %d", is_npm);
+	if ( !regs ) {
+		mdbg(ERR3, "Failed to create a checkpoint file. No regs provided");
+		goto exit0;
+	}
+	
+	ckpt = tcmi_ckpt_new(file);
+	if ( IS_ERR(ckpt) ) {
+		mdbg(ERR3, "Failed to create a checkpoint file. Err: %ld", PTR_ERR(ckpt));
+		goto exit0;
+	}
+	if ( ckpt == NULL ) {
+		mdbg(ERR3, "Failed to create a checkpoint file.");
+		goto exit0;
+	}
+
+	if (tcmi_ckpt_write_hdr(ckpt, is_npm) < 0) {
+		mdbg(ERR3, "Error writing checkpoint header!");
+		goto exit1;
+	}
+	if (tcmi_ckpt_write_rlimit(ckpt, current) < 0) {
+		mdbg(ERR3, "Error writing checkpoint rlimit!");
+		goto exit1;
+	}
+	if (tcmi_ckpt_write_files(ckpt) < 0) {
+		mdbg(ERR3, "Error writing checkpoint files!");
+		goto exit1;
+	}
+	if (tcmi_ckpt_mm_write(ckpt) < 0) {
+		mdbg(ERR3, "Error writing memory descriptor!");
+		goto exit1;
+	}
+	
+	if ( !is_npm ) {
+		if (tcmi_ckpt_write_vmas(ckpt, heavy) < 0) {
+			mdbg(ERR3, "Error writing VM areas type: %d", heavy);
+			goto exit1;
+		}
+	}
+
+	if (tcmi_ckpt_regs_write(ckpt, regs) < 0) {
+		mdbg(ERR3, "Error writing processor registers descriptor!");
+		goto exit1;
+	}
+	if (tcmi_ckpt_tls_write(ckpt, current) < 0) {
+		mdbg(ERR3, "Error writing process tls!");
+		goto exit1;
+	}
+	if (tcmi_ckpt_fsstruct_write(ckpt, current) < 0) {
+		mdbg(ERR3, "Error writing process fs struct!");
+		goto exit1;
+	}
+	if (tcmi_ckpt_sig_write(ckpt) < 0) {
+		mdbg(ERR3, "Error writing signal data!");
+		goto exit1;
+	}
+
+	if ( is_npm ) {
+		if (tcmi_ckpt_npm_params_write(ckpt, npm_params) < 0) {
+			mdbg(ERR3, "Error writing npm params!");
+			goto exit1;
+		}	
+	}
+
+	end_time = cpu_clock(smp_processor_id());
+	mdbg(INFO3, "Checkpoint (npm: %d) took '%llu' ms.'", is_npm, (end_time - beg_time) / 1000000);
+	printk("Checkpoint (npm: %d) took '%llu' ms.\n'", is_npm, (end_time - beg_time) / 1000000);
+
+
+	tcmi_ckpt_put(ckpt);
+	return 0;
+
+	/* error handling */
+ exit1:
+	tcmi_ckpt_put(ckpt);
+ exit0:
+	return -ENOEXEC;
+}
+
+/** \<\<public\>\> Creates a preemptive process checkpoint. */
+int tcmi_ckptcom_checkpoint_ppm(struct file *file, struct pt_regs *regs, int heavy) {
+	return tcmi_ckptcom_checkpoint(file, regs, heavy, NULL);
+}
+
+/** \<\<public\>\> Creates a non-preemptive process checkpoint. */
+int tcmi_ckptcom_checkpoint_npm(struct file *file, struct pt_regs *regs, struct tcmi_npm_params* params) {
+	return tcmi_ckptcom_checkpoint(file, regs, 0, params);
+}
+
+/** 
+ * \<\<public\>\> Restarts a process from a checkpoint (new binfmt
+ * handler).  This consists of:
+ *
+ * - creating a new checkpoint instance 
+ * - reading a checkpoint header - might fail, if the magic number
+ * doesn't match.
+ * - reading open files
+ * - reading memory descriptor
+ * - reading memory areas along with pages
+ * - reading process state (registers)
+ * - reading signal handlers
+ *
+ * @param *bprm - binary object that is passed to this method by
+ * execve and contains a pointer to the executable file
+ * @param *regs - references the registers of the process, so that
+ * they can be overlayed from the checkpoint.
+ * @return 0 upon success
+ */
+int tcmi_ckptcom_restart(struct linux_binprm *bprm, struct pt_regs *regs)
+{
+	struct tcmi_ckpt *ckpt;
+	struct pt_regs* original_regs;	
+//	int i;	
+	u64 beg_time = 0, end_time = 0;
+	
+	beg_time = cpu_clock(smp_processor_id());
+	
+
+	memory_sanity_check("Start");
+	
+	original_regs = kmalloc(sizeof(struct pt_regs), GFP_KERNEL);
+	if ( !original_regs )
+		return -ENOMEM;
+
+	if (!tcmi_ckpt_check_magic(bprm->buf)) {
+		goto exit0;
+	}
+	
+	mdbg(INFO3, "Restarting '%s'", bprm->filename);
+	if (!(ckpt = tcmi_ckpt_new(bprm->file))) {
+		mdbg(ERR3, "Failed to instantiate a checkpoint");
+		goto exit0;
+	}
+	if (tcmi_ckpt_read_hdr(ckpt) < 0) {
+		mdbg(ERR3, "Error reading checkpoint header!");
+		goto exit1;
+	}
+memory_sanity_check("Post header");
+	/* Flush all traces of the currently running executable */
+	if (flush_old_exec(bprm)) {
+		mdbg(ERR3, "Error flushing the old execution context!");
+		goto exit0;
+	}
+memory_sanity_check("Pre-rlimit");
+	if (tcmi_ckpt_read_rlimit(ckpt, current) < 0) {
+		mdbg(ERR3, "Error reading checkpoint rlimit!");
+		goto exit1;
+	}
+memory_sanity_check("Post-rlimit");
+	// Replaced macro FD_ISSET to function test_bit with equal parameters by Jiri Rakosnik
+  if ( test_bit(0, current->files->fdt->open_fds) ) {
+		mdbg(INFO3, "Closing open fs.. this should not happend though..");
+		sys_close(0);
+	}
+memory_sanity_check("Pre files");
+	if (tcmi_ckpt_read_files(ckpt) < 0) {
+		mdbg(ERR3, "Error reading checkpoint files!");
+		goto exit1;
+	}
+memory_sanity_check("Post - files");
+	if (tcmi_ckpt_mm_read(ckpt) < 0) {
+		mdbg(ERR3, "Error reading memory descriptor!");
+		goto exit1;
+	}
+memory_sanity_check("Post mm");
+	if ( !ckpt->hdr.is_npm ) {
+		if (tcmi_ckpt_read_vmas(ckpt) < 0) {
+			mdbg(ERR3, "Error reading VM areas");
+			goto exit1;
+		}
+	}
+
+	*original_regs = *regs;
+	if (tcmi_ckpt_regs_read(ckpt, regs) < 0) {
+		mdbg(ERR3, "Error reading processor registers descriptor!");
+		goto exit1;
+	}
+	if (tcmi_ckpt_tls_read(ckpt, current, regs) < 0) {
+		mdbg(ERR3, "Error reading process tls!");
+		goto exit1;
+	}
+	if (tcmi_ckpt_fsstruct_read(ckpt, current) < 0) {
+		mdbg(ERR3, "Error reading process fsstruct!");
+		goto exit1;
+	}
+	if (tcmi_ckpt_sig_read(ckpt) < 0) {
+		mdbg(ERR3, "Error reading signals informations!");
+		goto exit1;
+	}
+	if ( ckpt->hdr.is_npm ) {
+		struct tcmi_npm_params* params = vmalloc(sizeof(struct tcmi_npm_params));
+		int exec_result = -EFAULT;
+		mm_segment_t old_fs;
+		*regs = *original_regs;
+
+		if ( !params ) {
+			mdbg(ERR3, "Cannot allocate memory for npm params!");
+			goto exit1;
+		}
+		
+
+		if (tcmi_ckpt_npm_params_read(ckpt, params) < 0) {
+			mdbg(ERR3, "Error reading npm params!");
+			goto exit1;
+		}				
+		tcmi_ckpt_put(ckpt);
+
+		// TEMPORARY DEBUG!
+		if ( current->mm )
+			mdbg(INFO2, "MM %p nr_ptes: %lu", current->mm, current->mm->nr_ptes);
+		if ( current->active_mm )
+			mdbg(INFO2, "ACTIVE %p MM nr_ptes: %lu", current->active_mm, current->active_mm->nr_ptes);
+
+		// TODO: This is something REALLY NASTY! Some better solution is appreciated
+		if ( current->mm ) {
+			current->mm->nr_ptes = 0;
+		}
+
+		old_fs = get_fs();
+		set_fs(KERNEL_DS);		
+
+		// TEMPORARY DEBUG!
+		if ( current->mm )
+			mdbg(INFO2, "MM %p nr_ptes: %lu", current->mm, current->mm->nr_ptes);
+		if ( current->active_mm )
+			mdbg(INFO2, "ACTIVE %p MM nr_ptes: %lu", current->active_mm, current->active_mm->nr_ptes);
+
+		// We have to unlock temprarily guar to prevent recursive lock (we are calling recursive exceve). TODO: Some better solution?
+		// Moved cred_guard_mutex to struct signal in new kernel 3.7.1 => Fix by Jiri Rakosnik
+    mutex_unlock(&current->signal->cred_guard_mutex);
+		current->fs->in_exec = 0; // Required to pass through 'check_unsafe_exec'
+
+		mdbg(INFO3, "Going to execute '%s', Args: %d, Envps %d", params->file_name, params->argsc, params->envpc);
+		//mdbg(INFO3, "Arg[0] '%s', Envp[0] '%s'", params->args[0], params->envp[0]);
+		
+		exec_result = do_execve(params->file_name, (const char __user * const __user *)params->args, (const char __user * const __user *)params->envp, regs);
+		mdbg(INFO3, "NPM internal execution result %d", exec_result);
+
+		// And now we relock again as the relock of outer execve will be attempted.
+		// Moved cred_guard_mutex to struct signal in new kernel 3.7.1 => Fix by Jiri Rakosnik
+    if (mutex_lock_interruptible(&current->signal->cred_guard_mutex)) {
+			minfo(ERR3, "Failed to relock cred guard!");		
+		}				
+
+		// TODO: How do we release reference to the binmt of the module that was used for this execve.. ?
+		// Do we have to call "set_binfmt(&tcmi_ckptcom_format);" here or can we release it here?
+		set_fs(old_fs);
+
+		vfree(params);
+		mdbg(INFO3, "NPM after param free");		
+
+		if ( exec_result ) {// In case of error of internal execution, we have to return ENOEXEC
+			return -EFAULT;
+		}
+
+		end_time = cpu_clock(smp_processor_id());
+		mdbg(INFO3, "Checkpoint NPM took '%llu' ms.'", (end_time - beg_time) / 1000000);
+		printk("Checkpoint NPM took '%llu' ms.\n'", (end_time - beg_time) / 1000000);
+
+		return 0;
+	} else {
+		// Restart fixup is performed only in PPM
+		tcmi_resolve_restart_block(current, regs, ckpt->hdr.checkpoint_arch, ckpt->hdr.is_32bit_application);
+	}
+	kfree(original_regs);
+	
+	/* flush_signals(current);*/
+	tcmi_ckpt_put(ckpt);
+	/* successul execution of the image - need to set the format */
+	set_binfmt(&tcmi_ckptcom_format);
+
+  end_time = cpu_clock(smp_processor_id());
+	mdbg(INFO3, "Checkpoint PPM took '%llu' ms.'", (end_time - beg_time) / 1000000);
+	printk("Checkpoint PPM took '%llu' ms.\n'", (end_time - beg_time) / 1000000);
+
+	/* Something went wrong, return the inode and free the argument pages*/
+/* 
+What is the point of the following code? It does not really seem to free memory, but in any case, it does not compile on latest kernels ;)
+	for (i = 0 ; i < MAX_ARG_PAGES ; i++) {
+		bprm->page[i] = NULL;
+	}
+*/
+
+	return 0;
+
+	/* error handling */
+ exit1:
+	tcmi_ckpt_put(ckpt);
+ exit0:
+	return -ENOEXEC;
+}
+
+/**
+ * Core dumping function.
+ * Currently just logs some process data.
+ *
+ * @TODO: We should somehow keep track of the original binary format and locate corresponding dump function here and perform original binmt dump
+ */
+static int tcmi_core_dump(struct coredump_params *cprm) {
+	debug_registers(cprm->regs);
+	return 0;
+}
+
+
+/** 
+ * Initializes the migration component.  This requires registering a
+ * new binary format with the kernel.
+ *
+ * @return 0 upon success
+ */
+static int __init tcmi_ckptcom_init(void)
+{
+	register_binfmt(&tcmi_ckptcom_format);
+  return 0;
+}
+
+/** 
+ * Shutdown for the migration component.  This requires unregistering
+ * a new binary format with the kernel.
+ */
+static void __exit tcmi_ckptcom_exit(void)
+{
+	unregister_binfmt(&tcmi_ckptcom_format);
+}
+
+
+/** @addtogroup tcmi_ckptcom_class
+ *
+ * @{
+ */
+/** Initialize the new checkpoint binary format  */
+static struct linux_binfmt tcmi_ckptcom_format = { 
+	.module = THIS_MODULE, 
+	.load_binary = tcmi_ckptcom_restart,	
+	.core_dump = tcmi_core_dump,
+	.min_coredump = 0
+};
+
+/**
+ * @}
+ */
+
+
+module_init(tcmi_ckptcom_init);
+module_exit(tcmi_ckptcom_exit);
+
+EXPORT_SYMBOL_GPL(tcmi_ckptcom_checkpoint_ppm);
+EXPORT_SYMBOL_GPL(tcmi_ckptcom_checkpoint_npm);
+EXPORT_SYMBOL_GPL(tcmi_ckptcom_restart);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Jan Capek");
--- linux-3.7.1_original/clondike/src/tcmi/ckpt/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/ckpt/Makefile	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,27 @@
+##############################################################################
+# @file Makefile - Builds Checkpointing component
+#
+# Author: Petr Malat
+#
+# This file is part of Clondike.
+#
+# Clondike is free software: you can redistribute it and/or modify it under 
+# the terms of the GNU General Public License version 2 as published by 
+# the Free Software Foundation.
+#
+# Clondike is distributed in the hope that it will be useful, but WITHOUT ANY
+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
+# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more 
+# details.
+# 
+# You should have received a copy of the GNU General Public License along with 
+# Clondike. If not, see http://www.gnu.org/licenses/.
+##############################################################################
+
+ccflags-y = `dbgenv $<`
+
+obj-$(CONFIG_TCMI) := tcmickptcom.o
+tcmickptcom-objs   := tcmi_ckptcom.o tcmi_ckpt.o tcmi_ckpt_openfile.o \
+		      tcmi_ckpt_vm_area.o ../../arch/arch_ids.o \
+		      ../../arch/current/regs.o
+
--- linux-3.7.1_original/clondike/src/tcmi/ckpt/tcmi_ckpt_fsstruct.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/ckpt/tcmi_ckpt_fsstruct.h	2013-03-09 12:04:48.000000000 +0100
@@ -0,0 +1,112 @@
+#ifndef _TCMI_CKPT_FSSTRUCT_H
+#define _TCMI_CKPT_FSSTRUCT_H
+
+#include <linux/err.h>
+#include <linux/mount.h>
+#include <linux/fs.h>
+#include <linux/fs_struct.h>
+#include <linux/namei.h>
+#include "tcmi_ckpt.h"
+
+/** Currently only current "pwd" of the process is migrated. If more data are required (like current mount point) extend it
+ * (though for current mount point we have to be careful as on PENs process may run chrooted into distributed FS)
+ *
+ * @TODO: If process is in not "rooted" in root of root fs, we do not handle the migration properly.
+ */
+static inline int tcmi_ckpt_fsstruct_write(struct tcmi_ckpt *ckpt, struct task_struct* task)
+{
+	char* pwd = NULL;
+	int32_t pwdlen;
+	unsigned long page;
+
+	if (!(page = __get_free_page(GFP_KERNEL))) {
+		mdbg(ERR3, "Can't allocate page for pwd pathname!");
+		goto exit0;
+	}
+
+	pwd = d_path(&task->fs->pwd, (char*)page, PAGE_SIZE);
+	if ( IS_ERR(pwd) ) {
+		mdbg(ERR3, "Failed to lookup pwd path!");
+		goto exit1;
+	}
+
+	pwdlen = strlen(pwd)+1;
+		
+	if (tcmi_ckpt_write(ckpt, &pwdlen, sizeof(pwdlen)) < 0) {
+		mdbg(ERR3, "Error writing to checkpoint");
+		goto exit1;
+	}
+
+	if (tcmi_ckpt_write(ckpt, pwd, pwdlen) < 0) {
+		mdbg(ERR3, "Error writing to checkpoint");
+		goto exit1;
+	}
+
+	mdbg(INFO4, "Written pwd path: %s", pwd);
+	free_page(page);
+	return 0;
+		
+	/* error handling */
+ exit1:
+	kfree(pwd);
+ exit0:
+	free_page(page);
+	return -EINVAL;
+}
+
+
+/**
+ * Loads and resotres task's pwd. It is assumed the task is already chrooted in its new root if required.
+ *
+ * There are 3 basic cases:
+ *   1) (PEN) Migrated processes are running chrooted into the distributed file system
+ *   2) (PEN) Migrated processes are running in standard PEN fs and for shared files a distributed filesystem is used. Only file in this filesystem may be used by the process
+ *   3) (CCN) Process is migrated back to its UHN and it has to open real files in the fs (or files in distributed filesystem if option 2 is used)
+ *   
+ * Option 1) does not need any pwdmnt resolution as it is equal to new process current dir. Options 2&3 need resolution of pwdmnt by pwd path. We do the resolution in all 3 options
+ * for simplicity.
+ */
+static inline int tcmi_ckpt_fsstruct_read(struct tcmi_ckpt *ckpt, struct task_struct* task)
+{
+	int32_t pwd_len, error = -EINVAL;
+	char* pwd = NULL;
+	struct nameidata nd;
+	
+	if (tcmi_ckpt_read(ckpt, &pwd_len, sizeof(pwd_len)) < 0) {
+		mdbg(ERR3, "Error reading from ckpt (fsstruct pwdlen)");
+		goto exit0;
+	}
+	
+	pwd = kmalloc(pwd_len, GFP_KERNEL);
+	if ( !pwd )
+		return -ENOMEM;
+
+	if (tcmi_ckpt_read(ckpt, pwd, pwd_len) < 0) {
+		mdbg(ERR3, "Error reading from ckpt (fsstruct pwd)");
+		goto exit0;
+	}
+
+	/* Lookup path data */
+	error = do_path_lookup(AT_FDCWD, pwd, LOOKUP_FOLLOW, &nd);      // Fix for kernel 3.7.1 substitute function path_lookup to do_path_lookup by Jiri Rakosnik 
+	if ( error ) {
+		mdbg(ERR3, "Cannot lookup path: %s", pwd);
+		goto exit0;
+	}
+
+	/* Set current process pwd */
+	//path_get(&nd.path);
+	task->fs->pwd = nd.path;	
+	//path_put(&nd.path);
+
+	mdbg(INFO4, "Pwd set to path: %s", pwd);
+
+	kfree(pwd);
+	return 0;
+		
+	/* error handling */
+ exit0:
+	kfree(pwd);
+	return error;
+}
+
+#endif
--- linux-3.7.1_original/clondike/src/tcmi/ckpt/tcmi_ckpt_regs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/ckpt/tcmi_ckpt_regs.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,139 @@
+/**
+ * @file tcmi_ckpt_regs.h - a helper class that provides functionality to
+ *                     store process registers
+ *                      
+ * 
+ *
+ *
+ * Date: 05/02/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_ckpt_regs.h,v 1.5 2007/09/15 14:46:09 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_CKPT_REGS_H
+#define _TCMI_CKPT_REGS_H
+
+#include <asm/uaccess.h>
+#include <arch/current/regs.h>
+
+#include "tcmi_ckpt.h"
+
+/** 
+ * Writes a current process registers into the checkpoint file.
+ * Adjusts the EIP value if the process has aborted a system call.
+ *
+ * @param *ckpt - checkpoint file where the area is to be stored
+ * @param *regs - registers of the current process
+ * @return 0 upon success.
+ */
+static inline int tcmi_ckpt_regs_write(struct tcmi_ckpt *ckpt, struct pt_regs *regs)
+{	
+	struct tcmi_regs tcmi_regs;
+	int32_t regs_length;
+
+	mdbg(INFO4, "Getting registers: %p", regs);
+
+	/* copy the process registers into the header */
+	get_registers(regs, &tcmi_regs);
+
+	regs_length = sizeof(tcmi_regs);
+	/* write length of the registers structure to ckpt (every architecture can have different length) */
+	if (tcmi_ckpt_write(ckpt, &regs_length, sizeof(regs_length)) < 0) {
+		mdbg(ERR3, "Error writing registers length");
+		goto exit0;
+	}
+
+	/* write the registers into the checkpoint */
+	if (tcmi_ckpt_write(ckpt, &tcmi_regs, sizeof(tcmi_regs)) < 0) {
+		mdbg(ERR3, "Error writing registers");
+		goto exit0;
+	}
+
+	mdbg(INFO4, "Written process registers:");
+	debug_registers(regs);
+
+	return 0;
+		
+	/* error handling */
+ exit0:
+	return -EINVAL;
+
+}
+
+/** 
+ * Reads a process registers from the checkpoint file and sets
+ * them for the current process.
+ *
+ * @param *ckpt - checkpoint file where the area is to be stored
+ * @param *regs - registers of the current process
+ * @return 0 upon success.
+ */
+static inline int tcmi_ckpt_regs_read(struct tcmi_ckpt *ckpt, struct pt_regs *regs)
+{
+	void* platform_regs = NULL;
+	int32_t regs_length;
+
+	if (tcmi_ckpt_read(ckpt, &regs_length, sizeof(regs_length)) < 0) {
+		mdbg(ERR3, "Error reading process register length");
+		goto exit0;
+	}
+
+	platform_regs = kmalloc(regs_length, GFP_KERNEL);
+	if ( !platform_regs ) {
+		mdbg(ERR3, "Not enough memory to load registers");
+		goto exit0;
+	}
+
+	/* Read the regisiters */
+	if (tcmi_ckpt_read(ckpt, platform_regs, regs_length) < 0) {
+		mdbg(ERR3, "Error reading process register descriptor header");
+		goto exit1;
+	}
+
+	load_from_platform_registers(platform_regs, regs, ckpt->hdr.checkpoint_arch, ckpt->hdr.is_32bit_application);
+	platform_start_thread(regs, instruction_pointer(regs), stack_pointer(regs), ckpt->hdr.checkpoint_arch, ckpt->hdr.is_32bit_application);
+
+	mdbg(INFO4, "Read process registers:");
+	debug_registers(regs);
+
+	kfree(platform_regs);
+
+	return 0;
+		
+	/* error handling */
+ exit1:
+	kfree(platform_regs);
+ exit0:
+	return -EINVAL;
+}
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_CKPT_REGS_PRIVATE
+
+
+#endif /* TCMI_CKPT_REGS_PRIVATE */
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_CKPT_REGS_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/ckpt/tcmi_ckpt_thread.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/ckpt/tcmi_ckpt_thread.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,85 @@
+#ifndef _TCMI_CKPT_THREAD_H
+#define _TCMI_CKPT_THREAD_H
+
+#include "tcmi_ckpt.h"
+#include <arch/current/thread.h>
+
+#include <asm/desc.h>
+
+static inline int tcmi_ckpt_tls_write(struct tcmi_ckpt *ckpt, struct task_struct *task) {
+	struct tcmi_thread tcmi_thread;
+	int32_t length;
+	
+	get_tcmi_thread(&task->thread, &tcmi_thread);
+
+	length = sizeof(tcmi_thread);
+	if (tcmi_ckpt_write(ckpt, &length, sizeof(length)) < 0) {
+		mdbg(ERR3, "Error writing thread length");
+		goto exit0;
+	}	
+
+	/* write the header into the checkpoint */
+	if (tcmi_ckpt_write(ckpt, &tcmi_thread, sizeof(struct tcmi_thread)) < 0) {
+		mdbg(ERR3, "Error writing thread data");
+		goto exit0;
+	}
+/*	mdbg(INFO4, "Written tls:");
+	mdbg(INFO4, "GS   : %08lx     FS  : %08lx", task->thread.gs, task->thread.fs);
+*/
+	return 0;
+		
+	/* error handling */
+ exit0:
+	return -EINVAL;
+
+}
+
+
+static inline int tcmi_ckpt_tls_read(struct tcmi_ckpt *ckpt, struct task_struct *task, struct pt_regs *regs)
+{
+	int cpu;
+	
+	int32_t length;
+	void* platform_thread;
+
+	if (tcmi_ckpt_read(ckpt, &length, sizeof(length)) < 0) {
+		mdbg(ERR3, "Error reading thread length");
+		goto exit0;
+	}
+
+	platform_thread = kmalloc(length, GFP_KERNEL);
+	if ( !platform_thread ) {
+		mdbg(ERR3, "Not enough memory for thread struct");
+		goto exit0;
+	}
+
+	if (tcmi_ckpt_read(ckpt, platform_thread, length) < 0) {
+		mdbg(ERR3, "Error reading process register descriptor header");
+		goto exit1;
+	}
+	
+	load_from_platform_thread(platform_thread, &task->thread, ckpt->hdr.checkpoint_arch);
+
+	/* Here we restore a bits of the thread_struct. We cannot copy it whole as there are some parts not-transferable (which?:).. so here we copy just what we know we need */	
+	cpu = get_cpu();
+	resolve_TLS(&task->thread, cpu, regs);
+	put_cpu();
+
+	/* TODO: Resolve FPU with 64 bit in mind! */
+	/* Restore FPU state */
+	//memcpy(&task->thread.i387, &tls.thread.i387, sizeof(task->thread.i387));
+	/* Set TS flag of CR0 in order to enable lazy load of FPU state when required */
+	//stts();
+
+	kfree(platform_thread);
+	return 0;
+		
+	/* error handling */
+ exit1:
+	kfree(platform_thread);
+ exit0:
+	return -EINVAL;
+}
+
+
+#endif
--- linux-3.7.1_original/clondike/src/tcmi/ckpt/tcmi_ckpt.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/ckpt/tcmi_ckpt.h	2013-03-11 08:53:49.000000000 +0100
@@ -0,0 +1,378 @@
+/**
+ * @file tcmi_ckpt.h - a helper class that provides functionality to
+ *                     create a process checkpoint
+ *                      
+ * 
+ *
+ *
+ * Date: 04/30/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_ckpt.h,v 1.7 2007/09/03 20:57:44 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_CKPT_H
+#define _TCMI_CKPT_H
+
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/mm.h>
+#include <asm/uaccess.h>
+
+/** enables access to system calls from kernel */
+#define __KERNEL_SYSCALLS__
+#include <linux/syscalls.h> 
+#include <linux/unistd.h> 
+
+#include "tcmi_fdcache.h"
+
+#include <arch/arch_ids.h> 
+#include <dbg.h>
+
+/** @defgroup tcmi_ckpt_class tcmi_ckpt class 
+ *
+ * @ingroup tcmi_ckptcom_class
+ *
+ * This is a helper class used by the checkpointing component that
+ * provides functionality to:
+ * - write current process into a checkpoint file
+ * - restore a current process from a checkpoint file
+ *
+ * It doesn't do the whole job at once, it relies on its controlling
+ * class (\link tcmi_ckptcom_class checkpointing component \endlink).
+ * The checkpointing component instructs the checkpoint instance what
+ * to do in each step (this applies to creating the checkpoint as
+ * well as restoring the process execution).
+ *
+ * Implementation is Linux kernel specific.
+ * 
+ * @{
+ */
+/** Describes the checkpoint header */
+struct tcmi_ckpt_hdr {
+	/** magic number identifying the checkpoint file. */
+	int32_t magic;
+	/** total count of virtual memory areas. */
+	int32_t map_count;
+	/** total count of open files. */
+	int32_t file_count;
+	/** Architecture (hw) of the checkpointed data */
+	enum arch_ids checkpoint_arch;
+	/** Flag, indicating whether the checkpointed application was 32 bit application (otherwise 64 bit is assumed) */
+	int8_t is_32bit_application;
+	/** 1, if this is checkpoint created as a result of non-preemptive migration request (0 otherwise) */
+	int8_t is_npm;
+	/** Process executable name */
+	char comm[TASK_COMM_LEN];
+} __attribute__((__packed__));
+
+/** Compound structure that gathers necessary process information. */
+struct tcmi_ckpt {
+	/** Actual file used create/restore the process checkpoint */
+	struct file *file;
+
+	/** File descriptor cache - used when indentifying descriptors
+	 * referencing the same file. */
+	struct tcmi_fdcache *fdcache;
+
+	/** Checkpoint header */
+	struct tcmi_ckpt_hdr hdr;
+
+	/** Instance reference counter. */
+	atomic_t ref_count;
+};
+
+/** Casts to the checkpoint  instance. */
+#define TCMI_CKPT(ckpt) ((struct tcmi_ckpt*)ckpt)
+
+/** a magic number for the header  */
+#define TCMI_CKPT_MAGIC 0xdeadbeef
+
+/** \<\<public\>\> Checkpoint constructor. */
+extern struct tcmi_ckpt* tcmi_ckpt_new(struct file *file);
+
+/** \<\<public\>\> Writes a checkpoint header. */
+extern int tcmi_ckpt_write_hdr(struct tcmi_ckpt *self, int is_npm);
+/** \<\<public\>\> Reads a checkpoint header. */
+extern int tcmi_ckpt_read_hdr(struct tcmi_ckpt *self);
+
+/** \<\<public\>\> Writes open files into the checkpoint. */
+extern int tcmi_ckpt_write_files(struct tcmi_ckpt *self);
+/** \<\<public\>\> Reads open files from the checkpoint. */
+extern int tcmi_ckpt_read_files(struct tcmi_ckpt *self);
+
+/** \<\<public\>\> Writes process memory regions into the checkpoint. */
+extern int tcmi_ckpt_write_vmas(struct tcmi_ckpt *self, int heavy);
+/** \<\<public\>\> Reads process memory regions from the checkpoint. */
+extern int tcmi_ckpt_read_vmas(struct tcmi_ckpt *self);
+
+/** \<\<public\>\> Writes process CPU registers into the checkpoint. */
+extern int tcmi_ckpt_write_regs(struct tcmi_ckpt *self, struct pt_regs *regs);
+/** \<\<public\>\> Reads process CPU registers from the checkpoint. */
+extern int tcmi_ckpt_read_regs(struct tcmi_ckpt *self, struct pt_regs *regs);
+
+/** \<\<public\>\> Writes signals related stuff into the checkpoint. */
+//extern int tcmi_ckpt_sig_write(struct tcmi_ckpt *self);
+/** \<\<public\>\> Reads signals related stuff from the checkpoint. */
+//extern int tcmi_ckpt_sig_read(struct tcmi_ckpt *self);
+
+/**
+ * \<\<public\>\> Performs a quick check if the specified buffer
+ * contains a valid magic number of the checkpoint file.
+ *
+ * @param *buf - buffer containing the magic number
+ * @return true when valid.
+ */
+static inline int tcmi_ckpt_check_magic(void *buf)
+{
+	return ((struct tcmi_ckpt_hdr*)buf)->magic == TCMI_CKPT_MAGIC;
+}
+
+/** 
+ * \<\<public\>\> Instance accessor, increments the reference counter.
+ *
+ * @param *self - pointer to this checkpoint instance
+ * @return tcmi_ckpt instance
+ */
+static inline struct tcmi_ckpt* tcmi_ckpt_get(struct tcmi_ckpt *self)
+{
+	if (self) {
+		atomic_inc(&self->ref_count);
+	}
+	return self;
+}
+
+
+/** 
+ * \<\<public\>\> Releases the instance.
+ *
+ * @param *self - pointer to this instance
+ */
+static inline void tcmi_ckpt_put(struct tcmi_ckpt *self)
+{
+	if (self && atomic_dec_and_test(&self->ref_count)) {
+		mdbg(INFO4, "Destroying TCMI ckpt, %p", self);
+		fput(self->file);
+		tcmi_fdcache_put(self->fdcache);
+		kfree(self);
+	}
+}
+
+
+
+/** Describes the signature of the VFS method (typically vfs_read or vfs_write */
+typedef ssize_t vfs_method_t(struct file*, char __user*, size_t, loff_t*);
+
+/**
+ * \<\<private\>\> Executes a specified VFS method on the checkpoint
+ * file.
+ *
+ * @param *self - this checkpoint instance
+ * @param *data - buffer for the data
+ * @param count - number of bytes to be processed
+ * @param *vfs_method - VFS method to be executed on the checkpoint
+ * and data
+ * @return 0 upon successful vfs method execution or an error (< 0)
+ */
+static inline int tcmi_ckpt_read_write(struct tcmi_ckpt *self, 
+				       void *data, int count,
+				       vfs_method_t *vfs_method)
+{
+	mm_segment_t old_fs;
+	int result = 0;
+
+	old_fs = get_fs();
+	set_fs(get_ds());
+	/* The cast to a user pointer is valid due to the set_fs() */
+	result = vfs_method(self->file, (void __user *)data, count, &self->file->f_pos);
+	set_fs(old_fs);
+
+	return (result == count ? 0 : -EINVAL);
+}
+
+/**
+ * \<\<public\>\> Writes a specified number of bytes into a
+ * checkpoint file.  
+ *
+ * @param *self - this checkpoint instance
+ * @param *data - data to be written
+ * @param count - number of bytes to be written
+ * @return 0 upon successful write of count bytes
+ */
+static inline int tcmi_ckpt_write(struct tcmi_ckpt *self, void *data, int count)
+{
+	return tcmi_ckpt_read_write(self, data, count, (vfs_method_t*)vfs_write);
+}
+
+/**
+ * \<\<public\>\> Reads a specified number of bytes from a checkpoint
+ * file. 
+ *
+ * @param *self - this checkpoint instance
+ * @param *data - buffer for the data
+ * @param count - number of bytes to be read
+ * @return 0 upon successful write of count bytes
+ */
+static inline int tcmi_ckpt_read(struct tcmi_ckpt *self, void *data, int count)
+{
+	mdbg(INFO3, "CKPT read to %p, count %d bytes", data, count);
+	return tcmi_ckpt_read_write(self, data, count, (vfs_method_t*)vfs_read);
+}
+
+
+/**
+ * \<\<public\>\> Seeks in the checkpoint file based on specified
+ * offset.
+ * 
+ * @param *self - this checkpoint instance
+ * @param *offset - relative offset
+ * @param origin - 0 - offset is absolute from file start
+ *                 1 - offset is relative from current file position
+ *                 2 - offset is relative from end of file
+ * @return new file position or error (< 0)
+ */
+static inline loff_t tcmi_ckpt_seek(struct tcmi_ckpt *self, loff_t offset, int origin)
+{
+	return vfs_llseek(self->file, offset, origin);
+}
+
+
+/**
+ * \<\<public\>\> Helper method that performs a memory mapping on the
+ * checkpoint file at its current offset. After that the position is
+ * advanced by len bytes.
+ * 
+ * @param *self - this checkpoint instance
+ * @param addr - starting address where the 
+ * @param len - length of the region
+ * @param prot - access rights of the pages included in the memory
+ * region
+ * @param flags - memory region flags (see mm.h)
+ * @return new file position or error (< 0)
+ */
+static inline unsigned long tcmi_ckpt_do_mmap(struct tcmi_ckpt *self, unsigned long addr,
+					      unsigned long len, unsigned long prot,
+					      unsigned long flags)
+{
+
+	mdbg(INFO4, "Mapping VMA start:%08lx, len %08lx, prot: %08lx, flags: %08lx, pgoff: %08Lx", 
+	     addr, len, prot, flags, self->file->f_pos >> PAGE_SHIFT);
+
+	down_write(&current->mm->mmap_sem);
+	addr = do_mmap_pgoff(self->file, addr, len, prot, flags, self->file->f_pos);  //Replaced function do_mmap to do_mmap_pgoff for kernel 3.7.x by Jiri Rakosnik
+	up_write(&current->mm->mmap_sem);
+
+	tcmi_ckpt_seek(self, len, 1);
+
+	mdbg(INFO4, "Memory mapping at %08lx, new off %08Lx", addr, self->file->f_pos);
+	return addr;
+}
+
+/**
+ * \<\<public\>\> Aligns the position in the checkpoint file to page
+ * boundary.  This is needed when reading or writing pages.
+ * 
+ * @param *self - this checkpoint instance
+ * @return new file position or error (< 0)
+ */
+static inline loff_t tcmi_ckpt_page_align(struct tcmi_ckpt *self)
+{
+	return vfs_llseek(self->file, (self->file->f_pos + PAGE_SIZE - 1) & PAGE_MASK, 0);
+}
+
+
+/**
+ * \<\<public\>\> Adds a file descriptor - file object pair into the
+ * fd cache. This information will be used for later lookup of
+ * duplicate file descriptors.
+ * 
+ * @param *self - this checkpoint instance
+ * @param fd - file descriptor of the file
+ * @param *file - file object - used for duplicate file descriptor lookup
+ * @return 0 upon success
+ */
+static inline int tcmi_ckpt_fdcache_add(struct tcmi_ckpt *self, int fd, struct file *file)
+{
+	return tcmi_fdcache_add(self->fdcache, fd, file);
+}
+
+/**
+ * \<\<public\>\> Searches the file descriptor cache for a file.
+ *
+ * @param *self - this checkpoint instance
+ * @param *file - file object to be looked up
+ * @return file descriptor of the file or error (< 0)
+ */
+static inline int tcmi_ckpt_fdcache_lookup(struct tcmi_ckpt *self, struct file *file)
+{
+	return tcmi_fdcache_lookup(self->fdcache, file);
+}
+
+/** 
+ * \<\<public\>\> Iterates through all open files 
+ *
+ * @param file - current file
+ * @param fd - descriptor of the file
+ * Replaced macro FD_ISSET to function test_bit | by Jiri Rakosnik
+ */
+#define tcmi_ckpt_foreach_openfile(file, fd)						\
+	for (fd = 0, file = current->files->fdt->fd[fd]; 					\
+	     fd < current->files->fdt->max_fds; fd++, file = current->files->fdt->fd[fd])		\
+		if (test_bit(fd, current->files->fdt->open_fds)) 
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_CKPT_PRIVATE
+
+/** Calculates the number of memory regions of the current process. */
+static int tcmi_ckpt_map_count(struct tcmi_ckpt *self);
+
+/** Calculates the number of open files of the current process. */
+static int tcmi_ckpt_file_count(struct tcmi_ckpt *self);
+
+/**
+ * Initializes filedescriptor cache for a given file count
+ * 
+ * @param *self - this checkpoint instance
+ * @param count - maximum number of files that it will retain.
+ */
+static inline int tcmi_ckpt_fdcache_init(struct tcmi_ckpt *self)
+{
+	self->fdcache = tcmi_fdcache_new(self->hdr.file_count);
+	return self->fdcache ? 0 : -ENOMEM;
+}
+
+
+
+/** Iterates through all VM areas */
+#define tcmi_ckpt_foreach_vma(vma)				\
+for (vma = current->mm->mmap; vma != NULL; vma = vma->vm_next) 
+
+
+
+#endif /* TCMI_CKPT_PRIVATE */
+
+
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_CKPT_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/ckpt/tcmi_ckpt_npm_params.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/ckpt/tcmi_ckpt_npm_params.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,129 @@
+/**
+ * @file tcmi_ckpt_npm_params.h - a helper class that provides functionality to
+ *                    non-preemtive migration process parameters (args, env,..)
+ */
+#ifndef _TCMI_CKPT_NPM_PARAMS_H
+#define _TCMI_CKPT_NPM_PARAMS_H
+
+#include "tcmi_ckpt.h"
+#include <tcmi/migration/tcmi_npm_params.h>
+
+/** 
+ * Writes non-preemptive process startup params to the checkpoint.
+ *
+ * @param *ckpt - checkpoint file where the area is to be stored
+ * @param *params - contains current process npm params
+ * @return 0 upon success.
+ */
+static inline int tcmi_ckpt_npm_params_write(struct tcmi_ckpt *ckpt, struct tcmi_npm_params* params) {
+	u_int32_t data_length, filename_length = strlen(params->file_name) + 1;
+	mdbg(INFO3, "Going to write npm '%s', Args: %d, Envps %d (Filename length: %d, Data length: %d)", params->file_name, params->argsc, params->envpc, filename_length, params->used_data_length);
+
+
+	if (tcmi_ckpt_write(ckpt, &params->argsc, sizeof(u_int8_t)) < 0) {
+		mdbg(ERR3, "Error writing npm params");
+		goto exit0;
+	}
+
+	if (tcmi_ckpt_write(ckpt, &params->envpc, sizeof(u_int8_t)) < 0) {
+		mdbg(ERR3, "Error writing npm params");
+		goto exit0;
+	}
+
+	if (tcmi_ckpt_write(ckpt, &filename_length, sizeof(u_int32_t)) < 0) {
+		mdbg(ERR3, "Error writing npm params");
+		goto exit0;
+	}
+
+	if (tcmi_ckpt_write(ckpt, params->file_name, filename_length) < 0) {
+		mdbg(ERR3, "Error writing npm params");
+		goto exit0;
+	}
+
+	data_length = params->used_data_length;
+
+	if (tcmi_ckpt_write(ckpt, &data_length, sizeof(u_int32_t)) < 0) {
+		mdbg(ERR3, "Error writing npm params");
+		goto exit0;
+	}
+
+	if (tcmi_ckpt_write(ckpt, params->data, data_length) < 0) {
+		mdbg(ERR3, "Error writing npm params");
+		goto exit0;
+	}	
+	
+	mdbg(INFO4, "Written npm params. Size: %d.", (filename_length+data_length));
+
+	return 0;
+		
+	/* error handling */
+ exit0:
+	return -EINVAL;
+}
+
+/** 
+ * Reads non-preemptive process startup params from the checkpoint
+ *
+ * @param *ckpt - checkpoint file where the area is to be stored
+ * @param *params - This structure will be filled with the npm params
+ * @return 0 upon success.
+ */
+static inline int tcmi_ckpt_npm_params_read(struct tcmi_ckpt *ckpt, struct tcmi_npm_params* params) {
+	u_int32_t data_length, filename_length;
+
+	if (tcmi_ckpt_read(ckpt, &params->argsc, sizeof(u_int8_t)) < 0) {
+		mdbg(ERR3, "Error reading npm params");
+		goto exit0;
+	}
+
+	if (tcmi_ckpt_read(ckpt, &params->envpc, sizeof(u_int8_t)) < 0) {
+		mdbg(ERR3, "Error reading npm params");
+		goto exit0;
+	}
+
+	if (tcmi_ckpt_read(ckpt, &filename_length, sizeof(u_int32_t)) < 0) {
+		mdbg(ERR3, "Error reading npm params");
+		goto exit0;
+	}
+
+	if (tcmi_ckpt_read(ckpt, params->file_name, filename_length) < 0) {
+		mdbg(ERR3, "Error reading npm params");
+		goto exit0;
+	}
+
+	if (tcmi_ckpt_read(ckpt, &data_length, sizeof(u_int32_t)) < 0) {
+		mdbg(ERR3, "Error reading npm params");
+		goto exit0;
+	}
+
+	if (tcmi_ckpt_read(ckpt, params->data, data_length) < 0) {
+		mdbg(ERR3, "Error reading npm params");
+		goto exit0;
+	}
+
+	// We have to fixup args pointers in params structure
+	fixup_npm_params_pointers(params);
+
+	mdbg(INFO4, "Read npm params. Size: %d.", (filename_length+data_length));
+	mdbg(INFO3, "Read npm '%s', Args: %d, Envps %d", params->file_name, params->argsc, params->envpc);
+
+	return 0;
+		
+	/* error handling */
+ exit0:
+	return -EINVAL;
+}
+
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_CKPT_NPM_PARAMS_PRIVATE
+
+
+#endif /* TCMI_CKPT_REGS_PRIVATE */
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_CKPT_NPM_PARAMS_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/ckpt/tcmi_ckpt_openfile.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/ckpt/tcmi_ckpt_openfile.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,381 @@
+/**
+ * @file tcmi_ckpt_openfile.c - a helper class that provides functionality to
+ *                              store/restore information about an open file in the checkpoint
+ *                      
+ * 
+ *
+ *
+ * Date: 04/30/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_ckpt_openfile.c,v 1.10 2007/11/05 19:38:28 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include "tcmi_ckpt.h"
+#include <clondike/tcmi/tcmi_struct.h>
+
+#define TCMI_CKPT_OPENFILE_PRIVATE
+#include "tcmi_ckpt_openfile.h"
+
+#include <proxyfs/proxyfs_server.h>
+#include <proxyfs/proxyfs_helper.h>
+#include <proxyfs/proxyfs_file.h>
+
+#include <linux/syscalls.h>
+
+/** 
+ * \<\<public\>\> Writes an open file information into the
+ * checkpoint file.
+ * Writing the information about an open file requires:
+ * - checking if there is the same file object already stored
+ * in the file descriptor cache of the checkpoint. This indicates
+ * that such file has already been written into the checkpoint.
+ * In that case we delegate the work to write_dupfd.
+ * - othewise we delegate the work to write_newfd method that
+ * stores the full file information in about the file.
+ *
+ * @param *ckpt - checkpoint instance, that we are writing into
+ * @param fd - file descriptor of associated with the file object
+ * @param *file - file whose information is be written
+ * @return 0 upon succes
+ */
+int tcmi_ckpt_openfile_write(struct tcmi_ckpt *ckpt, int fd, struct file *file)
+{
+	int dup_fd;
+	int err;
+
+	/* search for the file descriptor in the cache first */
+	if ( (dup_fd = tcmi_ckpt_fdcache_lookup(ckpt, file)) >= 0)
+		err = tcmi_ckpt_openfile_write_dupfd(ckpt, fd, dup_fd);
+	/* not found, write the whole file details. */
+	else
+		err = tcmi_ckpt_openfile_write_newfd(ckpt, fd, file);
+
+	return err;
+}
+
+/** 
+ * \<\<public\>\> Reads and restores an open file from the checkpoint
+ * file. Restoring the open file requires:
+ * - detecting whether the file to be restored requires only
+ * duplication of an existing file descriptor or reopening the file
+ * from scratch.
+ * - after reading the header, the work is delegated to corresponding
+ * method.
+ *
+ * @param *ckpt - checkpoint instance, that we are restoring from
+ * @return 0 upon succes
+ */
+int tcmi_ckpt_openfile_read(struct tcmi_ckpt *ckpt)
+{
+	int err = -EINVAL;
+	struct tcmi_ckpt_openfile_generic_hdr hdr;
+	if (tcmi_ckpt_read(ckpt, &hdr, sizeof(hdr)) < 0) {
+			mdbg(ERR3, "Error reading file generic header");
+			err = -EINVAL;
+			goto exit0;
+	}
+	mdbg(INFO3, "Read generic file header restore type: %08x", hdr.restore_type);
+
+	switch (hdr.restore_type) {
+		case TCMI_CKPT_OPENFILE_NEWFILE:
+			err = tcmi_ckpt_openfile_read_newfd(ckpt);
+			break;
+		case TCMI_CKPT_OPENFILE_DUPFILE:
+			err = tcmi_ckpt_openfile_read_dupfd(ckpt);
+			break;
+		default:
+			mdbg(ERR3, "Unknown restore type %x", hdr.restore_type);
+			err = -EINVAL;
+			break;
+	}
+	return err;
+
+	/* error handling */
+ exit0:
+	return -EINVAL;
+}
+
+
+/** @addtogroup tcmi_ckpt_openfile_class
+ *
+ * @{
+ */
+
+/**
+ *  \<\<private\>\> Writes a duplicate file descriptor chunk into the
+ *  checkpoint file.
+ * 
+ * @param *ckpt - this checkpoint instance
+ * @param fd - original file descriptor
+ * @param dup_fd - duplicate file descriptor that references the same file
+ * as fds 
+ * @return 0 upon succes
+ */
+static int tcmi_ckpt_openfile_write_dupfd(struct tcmi_ckpt *ckpt, int fd, int dup_fd)
+{
+	struct tcmi_ckpt_openfile_generic_hdr gen_hdr;
+	struct tcmi_ckpt_openfile_dupfile_hdr dup_hdr;
+
+	gen_hdr.restore_type = TCMI_CKPT_OPENFILE_DUPFILE;
+	/* restore type identifier header */
+	if (tcmi_ckpt_write(ckpt, &gen_hdr, sizeof(gen_hdr)) < 0) {
+		mdbg(ERR3, "Error writing file generic header");
+		goto exit0;
+	}
+	dup_hdr.fd = fd;
+	dup_hdr.dup_fd = dup_fd;
+	if (tcmi_ckpt_write(ckpt, &dup_hdr, sizeof(dup_hdr)) < 0) {
+		mdbg(ERR3, "Error writing dupfd chunk");
+		goto exit0;
+	}
+	mdbg(INFO3, "Written dupfd  fd=%d, dup_fd=%d", fd, dup_fd);
+	return 0;
+	/* error handling */
+ exit0:
+	return -EINVAL;
+}
+
+/**
+ *  \<\<private\>\> Writes a new file chunk into the checkpoint file.
+ * This includes:
+ * - file descriptor
+ * - current position in the file
+ * - length of the file pathname
+ * - filepathname
+ *
+ * @param *ckpt - this checkpoint instance
+ * @param fd - file descriptor
+ * @param *file - file object to be written into the checkpoint
+ * @return 0 upon succes
+ */
+static int tcmi_ckpt_openfile_write_newfd(struct tcmi_ckpt *ckpt, int fd, struct file *file)
+{
+	struct tcmi_ckpt_openfile_generic_hdr gen_hdr;
+	struct tcmi_ckpt_openfile_newfile_hdr new_hdr;
+	/* page for the filepathname */
+	unsigned long page;
+	char *pathname;
+
+	gen_hdr.restore_type = TCMI_CKPT_OPENFILE_NEWFILE;
+
+	/* write the generic header first */
+	if (tcmi_ckpt_write(ckpt, &gen_hdr, sizeof(gen_hdr)) < 0) {
+		mdbg(ERR3, "Error writing file generic header");
+		goto exit0;
+	}
+
+	new_hdr.fd = fd;
+	new_hdr.pos = file->f_pos;
+	new_hdr.flags = file->f_flags;
+	new_hdr.mode = file->f_mode;
+	new_hdr.type = file->f_dentry->d_inode->i_mode;
+	new_hdr.pathname_size = 0;
+	mdbg(INFO3, "File pos: %llu", (unsigned long long)file->f_pos);
+	mdbg(INFO3, "Write: Fd: %ld, Pos %llu, File name size: %lu, Flags: %08lo, Mode: %08lo", (long)new_hdr.fd, (unsigned long long)new_hdr.pos, (unsigned long)new_hdr.pathname_size, (unsigned long)new_hdr.flags, (unsigned long)new_hdr.mode);
+
+	/* resolve the path name. */
+	if (!(page = __get_free_page(GFP_KERNEL))) {
+		mdbg(ERR3, "Can't allocate page for file pathname!");
+		goto exit0;
+	}
+
+	// By default files are simply reopened
+	// WARNING: Very important! Buffer length is returned as a PAGE_SIZE - 1000. THe d_path fills in path from the end of the buffer
+	// and if we return full buffer size, we are not able to append anything to the string, but we want to do that for the proxy files!
+	if (IS_ERR(pathname = d_path(&file->f_path, (char*)page, PAGE_SIZE - 1000))) {
+		mdbg(ERR3, "Can't resolve pathname for '%s'", file->f_dentry->d_name.name);
+		goto exit1;
+	}
+
+	if ( !is_proxyfs_file(pathname) && ((S_ISCHR(new_hdr.type) || S_ISFIFO(new_hdr.type))) ){ // Special file, use proxyfs
+		// Overtake only for shadow tasks and exclude dev-null
+		if( current->tcmi.tcmi_task && current->tcmi.task_type == shadow && !is_dev_null(pathname) ){
+			struct proxyfs_file_identifier* fileident = proxyfs_server_overtake_file(fd);
+
+			if( fileident == NULL ){
+				mdbg(ERR3, "Registering file in proxyfs_server failed!");
+				goto exit1;
+			}
+
+			mdbg(INFO3, "BEFORE PROXY FS NAME: %s", pathname);
+			create_proxyfs_name(current, pathname, fileident->file_ident);
+			mdbg(INFO3, "AFTER PROXY FS NAME: %s", pathname);
+		}
+	}
+
+	new_hdr.pathname_size = strlen(pathname) + 1;
+	/* write the header and the pathname into the checkpoint */
+	if (tcmi_ckpt_write(ckpt, &new_hdr, sizeof(new_hdr)) < 0) {
+		mdbg(ERR3, "Error writing newfd chunk");
+		goto exit1;
+	}
+	if (tcmi_ckpt_write(ckpt, pathname, new_hdr.pathname_size) < 0) {
+		mdbg(ERR3, "Error writing file pathname chunk");
+		goto exit1;
+	}
+	tcmi_ckpt_fdcache_add(ckpt, fd, file);
+	mdbg(INFO4, "Written new file descriptor fd=%d, type=%0o '%s'", fd, new_hdr.type, pathname);	
+	free_page(page);	
+	return 0;
+
+	/* error handling */
+ exit1:
+	free_page(page);
+ exit0:
+	return -EINVAL;
+}
+
+/**
+ * \<\<private\>\> Reads a duplicate file descriptor chunk from the
+ * checkpoint file.  The original file descriptor (dup_fd) is
+ * duplicated into the file descriptor of this chunk (fd). Both then
+ * refer to the same file.
+ * 
+ * @param *ckpt - checkpoint instance
+ * @return 0 upon succes
+ */
+static int tcmi_ckpt_openfile_read_dupfd(struct tcmi_ckpt *ckpt)
+{
+	struct tcmi_ckpt_openfile_dupfile_hdr dup_hdr;
+
+	int err = 0;
+
+	if (tcmi_ckpt_read(ckpt, &dup_hdr, sizeof(dup_hdr)) < 0) {
+		mdbg(ERR3, "Error reading dupfd chunk");
+		goto exit0;
+	}
+	if ((err = sys_dup2(dup_hdr.dup_fd, dup_hdr.fd)) != dup_hdr.fd) {
+		mdbg(ERR3, "Error duplicating file descriptor %d into %d, error=%d!", 
+		     dup_hdr.dup_fd, dup_hdr.fd, err);
+		goto exit0;
+	}
+	mdbg(INFO4, "Restored duplicate file descriptor fd=%d, dup_fd=%d", dup_hdr.fd, dup_hdr.dup_fd);
+	return 0;
+
+	/* error handling */
+ exit0:
+	return -EINVAL;
+}
+
+/**
+ *  \<\<private\>\> Reads a new file chunk from the checkpoint file.
+ * This includes:
+ * - file descriptor
+ * - current position in the file
+ * - length of the file pathname
+ * - filepathname
+ * Opens the file with the same descriptor(might require using dup2 system call)
+ * and seeks to the specified position. Since the stdin/stdout/stderr might
+ * appear in the checkpoint image, we skip those for now - they are
+ * of type character device.
+ *
+ * @param *ckpt - checkpoint instance
+ */
+static int tcmi_ckpt_openfile_read_newfd(struct tcmi_ckpt *ckpt)
+{
+	struct tcmi_ckpt_openfile_newfile_hdr new_hdr;
+	mm_segment_t old_fs;
+	int fd = -1;
+	/* page for the filepathname */
+	unsigned long page;
+
+
+	old_fs = get_fs();
+	set_fs(get_ds());
+
+	if (tcmi_ckpt_read(ckpt, &new_hdr, sizeof(new_hdr)) < 0) {
+		mdbg(ERR3, "Error reading newfd chunk");
+		goto exit0;
+	}
+	mdbg(INFO3, "Read: Fd: %ld, Pos %llu, File name size: %lu, Flags: %08lo, Mode: %08lo", (long)new_hdr.fd, (unsigned long long)new_hdr.pos, (unsigned long)new_hdr.pathname_size, (unsigned long)new_hdr.flags, (unsigned long)new_hdr.mode);
+
+	if ( new_hdr.pathname_size >= PAGE_SIZE )
+		goto exit0;
+
+	/* resolve the path name. */
+	if (!(page = __get_free_page(GFP_KERNEL))) {
+		mdbg(ERR3, "Can't allocate page for file pathname!");
+		goto exit0;
+	}
+	if (tcmi_ckpt_read(ckpt, (char *)page, new_hdr.pathname_size) < 0) {
+		mdbg(ERR3, "Error reading file pathname chunk");
+		goto exit1;
+	}
+
+	/* reopen directory and regular files  */
+	if ((S_ISDIR(new_hdr.type) || S_ISREG(new_hdr.type) || S_ISCHR(new_hdr.type) || S_ISFIFO(new_hdr.type))) {
+		/* open */
+		if ((fd = do_sys_open(AT_FDCWD, (char*)page, (int)new_hdr.flags, (int)new_hdr.mode)) < 0) {
+			mdbg(ERR3, "Error opening file '%s', err=%d", (char*)page, fd);
+			goto exit1;
+		}
+		/* setup the file position */
+		if (new_hdr.pos != vfs_llseek(current->files->fdt->fd[fd], new_hdr.pos, 0)) {
+			mdbg(ERR3, "Failed to set position %Lx in file '%s'", new_hdr.pos, (char*)page);
+			goto exit1;
+		}
+	}
+
+	/*
+	if ( S_ISCHR(new_hdr.type) || S_ISFIFO(new_hdr.type) ){ // Forward operations via proxyfile
+		mdbg(INFO3, "File '%s' fd = %d will be accesed trought proxyfile", (char*)page, new_hdr.fd);
+		tcmi_ckpt_proxy_path((char*)page, (char*)page);
+		mdbg(INFO3, "Opening file '%s' fd = %d", (char*)page, new_hdr.fd);
+		if ((fd = sys_open((char*)page, new_hdr.flags, new_hdr.mode)) < 0) {
+			mdbg(ERR3, "Error opening file '%s', err=%d", (char*)page, fd);
+			goto exit1;
+		}
+	}
+	*/
+
+	/* set the original descriptor of the file */
+	if (new_hdr.fd != fd) {
+		mdbg(INFO3, "Duplicating file descriptor %d into %d!", fd, new_hdr.fd);		
+		if (sys_dup2(fd, new_hdr.fd) != new_hdr.fd) {
+			mdbg(ERR3, "Error duplicating file descriptor %d into %d!", fd, new_hdr.fd);
+			goto exit1;
+		}
+		sys_close(fd);
+	}
+
+	mdbg(INFO4, "Restored new file descriptor fd=%d, pos=%Lx, type=%0o, "
+	     "pathname_size=%d, pathname='%s'",
+	     new_hdr.fd, new_hdr.pos, new_hdr.type, new_hdr.pathname_size, (char*)page);
+
+	free_page(page);
+	set_fs(old_fs);
+
+	return 0;
+
+	/* error handling */
+
+ exit1:
+	free_page(page);
+ exit0:
+	set_fs(old_fs);
+	return -EINVAL;
+}
+
+/**
+ * @}
+ */
+
--- linux-3.7.1_original/clondike/src/tcmi/ckpt/tcmi_fdcache.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/ckpt/tcmi_fdcache.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,202 @@
+/**
+ * @file tcmi_fdcache.h - a helper class that allows caching of used file descriptors.
+ *                      and lookup of duplicate file descriptors.
+ * 
+ *
+ *
+ * Date: 05/02/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_fdcache.h,v 1.2 2007/07/02 02:26:17 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_FDCACHE_H
+#define _TCMI_FDCACHE_H
+
+#include <asm/atomic.h>
+
+#include <dbg.h>
+
+/** @defgroup tcmi_fdcache_class tcmi_fdcache class 
+ *
+ * @ingroup tcmi_ckpt_class
+ *
+ * This is a helper class used by the checkpoint to keep track of
+ * already open file descriptors. It allows easy lookup of a duplicate
+ * file descriptor. This is needed when checkpointing open files of a
+ * process.
+ *
+ * There is no need for locking nor reference counting as fdcache is a
+ * temporary object (as well as \link tcmi_ckpt_class a checkpoint
+ * object \endlink) accessed from a single thread of execution. The
+ * reference counter is just to keep it consistent with current
+ * software design.
+ *
+ * @{
+ */
+
+/** Describes an fd cache entry. */
+struct tcmi_fdcache_entry {
+	/** file descriptor. */
+	int fd;
+	/** file that references. */
+	struct file *file;
+};
+
+/** Compound structure contains all fd cache entries. */
+struct tcmi_fdcache {
+	/** File descriptor cache - used when indentifying descriptors
+	 * referencing the same file. */
+	struct tcmi_fdcache_entry *entries;
+	/** current files in the cache. */
+	int used;
+	/** actual cache size. */
+	int size;
+	/** Instance reference counter. */
+	atomic_t ref_count;
+};
+
+/**
+ * \<\<public\>\> Creates a file descriptor cache of the specified
+ * size. This requires:
+ * - creating new instance
+ * - allocating a requested number of entries
+ *
+ * @param size - maximum number of entries - should match the current
+ * number of open files of a process - this handles the worst case
+ * when there are none duplicate descriptors but one.
+ * @return fdcache instance or NULL
+ */
+static inline struct tcmi_fdcache* tcmi_fdcache_new(int size)
+{
+	struct tcmi_fdcache *fdcache;
+	if (!(fdcache = kmalloc(sizeof(struct tcmi_fdcache), 
+				GFP_KERNEL))) {
+		mdbg(ERR3, "Can't allocate memory for TCMI fdcache");
+		goto exit0;
+	}
+	if (!(fdcache->entries = kmalloc(sizeof(struct tcmi_fdcache_entry) * size,
+					 GFP_KERNEL))) {
+		mdbg(ERR3, "Can't get memory for TCMI fdcache %d entries", size);
+		goto exit1;
+	}
+	atomic_set(&fdcache->ref_count, 1);
+	fdcache->size = size;
+	/* no used entries yet */
+	fdcache->used = 0;
+
+	return fdcache;
+	/* error handling */
+ exit1:
+	kfree(fdcache);
+ exit0:
+	return NULL;
+}
+
+/** 
+ * \<\<public\>\> Instance accessor, increments the reference counter.
+ *
+ * @param *self - pointer to this fdcache instance
+ * @return fd cache instance
+ */
+static inline struct tcmi_fdcache* tcmi_fdcache_get(struct tcmi_fdcache *self)
+{
+	if (self) {
+		atomic_inc(&self->ref_count);
+	}
+	return self;
+}
+
+/** 
+ * \<\<public\>\> Releases the instance.
+ *
+ * @param *self - pointer to this fd cache instance
+ */
+static inline void tcmi_fdcache_put(struct tcmi_fdcache *self)
+{
+	if (self && atomic_dec_and_test(&self->ref_count)) {
+		mdbg(INFO4, "Destroying TCMI fdcache, %p", self);
+		kfree(self->entries);
+		kfree(self);
+	}
+}
+
+/**
+ * \<\<public\>\> Adds a file descriptor - file object pair into the
+ * fd cache.
+ * 
+ * @param *self - this fdcache instance
+ * @param fd - file descriptor of the file
+ * @param *file - file object - used for duplicate file descriptor lookup
+ * @return -ENOMEM if the cache is full
+ */
+static inline int tcmi_fdcache_add(struct tcmi_fdcache *self, int fd, struct file *file)
+{
+	struct tcmi_fdcache_entry *entry;
+	if (!self || (self->used == self->size)) {
+		mdbg(ERR3, "TCMI fdcache full or not properly instantiated!");
+		goto exit0;
+	}
+	entry = &self->entries[self->used++];
+	entry->fd = fd;
+	entry->file = file;
+	return 0;
+
+	/* error handling */
+ exit0:
+	return -ENOMEM;
+}
+
+/**
+ * \<\<public\>\> Searches the file descriptor cache for a file.
+ *
+ * @param *self - this fdcache instance
+ * @param *file - file object to be looked up
+ * @return file descriptor of the file or error (< 0)
+ */
+static inline int tcmi_fdcache_lookup(struct tcmi_fdcache *self, struct file *file)
+{
+	int i;
+	int fd = -EINVAL;
+	/* safes dereferences */
+	int used = self->used;
+	struct tcmi_fdcache_entry *entry = self->entries;
+	for (i = 0; i < used; i++, entry++) {
+		if (entry->file == file) {
+			fd = entry->fd;
+			mdbg(INFO4, "Found descriptor %d in the fdcache", fd);
+			break;
+		}
+	}
+
+	return fd;
+}
+
+#endif /* TCMI_FDCACHE_PRIVATE */
+
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_FDCACHE_PRIVATE
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_FDCACHE_H */
--- linux-3.7.1_original/clondike/src/tcmi/ckpt/tcmi_ckpt_vm_area.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/ckpt/tcmi_ckpt_vm_area.c	2013-03-11 09:29:27.000000000 +0100
@@ -0,0 +1,481 @@
+/**
+ * @file tcmi_ckpt_vm_area.c - a helper class that provides functionality to
+ *                     store a single VM area (memory regions)
+ *                      
+ * 
+ *
+ *
+ * Date: 05/01/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_ckpt_vm_area.c,v 1.4 2007/09/02 10:53:17 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#if defined(__i386__)
+#include <asm/highmem.h>
+#endif
+#include <asm/cacheflush.h>
+
+#define TCMI_CKPT_VM_AREA_PRIVATE
+#include "tcmi_ckpt_vm_area.h"
+
+/**
+ * \<\<public\>\> Writes a specified memory area into the checkpoint
+ * file.  Checks for the requested type - when the light version is
+ * required, it will do so only if the area is non-writable and maps a
+ * file.  The actual work is then delegated to the light or heavy
+ * version of this method.
+ *
+ * @param *ckpt - checkpoint file where the area is to be stored
+ * @param *vma - the actual VM area that is being processed
+ * @param type - requested type of the checkpoint
+ * @return 0 upon success.
+ */
+int tcmi_ckpt_vm_area_write(struct tcmi_ckpt *ckpt, struct vm_area_struct *vma,
+			    tcmi_ckpt_vm_area_t type)
+{
+	int err;
+	struct tcmi_ckpt_vm_area_hdr hdr;
+	hdr.vm_start = vma->vm_start;
+	hdr.vm_end = vma->vm_end;
+	hdr.vm_flags = vma->vm_flags;
+	hdr.vm_pgoff = vma->vm_pgoff;
+	/* light version only when it's non-writable and  maps a file */
+	if (type == TCMI_CKPT_VM_AREA_LIGHT && 
+	    !(vma->vm_flags & VM_WRITE) && vma->vm_file)
+		err = tcmi_ckpt_vm_area_write_l(ckpt, vma, &hdr);
+	else
+		err = tcmi_ckpt_vm_area_write_h(ckpt, vma, &hdr);
+	return err;
+}
+
+
+/**
+ * \<\<public\>\> Reads a memory area from the checkpoint file. Reads
+ * the VM area header and checks for the requested type. The actual
+ * work is then delegated to the light or heavy version of this
+ * method.
+ *
+ * @param *ckpt - checkpoint file where the area is stored
+ * @return 0 upon success.
+ */
+int tcmi_ckpt_vm_area_read(struct tcmi_ckpt *ckpt)
+{
+	int err = 0;
+	struct tcmi_ckpt_vm_area_hdr hdr;
+	
+	if (tcmi_ckpt_read(ckpt, &hdr, sizeof(hdr)) < 0) {
+		mdbg(ERR3, "Error read VM aread header");
+		goto exit0;
+	}
+	mdbg(INFO4, "Reading VMA start:%08llx, end: %08llx, flags: %08llx, pgoff %08llx", 
+	     (unsigned long long)hdr.vm_start, (unsigned long long)hdr.vm_end, (unsigned long long)hdr.vm_flags, (unsigned long long)hdr.vm_pgoff);
+	/* light version only when it's non-writable and  maps a file */
+	if (hdr.type == TCMI_CKPT_VM_AREA_LIGHT)
+		err = tcmi_ckpt_vm_area_read_l(ckpt, &hdr);
+	else if (hdr.type == TCMI_CKPT_VM_AREA_HEAVY)
+		err = tcmi_ckpt_vm_area_read_h(ckpt, &hdr);
+	else {
+		mdbg(ERR3, "Unrecognized header type %x", hdr.type);
+		goto exit0;
+	}
+	return err;
+
+	/* error handling */
+ exit0:
+	return -EINVAL;
+}
+
+
+/** @addtogroup tcmi_ckpt_vm_area_class
+ *
+ * @{
+ */
+
+/**
+ * \<\<private\>\> Writes a specified memory area into the checkpoint
+ * file - light version.  It fills out the rest of the header,
+ * extracts the mapped file pathname and stores the header, pathname
+ * size and the actual pathname into the checkpoint.
+ *
+ * @param *ckpt - checkpoint file where the area is to be stored
+ * @param *vma - the actual VM area that is being processed
+ * @param *hdr - partially filled VM area header
+ * @return 0 upon success.
+ */
+static int tcmi_ckpt_vm_area_write_l(struct tcmi_ckpt *ckpt, 
+				     struct vm_area_struct *vma, 
+				     struct tcmi_ckpt_vm_area_hdr *hdr)
+{
+	/* page for the filepathname */
+	unsigned long page;
+	char *pathname;
+
+	/* finish the header */
+	hdr->type = TCMI_CKPT_VM_AREA_LIGHT;
+
+	/* resolve the path name. */
+	if (!(page = __get_free_page(GFP_KERNEL))) {
+		mdbg(ERR3, "Can't allocate page for file pathname!");
+		goto exit0;
+	}
+	if (IS_ERR(pathname = d_path(&vma->vm_file->f_path, 
+				     (char*)page, PAGE_SIZE))) {
+		mdbg(ERR3, "Can't resolve pathname for '%s'", 
+		     vma->vm_file->f_dentry->d_name.name);
+		goto exit1;
+	}
+	hdr->pathname_size = strlen(pathname) + 1;
+	/* write the header and the pathname into the checkpoint */
+	if (tcmi_ckpt_write(ckpt, hdr, sizeof(*hdr)) < 0) {
+		mdbg(ERR3, "Error writing VM_area header chunk");
+		goto exit1;
+	}
+	/* write the header and the pathname into the checkpoint */
+	if (tcmi_ckpt_write(ckpt, pathname, hdr->pathname_size) < 0) {
+		mdbg(ERR3, "Error writing pathname chunk");
+		goto exit1;
+	}
+
+	free_page(page);
+	return 0;
+
+	/* error handling */
+ exit1:
+	free_page(page);
+ exit0:
+	return -EINVAL;
+}
+
+/**
+ * \<\<private\>\> Writes a specified memory area into the checkpoint
+ * file - heavy version.  It fills out the rest of the header, sets
+ * pathname size to 0 (not used). and writes the header into the
+ * checkpoint file.
+ *
+ * It is necessary to align the file to page size. This is required
+ * otherwise we wouldn't be able to mmap pages from the file upon
+ * restoring the checkpoint.
+ *
+ * Following algorithm dumps the pages, the idea comes from a regular
+ * core dump handler (e.g. in fs/binfmt_elf.c)
+ *
+ \verbatim
+  For each page in the region do:
+    - get the page - might trigger pagefaults to load the pages
+    - map the page descriptor to a valid linear address (user pages might
+    be in high memory)
+    - if the page is zero or marked untouched, advance the offset in the
+    checkpoint only - there is no need to write 0's to disk, just create
+    the gap for them.
+    - otherwise write the entire page into the checkpoint file.
+ \endverbatim
+ *
+ * @param *ckpt - checkpoint file where the area is to be stored
+ * @param *vma - the actual VM area that is being processed
+ * @param *hdr - partially filled VM area header
+ * @return 0 upon success.
+ */
+static int tcmi_ckpt_vm_area_write_h(struct tcmi_ckpt *ckpt, 
+				     struct vm_area_struct *vma, 
+				     struct tcmi_ckpt_vm_area_hdr *hdr)
+{
+	/* page for the filepathname */
+	unsigned long addr;
+
+	/* finish the header */
+	hdr->type = TCMI_CKPT_VM_AREA_HEAVY;
+	hdr->pathname_size = 0;
+	/* write the header into the checkpoint */
+	if (tcmi_ckpt_write(ckpt, hdr, sizeof(*hdr)) < 0) {
+		mdbg(ERR3, "Error writing VM area header chunk");
+		goto exit0;
+	}
+	/* align the current file position to page size boundary */
+	tcmi_ckpt_page_align(ckpt);
+	for (addr = vma->vm_start; addr < vma->vm_end; addr += PAGE_SIZE) {
+		struct page *page;
+		struct vm_area_struct *vma;
+		void *kaddr;
+		if (get_user_pages(current, current->mm, addr, 1, 0, 1,
+				   &page, &vma) <= 0) {
+			mdbg(INFO4, "Skipping untouched page at %08lx", addr);
+			tcmi_ckpt_seek(ckpt, PAGE_SIZE, 1);
+			continue;
+		} 
+		/*if (page == ZERO_PAGE(addr)) {
+			mdbg(INFO4, "Skipping zero page at %08lx", addr);
+			tcmi_ckpt_seek(ckpt, PAGE_SIZE, 1);
+			continue;
+		}
+		*/
+		/* actual page, that needs to be written. */
+		flush_cache_page(vma, addr,  page_to_pfn(page));  /* TODO: check this fix is correct */
+		kaddr = tcmi_ckpt_vm_area_kmap(page);
+		/* write the page into the checkpoint */
+		if (tcmi_ckpt_write(ckpt, kaddr, PAGE_SIZE) < 0) {
+			mdbg(ERR3, "Error writing page at %08lx", addr);
+			goto exit0;
+		}
+		tcmi_ckpt_vm_area_kunmap(page);
+	}
+	return 0;
+
+	/* error handling */
+ exit0:
+	return -EINVAL;
+}
+
+
+
+/** 
+ * \<\<private\>\> Reads a memory area from the checkpoint file -
+ * light version. Reads the pathname of the file that is to be mapped
+ * into the area.
+ * - opens the file 
+ * - performs the memory mapping, 
+ * - releases the file - the memory mapping retains its own reference.
+ *
+ * @param *ckpt - checkpoint file where the area is to be stored
+ * @param *hdr - VM area header
+ * @return 0 upon success.
+ */
+
+static int tcmi_ckpt_vm_area_read_l(struct tcmi_ckpt *ckpt, 
+				    struct tcmi_ckpt_vm_area_hdr *hdr)
+{
+	/* page for the filepathname */
+	unsigned long page;
+	char *pathname = NULL;
+	struct file *file; /* file object for the vm_file */
+	unsigned long mmap_flags;
+	unsigned long addr;
+
+	/* finish the header */
+	hdr->type = TCMI_CKPT_VM_AREA_LIGHT;
+
+	/* resolve the path name. */
+	if (!(page = __get_free_page(GFP_KERNEL))) {
+		mdbg(ERR3, "Can't allocate page for file pathname!");
+		goto exit0;
+	}
+	pathname = (char*) page;
+	/* read the header and the pathname from the checkpoint */
+	if (tcmi_ckpt_read(ckpt, pathname, hdr->pathname_size) < 0) {
+		mdbg(ERR3, "Error reading pathname");
+		goto exit1;
+	}
+	/* convert the VM flags to MMAP flags */
+	mmap_flags = tcmi_ckpt_vm_area_to_mmap_flags(hdr->vm_flags);
+
+	file = filp_open(pathname, O_RDONLY, 0); 
+	if (IS_ERR(file)) {
+		mdbg(ERR3, "Error opening file '%s'", pathname);
+		goto exit1;
+	}
+	/* prot flags are just the lower bits extracted from vm_flags - see mman.h, mm.h */
+	addr = do_mmap_pgoff(file, hdr->vm_start, hdr->vm_end - hdr->vm_start,
+			     hdr->vm_flags & (PROT_READ | PROT_EXEC| PROT_WRITE),	
+			     mmap_flags, hdr->vm_pgoff);
+
+	if (addr != hdr->vm_start) {
+		mdbg(ERR3, "Error mapping file '%s' at: %lx", pathname, addr);
+		goto exit2;
+	}
+
+	/* or shall we perform filp_close??? */
+	fput(file);
+	free_page(page);
+
+	mdbg(INFO4, "Mapped at: 08%lx, VM_flags = %08llx, mmap flags = %08lx", 
+	     addr, (unsigned long long)hdr->vm_flags, mmap_flags);
+	return 0;
+
+	/* error handling */
+ exit2:
+	fput(file);
+ exit1:
+	free_page(page);
+ exit0:
+	return -EINVAL;
+	
+}
+
+/** 
+ * \<\<private\>\> Reads a memory area from the checkpoint file -
+ * heavy version.
+ * - aligns the position in the file to page boundary
+ * - computes memory mapping flags.
+ * - performs the memory mapping.
+ * There is special case that needs to be handled - if the area
+ * grows down which indicates a stack region stack setup
+ * work is delegated to tcmi_ckpt_vm_area_stack_fixup().
+ *
+ *
+ * @param *ckpt - checkpoint file where the area is to be stored
+ * @param *hdr - VM area header
+ * @return 0 upon success.
+ */
+static int tcmi_ckpt_vm_area_read_h(struct tcmi_ckpt *ckpt, 
+				    struct tcmi_ckpt_vm_area_hdr *hdr)
+{
+	unsigned long mmap_flags;
+	unsigned long addr;
+	unsigned long length;
+
+	tcmi_ckpt_page_align(ckpt);
+
+	length = hdr->vm_end - hdr->vm_start;
+
+	if ( length < PAGE_SIZE ) {
+		mdbg(ERR3, "Length of the area shorter than one page. Start: %16llx End: %16llx", (unsigned long long)hdr->vm_start, (unsigned long long)hdr->vm_end);
+		goto exit0;
+	}	
+
+	/* check if stack fixup is needed */
+	if ((hdr->vm_flags & VM_GROWSDOWN) ) {
+	    	if (tcmi_ckpt_vm_area_stack_fixup(ckpt, hdr) < 0) {
+			mdbg(ERR3, "Failed setting up stack area");
+			goto exit0;
+		}
+
+		length -= PAGE_SIZE;
+
+		/* The are was fully maped by the stack fixup */
+		if ( length == 0 )
+			return 0;
+
+	}
+
+	/* convert the VM flags to MMAP flags */
+	mmap_flags = tcmi_ckpt_vm_area_to_mmap_flags(hdr->vm_flags);
+	/* prot flags are just the lower bits extracted from vm_flags - see mman.h, mm.h */
+	addr = tcmi_ckpt_do_mmap(ckpt, hdr->vm_start, hdr->vm_end - hdr->vm_start,
+				 hdr->vm_flags & (PROT_READ | PROT_EXEC| PROT_WRITE),	
+				 mmap_flags);
+	if (addr != hdr->vm_start) {
+		mdbg(ERR3, "Error mapping checkpoint file at: %08lx (hdr->vm_start: %16llx", addr, (unsigned long long)hdr->vm_start);
+		goto exit0;
+	}
+	mdbg(INFO4, "Mapped checkpoint at: %08lx, VM_flags = %16llx, mmap flags = %08lx", 
+	     addr, (unsigned long long)hdr->vm_flags, mmap_flags);
+	return 0;
+
+	/* error handling */
+ exit0:
+	return -EINVAL;
+}
+
+
+/**
+ * \<\<private\>\> This method is responsible for fixing a the stack
+ * in the area just read from the checkpoint file. The idea is the
+ * split the supplied VM area into two:
+ *
+ * - one containing the top of the stack
+ * - the other will be created by the standard mechanism.
+ * 
+ * What needs to be done is to:
+ *
+ * - create an anonymous mapping with the MAP_GROWSDOWN flag, with start
+ * address the same as the VM area in the checkpoint and size of one page.  
+ * - read the first page of the stack area from the checkpoint file
+ * and copy it into the newly created mapping. The current top of the
+ * stack is somewhere in this page.
+ * - adjust the VM area header read from the checkpoint file:
+ * increment vm_start address and reset the VM_GROWSDOWN flag.
+ *
+ * Why is it so complex? Stack expansion is possible only for areas
+ * marked by VM_GROWSDOWN flag. However, it is not possible to create
+ * a file memory mapping using MAP_GROWSDOWN.  The memory mapping
+ * framework simply denies this as a regular user doesn't need it.  To
+ * change the size of a memory mapping, all processes are encouraged
+ * to use mremap().  Further, we would have a problem when the current
+ * stack pointer leaves the memory region by the allowed limit(max
+ * 32bytes). Where would the expansion get the page? It might end up
+ * asking the file to supply the missing page. This is obviously not
+ * possible.
+ *
+ *
+ * @param *ckpt - checkpoint file where the current stack area resides.
+ * @param *hdr - VM area header
+ * @return 0 upon success.
+ */
+static int tcmi_ckpt_vm_area_stack_fixup(struct tcmi_ckpt *ckpt, 
+					 struct tcmi_ckpt_vm_area_hdr *hdr)
+{
+	/* temporary page allocated for the top of the stack */
+	unsigned long page;
+	/* address of the target mapping - must match hdr->vm_start */
+	unsigned long addr;
+	unsigned long mmap_flags;
+
+	/* convert the VM flags to MMAP flags */
+	mmap_flags = tcmi_ckpt_vm_area_to_mmap_flags(hdr->vm_flags);
+
+	/* prot flags are just the lower bits extracted from vm_flags - see mman.h, mm.h */
+	down_write(&current->mm->mmap_sem);
+	addr = do_mmap_pgoff(NULL, hdr->vm_start, PAGE_SIZE,
+		       hdr->vm_flags & (PROT_READ | PROT_EXEC| PROT_WRITE),	
+		       mmap_flags, 0);                      //Replaced function do_mmap to do_mmap_pgoff for kernel 3.7.x by Jiri Rakosnik 
+	up_write(&current->mm->mmap_sem);
+
+	if (addr != hdr->vm_start) {
+		mdbg(ERR3, "Error creating an anonymous mapping for stack page %d", (int)addr);
+		goto exit0;
+	}
+	
+	if (!(page = __get_free_page(GFP_KERNEL))) {
+		mdbg(ERR3, "Can't allocate page for stack!");
+		goto exit0;
+	}
+	/* read the first page of the stack */
+	if (tcmi_ckpt_read(ckpt, (void*)page, PAGE_SIZE) < 0) {
+		mdbg(ERR3, "Error stack page!");
+		goto exit1;
+	}
+	mdbg(INFO4, "Copying stack page to %08lx from %08lx", addr, page);
+	if (tcmi_ckpt_vm_area_copy_page(addr, page) < 0) {
+		mdbg(ERR3, "Failed to copy stack page!!!");
+		goto exit1;
+	}
+	/* memcpy((void*)addr, (void*)page, PAGE_SIZE); */
+	mdbg(INFO4, "Copying done");
+	/* adjust the attributes */
+	hdr->vm_start += PAGE_SIZE;
+	hdr->vm_flags &= ~VM_GROWSDOWN; /* FIXME: make this unified for all archs!!!*/
+
+	free_page(page);
+
+	mdbg(INFO4, "Created anonymous mapping for stack at: %08lx", addr);
+	return 0;
+
+	/* error handling */
+ exit1:
+	free_page(page);
+ exit0:
+	return -EINVAL;
+}
+
+/**
+ * @}
+ */
+
--- linux-3.7.1_original/clondike/src/tcmi/ckpt/tcmi_ckpt_mm.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/ckpt/tcmi_ckpt_mm.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,175 @@
+/**
+ * @file tcmi_ckpt_mm.h - a helper class that provides functionality to
+ *                     store a single VM area (memory regions)
+ *                      
+ * 
+ *
+ *
+ * Date: 05/01/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_ckpt_mm.h,v 1.3 2007/09/02 10:53:17 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_CKPT_MM_H
+#define _TCMI_CKPT_MM_H
+
+#include <linux/mm.h>
+#include <linux/mman.h>
+
+#include <arch/types.h>
+#include "tcmi_ckpt.h"
+
+/** @defgroup tcmi_ckpt_mm_class tcmi_ckpt_mm class 
+ *
+ * @ingroup tcmi_ckpt_class
+ *
+ * This is a \<\<singleton\>\> that takes care of (re)storing a
+ * process memory descriptor.
+ *
+ *
+ * 
+ * @{
+ */
+
+/** Compound structure describes a process memory descriptor.
+ * Explanation if individual items is  e.g. in Understanding
+ * the Linux Kernel(chapter 8)
+ */
+struct tcmi_ckpt_mm_hdr {
+	/** code section, data section. */
+	u_int64_t start_code, end_code, start_data, end_data;
+	/** heap and stack. */
+	u_int64_t start_brk, brk, start_stack;
+	/** arguments and environment. */
+	u_int64_t arg_start, arg_end, env_start, env_end;
+	/** default access flags of the memory regions. */
+	u_int64_t def_flags;
+} __attribute__((__packed__));
+
+
+/** 
+ * Writes a current process memory descriptor into the checkpoint file. 
+ *
+ * @param *ckpt - checkpoint file where the area is to be stored
+ * @return 0 upon success.
+ */
+static inline int tcmi_ckpt_mm_write(struct tcmi_ckpt *ckpt)
+{
+	struct tcmi_ckpt_mm_hdr mm_hdr;
+        /* Now we dump the memory mapping */
+        mm_hdr.start_code  = current->mm->start_code;
+        mm_hdr.end_code    = current->mm->end_code;
+        mm_hdr.start_data  = current->mm->start_data;
+        mm_hdr.end_data    = current->mm->end_data;
+        mm_hdr.start_brk   = current->mm->start_brk;
+        mm_hdr.brk         = current->mm->brk;
+        mm_hdr.start_stack = current->mm->start_stack;
+        mm_hdr.arg_start   = current->mm->arg_start;
+        mm_hdr.arg_end     = current->mm->arg_end;
+        mm_hdr.env_start   = current->mm->env_start;
+        mm_hdr.env_end     = current->mm->env_end;
+        mm_hdr.def_flags   = current->mm->def_flags;
+
+
+
+	/* write the header into the checkpoint */
+	if (tcmi_ckpt_write(ckpt, &mm_hdr, sizeof(mm_hdr)) < 0) {
+		mdbg(ERR3, "Error writing memory descriptor header");
+		goto exit0;
+	}
+	mdbg(INFO4, "Written memory descriptor:");
+	mdbg(INFO4, "START CODE :      %08lx", current->mm->start_code);
+	mdbg(INFO4, "END CODE   :      %08lx", current->mm->end_code);
+	mdbg(INFO4, "START DATA :      %08lx", current->mm->start_data);
+	mdbg(INFO4, "END DATA   :      %08lx", current->mm->end_data);
+	mdbg(INFO4, "START BRK  :      %08lx", current->mm->start_brk);
+	mdbg(INFO4, "BRK        :      %08lx", current->mm->brk);
+	mdbg(INFO4, "START STACK:      %08lx", current->mm->start_stack);
+	return 0;
+		
+	/* error handling */
+ exit0:
+	return -EINVAL;
+
+}
+
+/** 
+ * Reads a memory area from the checkpoint file and sets the those in
+ * the memory descriptor. This also assumes that the old execution
+ * context has already been flushed by the caller.
+ *
+ * @param *ckpt - checkpoint file where the area is to be stored
+ * @return 0 upon success.
+ */
+static inline int tcmi_ckpt_mm_read(struct tcmi_ckpt *ckpt)
+{
+	struct tcmi_ckpt_mm_hdr mm_hdr;
+	/* write the header into the checkpoint */
+	if (tcmi_ckpt_read(ckpt, &mm_hdr, sizeof(mm_hdr)) < 0) {
+		mdbg(ERR3, "Error reading memory descriptor header");
+		goto exit0;
+	}
+        current->mm->start_code  = CHECKED_UINT64_TO_ULONG(mm_hdr.start_code);
+        current->mm->end_code    = CHECKED_UINT64_TO_ULONG(mm_hdr.end_code);
+        current->mm->start_data  = CHECKED_UINT64_TO_ULONG(mm_hdr.start_data);
+        current->mm->end_data    = CHECKED_UINT64_TO_ULONG(mm_hdr.end_data);
+        current->mm->start_brk   = CHECKED_UINT64_TO_ULONG(mm_hdr.start_brk);
+        current->mm->brk         = CHECKED_UINT64_TO_ULONG(mm_hdr.brk);
+        current->mm->start_stack = CHECKED_UINT64_TO_ULONG(mm_hdr.start_stack);
+        current->mm->arg_start   = CHECKED_UINT64_TO_ULONG(mm_hdr.arg_start);
+        current->mm->arg_end     = CHECKED_UINT64_TO_ULONG(mm_hdr.arg_end);
+        current->mm->env_start   = CHECKED_UINT64_TO_ULONG(mm_hdr.env_start);
+        current->mm->env_end     = CHECKED_UINT64_TO_ULONG(mm_hdr.env_end);
+        current->mm->def_flags   = CHECKED_UINT64_TO_ULONG(mm_hdr.def_flags);
+	/* no regions left as they all have been flushed */
+	current->mm->mmap = NULL;
+	mdbg(INFO4, "Read memory descriptor:");
+	mdbg(INFO4, "START CODE :      %08lx", current->mm->start_code);
+	mdbg(INFO4, "END CODE   :      %08lx", current->mm->end_code);
+	mdbg(INFO4, "START DATA :      %08lx", current->mm->start_data);
+	mdbg(INFO4, "END DATA   :      %08lx", current->mm->end_data);
+	mdbg(INFO4, "START BRK  :      %08lx", current->mm->start_brk);
+	mdbg(INFO4, "BRK        :      %08lx", current->mm->brk);
+	mdbg(INFO4, "START STACK:      %08lx", current->mm->start_stack);
+	mdbg(INFO4, "ARG START:      %08lx", current->mm->arg_start);
+	mdbg(INFO4, "ARG END:      %08lx", current->mm->arg_end);
+	mdbg(INFO4, "ENV START:      %08lx", current->mm->env_start);
+	mdbg(INFO4, "ENV END:      %08lx", current->mm->env_end);
+	mdbg(INFO4, "DEF FLAGS:      %08lx", current->mm->def_flags);
+	return 0;
+		
+	/* error handling */
+ exit0:
+	return -EINVAL;
+}
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_CKPT_MM_PRIVATE
+
+
+#endif /* TCMI_CKPT_MM_PRIVATE */
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_CKPT_MM_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/ckpt/tcmi_ckpt.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/ckpt/tcmi_ckpt.c	2013-03-11 09:00:46.000000000 +0100
@@ -0,0 +1,376 @@
+/**
+ * @file tcmi_ckpt.c - a helper class that provides functionality to
+ *                     create a process checkpoint
+ *                      
+ * 
+ *
+ *
+ * Date: 04/30/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_ckpt.c,v 1.7 2007/11/05 19:38:28 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <linux/mm.h>
+#include <linux/fs.h>
+#include <linux/fs_struct.h>
+#include <linux/fdtable.h>
+
+
+#define TCMI_CKPT_PRIVATE
+#include "tcmi_ckpt.h"
+
+#include "tcmi_ckpt_openfile.h"
+#include "tcmi_ckpt_vm_area.h"
+
+#include <arch/arch_ids.h>
+#include <arch/current/regs.h>
+#include <arch/current/vma.h>
+
+#include <linux/personality.h>
+
+
+/** 
+ * \<\<public\>\> Checkpoint constructor. 
+ * - allocates a new instance
+ * - resets the byte counter
+ * - reserves an extra reference for the file
+ * - reset position in the file to the beginning
+ * 
+ *
+ * @param *file - points to the file where the checkpoint is to be
+ * written/read
+ * @return tcmi_ckpt instance or NULL
+ */
+struct tcmi_ckpt* tcmi_ckpt_new(struct file *file)
+{
+	struct tcmi_ckpt *ckpt;
+	loff_t seek_res;
+
+	if (!(ckpt = TCMI_CKPT(kmalloc(sizeof(struct tcmi_ckpt), 
+				       GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate memory for TCMI ckpt");
+		goto exit0;
+	}
+	get_file(file);
+	ckpt->file = file;
+	ckpt->fdcache = NULL;
+	atomic_set(&ckpt->ref_count, 1);
+	mdbg(INFO2, "Created new checkpoint %p", ckpt);
+	/* reset the file position */
+	seek_res = tcmi_ckpt_seek(ckpt, 0, 0);
+
+	if ( seek_res < 0 ) {
+		kfree(ckpt);
+		return ERR_PTR(seek_res);
+	}
+
+	return ckpt;
+
+	/* error handling */
+ exit0:
+	return NULL;
+
+}
+
+/** 
+ * \<\<public\>\> Writes a checkpoint header.
+ * The checkpoint header consists of:
+ * - a magic number 
+ * - total VM area count
+ * - total file count
+ *
+ * @param *self - this checkpoint instance
+ * @param is_npm - Is this a non-preemptive checkpoint (otherwise preemptive is assumed)
+ * @return 0 upon success
+ */
+int tcmi_ckpt_write_hdr(struct tcmi_ckpt *self, int is_npm)
+{
+	self->hdr.checkpoint_arch = ARCH_CURRENT;
+	self->hdr.is_32bit_application = check_is_application_32bit();
+	self->hdr.magic = TCMI_CKPT_MAGIC;
+	self->hdr.is_npm = is_npm;
+	if ((self->hdr.map_count = tcmi_ckpt_map_count(self)) < 0) {
+		mdbg(ERR3, "Failed counting mmap's");
+		goto exit0;
+	}
+	if ((self->hdr.file_count = tcmi_ckpt_file_count(self)) < 0) {
+		mdbg(ERR3, "Failed counting open files");
+		goto exit0;
+	}
+	
+	if (tcmi_ckpt_fdcache_init(self) < 0) {
+		mdbg(ERR3, "Error initializing file descriptor cache!!");
+		goto exit0;
+	}
+	// No need to lock, exclusive access
+	strncpy(self->hdr.comm, current->comm, sizeof(current->comm));
+
+	mdbg(INFO3, "Writing header of size: %lu Address: %p First 4 bytes: %8x", (unsigned long)sizeof(self->hdr), &self->hdr, ((uint32_t*)(&self->hdr))[0]);
+	
+	return tcmi_ckpt_write(self, &self->hdr, sizeof(self->hdr));
+	
+	/* error handling */
+ exit0:
+	return -EINVAL;
+}
+
+/** 
+ * \<\<public\>\> Reads the checkpoint header.  
+ * The magic number has to match TCMI_CKPT_MAGIC.
+ *
+ * @param *self - this checkpoint instance
+ * @return 0 upon success
+ */
+int tcmi_ckpt_read_hdr(struct tcmi_ckpt *self)
+{
+	int err;
+
+	if ((err = tcmi_ckpt_read(self, &self->hdr, sizeof(self->hdr))) < 0) {
+		mdbg(ERR3, "Can't read checkpoint header %d", err);
+		goto exit0;
+	}
+	if (self->hdr.magic != TCMI_CKPT_MAGIC) {
+		mdbg(ERR3, "Invalid checkpoint magic: %08x, expected: %08x",
+		     self->hdr.magic, TCMI_CKPT_MAGIC);
+		goto exit0;
+	}
+	mdbg(INFO4, "Read ckpt header - magic: %08x, map_count: %d, files: %d (Header size: %lu)", 
+	     self->hdr.magic, self->hdr.map_count, self->hdr.file_count, (unsigned long)sizeof(self->hdr));
+
+	if (tcmi_ckpt_fdcache_init(self) < 0) {
+		mdbg(ERR3, "Error initializing file descriptor cache!!");
+		goto exit0;
+	}
+	tcmi_ckpt_file_count(self);
+	
+	strncpy(current->comm, self->hdr.comm, sizeof(current->comm));
+
+	/* TODO: To some arch file ? */
+	#if defined(__x86_64__) 
+	if ( self->hdr.is_32bit_application )
+		set_thread_flag(TIF_IA32); /* This flag must be set for 32bit applications running on 64 bit kernel */		
+
+	if ( self->hdr.checkpoint_arch == ARCH_I386 )
+		set_personality(PER_LINUX32_3GB); /* Address space must be limited by 3GB, so that we are possibly able to migrate back */
+	#endif
+
+	mdbg(INFO3, "Read header. Architecture of checkpoint %d Is 32 bit app: %d", self->hdr.checkpoint_arch, self->hdr.is_32bit_application);
+	return 0;
+
+	/* error handling */
+ exit0:
+	return -EINVAL;
+}
+
+/** 
+ * \<\<public\>\> Writes open files into the checkpoint.  Iterates through all open
+ * files of the current process and writes each file details into the
+ * checkpoint. Since some files might be just a duplicate file
+ * descriptor, we always check with the file descriptor cache.
+ * For duplicate file descriptors only simplified record is needed.
+ * 
+ * @param *self - this checkpoint instance
+ * @return 0 upon success
+ */
+int tcmi_ckpt_write_files(struct tcmi_ckpt *self)
+{
+	int fd = 0;
+	int err = 0;
+	struct file *file;
+
+	/* Check each open file */
+	tcmi_ckpt_foreach_openfile(file, fd) {
+		mdbg(INFO4, "Processing '%s' fd=%d, type=%0o flags %08o, mode %08o, %p", 
+		     file->f_dentry->d_name.name, fd, file->f_dentry->d_inode->i_mode & S_IFMT, 
+		     file->f_flags, file->f_mode, file);
+		if ( (err = tcmi_ckpt_openfile_write(self, fd, file)) < 0) {
+			mdbg(INFO3, "Error writing file into checkpoint. Error %d", err);
+			goto exit0;
+		}
+	}
+	return 0;
+
+	/* error handling */
+ exit0:
+	return err;
+}
+
+/** 
+ * \<\<public\>\> Reads open files from the checkpoint. 
+ *
+ * @param *self - this checkpoint instance
+ * @return 0 upon success
+ */
+int tcmi_ckpt_read_files(struct tcmi_ckpt *self)
+{
+	int err = 0;
+	int i = 0;
+	while ((i < self->hdr.file_count) && !err) {
+		err = tcmi_ckpt_openfile_read(self);
+		i++;
+	}
+	tcmi_ckpt_file_count(self);
+	return err;
+}
+
+/** 
+ * \<\<public\>\> Writes all process memory regions into the checkpoint. 
+ *
+ * @param *self - this checkpoint instance
+ * @param heavy - if set a full checkpoint of all memory areas
+ * is made(see tcmi_ckptcom.c::tcmi_ckptcom_checkpoint()).
+ * @return 0 upon success
+ */
+int tcmi_ckpt_write_vmas(struct tcmi_ckpt *self, int heavy)
+{
+	struct vm_area_struct *vma;
+	int err = 0;
+	tcmi_ckpt_vm_area_t type;
+	/* select the checkpoint type*/
+	type = (heavy ? TCMI_CKPT_VM_AREA_HEAVY : TCMI_CKPT_VM_AREA_LIGHT);
+
+	tcmi_ckpt_foreach_vma(vma) {
+		if ( vma_ignore(self, vma) )
+			continue;
+
+		if ((err = tcmi_ckpt_vm_area_write(self, vma, type)) < 0) {
+		mdbg(ERR3, "Can't write vm area start:%08lx, end: %08lx, flags: %08lx, pageprot %08lx", 
+		     vma->vm_start, vma->vm_end, vma->vm_flags, vma->vm_page_prot.pgprot);
+		goto exit0;
+		}
+	}
+
+	return 0;
+
+	/* error handling */
+ exit0:
+	return -EINVAL;
+}
+
+/** 
+ * \<\<public\>\> Reads process pages from the checkpoint.
+ *
+ * @param *self - this checkpoint instance
+ * @return 0 upon success
+ */
+int tcmi_ckpt_read_vmas(struct tcmi_ckpt *self)
+{
+	int err = 0;
+	int i = 0;
+	while ((i < self->hdr.map_count) && !err) {
+		err = tcmi_ckpt_vm_area_read(self);
+		i++;
+	}
+
+	tcmi_ckpt_map_count(self);
+	
+	return err;
+}
+
+/** @addtogroup tcmi_ckpt_class
+ *
+ * @{
+ */
+
+/**
+ * \<\<private\>\> Calculates the number of memory regions of the
+ * current process.  We can't simply return current->map_count. We
+ * need to check for special regions that would prevent creating a
+ * valid checkpoint
+ * 
+ * For now, we have to verify that the memory region is not:
+ * - VM_IO - I/O mapped devices 
+ * - VM_SHARED - shared memory - this will be included later on,
+ * when we support checkpointing and migration of LWP's
+ * - VM_RESERVED - special mappings  
+ * 
+ * @param *self - this checkpoint instance
+ * @return number of memory regions, or error (< 0)
+ */
+static int tcmi_ckpt_map_count(struct tcmi_ckpt *self)
+{
+	struct vm_area_struct *vma;
+	int count = 0;
+	int err = 0;
+
+	tcmi_ckpt_foreach_vma(vma) {
+		if ( vma_ignore(self, vma) )
+			continue;
+
+		count++;
+		/* Do not dump I/O mapped devices, shared memory, or special mappings */
+		if (vma->vm_flags & (VM_IO | VM_SHARED | VM_DONTEXPAND | VM_DONTDUMP))       // VM_RESERVED replaced to VM_DONTEXPAND | VM_DONTDUMP by Jiri Rakosnik
+			err = -EINVAL;
+		mdbg(INFO4, "Scanning area start:%08lx, end: %08lx, flags: %08lx, pageprot %08lx", 
+		     vma->vm_start, vma->vm_end, vma->vm_flags, vma->vm_page_prot.pgprot);
+	}
+	mdbg(INFO4, "Found %d areas, mm indicates: %d", count, current->mm->map_count);
+	return (err ? err : count);
+}
+
+/**
+ * \<\<private\>\> Calculates the number of open files of the current process.
+ * For each file check if the file is supported if so,
+ * adjust the counter.
+ *
+ * An error is indicated if any of the files is:
+ * - socket
+ * - pipe
+ * - symlink
+ * - special file
+ * 
+ * @param *self - this checkpoint instance
+ * @return number of open files, or error (< 0)
+ */
+static int tcmi_ckpt_file_count(struct tcmi_ckpt *self)
+{
+	/* file descriptor count */
+	int fd;
+	int count = 0;
+	int err = 0;
+	struct file *file;
+	struct inode *inode;
+
+	/* Check each open file */
+	tcmi_ckpt_foreach_openfile(file, fd) {
+		inode = file->f_dentry->d_inode;
+		if (!tcmi_ckpt_openfile_supported(inode)) {
+			mdbg(ERR3, "Unsupported file mode detected %o [FD: %d]", inode->i_mode, fd);
+			err = -EINVAL;
+			goto exit0;
+		}
+		count++;
+		/*mdbg(INFO4, "Scanned file fd=%d, type=%0o '%s'", fd, file->f_flags, 
+		  file->f_dentry->d_name.name); */
+	}
+
+	mdbg(INFO4, "Found %d files, err=%d", count, err);
+	return count;
+
+	/* error handling */
+ exit0:
+	return -EINVAL;
+}
+
+/**
+ * @}
+ */
--- linux-3.7.1_original/clondike/src/tcmi/ckpt/tcmi_ckpt_openfile.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/ckpt/tcmi_ckpt_openfile.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,186 @@
+/**
+ * @file tcmi_ckpt_openfile.h - a helper class that provides functionality to
+ *                              store/restore information about an open file in the checkpoint
+ *                      
+ * 
+ *
+ *
+ * Date: 04/30/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_ckpt_openfile.h,v 1.4 2007/09/03 01:17:58 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_CKPT_OPENFILE_H
+#define _TCMI_CKPT_OPENFILE_H
+
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/mm.h>
+#include <asm/uaccess.h>
+
+#define __KERNEL_SYSCALLS__
+#include <linux/syscalls.h> 
+#include <linux/unistd.h> 
+
+#include "tcmi_ckpt.h"
+
+#include <dbg.h>
+
+/** @defgroup tcmi_ckpt_openfile_class tcmi_ckpt_openfile class 
+ *
+ * @ingroup tcmi_ckpt_class
+ *
+ * This is a helper \<\<singleton\>\> class used by the \link
+ * tcmi_ckpt_class checkpoint \endlink and provides functionality to:
+ *
+ * - write an information about an open file into the checkpoint 
+ * - restore/reopen a file based on information in the checkpoint 
+ *
+ * The checkpoint instance during checkpoint image creation passes
+ * each file along with its file descriptor and current file
+ * descriptor cache to this component. The are two separate cases:
+ * - the file information has already been written into the checkpoint -
+ * this is indicated by a file object being already present in the 
+ * \link tcmi_fdcache_class file descriptor cache \endlink.
+ * In this case only a short information about a file is written
+ * into the checkpoint file - it's current file descriptor and the
+ * file descriptor that it's duplicating
+ * - the file information hasn't been written into the checkpoint
+ * (not present in the fd cache). In this case a full record
+ * is required:
+ *     - file descriptor
+ *     - current position in file
+ *     - file flags used when opening the file
+ *     - file access mode
+ *     - file type(regular/directory/char/block device/pipe/socket/symlink)
+ *     - full pathname
+ *
+ *
+ * Initial implementation supports checkpointing of regular files and
+ * directories only. There is a limited support when checkpointing
+ * open character devices - seek operation is omitted. Future
+ * implementation when restoring the open files should consider the
+ * circumstances and decided to reopen the original file or special
+ * proxy file. The main purpose of the proxy file will be to forward
+ * all requests to the original node.
+ * 
+ * @todo Implement handling of special files (character devices/block
+ * devices, pipes, sockets)
+ *
+ *  @{
+ */
+
+/** describes various chunks of the checkpoint file */
+typedef enum {
+	/* new file */
+	TCMI_CKPT_OPENFILE_NEWFILE = 0,
+	/* duplicate file descriptor, refers to some regular file */
+	TCMI_CKPT_OPENFILE_DUPFILE
+} tcmi_ckpt_openfile_chunk_t;
+
+/** Describes generic header that consists of a file type only - the
+ * options are new or dup file*/
+struct tcmi_ckpt_openfile_generic_hdr {
+	/** type of the open file */
+	tcmi_ckpt_openfile_chunk_t  restore_type;
+} __attribute__((__packed__));
+
+
+/** Describes a file occurs in the checkpoint for the first time. */
+struct tcmi_ckpt_openfile_newfile_hdr {
+	/** file descriptor */
+	int32_t fd;
+	/** current position in the file. */
+	u_int64_t pos;
+	/** flags specified by the user when opening the file */
+	u_int32_t flags;
+	/** access mode for the file */
+	u_int32_t mode; /* mode_t mode; */
+	/** file type */
+	u_int32_t type;
+	/** length of the pathname string (including trailing zero) */
+	int32_t pathname_size;
+} __attribute__((__packed__));
+
+
+/** Describes a duplicate file. The duplicate file descriptor refers
+ * to the original file object that has been open for the first
+ * time. That is: 'dup_fd' has to be duplicated into 'fd' upon
+ * checkpoint restart. */
+struct tcmi_ckpt_openfile_dupfile_hdr {
+	/** file descriptor */
+	int32_t fd;
+	/** file descriptor that refers to the actual file. */
+	int32_t dup_fd;
+} __attribute__((__packed__));
+
+/** \<\<public\>\> Writes an open file information into the checkpoint file. */
+extern int tcmi_ckpt_openfile_write(struct tcmi_ckpt *ckpt, int fd, struct file *file);
+/** \<\<public\>\> Reads and restores an open file from the checkpoint file. */
+extern int tcmi_ckpt_openfile_read(struct tcmi_ckpt *ckpt);
+
+
+/**
+ * \<\<public\>\> Class method - checks if the specified
+ * file(represented by its inode) is supported by checkpoint.
+ *
+ * @param *inode - inode to be checked
+ */
+static inline int tcmi_ckpt_openfile_supported(struct inode *inode)
+{
+	return (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) || S_ISCHR(inode->i_mode) || S_ISFIFO(inode->i_mode) );
+}
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_CKPT_OPENFILE_PRIVATE
+
+
+
+
+/** Writes a duplicate file descriptor chunk into the checkpoint file. */
+static int tcmi_ckpt_openfile_write_dupfd(struct tcmi_ckpt *ckpt, int fd, int dup_fd);
+
+/** Writes a new file chunk into the checkpoint file. */
+static int tcmi_ckpt_openfile_write_newfd(struct tcmi_ckpt *ckpt, int fd, 
+					  struct file *file);
+
+/** Reads a duplicate file descriptor chunk from the checkpoint file. */
+static int tcmi_ckpt_openfile_read_dupfd(struct tcmi_ckpt *ckpt);
+
+/** Reads a new file chunk from the checkpoint file */
+static int tcmi_ckpt_openfile_read_newfd(struct tcmi_ckpt *ckpt);
+
+static inline void tcmi_ckpt_proxy_path(char *page, char *name)
+{
+	char buf[128];
+	snprintf(buf, 127, "%s/%s", "/proxyfs", page);
+	strcpy( page, buf );
+}
+
+#endif /* TCMI_CKPT_OPENFILE_PRIVATE */
+
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_CKPT_OPENFILE_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/migration/tcmi_mighooks.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/migration/tcmi_mighooks.h	2013-03-12 19:14:25.000000000 +0100
@@ -0,0 +1,78 @@
+/**
+ * @file tcmi_mighooks.h - a separate module that install migration hooks into the kernel.
+ *                      
+ * 
+ *
+ *
+ * Date: 05/06/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_mighooks.h,v 1.5 2007/11/05 19:38:28 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <asm/uaccess.h>
+
+#ifndef _TCMI_MIGHOOKS_H
+#define _TCMI_MIGHOOKS_H
+
+/** @defgroup tcmi_mighooks_class tcmi_mighooks class 
+ *
+ * @ingroup tcmi_migration_group
+ *
+ * A \<\<singleton\>\> class that installs migration hooks into the kernel.
+ * Currently the hooks cover:
+ * - \link tcmi_mighooks_mig_mode() migration mode callback \endlink
+ * - \link tcmi_mighooks_do_exit() exit system call hook \endlink
+ * 
+ * @{
+ */
+
+/** \<\<public\>\> Registers all hooks with the kernel. */
+int tcmi_mighooks_init(void);
+
+/** \<\<public\>\> Unregisters all hooks. */
+void tcmi_mighooks_exit(void);
+
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_MIGHOOKS_PRIVATE
+/** Exit system call hook */
+static long tcmi_mighooks_do_exit(long code);
+
+/** This hook is called upon SIGUNUSED delivery to a particular process. */
+static long tcmi_mighooks_mig_mode(struct pt_regs *regs);
+
+/** This hook is called on every execve invocation */
+static long tcmi_mighooks_execve(const char *filename, const char __user * const __user * argv, const char __user * const __user * envp, struct pt_regs *regs);
+
+/** This hook replaces paths starting with /proc/self with /proc/<<PROCESS PID>> so that remote querying of /proc/self works. it is used in path_lookup kernel function */
+static long tcmi_mighooks_replace_proc_self_file(const char* filename, const char** result);
+
+#endif /* TCMI_MIGHOOKS_PRIVATE */
+
+
+/**
+ * @}
+ */
+
+
+#endif /* _TCMI_MIGHOOKS_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/migration/tcmi_migcom.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/migration/tcmi_migcom.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,87 @@
+/**
+ * @file tcmi_migcom.h - TCMI migration component.
+ *                      
+ * 
+ *
+ *
+ * Date: 05/05/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_migcom.h,v 1.5 2007/10/20 14:24:20 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_MIGCOM_H
+#define _TCMI_MIGCOM_H
+
+#include <linux/types.h>
+
+#include <tcmi/manager/tcmi_migman.h>
+#include <tcmi/ctlfs/tcmi_ctlfs_entry.h>
+#include <tcmi/comm/tcmi_msg.h>
+
+struct tcmi_npm_params;
+
+/** @defgroup tcmi_migcom_class tcmi_migcom class 
+ *
+ * @ingroup tcmi_migration_group
+ *
+ * A \<\<singleton\>\> class that handles migration requests from user
+ * space as well as from  migration managers.
+ * 
+ * @{
+ */
+
+/** \<\<public\>\> Migrates a task from a CCN to a PEN */
+extern int tcmi_migcom_emigrate_ccn_ppm_p(pid_t pid, struct tcmi_migman *migman);
+
+/** \<\<public\>\> Migrates non-preemptively a task from a CCN to a PEN */
+extern int tcmi_migcom_emigrate_ccn_npm(pid_t pid, struct tcmi_migman *migman, struct pt_regs* regs, struct tcmi_npm_params* npm_params);
+
+/** \<\<public\>\> Immigrates a task - handles accepting the task on the PEN side */
+extern int tcmi_migcom_immigrate(struct tcmi_msg *m, struct tcmi_migman *migman);
+
+/** \<\<public\>\> Migrates task home from PEN (method can be used both on PEN or CCN) */
+extern int tcmi_migcom_migrate_home_ppm_p(pid_t pid);
+
+/** \<\<public\>\> Fork of guest */
+extern int tcmi_migcom_guest_fork(struct task_struct* parent, struct task_struct* child, struct tcmi_migman* migman);
+
+/** \<\<public\>\> Fork of shadow */
+extern int tcmi_migcom_shadow_fork(struct task_struct* parent, struct task_struct* child, struct tcmi_migman* migman);
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_MIGCOM_PRIVATE
+
+/** Initial thread for a newly 'immigrated' task. */
+static int tcmi_migcom_migrated_task(void *data);
+
+/** Migration mode handler. */
+static void tcmi_migcom_mig_mode_handler(void);
+
+#endif /* TCMI_MIGCOM_PRIVATE */
+
+
+/**
+ * @}
+ */
+
+
+#endif /* _TCMI_MIGCOM_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/migration/tcmi_npm_params.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/migration/tcmi_npm_params.h	2013-03-12 19:44:28.000000000 +0100
@@ -0,0 +1,97 @@
+/**
+ * @file tcmi_npm_params.h - non-preemtive migration process parameters (args, env,..)
+ */
+#ifndef _TCMI_NPM_PARAMS_H
+#define _TCMI_NPM_PARAMS_H
+
+#include <linux/limits.h>
+#include <linux/types.h>
+#include <linux/compiler.h>
+#include <linux/list.h>
+#include <linux/binfmts.h>
+#include <asm/page.h>
+
+#ifndef MAX_ARG_PAGES
+#define MAX_ARG_PAGES (MAX_ARG_STRLEN/PAGE_SIZE)
+#endif
+
+#define NPM_FILENAME_MAX PATH_MAX
+#define NPM_DATA_SIZE_MAX (PAGE_SIZE*MAX_ARG_PAGES)
+
+/** 
+ * Structure containing data required for performing of non-preemtive restart 
+ *
+ * The structure contains all required data in itself, the pointers all point to a "data" field.
+ * The organization in data field is as follows:
+ *   args array (pointer to strings) + null termination
+ *   args[0] first arg + null termination
+ *   .....
+ *   envp array (pointer to envp strings) + null termination
+ *  ...
+ */
+struct tcmi_npm_params {
+	/** Name of the file that is being "execve-ed" */
+	char file_name[NPM_FILENAME_MAX];
+	/** Count of args/envp params */
+	u_int8_t argsc, envpc;
+	/** Arrays of args and envps.. the actual values are stored in "data" member */
+	char** args, **envp;
+	/** 
+         * This field represents, how many bytes of data field is actually used. (It is used for optimization of checkpoint size)
+         * This value is filled, when the args&envp are serialized into the data.
+         */
+	u_int32_t used_data_length;
+	/** Helper field that stores content of args/envp for the serialization */
+	char data[NPM_DATA_SIZE_MAX];
+}  __attribute__((__packed__));
+
+/** Extracts npm params from user space passed params to a tcmi structure.
+ *
+ * @param params Structure to be filled with extracted data
+ * @returns 0 on success
+ */
+int extract_tcmi_npm_params(struct tcmi_npm_params* params, const char * filename, const char __user * const __user *argv, const char __user * const __user *envp);
+
+
+/** UGLY UGLY! Following 2 funcs would ideally not be in a header.. this is just a quick hack to made code working when deployed as modules.. better solution required */
+
+/** How many bytes to be reserved for array */
+static inline int reserve_array_length(int count) {
+	// We have to use size of 64 bit pointer so that it is platform compatible
+	return (1+count)*sizeof(int64_t);
+}
+
+/**
+ * Given a npm params structure, this method will fixup args and envp pointers to point to correct places 
+ * in the data member.
+ */
+static int fixup_npm_params_pointers(struct tcmi_npm_params* params) {
+	int i, pos =0;
+
+	// Decode args array pointer
+	params->args = (char**)params->data;
+	pos += reserve_array_length(params->argsc);
+	// Fill in pointers in arg arrays pointer
+	for ( i=0; i < params->argsc; i++ ) {
+		int len = strlen(params->data+pos);
+		
+		params->args[i] = params->data + pos;
+		pos += (len+1);
+	}
+	params->args[i] = NULL;
+
+	// Decode envp array pointer
+	params->envp = (char**)(params->data + pos);
+	pos += reserve_array_length(params->envpc);
+	// Fill in pointers in envp arrays pointer
+	for ( i=0; i < params->envpc; i++ ) {
+		int len = strlen(params->data+pos);
+		
+		params->envp[i] = params->data + pos;
+		pos += (len+1);
+	}
+	params->envp[i] = NULL;
+
+	return 0;
+}
+#endif
--- linux-3.7.1_original/clondike/src/tcmi/migration/tcmi_mighooks.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/migration/tcmi_mighooks.c	2013-03-12 19:30:31.000000000 +0100
@@ -0,0 +1,284 @@
+/**
+ * @file tcmi_mighooks.c - a separate module that install migration hooks into the kernel.
+ *                      
+ * 
+ *
+ *
+ * Date: 05/06/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_mighooks.c,v 1.11 2009-04-06 21:48:46 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/vmalloc.h>
+#include <linux/resource.h>
+
+#include <tcmi/task/tcmi_taskhelper.h>
+#include <tcmi/comm/tcmi_vfork_done_procmsg.h>
+#include <tcmi/manager/tcmi_ccnman.h>
+#include <tcmi/manager/tcmi_penman.h>
+#include <clondike/tcmi/tcmi_hooks.h>
+
+#define TCMI_MIGHOOKS_PRIVATE
+#include "tcmi_mighooks.h"
+#include "tcmi_npm_params.h"
+#include <arch/current/regs.h>
+
+#include <dbg.h>
+#include <director/director.h>
+#include <proxyfs/proxyfs_server.h>
+#include <proxyfs/proxyfs_helper.h>
+
+/** 
+ * \<\<public\>\> Registers all hooks with the kernel.
+ *
+ * @return 0 upon success
+ */
+int tcmi_mighooks_init(void)
+{
+	minfo(INFO1, "Registering TCMI migration hooks");
+	tcmi_hooks_register_exit(tcmi_mighooks_do_exit);
+	tcmi_hooks_register_sig_unused(tcmi_mighooks_mig_mode);
+	tcmi_hooks_register_execve(tcmi_mighooks_execve);
+	tcmi_hooks_register_replace_proc_self_file(tcmi_mighooks_replace_proc_self_file);
+	return 0;
+}
+
+/** 
+ * \<\<public\>\> Unregisters all hooks.
+ */
+void tcmi_mighooks_exit(void)
+{
+	minfo(INFO1, "Unregistering TCMI migration hooks");
+	tcmi_hooks_unregister_exit();
+	tcmi_hooks_unregister_sig_unused();
+	tcmi_hooks_unregister_execve();
+	tcmi_hooks_unregister_replace_proc_self_file();
+}
+
+/** @addtogroup tcmi_mighooks_class
+ *
+ * @{
+ */
+
+
+// TODO: Temporary 64 bit debug.. make it either arch independed or remove it
+/*
+static void dump_user_stack(void) {
+        struct frame_head {
+                struct frame_head * ebp;
+                unsigned long ret;
+        } __attribute__((packed)) stack_frame[2], *head;
+
+        struct pt_regs *nregs = task_pt_regs(current);
+
+        mdbg(INFO1,"[user] <%lx> EBP <%lx>\n ESP <%lx>", nregs->rip, nregs->rbp, nregs->rsp);
+
+        head = (struct frame_head *)nregs->rbp;
+
+        if (user_mode_vm(nregs)) {
+                do {
+			if (!access_ok(VERIFY_READ, head, sizeof(stack_frame)))
+                 		return;
+
+         		if (__copy_from_user_inatomic((char *)stack_frame, head, sizeof(stack_frame)))
+				return;
+
+                        mdbg(INFO1,"[user] <%lx> EBP: <%lx>\n", stack_frame[0].ret, stack_frame[0].ebp);
+
+                        if (head >= stack_frame[0].ebp)
+		                return;
+
+                        head = stack_frame[0].ebp;
+                        } while (head->ebp);
+                mdbg(INFO1,"[user] <%lx>\n", head->ret);
+        }
+}
+*/
+
+/**
+ * \<\<private\>\> Exit system call hook.  Delegates work to the task
+ * helper that notifies current process by submitting a task_exit
+ * method and supplying the exit code.  The task handles the rest on
+ * its own.
+ *
+ * The priority notification is used, so that the exit follows
+ * immediately.
+ *
+ * This hook is called for every process in the system, but does
+ * something only for TCMI tasks.
+ *
+ * @param code - process exit code
+ * @return - status of how the notification went.
+ */
+static long tcmi_mighooks_do_exit(long code)
+{
+	int prio = 1, is_shadow;
+	struct rusage rusage;
+	mm_segment_t old_fs;
+	long res;
+	
+	is_shadow = (current->tcmi.task_type == shadow || current->tcmi.task_type == shadow_detached);
+
+	old_fs = get_fs();
+	set_fs(get_ds());
+	res = getrusage(current, RUSAGE_SELF, &rusage);
+	set_fs(old_fs);
+	director_task_exit(current->pid, code, &rusage);
+	
+	res = tcmi_taskhelper_notify_current(tcmi_task_exit, &code, 
+					      sizeof(code), prio);
+
+	if ( is_shadow ) { // If the exitting task is a shadow task, we release all its proxy files as they won't be needed
+		proxyfs_sync_files_on_exit(); // We have to synchronize all files first so that no new writes occur after server release
+		proxyfs_server_release_all();
+	}
+
+	return res;
+}
+
+
+/**
+ * \<\<private\>\> This hook is called upon SIGUNUSED delivery to a
+ * particular process.  All work is delegated to the task helper. The
+ * context passed onto the task helper is used for updating the TCMI
+ * task. Any potential migration request thus operates on the latest
+ * process context.
+ *
+ * @param *regs - process context right before entering kernel mode.
+ */
+static long tcmi_mighooks_mig_mode(struct pt_regs *regs)
+{
+	tcmi_taskhelper_do_mig_mode(regs);
+	return 0;
+}
+
+static void tcmi_try_npm_on_exec(const char *filename, const char __user * const __user * argv, 
+		const char __user * const __user * envp, struct pt_regs *regs, 
+		struct tcmi_man* man, int is_guest) 
+{
+	struct rusage rusage;
+	mm_segment_t old_fs;
+	int migman_to_use = -1;
+	int migrate_home = 0;
+
+	old_fs = get_fs();
+	set_fs(get_ds());
+	getrusage(current, RUSAGE_SELF, &rusage);
+	set_fs(old_fs);
+	if (director_npm_check(current->pid, current_euid(), is_guest, filename, argv, envp, &migman_to_use, &migrate_home, &rusage) != 1 )
+		return;
+
+	migrate_home = is_guest ? migrate_home : 0;
+
+	// Check if we should emigrate and if so where
+	if ( migman_to_use != -1 || migrate_home ) {
+		struct tcmi_npm_params* npm_params = vmalloc(sizeof(struct tcmi_npm_params));
+		int err = extract_tcmi_npm_params(npm_params, filename, argv, envp);	
+		mdbg(INFO4, "AFTER EXTRACT Filename: %s, Argc: %d, Evnpc: %d.", npm_params->file_name, npm_params->argsc, npm_params->envpc);
+		if ( err ) {
+			mdbg(ERR3, "Error extracting npm params: %d. Skipping npm emigration attempt.", err);
+			vfree(npm_params);
+		} else {
+			if ( migrate_home )
+				tcmi_penman_migrateback_npm(man, regs, npm_params);
+			else
+				tcmi_man_emig_npm(man, current->pid, migman_to_use, regs, npm_params);
+			// If we got here, the migration was not performed => free npm params
+			mdbg(INFO3, "Freeing npm_params after unsuccessful npm migration attempt.");
+			vfree(npm_params);
+		}
+	}
+}
+
+static long tcmi_mighooks_execve(const char *filename, const char __user * const __user * argv, const char __user * const __user * envp, struct pt_regs *regs) {	
+	if ( !current->tcmi.tcmi_task ) {
+		// The task is not controlled by clondike => we can non-preemptively migrate it ONLY if there is CCN registered on current node
+		struct tcmi_ccnman* ccn_man = tcmi_ccnman_get_instance();
+		if ( ccn_man != NULL )
+			tcmi_try_npm_on_exec(filename, argv, envp, regs, TCMI_MAN(ccn_man), 0);
+	} else if ( tcmi_task_get_type(current->tcmi.tcmi_task) == guest ) {
+		// We allow npm only after we get initial execve executed.. not during the initial image load!
+		if ( tcmi_task_get_execve_count(current->tcmi.tcmi_task) > 1 ) {
+			// Task is guest, so DN has to take care of its possible NPM
+			struct tcmi_penman* pen_man = tcmi_penman_get_instance();
+	
+			mdbg(INFO3, "Guest exec hook called. File %s", filename);
+			tcmi_try_npm_on_exec(filename, argv, envp, regs, TCMI_MAN(pen_man), 1);
+		} else {
+			// On first exceve, we notify about possible vfork done
+			// TODO: We may optimize this, and notify only in case it is required.. this would require some flag in tcmi_task, that would be caried here during emigration
+			struct tcmi_msg *m;
+			// We do not aquire reference to t_task as it cannot be release at this moment
+			struct tcmi_task* t_task = current->tcmi.tcmi_task;
+		
+			if ( !t_task) {
+				mdbg(ERR3, "No tcmi task associated!");
+				goto exit0;
+			}
+
+			if (!(m = tcmi_vfork_done_procmsg_new_tx(t_task->remote_pid))) {
+				mdbg(ERR3, "Can't create vfork done message");
+				// TODO: What to do in this case? ;) For now we just ignore it.
+				goto exit0;
+			}
+
+		
+			tcmi_task_send_anonymous_msg(t_task, m);
+			tcmi_msg_put(m);
+			
+			exit0:
+			;
+		}
+		tcmi_task_inc_execve_count(current->tcmi.tcmi_task);
+	} else {
+		// We are shadow task => ignore this hook, shadow execves only when restarting process that was migrated back
+		tcmi_task_inc_execve_count(current->tcmi.tcmi_task);
+	}
+
+	return 0;
+};
+
+
+static long tcmi_mighooks_replace_proc_self_file(const char* filename, const char** result) {	
+	if ( strncmp("/proc/self",filename,10) == 0 ) {
+		int len;
+		char * tmp_result = __getname();
+	
+		if ( !(tmp_result) )
+			return -ENOMEM;
+
+		//len = sprintf((tmp_result), "/proc/%d%s", tcmi_task_remote_pid(current->tcmi.tcmi_task), filename+10);
+		len = sprintf((tmp_result), "/mnt/local/proc/self%s", filename+10);
+
+		mdbg(ERR3, "Replaced open filename from %s to %s (len: %d)", filename, (tmp_result), len);
+		*result = tmp_result;
+	}	
+
+	return 0;
+}
+
+/**
+ * @}
+ */
--- linux-3.7.1_original/clondike/src/tcmi/migration/tcmi_npm_params.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/migration/tcmi_npm_params.c	2013-03-12 19:52:31.000000000 +0100
@@ -0,0 +1,98 @@
+/**
+ * @file tcmi_npm_params.c - non-preemptive parameters utils.
+ *                      
+ */
+
+#include "tcmi_npm_params.h"
+#include <asm/uaccess.h>
+#include <linux/module.h>
+
+#include <dbg.h>
+
+/*
+ * @copied_from_kernel
+ *
+ * count() counts the number of strings in array user char array
+ */
+static int count(const char __user * const __user * argv, int max)
+{
+	int i = 0;
+
+	if (argv != NULL) {
+		for (;;) {
+			char __user * p;
+
+			if (get_user(p, argv))
+				return -EFAULT;
+			if (!p)
+				break;
+			argv++;
+			if(++i > max)
+				return -E2BIG;
+			cond_resched();
+		}
+	}
+	return i;
+}
+
+static int copy_strings(int argc, const char __user * const __user * argv,
+			struct tcmi_npm_params* params, int* remaining_max_length)
+{
+	int ret = 0, i;
+
+	(*remaining_max_length) -= reserve_array_length(argc); // Reserve space for the array pointing to strings
+
+	for (i = 0; i < argc; i++ ) {
+		char __user *str;
+		int len, err;
+
+		if (get_user(str, argv+i) ||
+				!(len = strnlen_user(str, *remaining_max_length))) {
+			ret = -EFAULT;
+			goto out;
+		} // Retrieved len includes trailing zero
+		
+		if ( *remaining_max_length < len)  {
+			ret = -E2BIG;
+			goto out;
+		}
+
+		err = copy_from_user(params->data + NPM_DATA_SIZE_MAX - (*remaining_max_length), str, len);
+		if (err) {
+			ret = -EFAULT;
+			goto out;
+		}
+
+		*remaining_max_length -= len;		
+	}	
+out:
+	return ret;
+}
+
+int extract_tcmi_npm_params(struct tcmi_npm_params* params, const char * filename, 
+			const char __user * const __user *argv, const char __user * const __user *envp) {
+	int remaining_max = NPM_DATA_SIZE_MAX;
+	int err;
+
+	if ( !params )
+		return -EINVAL;
+
+	if ( strlen(filename)+1 > NPM_FILENAME_MAX )
+		return -EINVAL;
+
+	strcpy(params->file_name, filename);
+
+	params->argsc = count(argv, NPM_DATA_SIZE_MAX/sizeof(void*));
+	params->envpc = count(envp, NPM_DATA_SIZE_MAX/sizeof(void*));
+
+	if ( (err = copy_strings(params->argsc, argv, params, &remaining_max)) )
+		return err;
+	if ( (err = copy_strings(params->envpc, envp, params, &remaining_max)) )
+		return err;
+
+	params->used_data_length = NPM_DATA_SIZE_MAX - remaining_max;
+
+	mdbg(INFO4, "Filename: %s, Argc: %d, Evnpc: %d Used data: %d", params->file_name, params->argsc, params->envpc, params->used_data_length);
+
+  return fixup_npm_params_pointers(params);
+};
--- linux-3.7.1_original/clondike/src/tcmi/migration/fs/9p_fs_mounter.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/migration/fs/9p_fs_mounter.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,14 @@
+#ifndef _9P_FS_MOUNTER_H
+#define _9P_FS_MOUNTER_H
+
+struct fs_mounter;
+struct fs_mount_params;
+
+/**
+ * 9p mounter handles mounting of Plan9 filesystem in the private namespace. It does not support any security right not.
+ */
+
+/** Creates a new instance of the 9p file system mounter */
+struct fs_mounter* new_9p_fs_mounter(struct fs_mount_params* params);
+
+#endif
--- linux-3.7.1_original/clondike/src/tcmi/migration/fs/fs_mounter_register.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/migration/fs/fs_mounter_register.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,33 @@
+#include "fs_mounter_register.h"
+#include <dbg.h>
+#include <asm/string.h>
+#include <linux/slab.h>
+
+#include "fs_mounter.h"
+#include "fs_mount_params.h"
+#include "9p_fs_mounter.h"
+#include "9p_fs_global_mounter.h"
+
+/**
+ * Returns new mounter instance with specified params.
+ */
+struct fs_mounter* get_new_mounter(struct fs_mount_params* params) {
+	if ( strcmp("9p",params->mount_type) == 0 )
+		return new_9p_fs_mounter(params);
+
+	if ( strcmp("9p-global",params->mount_type) == 0 )
+		return new_9p_global_fs_mounter(params);
+
+	return NULL;
+}
+
+/** Releases mounter instance */
+void free_mounter(struct fs_mounter* mounter) {
+	if ( !mounter )
+		return;
+	
+	if ( mounter->free )
+		mounter->free(mounter);
+
+	kfree(mounter);
+}
--- linux-3.7.1_original/clondike/src/tcmi/migration/fs/9p_fs_global_mounter.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/migration/fs/9p_fs_global_mounter.c	2013-03-12 01:09:37.000000000 +0100
@@ -0,0 +1,70 @@
+#include <linux/slab.h>
+#include "9p_fs_global_mounter.h"
+#include "fs_mounter.h"
+#include <dbg.h>
+#include "9p_fs_helper.h"
+#include <tcmi/lib/util.h>
+
+#define MAX_MOUNT_ROOT_PATH 300
+
+static void get_mount_root(const char* device, int fsuid, int fsgid, char* mount_root) {
+	// TODO: Now we have fixed "root" of mount to /mnt/clondike.. maybe we can parametrize that? ;)
+	sprintf(mount_root, "/mnt/clondike/%s-%d-%d", device, fsuid, fsgid);
+}
+
+static int global_9p_mount(struct fs_mounter* mounter, int16_t fsuid, int16_t fsgid) {	
+	int err = 0;
+	char mount_buffer[MAX_MOUNT_ROOT_PATH], root_buffer[MAX_MOUNT_ROOT_PATH+6];
+	struct nameidata nd;
+	get_mount_root(mounter->params.mount_device, fsuid, fsgid, mount_buffer);
+	err = do_path_lookup(AT_FDCWD, mount_buffer, LOOKUP_FOLLOW | LOOKUP_DIRECTORY ,&nd);
+	if ( err ) {
+		minfo(ERR1, "Failed to lookup path %s: %d. Trying to create", mount_buffer, err);
+		err = mk_dir(mount_buffer, 777);
+	}
+	if ( err ) {
+		// TODO: For now, the dirs for mount have to be precreated.. they can be for example
+		// auto created via a user-space controller. In kernel, we do not have access to mkdir, right?
+		minfo(ERR1, "Failed to lookup path %s: %d. Creation failed.", mount_buffer, err);
+		return err;
+	}
+	sprintf(root_buffer, "%s/root", mount_buffer);
+	// TODO: In critical section so that we do not do multiple mounts
+	err = do_path_lookup(AT_FDCWD, root_buffer, LOOKUP_FOLLOW | LOOKUP_DIRECTORY ,&nd);	
+	if ( err ) {
+		// We've checked that "root"/root does not exist (We assume existence of a root dir in root of fs
+		// => 9p is not yet globally mount => mount
+		if ( (err = mount_9p_fs(mount_buffer, mounter, fsuid, fsgid)) ) {
+			minfo(ERR1, "Mount failed with err %d", err);
+			return err;
+		}
+	}		
+
+	return 0;
+}
+
+static int chroot_to_mount(struct fs_mounter* mounter, int16_t fsuid, int16_t fsgid) {	
+	int err = 0;
+	char mount_buffer[MAX_MOUNT_ROOT_PATH];
+
+	get_mount_root(mounter->params.mount_device, fsuid, fsgid, mount_buffer);
+
+	if ( (err = chroot_to(mount_buffer)) )
+		return err;
+		
+	return 0;
+}
+
+
+struct fs_mounter* new_9p_global_fs_mounter(struct fs_mount_params* params) {
+	struct fs_mounter* mounter = kmalloc(sizeof(struct fs_mounter), GFP_KERNEL);
+	
+	if ( !mounter )
+		return NULL;
+
+	mounter->global_mount = global_9p_mount;
+	mounter->private_mount = chroot_to_mount;
+	mounter->free = NULL;
+	mounter->params = *params;
+	return mounter;
+}
--- linux-3.7.1_original/clondike/src/tcmi/migration/fs/fs_mounter_register.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/migration/fs/fs_mounter_register.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,15 @@
+#ifndef _FS_MOUNTER_REGISTER_H
+#define _FS_MOUNTER_REGISTER_H
+
+struct fs_mounter;
+struct fs_mount_params;
+
+/**
+ * Returns new mounter instance with specified params.
+ */
+struct fs_mounter* get_new_mounter(struct fs_mount_params* params);
+
+/** Releases mounter instance */
+void free_mounter(struct fs_mounter* mounter);
+
+#endif
--- linux-3.7.1_original/clondike/src/tcmi/migration/fs/9p_fs_helper.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/migration/fs/9p_fs_helper.h	2013-03-12 01:11:04.000000000 +0100
@@ -0,0 +1,90 @@
+#ifndef _9P_FS_HELPER_H
+#define _9P_FS_HELPER_H
+
+#include <linux/types.h>
+#include <linux/completion.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/fs_struct.h>
+#include <linux/mount.h>
+#include <linux/namei.h>
+#include <linux/sched.h>
+#include <linux/jiffies.h>
+#include <linux/slab.h>
+
+#define MAX_ADDITIONAL_CONNECT_STR_LEN 200
+
+static int mount_9p_fs(const char* mount_point, struct fs_mounter* mounter, int16_t fsuid, int16_t fsgid) {
+	int err;
+	char* device = mounter->params.mount_device;
+	char* connect_param = mounter->params.mount_options;
+	char* mount_point_page = __getname();
+	int connect_str_len = strlen(connect_param);
+
+	if ( !mount_point_page )
+		return -ENOMEM;
+
+	memcpy(mount_point_page, mount_point, strlen(mount_point) + 1);
+	
+	connect_param = kmalloc(connect_str_len + MAX_ADDITIONAL_CONNECT_STR_LEN, GFP_KERNEL);
+	if ( !connect_param ) {
+		err = -ENOMEM;
+		goto exit0;
+	}
+
+	if ( connect_str_len == 0 ) {
+		snprintf(connect_param, connect_str_len + MAX_ADDITIONAL_CONNECT_STR_LEN, "cuid=%d,cgid=%d", fsuid, fsgid);
+	} else {
+		snprintf(connect_param, connect_str_len + MAX_ADDITIONAL_CONNECT_STR_LEN, "%s,cuid=%d,cgid=%d", mounter->params.mount_options, fsuid, fsgid);
+	}
+
+	mdbg(INFO2, "9p mount device: %s mount options: %s mount point: %s", device, connect_param, mount_point);
+
+	err = do_mount(device, mount_point_page, "9p", 0, connect_param);
+	mdbg(INFO2, "After 9P mount: %d", err);
+	if ( err ) {
+		minfo(ERR1, "Failed to mount filesystem: %d", err);
+		goto exit1;
+	}
+	return 0;
+
+exit1:
+	kfree(connect_param);
+exit0:
+	__putname(mount_point_page);
+	return err;	
+};
+
+/**
+ * Chroots process to a new root
+ *
+ * @todo: Move to some generic fs helper, if we ever have another fs mounter.
+ */
+static int chroot_to(const char* path_to_chroot) {
+	int err;
+	struct path old_root;
+	struct nameidata nd;
+
+	err = do_path_lookup(AT_FDCWD, path_to_chroot, LOOKUP_FOLLOW | LOOKUP_DIRECTORY ,&nd);
+	if ( err ) {
+		minfo(ERR1, "Failed to lookup path %s: %d", path_to_chroot, err);
+		goto exit0;
+	}	
+
+	/* Chroots.. duplicated code from chroot as it cannot be used directly */
+        write_lock(&current->fs->lock);
+        old_root = current->fs->root;
+	path_get(&nd.path);
+        current->fs->root = nd.path;
+        write_unlock(&current->fs->lock);
+        if (old_root.dentry) {
+                 path_put(&old_root);                 
+        }
+
+	return 0;
+
+exit0:
+	return err;
+};
+
+#endif
--- linux-3.7.1_original/clondike/src/tcmi/migration/fs/9p_fs_mounter.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/migration/fs/9p_fs_mounter.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,33 @@
+#include "9p_fs_mounter.h"
+#include "fs_mounter.h"
+#include <dbg.h>
+#include "9p_fs_helper.h"
+#include <tcmi/lib/util.h>
+
+static int do_private_9p_mount(struct fs_mounter* mounter, int16_t fsuid, int16_t fsgid) {	
+	int err = 0;
+	/* 
+ 	   TODO: improvement would be to find some existing dir, currently /mnt/test is assumed to exist, perhaps just /mnt would be better..
+	*/
+	if ( (err = mount_9p_fs("/mnt/test", mounter, fsuid, fsgid)) )
+		return err;
+
+	if ( (err = chroot_to("/mnt/test")) )
+		// TODO: Unmount?
+		return err;
+		
+	return 0;
+}
+
+struct fs_mounter* new_9p_fs_mounter(struct fs_mount_params* params) {
+	struct fs_mounter* mounter = kmalloc(sizeof(struct fs_mounter), GFP_ATOMIC);
+	
+	if ( !mounter )
+		return NULL;
+
+	mounter->global_mount = NULL;
+	mounter->private_mount = do_private_9p_mount;
+	mounter->free = NULL;
+	mounter->params = *params;
+	return mounter;
+}
--- linux-3.7.1_original/clondike/src/tcmi/migration/fs/fs_mounter.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/migration/fs/fs_mounter.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,21 @@
+#ifndef _FS_MOUNTER_H
+#define _FS_MOUNTER_H
+
+#include "fs_mount_params.h"
+#include <linux/types.h>
+
+/** 
+ * Class handling the filesystem mounting, that is performed before the process restart 
+ * If there is no fs_mounter registered, no mounting is performed and the filesystem is expected to be already mounted (or not required)
+ */
+struct fs_mounter {
+	struct fs_mount_params params;
+	/** Called, in context of a kernel process, it can make mounts to a global namespace*/
+	int (*global_mount)(struct fs_mounter* self, int16_t fsuid, int16_t fsgid);
+	/** Called, in context of a new process, in its private namespace */
+	int (*private_mount)(struct fs_mounter* self, int16_t fsuid, int16_t fsgid);
+	/** Custom free method */
+	void (*free)(struct fs_mounter* self);
+};
+
+#endif
--- linux-3.7.1_original/clondike/src/tcmi/migration/fs/fs_mount_params.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/migration/fs/fs_mount_params.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,21 @@
+#ifndef _FS_MOUNT_PARAMS_H
+#define _FS_MOUNT_PARAMS_H
+
+/** Max length of the mount type name */
+#define TCMI_FS_MOUNT_LENGTH 80
+/** Max length of the mount options */
+#define TCMI_FS_MOUNT_OPTIONS_LENGTH 128
+/** Max length of the mount device */
+#define TCMI_FS_MOUNT_DEVICE_LENGTH 64
+
+/** Helper structure that keeps data about the mounting which should be performed on PEN */
+struct fs_mount_params {
+	/** Mounter to be used */
+	char mount_type[TCMI_FS_MOUNT_LENGTH];
+	/** Mounter options */
+	char mount_options[TCMI_FS_MOUNT_OPTIONS_LENGTH];
+	/** Mounter device */
+	char mount_device[TCMI_FS_MOUNT_DEVICE_LENGTH];
+} __attribute__((__packed__));;
+
+#endif
--- linux-3.7.1_original/clondike/src/tcmi/migration/fs/9p_fs_global_mounter.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/migration/fs/9p_fs_global_mounter.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,14 @@
+#ifndef _9P_GLOBAL_FS_MOUNTER_H
+#define _9P_GLOBAL_FS_MOUNTER_H
+
+struct fs_mounter;
+struct fs_mount_params;
+
+/**
+ * 9p mounter handles mounting of Plan9 filesystem in a public namespace. It does not support any security right not.
+ */
+
+/** Creates a new instance of the 9p file system mounter */
+struct fs_mounter* new_9p_global_fs_mounter(struct fs_mount_params* params);
+
+#endif
--- linux-3.7.1_original/clondike/src/tcmi/migration/tcmi_migcom.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/migration/tcmi_migcom.c	2013-03-12 00:32:25.000000000 +0100
@@ -0,0 +1,680 @@
+/**
+ * @file tcmi_migcom.c - TCMI migration component.
+ *                      
+ * 
+ *
+ *
+ * Date: 05/05/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_migcom.c,v 1.13 2009-04-06 21:48:46 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <tcmi/task/tcmi_taskhelper.h>
+#include <tcmi/task/tcmi_shadowtask.h>
+#include <tcmi/task/tcmi_guesttask.h>
+#include <tcmi/lib/util.h>
+
+#define TCMI_MIGCOM_PRIVATE
+#include "tcmi_migcom.h"
+#include <tcmi/manager/tcmi_penmigman.h>
+#include <tcmi/migration/fs/fs_mounter_register.h>
+#include <tcmi/migration/fs/fs_mounter.h>
+#include "tcmi_npm_params.h"
+
+#include <director/director.h>
+
+#include <dbg.h>
+
+
+static int mount_proxyfs(struct kkc_sock* sock) {	
+	int err = 0, len;
+	char buffer[KKC_MAX_ARCH_LENGTH + KKC_SOCK_MAX_ADDR_LENGTH + 2];	
+	char* last_colon_char;
+	struct cred* new_cred;
+
+	new_cred = prepare_creds();
+	if ( !new_cred )
+		return -ENOMEM;
+
+	// TODO: Make mount dir configurable?
+	
+	memset(buffer, 0, KKC_MAX_ARCH_LENGTH + KKC_SOCK_MAX_ADDR_LENGTH + 2);
+	kkc_sock_getarchname(sock, buffer, KKC_MAX_ARCH_LENGTH);
+	len = strlen(buffer);
+	buffer[len] = ':';
+	kkc_sock_getpeername(sock, buffer + len + 1, KKC_SOCK_MAX_ADDR_LENGTH);
+	// TODO: Ugly ugly... works only for specific format of string and in addition port is hardcoded here
+	last_colon_char = strrchr(buffer, ':');	
+	sprintf(last_colon_char+1, "%d", 1112); 
+	
+	mdbg(INFO2, "Going to mount proxyfs on dev: %s fsuid: %d euid: %d csa: %d euid: %d uid: %d, suid: %d", buffer, current_fsuid(), current_euid(), capable(CAP_SYS_ADMIN), current_euid(), current_uid(), current_suid() );
+
+	// TODO: Ohh man.. this is something terrible.. we should fiddle better with the fs rights, so that we do not need this
+	// The problem is, that all works fine for newly created immigrated processes, since they have these capabilities, but
+	// when we start using forked processes, they do not and they have a lot of problems with FS access, for example to proxy-fs			
+	cap_raise (new_cred->cap_effective, CAP_SYS_ADMIN);
+	cap_raise (new_cred->cap_effective, CAP_DAC_READ_SEARCH);
+	cap_raise (new_cred->cap_effective, CAP_DAC_OVERRIDE);  
+	cap_raise (new_cred->cap_effective, CAP_FOWNER);
+	cap_raise (new_cred->cap_effective, CAP_FSETID);
+
+	commit_creds(new_cred);
+
+	err = do_mount(buffer, "/mnt/proxy", "proxyfs", 0, NULL);
+	mdbg(INFO2, "After Proxyfs mount: %d", err);
+	if ( err ) {
+		minfo(ERR1, "Failed to mount filesystem: %d", err);
+		goto exit0;
+	}	
+
+exit0:
+	return err;
+}
+
+static const char proc_path[] = "/mnt/local/proc";
+/** Mounts local machine procfs into some directory in chrooted env, so that it can be later accessed if required */
+static int mount_local_procfs(struct kkc_sock* sock) {
+	struct nameidata nd;
+	int err;
+  //Replaced function path_lookup to do_path_lookup for kernel 3.7.1 | by Jiri Rakosnik 
+	err = do_path_lookup(AT_FDCWD, proc_path, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &nd);
+	if ( err ) {
+		minfo(ERR1, "Failed to lookup path %s: %d. Trying to create", proc_path, err);
+		err = mk_dir(proc_path, 777);
+		if (err) {
+			goto exit0;
+		}
+	}
+
+	err = do_mount("none", proc_path, "proc", 0, NULL);
+	mdbg(INFO2, "Procfs mount result: %d", err);
+	if ( err ) {
+		minfo(ERR1, "Failed to mount filesystem: %d", err);
+		goto exit0;
+	}	
+
+exit0:
+	return err;
+}
+
+static int tcmi_task_mount_proxyfs(void *self, struct tcmi_method_wrapper *wr) {
+	int res;
+	struct kkc_sock* sock = *(struct kkc_sock**)tcmi_method_wrapper_data(wr);
+	if ( (res =mount_proxyfs(sock)) ) {
+		minfo(ERR1, "Failed to mount proxy filesystem: %d", res);
+		// Kill current process.. do not exit via kill me as it does not invoke exit hook
+		force_sig(SIGKILL, current);
+	}
+	return TCMI_TASK_KEEP_PUMPING;
+}
+
+/** 
+ * \<\<public\>\> Migrates a task from a CCN to a PEN. 
+ * This requires:
+ * - instantiating a new shadow task - requires migration manager ID,
+ * communication socket, migproc directory(where the shadow will
+ * present its information) and root directory of the migration
+ * manager(for a symbolic link)
+ * - submitting emigration method
+ * - attaching the shadow task to the target process that is
+ * to be migrated
+ * - forcing the target process into migration mode
+ * - checking if the process has properly picked up the shadow task
+ *
+ * This method exclusively uses preemptive process migration using
+ * physical checkpoint image.
+ *
+ * @param pid - task that is to be migrated
+ * @param *migman - migration manager that will provide the communication
+ * channel for the migrated task.
+ * @return 0 upon success;
+ */
+int tcmi_migcom_emigrate_ccn_ppm_p(pid_t pid, struct tcmi_migman *migman)
+{
+	int err = 0;
+	struct tcmi_task *shadow;
+
+	/* create a new PPM shadow task for physical ckpt image  */
+	if (!(shadow = 
+	      tcmi_shadowtask_new(pid, migman, 
+				  tcmi_migman_sock(migman), 
+				  tcmi_migman_migproc_dir(migman), 
+				  tcmi_migman_root(migman)))) {
+		minfo(ERR3, "Error creating a shadow task");
+		goto exit0;
+	}
+
+	/* submit the emigrate method */
+	mdbg(INFO3, "Submitting emigrate_ppm_p");
+	tcmi_task_submit_method(shadow, tcmi_task_emigrate_ppm_p, NULL, 0);
+
+	/* attaches the shadow to its thread. */
+	if (tcmi_taskhelper_attach(shadow, tcmi_migcom_mig_mode_handler) < 0) {
+		mdbg(ERR3, "Failed attaching shadow PID=%d to its thread", 
+		     tcmi_task_local_pid(shadow));
+		goto exit1;
+	}
+
+	/* switch the task to migration mode */	
+	tcmi_taskhelper_enter_mig_mode(shadow);
+
+	/* wait for pickup */
+	if (tcmi_taskhelper_wait_for_pick_up_timeout(shadow, 2*HZ) < 0) {
+		mdbg(INFO1, "Shadow not picked up: %p", shadow);
+		director_emigration_failed(pid);
+	} else {
+		mdbg(INFO1, "Shadow successfully picked up: %p", shadow);
+	}
+
+	/* release the shadow instance reference (Reference is now held by the associated task_struct - it got it in attach method)*/
+	tcmi_task_put(shadow);
+
+	return 0;
+
+	/* error handling */
+ exit1:
+	tcmi_task_put(shadow);
+ exit0:
+	return err;
+
+}
+
+/** \<\<public\>\> Migrates non-preemptively a task from a CCN to a PEN */
+int tcmi_migcom_emigrate_ccn_npm(pid_t pid, struct tcmi_migman *migman, struct pt_regs* regs, struct tcmi_npm_params* npm_params) {
+	int err = 0;
+	struct tcmi_task *shadow;
+
+	/* create a new PPM shadow task for physical ckpt image  */
+	if (!(shadow = 
+	      tcmi_shadowtask_new(pid, migman, 
+				  tcmi_migman_sock(migman), 
+				  tcmi_migman_migproc_dir(migman), 
+				  tcmi_migman_root(migman)))) {
+		minfo(ERR3, "Error creating a shadow task");
+		goto exit0;
+	}
+	/* submit the emigrate method */
+	mdbg(INFO3, "Submitting emigrate_ppm_p");
+	tcmi_task_submit_method(shadow, tcmi_task_emigrate_npm, &npm_params, sizeof(void*));
+
+	/* attaches the shadow to its thread. */
+	if (tcmi_taskhelper_attach(shadow, tcmi_migcom_mig_mode_handler) < 0) {
+		mdbg(ERR3, "Failed attaching shadow PID=%d to its thread", 
+		     tcmi_task_local_pid(shadow));
+		goto exit1;
+	}
+
+
+	/* release the shadow instance reference (Reference is now held by the associated task_struct - it got it in attach method)*/
+	tcmi_task_put(shadow);
+	/* Task now holds its reference to a migman so we can release it */
+	tcmi_migman_put(migman);
+
+	/* We are already in migmode so we can directly execute handler here */
+	tcmi_taskhelper_do_mig_mode(regs);
+	//tcmi_migcom_mig_mode_handler();
+			
+	// We get here only if npm migration failed, othewise either of the following happens:
+	// - task finishes remotely, so the handler exists
+	// - task migrates back, so it must execve to a new checkpoint => we still do not get here
+	mdbg(INFO3, "Got after npm migration handler start");
+	
+	director_emigration_failed(pid);
+
+	// Ok, the emigration failed. Task is going to release its reference to migman and we've release the reference we got
+	// from the manager.. we have to retake this reference so that the release made by manager has matching get
+	// TODO: This is incorrect.. task is already freed and has freed its reference! It may happen, that the migman is already freed!
+	// How to solve this nicely? .. ;)
+	tcmi_migman_get(migman);
+	return 0;
+
+	/* error handling */
+ exit1:
+	tcmi_task_put(shadow);
+ exit0:
+	return err;
+
+};
+
+/** Helper struct to be passed to immigration statup thread */
+struct  immigrate_startup_params {
+	/** used to signal the thread the guest(or fs mount respectively) is ready */	
+	struct completion guest_ready, fs_ready;
+	/** Params for mounting of distributed fs */
+	struct fs_mount_params* mount_params;
+	/** Migman socket.. used to determine peers address so that we can mount its proxyfs */
+	struct kkc_sock* sock;
+	/** Credentials that can be used for fs mounting */
+	int16_t fsuid, fsgid;
+};
+
+/** 
+ * \<\<public\>\> Immigrates a task - handles accepting the task on
+ * the PEN side.  This method immigrates a new task based on an
+ * emigration message that a PEN has received as follows:
+ *
+ * - creates a new kernel thread that will wait until the new guest
+ * process is instantiated (waits with timeout on guest_ready
+ * completion)
+ * - instantiates a new guest task. 
+ * - delivers the migration message to it and makes a necessary setup,
+ * so that the guest task processes the message as soon as it becomes
+ * a regular migrated process
+ * - attaches the guest to its new process(thread)
+ * - announces that the guest instance is ready to the thread via completion
+ * - waits for the thread to pickup the guest and become a migrated
+ * process
+ *
+ * @param *m - a message based on which we are immigrating the task
+ * @param *migman - migration manager that will provide the communication
+ * channel for the migrated task.
+ * migration information
+ * @return 0 upon success
+ */
+int tcmi_migcom_immigrate(struct tcmi_msg *m, struct tcmi_migman *migman)
+{
+	int err = -EINVAL;
+	int pid;
+	int wait_for_msg = 0;
+
+	struct fs_mounter* mounter;
+
+	struct immigrate_startup_params startup_params;
+	struct tcmi_task *guest;
+	struct tcmi_penmigman* penmigman = TCMI_PENMIGMAN(migman);
+	struct tcmi_p_emigrate_msg* msg = TCMI_P_EMIGRATE_MSG(m);
+	int accept = 0;
+
+
+	int call_res = director_immigration_request(tcmi_migman_slot_index(migman), tcmi_p_emigrate_msg_euid(msg), tcmi_p_emigrate_msg_exec_name(msg), &accept);
+	if ( call_res == 0 ) {
+		if ( !accept ) {
+			mdbg(INFO2, "Immigration rejected by director.");
+			// Rejected immigration
+			return -EINVAL;
+		}
+	}
+
+
+	init_completion(&startup_params.guest_ready);
+	init_completion(&startup_params.fs_ready);
+	startup_params.mount_params = tcmi_penmigman_get_mount_params(penmigman);
+	startup_params.sock = tcmi_migman_sock(migman);
+	startup_params.fsuid = tcmi_p_emigrate_msg_fsuid(msg);
+	startup_params.fsgid = tcmi_p_emigrate_msg_fsgid(msg);
+
+	// Global part of mount
+	mounter = get_new_mounter(startup_params.mount_params);	
+	if ( mounter && mounter->global_mount ) {
+		/* Some file system mounter is registered => perform the mount */
+		mdbg(INFO2, "Doing global mount");
+		err = mounter->global_mount(mounter, startup_params.fsuid, startup_params.fsgid);
+		if ( err ) {
+			free_mounter(mounter);
+			goto exit0;
+		}
+	}
+	free_mounter(mounter);
+
+
+	/* new thread is started with a private namespace so that the mounts in that thread are not global */
+	if ((pid = kernel_thread(tcmi_migcom_migrated_task, &startup_params, CLONE_NEWNS)) < 0) {
+		mdbg(ERR3, "Cannot start kernel thread for guest process %d", pid);
+		goto exit0;
+	}
+
+	/* before we proceed with restarting, we have to wait till the file system mount is ready (if it is performed) */
+	if ((err = wait_for_completion_interruptible(&startup_params.fs_ready))) {
+		minfo(ERR3, "Received signal fs not ready");
+		goto exit0;
+	}
+	
+	if (!(guest = tcmi_guesttask_new(pid, migman, 
+					tcmi_migman_sock(migman), 
+					tcmi_migman_migproc_dir(migman), 
+					tcmi_migman_root(migman)))) {
+		mdbg(ERR3, "Error creating a guest task");
+		goto exit0;
+	}
+	/* have the guest task deliver the message to itself, extra message reference is for the guest.*/
+	if (tcmi_task_deliver_msg(guest, tcmi_msg_get(m)) < 0) {
+		mdbg(ERR3, "Error delivering the message to the guest process");
+		tcmi_msg_put(m);
+	}
+	/* The message will be processed first. Submitted version does not wait for other messages,
+	so that it does not block potential processing of other methods later. */
+	mdbg(INFO3, "Submitting process_msg");
+	tcmi_task_submit_method(guest, tcmi_task_process_msg, &wait_for_msg, sizeof(int));
+
+	/* attaches the guest to its thread. */
+	if (tcmi_taskhelper_attach(guest, tcmi_migcom_mig_mode_handler) < 0) {
+		minfo(ERR3, "Failed attaching guest PID=%d to its thread", 
+		      tcmi_task_local_pid(guest));
+		goto exit1;
+	}
+
+	/* signal the new thread that the guest is ready. */
+	complete(&startup_params.guest_ready);
+
+	/* wait for pickup */
+	if (tcmi_taskhelper_wait_for_pick_up_timeout(guest, 2*HZ) < 0) {
+		mdbg(ERR1, "Guest not picked up: %p!!!!", guest);
+		goto exit1;
+	}
+	mdbg(INFO2, "Guest successfully picked up: %p", guest);
+	director_immigration_confirmed(tcmi_migman_slot_index(migman), tcmi_p_emigrate_msg_euid(msg), tcmi_p_emigrate_msg_exec_name(msg), pid, tcmi_p_emigrate_msg_reply_pid(msg));	
+	tcmi_task_put(guest);
+	return 0;
+
+	/* error handling */
+ exit1:
+	tcmi_task_put(guest);
+ exit0:
+	return err;
+
+}
+
+
+/** 
+ * \<\<public\>\> Migrates a task back to its home node using
+ * preemptive migration with physical checkpoint file. The approach is
+ * the same on CCN and PEN:
+ *
+ * - send a notification to a process with a given PID.
+ * - the priority is set to 1 which causes all method from the
+ * TCMI task to be flushed from its method queue.
+ *
+ * @param pid - task that is to be migrated
+ * @return 0 upon success;
+ */
+int tcmi_migcom_migrate_home_ppm_p(pid_t pid)
+{
+	/* set priority for the method - causes all methods to be flushed */
+	int prio = 1;
+	mdbg(INFO4, "request to migrate home pid %d", pid);
+	return tcmi_taskhelper_notify_by_pid(pid, tcmi_task_migrateback_ppm_p, 
+					     NULL, 0, prio);
+}
+
+
+/** @addtogroup tcmi_migcom_class
+ *
+ * @{
+ */
+
+/** 
+ * \<\<private\>\> This method represents a kernel thread that will
+ * eventually become the 'immigrated' task. It does following:
+ * 
+ * - tries to mount a distributed filesystem, if required (note, that this must be done by this thread as we are mounting into its private namespace)
+ * - mounts a proxyfs into a private namespace
+ * - waits until signalled, that the guest is ready
+ * - runs its migration mode handler (this picks up the task).
+ *
+ * @param *data - pointer to startup parameters
+ * @return shouldn't return as the execve will overlay current
+ * execution image.
+ * @todo process identity should be set according to the
+ * the user configuration (tcmi_confman)
+ */
+static int tcmi_migcom_migrated_task(void *data)
+{
+	int err = -EINVAL;
+	struct immigrate_startup_params* startup_params = (struct immigrate_startup_params*) data;
+	struct completion *guest_ready = &startup_params->guest_ready;
+	struct completion *fs_ready = &startup_params->fs_ready;
+	struct fs_mounter* mounter;
+	struct cred* new_cred;
+	
+	mdbg(INFO2, "New potential guest thread started. Pid: %d", current->pid);
+
+	new_cred = prepare_creds();
+	if ( !new_cred )
+		return -ENOMEM;
+
+	/* set process credentials */
+	new_cred->uid = new_cred->euid = new_cred->suid = new_cred->fsuid = 
+	new_cred->gid = new_cred->egid = new_cred->sgid = new_cred->fsgid = 999;
+
+	commit_creds(new_cred);
+
+	
+//	current_uid() = current_euid() = current_suid() = current_fsuid() =
+//		current_gid() = current_egid() = current_sgid() =
+//		current_fsgid() = 999;
+	/* This part simulates when the process didn't pickup
+	   the task on time 
+	set_current_state(TASK_INTERRUPTIBLE);
+	schedule_timeout(5*HZ); 
+	minfo(INFO1, "Task has woken up %p", current);
+	*/
+
+	// TODO: Close ALL fs.. are there some others? ;)
+	sys_close(0);
+	sys_close(1);
+	sys_close(2);
+
+	mdbg(INFO2, "Creating mounter: %s", startup_params->mount_params->mount_type);
+	mounter = get_new_mounter(startup_params->mount_params);	
+	mdbg(INFO2, "Created mounter: %p", mounter);
+	if ( mounter ) {
+		/* Some file system mounter is registered => perform the mount */
+		err = mounter->private_mount(mounter, startup_params->fsuid, startup_params->fsgid);
+		if ( !err )
+			mdbg(INFO2, "Private Mount succeeded");
+		free_mounter(mounter);
+		mdbg(INFO2, "Freed mounter");
+		if ( err ) {
+			/* We must notify anyway to prevent blocking */
+			complete(fs_ready);	
+			goto exit0;
+		}		
+	}
+	
+	err = mount_proxyfs(startup_params->sock);
+	if ( !err )
+		err = mount_local_procfs(startup_params->sock);
+
+	if ( err ) {
+		// We must notify anyway to prevent blocking
+		complete(fs_ready);	
+		goto exit0;
+	}
+
+	/* Notify about file system mount finished */
+	complete(fs_ready);
+
+	mdbg(INFO2, "Starting new thread for migrating task..");
+	if ((err = wait_for_completion_interruptible(guest_ready))) {
+		minfo(INFO1, "Received signal guest not ready");
+		goto exit0;
+	}
+	mdbg(INFO3, "Guest task is ready by now..");
+
+	/* migration mode handler picks up the task  */
+	if (tcmi_taskhelper_run_mig_mode_handler() < 0) {
+		mdbg(ERR3, "Failed to run migration mode handler");
+		goto exit0;
+	}
+
+	return 0;
+
+	/* error handling */
+ exit0:
+
+	return err;
+}
+
+/** \<\<public\>\> Fork of guest. Called in parent process context */
+int tcmi_migcom_guest_fork(struct task_struct* parent, struct task_struct* child, struct tcmi_migman* migman) {
+	struct tcmi_task *guest;
+	struct kkc_sock* sock;	
+
+	mdbg(INFO3, "Forking guest process => Making a new child guest as well.");
+	// TODO: We have to mount proxyfs&clondike fs in the child context.. schedule method to do that here
+	if (!(guest = tcmi_guesttask_new(child->pid, migman, 
+					tcmi_migman_sock(migman), 
+					tcmi_migman_migproc_dir(migman), 
+					tcmi_migman_root(migman)))) {
+		mdbg(ERR3, "Error creating a guest task on fork");
+		goto exit0;
+	}
+
+	sock = tcmi_migman_sock(migman); 
+	tcmi_task_submit_method(guest, tcmi_task_mount_proxyfs, &sock, sizeof(struct kkc_sock*));	
+	// Submit method, that will set tid of task into a user context.. it has to be done from that process context!	
+	tcmi_task_submit_method(guest, tcmi_guesttask_post_fork_set_tid, NULL, 0);
+
+	/* attaches the shadow to its thread. */
+	if (tcmi_taskhelper_attach_exclusive(child, guest, tcmi_migcom_mig_mode_handler) < 0) {
+		mdbg(ERR3, "Failed attaching guest PID=%d to its thread", 
+		     tcmi_task_local_pid(guest));
+		goto exit1;
+	}	
+
+	/* release the the instance reference (Reference is now held by the associated task_struct - it got it in attach method)*/
+	tcmi_task_put(guest);
+
+	/* switch the task to migration mode */	
+	tcmi_taskhelper_enter_mig_mode_exclusive(child, guest);
+
+	return 0;
+exit1:
+	tcmi_task_put(guest);
+exit0:
+	return -EINVAL;
+}
+
+/** \<\<public\>\> Fork of shadow */
+int tcmi_migcom_shadow_fork(struct task_struct* parent, struct task_struct* child, struct tcmi_migman* migman) {
+	struct tcmi_task *shadow;	
+
+	mdbg(INFO3, "Forking shadow process => Making a new child shadow as well.");
+
+	if (!(shadow = 
+	      tcmi_shadowtask_new(child->pid, migman, 
+				  tcmi_migman_sock(migman), 
+				  tcmi_migman_migproc_dir(migman), 
+				  tcmi_migman_root(migman)))) {
+		minfo(ERR3, "Error creating a shadow task for forked child");
+		goto exit0;
+	}
+	
+	// Submit process message so that the task is started in a main waiting loop
+	// First expected message to get is either about successful start, or about start failure
+	tcmi_task_submit_method(shadow, tcmi_task_process_msg, NULL, 0);
+
+	/* attaches the shadow to its thread. */
+	if (tcmi_taskhelper_attach_exclusive(child,shadow, tcmi_migcom_mig_mode_handler) < 0) {
+		mdbg(ERR3, "Failed attaching shadow PID=%d to its thread", 
+		     tcmi_task_local_pid(shadow));
+		goto exit1;
+	}
+
+	/* release the the instance reference (Reference is now held by the associated task_struct - it got it in attach method)*/
+	tcmi_task_put(shadow);
+
+
+	/* switch the task to migration mode */	
+	tcmi_taskhelper_enter_mig_mode_exclusive(child, shadow);
+
+	return 0;
+exit1:
+	tcmi_task_put(shadow);
+exit0:
+	return -EINVAL;
+}
+
+
+/** 
+ * \<\<private\>\> This handler is invoked when the sig_unused hook
+ * finds a non-NULL entry in the clondike record in the task_struct.
+ *
+ * What needs to be done:
+ * - check whether the process in migration mode has a valid TCMI task
+ * - launch the method pump
+ * - based on its return status:
+ *   -# let's the task return to user mode
+ *   -# detaches the TCMI task from the process and resumes user mode
+ *   -# detaches the TCMI task from the process and kills the process
+ */
+static void tcmi_migcom_mig_mode_handler(void)
+{
+	struct tcmi_task *tmp, *task;
+	int res;
+	long exit_code;
+
+	mdbg(INFO3, "Migration mode handler for task '%s' stack rp(%p) executing", 
+	     current->comm, &res);
+
+
+	if (!(task = tcmi_taskhelper_sanity_check())) {
+		mdbg(ERR2, "Process %p PID=%d - invalid entry to migration mode",
+		      current, current->pid);
+		goto exit0;
+	}
+
+	/* keep moving the task between migration managers */
+	while ((res = tcmi_task_process_methods(task)) ==
+	       TCMI_TASK_MOVE_ME);
+	/* check the result of the last method processed */
+	switch (res) {
+	case TCMI_TASK_KEEP_PUMPING:
+		mdbg(INFO2, "KEEP PUMPING - but no methods left %d", res);
+		break;
+	case TCMI_TASK_LET_ME_GO:
+		mdbg(INFO2, "LET ME GO - request %d", res);
+		break;
+		/* no need for special handling a fall through causes
+		 * do_exit which invokes the migration handler again. */
+	case TCMI_TASK_EXECVE_FAILED_KILL_ME:
+		mdbg(INFO2, "EXECVE_FAILED KILL ME - request %d", res);
+		break;
+	case TCMI_TASK_KILL_ME:
+		mdbg(INFO2, "KILL ME - request %d", res);
+		tmp = tcmi_taskhelper_detach();
+		/* get the exit code prior terminating. */
+		exit_code = tcmi_task_exit_code(tmp);
+		tcmi_task_put(tmp);
+		mdbg(INFO2, "Put done, going to exit %ld", exit_code);
+		complete_and_exit(NULL, exit_code);
+		break;
+	case TCMI_TASK_REMOVE_AND_LET_ME_GO:
+		mdbg(INFO2, "REMOVE AND LET ME GO - request %d", res);
+		tcmi_task_put(tcmi_taskhelper_detach());
+		break;
+	default:
+		mdbg(ERR2, "Unexpected result %d.", res);
+		break;
+	}
+	/* error handling */
+ exit0:
+	return;
+}
+
+
+/**
+ * @}
+ */
+
+
+
--- linux-3.7.1_original/clondike/src/tcmi/task/tcmi_task.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/task/tcmi_task.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,685 @@
+/**
+ * @file tcmi_task.h - common functionality for TCMI shadow and guest tasks.
+ *                      
+ * 
+ *
+ *
+ * Date: 04/25/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_task.h,v 1.10 2009-01-20 14:23:10 andrep1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_TASK_H
+#define _TCMI_TASK_H
+
+#include <asm/atomic.h>
+#include <linux/types.h>
+#include <linux/completion.h>
+#include <clondike/tcmi/tcmi_struct.h>
+
+#include "tcmi_method_wrapper.h"
+
+#include <tcmi/ctlfs/tcmi_ctlfs.h>
+#include <tcmi/ctlfs/tcmi_ctlfs_dir.h>
+#include <tcmi/ctlfs/tcmi_ctlfs_file.h>
+#include <tcmi/ctlfs/tcmi_ctlfs_symlink.h>
+
+#include <kkc/kkc.h>
+#include <tcmi/lib/tcmi_queue.h>
+#include <tcmi/lib/tcmi_slotvec.h>
+
+#include <tcmi/comm/tcmi_msg.h>
+
+#include <arch/current/make_syscall.h>
+
+#include <tcmi/lib/util.h>
+#include <linux/sched.h>
+
+struct tcmi_migman;
+struct tcmi_npm_params;
+
+/** @defgroup tcmi_task_class tcmi_task class 
+ * 
+ * @ingroup tcmi_task_group
+ *
+ * TCMI task is an abstraction for any process in the system that
+ * participates in migration. This \<\<template\>\> class gathers
+ * common functionality for shadow tasks that represent a migrated
+ * process on CCN as well as for guest tasks that represent the
+ * migrated process on PEN.
+ *
+ * TCMI tasks are controlled from user space via migration component.
+ * Each task is associated with its migration manager. This ensures
+ * that all messages addressed to a particular task are also delivered
+ * to its message queue or transactions slotvector.  A TCMI task is
+ * given a communication socket (KKC socket) upon its
+ * instantiation. It is the communication channel that it will use for
+ * sending messages out.  Note, that message delivery is handled
+ * exclusively by the migration manager. This makes it very easy to
+ * move a task among TCMI migration managers.
+ *
+ * The main purpose of this class is execution of methods in the context
+ * of the shadow and guest process resp. These methods are submitted by the
+ * migration component into the method queue and include:
+ * - request to migrate a process to a PEN - includes PPM_P, PPM_V, NPM
+ * - request to migrate a process back to CCN - includes PPM_P, PPM_V, NPM
+ * - request to process any incoming TCMI messages from the message queue.
+ * - request to terminate
+ *
+ * Methods in the queue are processed via a 'method pump'. Each method
+ * returns a status that is used by the controlling component to make
+ * a decision what to do further. Status return codes have following
+ * meanings:
+ *
+ * - KEEP_PUMPING - the method pump should keep going as long as there
+ * are methods to process
+ *
+ * - MOVE_ME - stop pumping and tell the task controlling component to
+ * move it to a different migration manager (relevant for shadow tasks
+ * on CCN)
+ *
+ * - EXECVE_FAILED_KILL_ME - stop pumping and tell the task
+ * controlling component to kill this task. This status denotes the
+ * situation when the task tried issuing execve(typically when loading
+ * a new checkpoint or processing a non-preemptive migration request)
+ * and it failed. This status is needed as it also instructs the method
+ * pump not to discard the method wrapper as it has already been done
+ * by (tcmi_task_execve() method internally)
+ * 
+ * - KILL_ME - stop pumping and tell the task controlling component to
+ * kill this task (issue do_exit()) and remove it from its migration
+ * manager
+ *
+ * - LET_ME_GO -stop pumping and tell the task controlling component
+ * leave the migration mode, leave the task as is.
+ *
+ * - REMOVE_AND_LET_ME_GO -stop pumping and tell the task controlling
+ * component to remove the task from its current migration manager,
+ * destroy the tcmi_task and and let the regular task go. For example,
+ * this status is returned by task_exit() method as it is called from
+ * the intercepted exit system call. Once the TCMI task is detached
+ * from its process the exit system call resumes and performs the
+ * actual exit.
+ *
+ * In addition, the task also holds the filename along with argv and
+ * envp arrays that will be executed. It is important to keep track of
+ * this data as they are required by the execve (e.g. when migrating a
+ * a task by executing it's checkpoint image). These resources
+ * eventually need to be released once the execve has been issued or
+ * when the task is destroyed. There is functionality that makes arguments
+ * and environment management easy.
+ *
+ * Abbreviations:
+ * - PPM_P - preemptive process migration using physical checkpoint image
+ * - PPM_V - preemptive process migration using virtual checkpoint image
+ * - NPM - non-preemptive process migration (using execve hook)
+ * 
+ * @{
+ */
+
+/** Compound structure that gathers necessary process information. */
+struct tcmi_task {
+	/** node for storage in the migration slot of the migration manager */
+	tcmi_slot_node_t node;
+
+	/** local PID on PEN, CCN resp. */
+	pid_t local_pid;
+	/** remote PID on PEN, CCN resp. */
+	pid_t remote_pid;
+
+	/* Identifier of a manager that this task belongs to.
+	u_int32_t migman_id;
+ 	*/
+	/** 
+	 * Reference to a migration manager to which this task belongs to.
+	 * TODO: This "back" reference perhaps couples the class to tighly to migman class. We in fact need just a slotvector of migman tasks so that this task can handle its addition/removal on creation/deletion.
+	 */
+	struct tcmi_migman* migman;
+
+	/** communication socket. */
+	struct kkc_sock *sock;
+
+	/** queue of methods to be executed. */
+	struct tcmi_queue method_queue;
+
+	/** Message queue for transaction-less messages. */
+	struct tcmi_queue msg_queue;
+	/** Message transactions. */
+	struct tcmi_slotvec *transactions;
+
+	/** TCMI ctlfs - migproc directory entry. */
+	struct tcmi_ctlfs_entry *d_task;
+	/** TCMI ctlfs - symlink to the migration manager directory. */
+	struct tcmi_ctlfs_entry *s_migman;
+	/** TCMI ctlfs - contains remote PID. */
+	struct tcmi_ctlfs_entry *f_remote_pid;
+
+	/** */
+	struct tcmi_ctlfs_entry *f_remote_pid_rev;
+
+	/** */
+	struct tcmi_ctlfs_entry *d_migman_root;
+
+	/** Task exit code - used when terminating the task. */
+	long exit_code;
+
+	/** Instance reference counter. */
+	atomic_t ref_count;
+
+	/** Pointer to the context of a process when switched into user mode. */
+	void *context;
+
+	/** contains the pathname of the latest checkpoint file */
+	char *ckpt_pathname;
+
+	/** command line arguments for the checkpoint file (NULL terminated array of strings) */
+	char **argv;
+	/** environment (NULL terminated array of strings) */
+	char **envp;
+	/** How many time was execve called on this task, since it became controlled by the tcmi */
+	int execve_count;
+
+	/** Data for proxyfs filesystem */
+	void *proxyfs_data;
+
+	/** Used for signalling when the task is picked up by the associated process */
+	struct completion picked_up;
+	/** This flag is set when the task has been picked up,
+	 * indicates the completion is finished. It is used when
+	 * performing synchronized waiting on pickup with timeout.
+	 */
+	int picked_up_flag;
+	
+	/** Flag used to inform the task that its peer is lost and it should terminate */
+	volatile int peer_lost;
+
+	/** Operations specific to shadow/guest tasks resp. */
+	struct tcmi_task_ops *ops;
+};
+
+/** TCMI task operations that support polymorphism */
+struct tcmi_task_ops {
+	/** Processes a message that has arrived on the message queue. */
+	int (*process_msg)(struct tcmi_task*, struct tcmi_msg*);
+	/** Emigrates a task to a PEN - PPM w/ physical checkpoint. */
+	int (*emigrate_ppm_p)(struct tcmi_task*);
+	/** Migrates a task back to CCN - PPM w/ physical checkpoint. */
+	int (*migrateback_ppm_p)(struct tcmi_task*);
+	/** Emigrates a task to a PEN - PPM w/ virtual checkpoint. */
+	int (*emigrate_ppm_v)(struct tcmi_task*);
+	/** Migrates a task back to CCN - PPM w/ virtual checkpoint. */
+	int (*migrateback_ppm_v)(struct tcmi_task*);
+	/** Emigrates a task to a PEN - NPM. */
+	int (*emigrate_npm)(struct tcmi_task*, struct tcmi_npm_params*);
+	/** Migrates a task back to CCN - NPM. */
+	int (*migrateback_npm)(struct tcmi_task*, struct tcmi_npm_params*);
+	/** Used upon task exit. */
+	int (*exit)(struct tcmi_task*, long);
+	/** Instance specific execve. */
+	int (*execve)(struct tcmi_task*);
+	/** Handles a specific signal. */
+	int (*do_signal)(struct tcmi_task *self, unsigned long signr, siginfo_t *info);
+	/** Releases the instance specific resources. */
+	void (*free)(struct tcmi_task*);
+	/** Return type of task */
+	enum tcmi_task_type (*get_type)(void);
+};
+
+/** Describes the status returned by task methods that are executed
+ * from the method queue. See the \link tcmi_task_class task \endlink
+ * detailed description for explanation of each individual return
+ * status.
+ */
+typedef enum {
+	TCMI_TASK_KEEP_PUMPING,
+	TCMI_TASK_MOVE_ME,
+	TCMI_TASK_EXECVE_FAILED_KILL_ME,
+	TCMI_TASK_KILL_ME,
+	TCMI_TASK_LET_ME_GO,
+	TCMI_TASK_REMOVE_AND_LET_ME_GO
+} tcmi_task_method_status_t;
+
+/** Casts to the task instance. */
+#define TCMI_TASK(t) ((struct tcmi_task*)t)
+
+/** Initializes the task. */
+extern int tcmi_task_init(struct tcmi_task *self, pid_t local_pid, struct tcmi_migman* migman, 
+			  struct kkc_sock *sock, 
+			  struct tcmi_ctlfs_entry *d_migproc, struct tcmi_ctlfs_entry *d_migman,
+			  struct tcmi_task_ops *ops);
+
+/** 
+ * \<\<public\>\> Instance accessor, increments the reference counter.
+ *
+ * @param *self - pointer to this task instance
+ * @return tcmi_task instance
+ */
+static inline struct tcmi_task* tcmi_task_get(struct tcmi_task *self)
+{
+	if (self) {
+		atomic_inc(&self->ref_count);
+	}
+	return self;
+}
+
+/** \<\<public\>\> Releases the instance. */
+extern void tcmi_task_put(struct tcmi_task *self);
+
+/** \<\<public\>\> Submits a method for execution. */
+extern void tcmi_task_submit_method(struct tcmi_task *self, tcmi_method_t *method, 
+				    void *data, int size);
+
+/** \<\<public\>\> Prior to submitting, atomically flushes the method queue. */
+extern void tcmi_task_flush_and_submit_method(struct tcmi_task *self, tcmi_method_t *method, 
+					      void *data, int size);
+
+/** \<\<public\>\> Processes all methods in the queue. */
+extern int tcmi_task_process_methods(struct tcmi_task *self);
+
+/** \<\<public\>\> Processes message in the message queue. */
+extern int tcmi_task_process_msg(void *self, struct tcmi_method_wrapper *wr);
+
+/** \<\<public\>\> Sends a message to peer. */
+extern int tcmi_task_send_message(void *self, struct tcmi_method_wrapper *wr);
+
+/** \<\<public\>\> Emigrates a task to a PEN - PPM w/ physical checkpoint. */
+extern int tcmi_task_emigrate_ppm_p(void *self, struct tcmi_method_wrapper *wr);
+
+/** \<\<public\>\> Migrates a task back to CCN - PPM w/ physical checkpoint. */
+extern int tcmi_task_migrateback_ppm_p(void *self, struct tcmi_method_wrapper *wr);
+
+
+/** \<\<public\>\> Emigrates a task to a PEN - PPM w/ virtual checkpoint. */
+extern int tcmi_task_emigrate_ppm_v(void *self, struct tcmi_method_wrapper *wr);
+
+/** \<\<public\>\> Migrates a task back to CCN - PPM w/ virtual checkpoint. */
+extern int tcmi_task_migrateback_ppm_v(void *self, struct tcmi_method_wrapper *wr);
+
+
+/** \<\<public\>\> Emigrates a task to a PEN - NPM. */
+extern int tcmi_task_emigrate_npm(void *self, struct tcmi_method_wrapper *wr);
+
+/** \<\<public\>\> Migrates a task back to CCN - NPM. */
+extern int tcmi_task_migrateback_npm(void *self, struct tcmi_method_wrapper *wr);
+
+/** \<\<public\>\> Exits a task. */
+extern int tcmi_task_exit(void *self, struct tcmi_method_wrapper *wr);
+
+/** \<\<public\>\> Prepares execution of a file given the arrays of arguments and
+ * environment.*/
+extern int tcmi_task_prepare_execve(struct tcmi_task *self, char *file, 
+				    char **argv, char **envp);
+
+/** \<\<public\>\> Executes the file that has been previously setup for execution. */
+extern int tcmi_task_execve(void *self, struct tcmi_method_wrapper *wr);
+
+/** \<\<public\>\> Delivers a specified message. */
+extern int tcmi_task_deliver_msg(struct tcmi_task *self, struct tcmi_msg *m);
+
+/**
+ * \<\<public\>\> Transactions accessor - needed when tasks construct
+ * their own messages.
+ * 
+ * @param *self - pointer to this task instance
+ * @return transactions slot vector.
+ */
+static inline struct tcmi_slotvec* tcmi_task_transactions(struct tcmi_task *self)
+{
+	return self->transactions;
+}
+
+
+/**
+ * \<\<public\>\> Exit code accessor.
+ * 
+ * @param *self - pointer to this task instance
+ * @return task exit code.
+ */
+static inline long tcmi_task_exit_code(struct tcmi_task *self)
+{
+	return self->exit_code;
+}
+
+/**
+ * \<\<public\>\> Exit code setter.
+ * 
+ * @param *self - pointer to this task instance
+ * @param code - exit code that is to be set for the task
+ */
+static inline void tcmi_task_set_exit_code(struct tcmi_task *self, long code)
+{
+	self->exit_code = code;
+}
+
+/**
+ * \<\<public\>\> Process context accessor.
+ * 
+ * @param *self - pointer to this task instance
+ * @return process context.
+ */
+static inline void* tcmi_task_context(struct tcmi_task *self)
+{
+	return self->context;
+}
+
+/**
+ * \<\<public\>\> Process context setter.
+ * 
+ * @param *self - pointer to this task instance
+ * @param *context - pointer to the context stored in the task
+ */
+static inline void tcmi_task_set_context(struct tcmi_task *self, void *context)
+{
+	self->context = context;
+}
+
+/**
+ * \<\<public\>\> Task checkpoint pathname accessor.
+ * 
+ * @param *self - pointer to this task instance
+ * @returns the most recent checkpoint pathname.
+ */
+static inline char* tcmi_task_ckpt_name(struct tcmi_task *self)
+{
+	return self->ckpt_pathname;
+}
+
+/**
+ * \<\<public\>\> Local PID accessor.
+ * 
+ * @param *self - pointer to this task instance
+ * @return local PID of the task
+ */
+static inline pid_t tcmi_task_local_pid(struct tcmi_task *self)
+{
+	return self->local_pid;
+}
+
+/**
+ * \<\<public\>\> Remote PID accessor.
+ * 
+ * @param *self - pointer to this task instance
+ * @return remote PID of the task
+ */
+static inline pid_t tcmi_task_remote_pid(struct tcmi_task *self)
+{
+	return self->remote_pid;
+}
+
+/**
+ * \<\<public\>\> Local PID setter.
+ * 
+ * @param *self - pointer to this task instance
+ * @param local_pid - new local PID of the task
+ */
+static inline void tcmi_task_set_local_pid(struct tcmi_task *self, pid_t local_pid)
+{
+	self->local_pid = local_pid;
+}
+
+/** */
+static int tcmi_task_show_remote_pid_rev(void *obj, void *data)
+{
+	struct tcmi_task *self = TCMI_TASK(obj);
+	int * local_pid = (int*) data;
+	*local_pid = tcmi_task_local_pid(self);
+	return 0;
+}
+
+/**
+ * \<\<public\>\> Remote PID setter.
+ * 
+ * @param *self - pointer to this task instance
+ * @param remote_pid - new remote PID of the task
+ */
+static inline void tcmi_task_set_remote_pid(struct tcmi_task *self, pid_t remote_pid)
+{
+	self->remote_pid = remote_pid;
+	self->f_remote_pid_rev = tcmi_ctlfs_intfile_new(self->d_migman_root, TCMI_PERMS_FILE_R,
+                                     self, tcmi_task_show_remote_pid_rev, NULL,
+                                     sizeof(pid_t),"%d" , self->remote_pid);
+
+}
+
+/**
+ * \<\<public\>\> Accessor of id of the migration manager associated with this task.
+ */
+extern u_int32_t tcmi_task_migman_id(struct tcmi_task *self);
+
+/**
+ * \<\<public\>\> Accessor of vector slot index of the migration manager associated with this task.
+ */
+extern u_int tcmi_task_migman_slot_index(struct tcmi_task *self);
+
+/**
+ * \<\<public\>\> Waits until the task is picked up, by the associated
+ * process.  Returns also when the timer expires. This method is meant
+ * to be used by the task helper, that provides \link
+ * tcmi_taskhelper.h::tcmi_taskhelper_wait_for_pick_up_timeout()
+ * tcmi_taskhelper_wait_for_pickup_timeout() \endlink.
+ *
+ * @param *self - pointer to this task instance
+ * @param timeout - time out limit in ticks to wait for pickup
+ * @return 0 when successfully completed
+ */
+static inline unsigned long tcmi_task_wait_for_pick_up_timeout(struct tcmi_task *self, 
+							       unsigned long timeout)
+{
+	return wait_for_completion_interruptible_timeout(&self->picked_up, timeout);
+}
+
+/**
+ * \<\<public\>\> Signals, the tcmi task has been pickedup by the
+ * associated process.n
+ *
+ * @param *self - pointer to this task instance
+ * @return 0 when successfully completed
+ */
+static inline void tcmi_task_pick_up(struct tcmi_task *self)
+
+{
+	complete(&self->picked_up);
+	self->picked_up_flag = 1;
+}
+
+/**
+ * \<\<public\>\> Checks whether the task has been picked up.
+ *
+ * @param *self - pointer to this task instance
+ * @return true when it has already been picked up
+ */
+static inline int tcmi_task_picked_up(struct tcmi_task *self)
+
+{
+	return self->picked_up_flag > 0;
+}
+
+/** 
+ * \<\<public\>\> Sends a specified message.  The message is sent as
+ * anonymous, so that any potential responses will be delivered to the
+ * message queue.
+ *
+ * @param *self - pointer to this task instance
+ * @param *m - message to be sent.
+ * @return 0 when the message has been successfully sent
+ */
+static inline int tcmi_task_send_anonymous_msg(struct tcmi_task *self, struct tcmi_msg *m)
+{
+	return tcmi_msg_send_anonymous(m, self->sock);
+}
+
+static inline int tcmi_task_get_execve_count(struct tcmi_task *self)
+
+{
+	return self->execve_count;
+}
+
+static inline void tcmi_task_inc_execve_count(struct tcmi_task *self)
+
+{
+	self->execve_count++;
+}
+
+/** Returns a task_struct associated with the tcmi_task */
+static inline struct task_struct* tcmi_task_to_task_struct(struct tcmi_task *self) {     
+	struct task_struct *task;
+	
+	/* try finding the target kernel task for our TCMI task by PID */
+	read_lock_irq(&tasklist_lock);
+	if (!(task = task_find_by_pid(tcmi_task_local_pid(self)))) {
+		mdbg(ERR3, "Can't find corresponding task_struct for PID: %d", 
+		     tcmi_task_local_pid(self));		
+	}	
+	read_unlock_irq(&tasklist_lock);
+  
+	return task;
+}
+
+
+/** 
+ * \<\<public\>\> Sends a specified message and waits for a response.
+ * All work is delegate to tcmi_msg.c::tcmi_msg_send_and_receive()
+ * method
+ *
+ * @param *self - pointer to this task instance
+ * @param *req - request message to be sent.
+ * @param **resp - output parameter, stores the response message or NULL
+ * @return 0 when the message has been sent.
+ */
+static inline int tcmi_task_send_and_receive_msg(struct tcmi_task *self, struct tcmi_msg *req,
+						 struct tcmi_msg **resp)
+{
+	return tcmi_msg_send_and_receive(req, self->sock, resp);
+}
+
+/** 
+ * Notifies task that it peer is lost and sends a kill signal to that task.
+ * The method is used for termination of tasks with lost peers.
+ */
+static inline void tcmi_task_signal_peer_lost(struct tcmi_task *self) {
+      self->peer_lost = 1;
+      force_sig(SIGKILL, tcmi_task_to_task_struct(self));
+}
+
+/**
+ * \<\<public\>\> Processes a specified signal.  The work is delegated
+ * to the task specific method if one is specified. This allows the
+ * shadow and guest processes to handle the signal differently. In
+ * fact, they have to: - shadow process takes appropriate actions and
+ * forwards the signal to the guest using signal forwarding
+ * component(since the guest might not be in migration mode) - guest
+ * process takes only appropriate actions and is able to communicate
+ * with the shadow directly.
+ *
+ * @param *self - pointer to this task instance 
+ * @param signr - signal that is to be processed
+ * @param *info - info for signal to be processed
+ *
+ * @return result of the task specific signal handling method or
+ * TCMI_TASK_KEEP_PUMPING
+ */
+static inline int tcmi_task_do_signal(struct tcmi_task *self, unsigned long signr, siginfo_t *info)
+{
+	int res = TCMI_TASK_KEEP_PUMPING;
+
+	mdbg(INFO2, "Processing signal %lu", signr);
+	
+	if ( self->peer_lost && signr == SIGKILL ) {
+		mdbg(INFO2, "Peer task is dead, killing current task");
+		return TCMI_TASK_KILL_ME;
+	}
+	
+	if (self->ops->do_signal)
+		res = self->ops->do_signal(self, signr, info);
+
+	return res;
+
+}
+
+
+/**
+ * \<\<public>\> Get task type
+ * @param *self - pointer to this task instance 
+ *
+ * @return (tcmi_task_type)shadow or (tcmi_task_type)guest (or unresolved if not defined).
+ */
+static inline enum tcmi_task_type tcmi_task_get_type(struct tcmi_task *self)
+{
+	enum tcmi_task_type res = unresolved;
+	if (self->ops->get_type)
+		res = self->ops->get_type();
+	return res;
+}
+
+/**
+ * \<\<public>\> Computes the hash value of the task (to be used in tasks slotvec of migman)
+ * 
+ * @param local_pid - local pid of the task
+ * @param hashmask - hashmask limiting the maximum hash value.
+ */
+static inline u_int tcmi_task_hash(pid_t local_pid, u_int hashmask)
+{
+	return (local_pid & hashmask);
+}
+
+/**
+ * Simple error checking method to be used after communication operations to detect lost peer. In case err indicates broken connection, peer is considered dead for us.
+ *
+ * @return Returns passed err param, so that it can be easily used for call chaining
+ */
+static inline int tcmi_task_check_peer_lost(struct tcmi_task *self, int err) {
+      // For now, we react only on broken pipe, but we may react on more cases, right?
+      if ( err == -EPIPE )
+	  tcmi_task_signal_peer_lost(self);
+
+      return err;
+}
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_TASK_PRIVATE
+
+/** Read method for the TCMI ctlfs - reports remote PID. */
+static int tcmi_task_show_remote_pid(void *obj, void *data);
+
+/** Releases the execve context (execve file, argv, envp). */
+static void tcmi_task_release_execve_context(struct tcmi_task *self);
+
+/** 
+ * \<\<private\>\> Adds the filled in method wrapper into the method queue. 
+ *
+ * 
+ * @param *self - pointer to this task instance
+ * @param *wr - method wrapper to be added to the method queue.
+ */
+static inline void tcmi_task_add_wrapper(struct tcmi_task *self, struct tcmi_method_wrapper *wr)
+{
+	tcmi_queue_add(&self->method_queue, &wr->node);
+}
+
+#endif /* TCMI_TASK_PRIVATE */
+
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_TASK_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/task/tcmi_taskhelper.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/task/tcmi_taskhelper.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,777 @@
+/**
+ * @file tcmi_taskhelper.h - TCMI task helper, supports task manipulation
+ *                      
+ * 
+ *
+ *
+ * Date: 04/28/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_taskhelper.h,v 1.13 2008/01/17 14:36:44 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_TASKHELPER_H
+#define _TCMI_TASKHELPER_H
+
+#include <linux/jiffies.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/fdtable.h>
+#include <linux/sched.h>
+#include <asm/current.h>
+
+#include <clondike/tcmi/tcmi_struct.h>
+
+#include <tcmi/ckpt/tcmi_ckptcom.h>
+#include <tcmi/ckpt/tcmi_ckpt.h>
+#include "tcmi_task.h"
+#include <tcmi/lib/util.h>
+
+/** @defgroup tcmi_taskhelper_class tcmi_taskhelper class 
+ * 
+ * @ingroup tcmi_task_group
+ * 
+ * This \<\<singleton\>\> class implements platform specific methods
+ * that make handling TCMI tasks easier. The functionality includes:
+ * - method to switch a task into migration mode
+ * - method to submit a specific method to a TCMI task and have it process
+ * the method
+ * - synchronization with a task entering the migration mode for the
+ * - OS specific basic signal handling
+ * 
+ * @{
+ */
+
+/**
+ * Runs migration mode handler of the current process.
+ *
+ * @return 0 upon success
+ */
+static inline int tcmi_taskhelper_run_mig_mode_handler(void)
+{
+	if (!current->tcmi.mig_mode_handler) {
+		mdbg(ERR3, "Missing migration mode handler for current process!!");
+		goto exit0;
+	}
+	current->tcmi.mig_mode_handler();
+
+	return 0;
+	/* error handling */
+ exit0:
+	return -EINVAL;
+}
+
+
+/** 
+ * \<\<public\>\> Switches the task into migration mode.  It is
+ * necessary to lookup the regular kernel process that the TCMI task
+ * is attached to and enforce its migration mode.  Essentially, it
+ * sends SIG_UNUSED signal to the process. The signal handler hook(see
+ * tcmi_taskhelper_do_mig_mode()) takes care of running the migration
+ * mode handler.
+ *
+ * @param *t_task - pointer to the TCMI task that is to be preempted into migration mode
+ */
+static inline void tcmi_taskhelper_enter_mig_mode(struct tcmi_task *t_task)
+{
+	struct task_struct* l_task = tcmi_task_to_task_struct(t_task);
+	
+	if ( !l_task ) {
+ 		minfo(ERR3, "Can't enter to mig_mode. Cannot find corresponding task_struct for PID: %d", 
+		     tcmi_task_local_pid(t_task));		
+		return;
+	}
+	
+	/* switch the task to migration mode */
+	force_sig(SIGUNUSED, l_task);
+}
+ 
+
+/** 
+ * \<\<public\>\> Same as standard enter_mig_mode, but in this case we have already a reference to current task, so we do not
+ * perform any locking
+ */
+static inline void tcmi_taskhelper_enter_mig_mode_exclusive(struct task_struct* l_task, struct tcmi_task *t_task)
+{
+	/* switch the task to migration mode */
+	force_sig(SIGUNUSED, l_task);
+
+	return;
+}
+
+
+/**
+ * \<\<public\>\> Finds a TCMI task based on PID, in addition checks
+ * whether the task has a valid migration mode handler assigned.
+ *
+ * @param pid - PID of a taks to be looked up
+ * @return TCMI task or NULL
+ */
+
+static inline struct tcmi_task* tcmi_taskhelper_find_by_pid(pid_t pid)
+{
+	struct task_struct *l_task;
+	struct tcmi_task *t_task = NULL;
+	
+
+	/* try finding the process by PID */
+	read_lock_irq(&tasklist_lock);
+	if (!(l_task = task_find_by_pid(pid))) {
+		mdbg(ERR3, "Can't find, no such process %d", pid);
+		goto exit0;
+	}
+	task_lock(l_task);
+	/* check whether the process has a TCMI task and a valid handler */
+	if (!(l_task->tcmi.mig_mode_handler && l_task->tcmi.tcmi_task)) {
+		mdbg(ERR3, "Process %d has no a mig. mode handler"
+		     "or TCMI task", pid);
+		task_unlock(l_task);
+		goto exit0;
+	}
+	/* get the extra task reference */
+	t_task = tcmi_task_get(l_task->tcmi.tcmi_task);
+	task_unlock(l_task);
+	read_unlock_irq(&tasklist_lock);
+
+	return t_task;
+	/* error handling */
+ exit0:
+	read_unlock_irq(&tasklist_lock);
+	return NULL;
+}
+
+/** 
+ * \<\<public\>\> Submits a specified method to a TCMI task identified by PID.
+ * To accomplish the job in SMP safe manner we need to:
+ * - get a valid reference to a TCMI task associated with particular PID
+ * - submit the method - based on priority we can also choose to flush
+ * the method queue
+ * - switch the process to migration mode - again, to be safe, we
+ * use the tcmi_taskhelper_enter_mig_mode()
+ * - drop the task reference
+ *
+ * @param pid - process that is to be notified
+ * @param *method - task method that is to be submitted
+ * @param *data - argument for the submitted method
+ * @param size - size of the argument in bytes
+ * @param priority - when > 0, the method queue is also flushed
+ * @return 0 upon success
+ *
+ * @todo Simplify the way the task is forced into migration mode, so
+ * that a full lookup doesn't need to be performed again via
+ * tcmi_taskhelper_enter_mig_mode()
+ */
+static inline int tcmi_taskhelper_notify_by_pid(pid_t pid, tcmi_method_t *method, 
+						void *data, int size, int priority)
+{
+	
+	struct tcmi_task *t_task = NULL;
+
+
+	if (!(t_task = tcmi_taskhelper_find_by_pid(pid))) {
+		mdbg(ERR3, "Can't find TCMI task PID %d", pid);
+		goto exit0;
+	}
+
+	/* now we can safely operate on the task as we own 1 reference */
+	if (priority > 0)
+		tcmi_task_flush_and_submit_method(t_task, method, data, size);
+	else
+		tcmi_task_submit_method(t_task, method, data, size);
+
+	/* using method is safe as we have no reference l_task */ 
+	tcmi_taskhelper_enter_mig_mode(t_task);
+	tcmi_task_put(t_task);
+
+	return 0;
+
+	/* error handling */
+ exit0:
+	return -EINVAL;
+}
+
+/** 
+ * \<\<public\>\> Synchronizes with a task entering the migration mode
+ * for the first time.  The thread associated with the task already has an
+ * extra reference.  If the task doesn't get picked up on time, it
+ * will be safely removed from under the thread.
+ *
+ * We don't need an extra reference to the kernel task struct as we
+ * are holding task_list_lock -> the task struct can't be removed from
+ * under us.
+ * 
+ * @param *t_task - pointer to the task instance that we are syncing with 
+ * @param timeout - in ticks
+ * @return 0 if the task has successfully entered the migration mode
+ */
+static inline int tcmi_taskhelper_wait_for_pick_up_timeout(struct tcmi_task *t_task,
+							   unsigned long timeout)
+{
+	int err = 0;
+	/* temporary storage for the task. */
+	struct tcmi_task *tmp = NULL;
+	/* regular linux task used for lookup*/
+	struct task_struct *l_task;
+	/* Wait for pickup first */
+	if (!tcmi_task_wait_for_pick_up_timeout(t_task, timeout)) {
+		/* try finding thread associated with the task by PID */
+		read_lock_irq(&tasklist_lock);
+		if (!(l_task = task_find_by_pid(tcmi_task_local_pid(t_task)))) {
+			mdbg(ERR3, "Failed to wait - no such process %d", 
+			     tcmi_task_local_pid(t_task));
+			err = -ESRCH;
+			read_unlock_irq(&tasklist_lock);
+			goto exit0;
+		}
+		/* A bad inconsistency if tasks don't match - bug */
+		BUG_ON(t_task != l_task->tcmi.tcmi_task);
+		/* the task might still have been picked up in the
+		 * meantime, we have to check again */
+		task_lock(l_task);
+		if (!tcmi_task_picked_up(l_task->tcmi.tcmi_task)) {
+			minfo(INFO1, "Task local PID = %d still not picked up destroying..",
+			      tcmi_task_local_pid(t_task));
+			tmp = l_task->tcmi.tcmi_task;
+			l_task->tcmi.mig_mode_handler = NULL;
+			l_task->tcmi.tcmi_task = NULL;
+			err = -EINVAL;
+		}
+		task_unlock(l_task);
+		read_unlock_irq(&tasklist_lock);
+		/* Release the task instance - safe if still NULL. We must release 1 reference as the thread that owned the task no longer owns it. */
+		tcmi_task_put(tmp);
+	}
+	/* error handling */
+ exit0:
+	return err;
+}
+
+/**
+ * \<\<public\>\> Checks if there are any pending signals and handles
+ * them.  For each pending signal, the task is requested to process it
+ * as long as the signal is not SIGUNUSED - which indicates an attempt
+ * to switch to migration mode, eventhough we are already in migration
+ * mode. This signal is ignored.
+ *
+ * We keep processing the signals as long as there are any pending left
+ * and the task method returns TCMI_TASK_KEEP_PUMPING.
+ *
+ * The result of the last call of the task method is communicated back.
+ *
+ * @param *t_task - pointer to this task instance 
+ * @return result of the task specific signal handling method or
+ * TCMI_TASK_KEEP_PUMPING
+ */
+static inline int tcmi_taskhelper_do_signals(struct tcmi_task *t_task)
+{
+	int res = TCMI_TASK_KEEP_PUMPING;
+	siginfo_t info;
+	unsigned long signr = 0;
+	sigset_t *mask = &current->blocked;
+
+	mdbg(INFO2, "Do signals being processed.");
+
+	/* check pending signal */
+	if (signal_pending(current)) {
+		mdbg(INFO2, "Has signal pending");
+		/* for all signals */
+		while (res == TCMI_TASK_KEEP_PUMPING) {
+			/* dequeue signal */
+			spin_lock_irq(&current->sighand->siglock);
+			signr = dequeue_signal(current, mask, &info);
+			spin_unlock_irq(&current->sighand->siglock);
+			/* no more signals in queue */
+			if (!signr)
+				break;
+			mdbg(INFO2, "Dequeued signal number: %lu..", signr);
+			if (signr != SIGUNUSED)
+				res = tcmi_task_do_signal(t_task, signr, &info);
+		}
+	}
+
+	mdbg(INFO2, "Signal handling finished. Result: %d", res);
+
+	return res;
+}
+
+/**
+ * \<\<public\>\> Flushes all pending signals of the task. Usually
+ * needed right after establishing a new shadow process.
+ *
+ * @param *t_task - pointer to this task instance 
+ */
+static inline void tcmi_taskhelper_flush_signals(struct tcmi_task *t_task)
+{
+	flush_signals(current);
+}
+
+/** 
+ * \<\<public\>\> Attaches the TCMI task to its kernel task.
+ * This requires:
+ * - looking up the target thread (denoted by task's local PID)
+ * - checking if there has been assigned no handler/task assigned yet
+ * - storing the specified handler+task inside the kernel task(process)
+ *
+ * The target kernel task will have an extra reference to the task.
+ *
+ * @param *t_task - pointer to the TCMI task that is to be attached
+ * @param *mig_mode_handler - migration mode handler specific to the
+ * task.
+ * @return 0 upon success.
+ */
+static inline int tcmi_taskhelper_attach(struct tcmi_task *t_task, 
+					 mig_mode_handler_t *mig_mode_handler)
+{
+	int err = -EINVAL;
+	struct task_struct *l_task;
+
+	/* try finding the target process for our TCMI task by PID */
+	read_lock_irq(&tasklist_lock);
+	if (!(l_task = task_find_by_pid(tcmi_task_local_pid(t_task)))) {
+		mdbg(ERR3, "No such process %d", tcmi_task_local_pid(t_task));
+		err = -ESRCH;
+		goto exit0;
+	}
+	/* synchronize with the migration mode handler that might run in paralle */
+	task_lock(l_task);
+	if (l_task->tcmi.mig_mode_handler || l_task->tcmi.tcmi_task) {
+		mdbg(ERR3, "Kernel task %d already has a mig. mode handler - %p "
+		     "or TCMI task - %p assigned, bailing out",
+		      tcmi_task_local_pid(t_task), l_task->tcmi.mig_mode_handler,
+		     l_task->tcmi.tcmi_task);
+		task_unlock(l_task);
+		goto exit0;
+	}
+	l_task->tcmi.mig_mode_handler = mig_mode_handler;
+	/* extra reference on TCMI task for the target process/its
+	 * migration component resp. */
+	l_task->tcmi.tcmi_task = tcmi_task_get(t_task); 
+	l_task->tcmi.task_type = tcmi_task_get_type(t_task);
+	task_unlock(l_task);
+
+	read_unlock_irq(&tasklist_lock);
+
+	return 0;
+
+	/* error handling */
+ exit0:
+	read_unlock_irq(&tasklist_lock);
+	return err;
+}
+
+
+/** 
+ * \<\<public\>\> Same as standard attach, but here we have a reference to a real task and we are
+ * exclusive owner of this reference and the task is not yet running => no locking required.
+ * 
+ *
+ * @param *l_task - pointer to a kernel task struct, to which we are attaching
+ * @param *t_task - pointer to the TCMI task that is to be attached
+ * @param *mig_mode_handler - migration mode handler specific to the
+ * task.
+ * @return 0 upon success.
+ */
+static inline int tcmi_taskhelper_attach_exclusive(struct task_struct* l_task, struct tcmi_task *t_task, 
+					 mig_mode_handler_t *mig_mode_handler)
+{
+	int err = -EINVAL;
+
+	if (l_task->tcmi.mig_mode_handler || l_task->tcmi.tcmi_task) {
+		mdbg(ERR3, "Kernel task %d already has a mig. mode handler - %p "
+		     "or TCMI task - %p assigned, bailing out",
+		      tcmi_task_local_pid(t_task), l_task->tcmi.mig_mode_handler,
+		     l_task->tcmi.tcmi_task);
+		goto exit0;
+	}
+	l_task->tcmi.mig_mode_handler = mig_mode_handler;
+	/* extra reference on TCMI task for the target process/its
+	 * migration component resp. */
+	l_task->tcmi.tcmi_task = tcmi_task_get(t_task); 
+	l_task->tcmi.task_type = tcmi_task_get_type(t_task);
+
+	return 0;
+
+	/* error handling */
+ exit0:
+	return err;
+}
+
+
+/** 
+ * \<\<private\>\> Dettaches the TCMI task from a specified process -
+ * lock free version. This method is intended for internal use only.
+ * It resets all TCMI related data in the specified process and
+ * returns the TCMI task pointer. It is user responsibility
+ * to ensure proper locking.
+ *
+ * @return TCMI task that has been detached.
+ */
+static inline struct tcmi_task* __tcmi_taskhelper_detach(struct task_struct *l_task)
+{
+	struct tcmi_task *tmp;
+
+	tmp = l_task->tcmi.tcmi_task;
+	l_task->tcmi.tcmi_task = NULL;
+	l_task->tcmi.mig_mode_handler = NULL;
+	if ( l_task->tcmi.task_type == shadow ) 
+		l_task->tcmi.task_type = shadow_detached;
+
+	return tmp;
+}
+
+/** 
+ * \<\<public\>\> Dettaches the TCMI task from its process The user
+ * specifies only kernel task, that is to be handled.  This method is
+ * typically used from migration mode handler -
+ * 
+ *
+ * Dettaching the task includes also resetting the migration mode
+ * handler to NULL. This work is delegated to
+ * __tcmi_taskhelper_detach().
+ *
+ * @return TCMI task that has been detached.
+ */
+static inline struct tcmi_task* tcmi_taskhelper_detach(void)
+{
+	struct tcmi_task *tmp;
+
+	read_lock_irq(&tasklist_lock);
+	task_lock(current);
+
+	
+	tmp = __tcmi_taskhelper_detach(current);
+
+	task_unlock(current);
+	read_unlock_irq(&tasklist_lock);
+
+	return tmp;
+}
+
+/** 
+ * \<\<public\>\> Dettaches the TCMI task from its process.  The
+ * process is looked up based on PID and the task is removed from the
+ * task_struct.
+ *
+ * @param pid - PID of the process whose TCMI task is to be detached
+ * @return TCMI task that has been detached.
+ */
+static inline struct tcmi_task* tcmi_taskhelper_detach_by_pid(pid_t pid)
+{
+	struct task_struct *l_task;
+	struct tcmi_task *t_task;
+
+	/* try finding the process by PID */
+	read_lock_irq(&tasklist_lock);
+	if (!(l_task = task_find_by_pid(pid))) {
+		mdbg(ERR3, "Can't notify, no such process %d", pid);
+		goto exit0;
+	}
+	task_lock(l_task);
+	t_task = __tcmi_taskhelper_detach(l_task);
+	task_unlock(l_task);
+
+	read_unlock_irq(&tasklist_lock);
+
+	return t_task;
+
+	/* error handling */
+ exit0:
+	read_unlock_irq(&tasklist_lock);
+	return NULL;
+}
+
+
+/** 
+ * \<\<public\>\> This method is intended for migration mode handler,
+ * it should be the very first check it performs. We verify that the
+ * current process has a valid TCMI task assigned. Also, if this is
+ * the first time entering the migration mode, the task has to be
+ * 'picked up'. This is a synchronization mechanism that is available
+ * for the TCMI task instantiator (usually the migration component).
+ *
+ * @return a valid TCMI task that is attached to the current kernel
+ * process or NULL;
+ */
+static inline struct tcmi_task* tcmi_taskhelper_sanity_check(void)
+{
+	struct tcmi_task *t_task;
+
+	task_lock(current);
+	/* safes a few dereferences */
+	t_task = current->tcmi.tcmi_task;
+	/* check that the TCMI task exists */
+	if (!t_task) {
+		mdbg(ERR3, "Kernel task '%s' PID=%d has no TCMI task assigned", 
+		     current->comm, current->pid);
+		goto exit0;
+	}
+	/* pickup the task when entering the migration mode for the first time */
+	if (!tcmi_task_picked_up(t_task)) {
+		mdbg(INFO2, "TCMI task %p PID=%d first time in mig. mode, picking up", 
+		     t_task, tcmi_task_local_pid(t_task));
+		tcmi_task_pick_up(t_task);
+	}
+	task_unlock(current);
+
+	return t_task;
+	/* error handling */
+ exit0:
+	task_unlock(current);
+	return NULL;
+}
+
+/**
+ * \<\<public\>\> This method is registered by CCN or PEN component as
+ * the SIGUNUSED signal handler. It is responsible for storing the
+ * current process user mode context into the shadow/guest task resp.
+ *
+ * @param *regs - the current process context (registers)
+ */
+static inline void tcmi_taskhelper_do_mig_mode(struct pt_regs *regs)
+{
+	if (current->tcmi.mig_mode_handler && current->tcmi.tcmi_task) {
+		mdbg(INFO3, "Migration mode active for %p '%s'", current, current->comm);
+		tcmi_task_set_context(current->tcmi.tcmi_task, regs);
+		current->tcmi.mig_mode_handler();
+	}
+}
+
+
+
+
+/**
+ * \<\<public\>\> current process notification - submission of a method.
+ * The notification requires:
+ * - checks for a valid TCMI task in current process
+ * - submits the method based on priority
+ * - launches the migration mode handler - we need to reassign
+ * the process context as this notification is typically used
+ * from system call hooks.
+ *
+ * @param *method - task method that is to be submitted
+ * @param *data - argument for the submitted method
+ * @param size - size of the argument in bytes
+ * @param priority - when > 0, the method queue is also flushed
+ * @return 0 upon success
+ */
+static inline int tcmi_taskhelper_notify_current(tcmi_method_t *method, 
+						 void *data, int size, int priority)
+{
+	struct tcmi_task *t_task;
+
+	mdbg(INFO3, "Notify current %p", current);
+	if (!(t_task = current->tcmi.tcmi_task)) {
+		goto exit0;
+	}
+
+	/* now we can safely operate on the task as we own 1 reference */
+	if (priority > 0)
+		tcmi_task_flush_and_submit_method(t_task, method, data, size);
+	else
+		tcmi_task_submit_method(t_task, method, data, size);
+
+	tcmi_taskhelper_do_mig_mode(tcmi_task_context(t_task));
+
+	return 0;
+
+	/* error handling */
+ exit0:
+	return -EINVAL;
+}
+
+/** 
+ * \<\<public\>\> Creates a new checkpoint of the process.  It might
+ * be a good idea to delete the old checkpoint too. This method has to
+ * be called from the context of the process that is to be
+ * checkpointed.
+ *
+ * - The checkpoint name is composed of the process name stored in
+ * current->comm pid and current value of jiffies.  Once the
+ * checkpoint name is complete, it is stored in the task instance(so
+ * that it can be accessed later on).
+ *
+ * - a new checkpoint file is open(created)
+ *
+ * - file object along with task context is passed onto the
+ * checkpointing component.
+ *
+ * 
+ * @param *t_task - pointer to the TCMI task that is to be checkpointed.
+ * @params *npm_params - Pointer to non-preemtive migration params (or null in case of preemptive migration)
+ * @return 0 upon success
+ */
+static inline int tcmi_taskhelper_checkpoint(struct tcmi_task *t_task, struct tcmi_npm_params* npm_params)
+{
+	/* page for the filepathname */
+	unsigned long page;
+	char *pathname = NULL;
+	struct file *file;
+	char *argv[] = { NULL };
+	char *envp[] = { NULL };
+
+	/* resolve the path name. */
+	if (!(page = __get_free_page(GFP_ATOMIC))) {
+		mdbg(ERR3, "Can't allocate page for file pathname!");
+		goto exit0;
+	}
+	pathname = (char*) page;
+	snprintf(pathname, PAGE_SIZE, "/home/clondike/%s.%d.%lu", current->comm, 
+		 current->pid, jiffies);
+	mdbg(INFO3, "Composed checkpoint name: '%s' Npm params: %p", pathname, npm_params);
+		
+	/* setup execve arguments - this is just to store checkpoint name in the instance */
+	if (tcmi_task_prepare_execve(t_task, pathname, argv, envp) < 0) {
+		mdbg(ERR3, "Failed preparing execve of the checkpoint '%s'", pathname);
+		goto exit1;
+	}
+
+	/* Ask the checkpointing component for a checkpoint */
+	file = filp_open(pathname, 
+			 O_CREAT | O_RDWR  | O_NOFOLLOW | O_LARGEFILE | O_TRUNC, 0700);
+	if (IS_ERR(file)) {
+		mdbg(ERR3, "Failed to create a checkpoint file for pid %d. Ckptname = '%s'. Error: %ld", current->pid,
+		     pathname, PTR_ERR(file));
+		goto exit1;
+	}
+
+	/* create the checkpoint, task context contains pointer to process registers */
+	if ( npm_params ) {
+		// Non-preemptive checkpoint
+		if (tcmi_ckptcom_checkpoint_npm(file, tcmi_task_context(t_task), npm_params) < 0) {
+			mdbg(ERR3, "Failed npm checkpointing process PID %d ckptname = '%s'", current->pid,
+			pathname);
+			goto exit2;
+		}
+	} else {
+		// Preemptive checkpoint
+		if (tcmi_ckptcom_checkpoint_ppm(file, tcmi_task_context(t_task), 1) < 0) {
+			mdbg(ERR3, "Failed ppm checkpointing process PID %d ckptname = '%s'", current->pid,
+			pathname);
+			goto exit2;
+		}
+	}
+
+	filp_close(file, NULL);	
+
+	free_page(page);
+	return 0;
+
+	/* error handling */
+ exit2:
+	filp_close(file, NULL);	
+ exit1:
+	free_page(page);
+ exit0:
+	return -EINVAL;
+}
+
+/** 
+ * \<\<public\>\> Schedules a task restart from a given checkpoint
+ * image. This requires:
+ *
+ * - preparing execve of the checkpoint (the task stores internally
+ * the execve name string, so that it can be released upon task destruction)
+ * - submitting execve method - it will be picked up by the method pump
+ * in its next iteration. We WANT to flush all methods from the queue as
+ * execve we is of high importance and want to make sure it runs next.
+ *
+ * @param *t_task - pointer to the TCMI task whose image will be overlayed
+ * with the checkpoint image
+ * @param ckpt_name - checkpoint image name.
+ * @return 0 upon success
+ */
+static inline int tcmi_taskhelper_restart(struct tcmi_task *t_task, char *ckpt_name)
+{
+	char *argv[] = { NULL };
+	char *envp[] = { NULL };
+	/* setup execve arguments*/
+	if (tcmi_task_prepare_execve(t_task, ckpt_name, argv, envp) < 0) { 
+		mdbg(ERR3, "Failed preparing execve of the checkpoint '%s'", ckpt_name);
+		goto exit0;
+	}
+	/* schedule task execve as the next method - requires flushing
+	 * all methods in the queue */
+	mdbg(INFO3, "Submitting execve");
+	tcmi_task_flush_and_submit_method(t_task, tcmi_task_execve, NULL, 0);
+	return 0;
+
+	/* error handling */
+ exit0:
+	return -EINVAL;
+}
+
+/**
+ * \<\<public\>\> Flushing files is required prior to issuing a
+ * migrate request. It is necessary to close all regular files that
+ * the process has open as those files will be accessed again by the
+ * restarted checkpoint. This prevents write conflicts.
+ *
+ *
+ */
+static inline void tcmi_taskhelper_flushfiles(void)
+{
+	int fd;
+	struct file *file;
+	struct inode *inode;
+	unsigned int old_flags = current->flags & PF_EXITING;
+	
+	/* We do a special trick here. In order to preserve proxy files during the migration, we need to tell the other end not to close the files.
+	   It does not close the files in case the clsoe was called in context of exit, as this file is going to be closed on process exit.
+	   So we pretend we are exitting here so that the server things it should not close the file */ 
+	current->flags |= PF_EXITING;
+	
+	/* Check each open file */
+	tcmi_ckpt_foreach_openfile(file, fd) {
+		inode = file->f_dentry->d_inode;
+		if (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) || S_ISCHR(inode->i_mode) || S_ISFIFO(inode->i_mode) ) {
+			mdbg(INFO4, "Closing file fd=%d, type=%0o '%s'", fd, file->f_flags, 
+			     file->f_dentry->d_name.name);
+			sys_close(fd);
+		}
+	}
+		
+	current->flags = old_flags;
+}
+
+/** \<\<public\>\> Set action for all signals accept SIGKILL and SIGSTOP 
+ * @param *action - struct k_sigaction, which will be set to all signals
+ */
+static inline void tcmi_taskhelper_catch_all_signals(struct k_sigaction *action)
+{
+	int i;
+	for( i = 1; i < _NSIG; i++ ){
+		if( i != SIGKILL && i != SIGSTOP )
+			do_sigaction( i, action, NULL );
+	}
+
+}
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_TASKHELPER_PRIVATE
+
+
+#endif /* TCMI_TASKHELPER_PRIVATE */
+
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_TASKHELPER_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/task/tcmi_shadowtask.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/task/tcmi_shadowtask.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,521 @@
+/**
+ * @file tcmi_shadowtask.c - TCMI shadow task, migrated process abstraction on CCN
+ *                      
+ * 
+ *
+ *
+ * Date: 04/26/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_shadowtask.c,v 1.17 2009-04-06 21:48:46 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <tcmi/comm/tcmi_messages_dsc.h>
+#include <tcmi/syscall/tcmi_shadow_rpc.h>
+#include <tcmi/comm/tcmi_rpc_procmsg.h>
+#include <tcmi/comm/tcmi_rpcresp_procmsg.h>
+#include <tcmi/comm/tcmi_ppm_p_migr_back_shadowreq_procmsg.h>
+#include <tcmi/manager/tcmi_migman.h>
+#include <tcmi/migration/tcmi_npm_params.h>
+#include "tcmi_taskhelper.h"
+
+#define TCMI_SHADOWTASK_PRIVATE
+#include "tcmi_shadowtask.h"
+#include <asm/signal.h>
+#include <proxyfs/proxyfs_server.h>
+
+#include <director/director.h>
+
+/** 
+ * This is just a "assertion check" handler. It should never be calles since all signals
+ * of the CCN should be processed in its main processing loop. 
+ *
+ * When the process is migrated away, this handler is registered as a handler of all its assocaited signals.
+ * When the process is migrated back, its real handlers are restored.
+ */
+static void tcmi_shadowtask_signal_handler(int sig)
+{
+	mdbg(ERR3, "Shadow signal handler for signal %d called", sig);
+}
+
+static struct k_sigaction signal_action = {
+	.sa = {
+		.sa_handler = &tcmi_shadowtask_signal_handler,
+		.sa_mask = {
+			#if defined(__x86_64__) 
+			.sig = { 0xffffFFFFffffFFFF }
+			#else
+			.sig = { 0xffffFFFF, 0xffffFFFF },
+			#endif
+		},
+		.sa_flags = SA_SIGINFO,
+		.sa_restorer = NULL,
+	},
+};
+
+
+/** 
+ * \<\<public\>\> Instance constructor.
+ * - allocates a new instance.
+ * - delegates its initialization to the super class.
+ *
+ * @param local_pid - local PID on CCN
+ * @param migman - The migration manager that maintains this task
+ * @param *sock - socket used for communication with guest task on PEN
+ * @param *d_migproc - directory where ctlfs entries of migrated
+ * processes reside
+ * @param *d_migman - TCMI ctlfs directory of the migration manager
+ * responsible for this task
+ * @return 0 upon success
+ */
+struct tcmi_task* tcmi_shadowtask_new(pid_t local_pid, struct tcmi_migman* migman,
+				      struct kkc_sock *sock, 
+				      struct tcmi_ctlfs_entry *d_migproc, 
+				      struct tcmi_ctlfs_entry *d_migman)
+{
+	struct tcmi_shadowtask *task;
+	minfo(INFO2, "Creating new shadow task for local PID=%d", local_pid);
+	if (!(task = TCMI_SHADOWTASK(kmalloc(sizeof(struct tcmi_shadowtask), 
+					     GFP_ATOMIC)))) {
+		minfo(ERR3, "Can't allocate memory for TCMI shadow task");
+		goto exit0;
+	}
+	if (tcmi_task_init(TCMI_TASK(task), local_pid, migman, sock, d_migproc, 
+			   d_migman, &shadowtask_ops) < 0) {
+		minfo(ERR3, "TCMI shadow task initialization failed!");
+		goto exit1;
+	}
+	return TCMI_TASK(task);
+
+	/* error handling */
+ exit1:
+	kfree(task);
+ exit0:
+	return NULL;
+}
+
+/** @addtogroup tcmi_shadowtask_class
+ *
+ * @{
+ */
+
+/** 
+ *  \<\<private\>\> Processes a message specified by the caller.
+ *
+ * @param *self - pointer to this task instance
+ * @param *m - message to be processed
+ * @return depends on the type of message that has been processed
+ */
+static int tcmi_shadowtask_process_msg(struct tcmi_task *self, struct tcmi_msg *m)
+{
+	int res = TCMI_TASK_KEEP_PUMPING;
+	struct tcmi_msg *resp = NULL;
+	pid_t remote_pid;
+	int err;
+	
+	/* struct tcmi_shadowtask *self_tsk = TCMI_SHADOWTASK(self); */
+
+	switch (tcmi_msg_id(m)) {
+		case TCMI_RPC_PROCMSG_ID:
+			mdbg(INFO1, "Receiced RPC message: %x", tcmi_msg_id(m));
+
+			tcmi_rpc_call2(tcmi_shadow_rpc, tcmi_rpc_procmsg_num(TCMI_RPC_PROCMSG(m)), (long)m, (long)(&resp));
+
+			if ( resp == NULL ) {
+				minfo(ERR3, "RPC#%d didn't returned rpc response message", 
+						tcmi_rpc_procmsg_num(TCMI_RPC_PROCMSG(m)));
+				break;
+			}
+
+			if ( tcmi_task_check_peer_lost(self, (err = tcmi_task_send_anonymous_msg(self, resp)) ) ){
+				minfo(ERR3, "Error sending RPC response message %d", err);
+				
+				if ( err == -ERESTARTSYS ) {
+				    minfo(INFO3, "Scheduling message for resubmission");  
+				    /* Protect response reference, retransmission method will be responsible for releasing of the msg */
+				    tcmi_msg_get(resp);
+				    tcmi_task_submit_method(self, tcmi_task_send_message, resp, sizeof(struct tcmi_msg));
+				}
+			}
+
+			tcmi_msg_put( resp );
+
+			break;
+		/* exit request */
+		case TCMI_EXIT_PROCMSG_ID:
+			mdbg(INFO2, "Process '%s' local PID=%d, remote PID=%d terminating, "
+					"code: %ld, anounced by guest",
+					current->comm, tcmi_task_local_pid(self), 
+					tcmi_task_remote_pid(self),
+					(long)tcmi_exit_procmsg_code(TCMI_EXIT_PROCMSG(m)));
+			tcmi_task_set_exit_code(self, tcmi_exit_procmsg_code(TCMI_EXIT_PROCMSG(m)));
+			res = TCMI_TASK_KILL_ME;
+			break;
+		/* vfork done on guest side */
+		case TCMI_VFORK_DONE_PROCMSG_ID:
+			mdbg(INFO2, "Process '%s' local PID=%d, remote PID=%d vfork done",
+					current->comm, tcmi_task_local_pid(self), 
+					tcmi_task_remote_pid(self));
+			tcmi_shadowtask_vfork_done(self);
+			break;
+			/* migrate back request */
+		case TCMI_PPM_P_MIGR_BACK_GUESTREQ_PROCMSG_ID:
+			res = tcmi_shadowtask_process_ppm_p_migr_back_guestreq_procmsg(self, m);
+			break;
+		case TCMI_GUEST_STARTED_PROCMSG_ID: // We can get here only in double-fork
+			remote_pid = tcmi_guest_started_procmsg_guest_pid(TCMI_GUEST_STARTED_PROCMSG(m));
+			mdbg(INFO3, "Fork confirmation from guesttask - task migrated, local PID %d, guest PID %d", tcmi_task_local_pid(self), remote_pid);
+			tcmi_task_set_remote_pid(self, remote_pid);
+			break;
+		default:
+			mdbg(ERR3, "Unexpected message from the guest task: %x", tcmi_msg_id(m));
+			break;
+	}
+
+	return res;
+}
+
+static void tcmi_shadowtask_vfork_done(struct tcmi_task *self) {
+	struct completion *vfork_done = current->vfork_done;
+	if ( current->vfork_done ) {
+		current->vfork_done = NULL;
+		complete(vfork_done);				
+	}
+}
+
+/** Internal helper method that can perform both NPM and PPM physical emigration */
+static int tcmi_shadowtask_emigrate_p(struct tcmi_task *self, struct tcmi_npm_params* npm_params) {
+	struct tcmi_msg *req, *resp;
+	char* exec_name;
+	u64 beg_time, end_time;
+	
+	beg_time = cpu_clock(smp_processor_id());
+	
+	if ( npm_params ) {
+		// For NPM, the exec name is name of the file being executed
+		exec_name = npm_params->file_name;
+	} else {
+		// TODO: Detect this from current in case of PPM.. how? ;)	
+		exec_name = current->comm;
+	}
+
+	mdbg(INFO2, "Process '%s' - local PID %d, emigrating",
+	     current->comm, tcmi_task_local_pid(self));
+
+	if (tcmi_taskhelper_checkpoint(self, npm_params) < 0) {
+		mdbg(ERR3, "Failed to create a checkpoint");
+		goto exit0;
+	}
+
+	if (!(req = tcmi_p_emigrate_msg_new_tx(tcmi_task_transactions(self), 
+						   tcmi_task_local_pid(self), 
+						   exec_name,
+						   tcmi_task_ckpt_name(self),
+						   current_euid(),
+						   current_egid(),
+						   current_fsuid(),
+						   current_fsgid()))) {
+		mdbg(ERR3, "Error creating an emigration message");
+		goto exit0;
+	}
+	if ( tcmi_task_check_peer_lost(self, tcmi_task_send_and_receive_msg(self, req, &resp)) < 0) {
+		mdbg(ERR3, "Failed to send message!!");
+		goto exit1;
+	}
+	if (tcmi_shadowtask_verify_migration(self, resp) < 0) {
+		mdbg(ERR3, "Failed to migrate the task '%s'", current->comm);
+		goto exit2;
+	}
+
+	end_time = cpu_clock(smp_processor_id());
+	mdbg(INFO3, "Emigration (npm: %d) took '%llu' ms.'", npm_params != NULL, (end_time - beg_time) / 1000000);
+	printk("Emigration (npm: %d) took '%llu' ms.\n'", npm_params != NULL, (end_time - beg_time) / 1000000);
+	
+	/* 
+	   Files are flushed only after we have confirmation that the migration have succeeded.
+ 	   Otherwise we keep them open so that we can eventually continue execution of the current
+           process.
+         */
+	tcmi_taskhelper_flushfiles();
+	tcmi_taskhelper_catch_all_signals(&signal_action);
+
+	mdbg(INFO3, "Submitting process_msg");
+	tcmi_task_submit_method(self, tcmi_task_process_msg, NULL, 0);
+	/* release the message */
+	tcmi_msg_put(req);
+	tcmi_msg_put(resp);
+
+	// In case the emigration succeeded, we are responsible for freeing of npm params, as the caller won't ever get chance
+	if ( npm_params )
+		vfree(npm_params);
+
+	return TCMI_TASK_KEEP_PUMPING;
+	/* error handling */
+ exit2:
+	tcmi_msg_put(resp);
+ exit1:
+	tcmi_msg_put(req);
+ exit0:
+	/* either checkpointing,communication or restart has failed. In either case we simply continue execution of the current task */
+	return TCMI_TASK_REMOVE_AND_LET_ME_GO;
+};
+
+/** 
+ * \<\<private\>\> Emigrates a task to a PEN.
+ * - create a new checkpoint
+ * - flush open files of the current process (prevents write conflicts
+ * after checkpoint restart)
+ * - creates a new emigration message specifying latest checkpoint name
+ * and shadow task PID
+ * - send the message waiting for a response
+ * - if the guest has been succesfully started submit process_msg method into
+ * the method queue and quit (migration verification). The submitted method
+ * will keep on processing any message that will arrive on the queue.
+ *
+ * @param *self - pointer to this task instance
+ * @return TCMI_TASK_KEEP_PUMPING, if the shadow has received a positive 
+ * response and the task has been successfully migrated.
+ *
+ * @todo - after creating a checkpoint and preparing the emigration
+ * message there a few things that need to be done:
+ *
+ * - some component should scan all open files and close all regular
+ * files as they will be accessed from the network filesystem.
+ * - character, block devices, pipes, sockets should stay open so that
+ * remote operations can be forwarded locally.
+ * - the current execution image should be flushed as it is not needed
+ * anymore
+ * 
+ */
+static int tcmi_shadowtask_emigrate_ppm_p(struct tcmi_task *self)
+{
+	return tcmi_shadowtask_emigrate_p(self, NULL);
+}
+
+static int tcmi_shadowtask_emigrate_npm(struct tcmi_task *self, struct tcmi_npm_params* npm_params)
+{
+	return tcmi_shadowtask_emigrate_p(self, npm_params);
+}
+
+
+/** 
+ * \<\<private\>\> Migrates a task back to CCN. This is done simply by sending
+ * a migrate back request to the associated ghost task, which will handle its
+ * migration home the same way as if it was requested on PEN
+ *
+ * @param *self - pointer to this task instance
+ * @return result of the task specific migrate back method or 
+ * TCMI_TASK_KEEP_PUMPING
+ */
+static int tcmi_shadowtask_migrateback_ppm_p(struct tcmi_task *self)
+{
+	int res = TCMI_TASK_KEEP_PUMPING;
+	struct tcmi_msg *msg;
+	/* struct tcmi_shadowtask *self_tsk = TCMI_SHADOWTASK(self); */
+
+	mdbg(INFO2, "Process '%s' - local PID %d, remote PID %d, migrate home requested",
+	     current->comm, tcmi_task_local_pid(self), tcmi_task_remote_pid(self));
+
+	if ( !(msg = tcmi_ppm_p_migr_back_shadowreq_procmsg_new_tx(tcmi_task_remote_pid(self))) ) {
+		mdbg(ERR3, "Error creating a migrate back message");
+		goto exit0;
+	}
+
+	if ( tcmi_task_check_peer_lost(self, tcmi_task_send_anonymous_msg(self, msg)) < 0) {
+		mdbg(ERR3, "Failed to send message!!");
+		goto exit1;
+	}
+exit1:
+	tcmi_msg_put(msg);
+exit0:	
+	return res;
+}
+
+
+/** 
+ * \<\<private\>\> Execve notification when merging shadow with
+ * migrating process on CCN.  This method is called right before
+ * issuing the actual execve on the checkpoint image of the migrated
+ * task. Since the task will be merged with the original process, it
+ * needs to be remove from the TCMI. All that needs to be done is
+ * scheduling a tcmi_task_exit() method. The migration mode handler
+ * takes care of the rest.
+ * 
+ * @param *self - pointer to this task instance 
+ * @return 0 upon success
+ */
+static int tcmi_shadowtask_execve(struct tcmi_task *self)
+{
+	tcmi_task_flush_and_submit_method(self, tcmi_task_exit, NULL, 0);
+	/* migration mode is entered when the actual execve resumes to
+	 * user mode */
+	tcmi_taskhelper_enter_mig_mode(self);
+	return 0;
+}
+
+/**
+ * \<\<private\>\> Processes a specified signal.  
+ * All signals are forwared to the guest task.
+ *
+ * @param *self - pointer to this task instance 
+ * @param signr - signal that is to be processed
+ * @param *info - info for signal to be processed
+ *
+ * @return TCMI_TASK_KEEP_PUMPING on any signal but second or more SIGKILL
+ */
+static int tcmi_shadowtask_do_signal(struct tcmi_task *self, unsigned long signr, siginfo_t *info)
+{
+	int res = TCMI_TASK_KEEP_PUMPING;
+	struct tcmi_msg *msg;
+
+	mdbg(INFO2, "Shadow is processing signal %lu", signr);
+	
+	msg = tcmi_signal_msg_new(tcmi_task_remote_pid(self), info);
+	if( msg ){
+		tcmi_task_check_peer_lost(self, tcmi_msg_send_anonymous(msg, tcmi_migman_sock(self->migman)));
+		mdbg(INFO2, "Signal message send");
+	}
+		
+	return res;
+}
+
+/**
+ * \<\<private\>\> Verifies, that the task has been successfully migrated.
+ * The verification is done based on response message the has to be
+ * TCMI_GUEST_STARTED_PROCMSG and has to carry a non-zero guest PID.
+ * If the verification is positive, the guest PID is stored inside
+ * this shadow instance. It will be used for further communication
+ * with the guest.
+ *
+ * @param *self - pointer to this task instance
+ * @param *resp - pointer to the response to be processed
+ * @return 0 if the task has been successfully migrated
+ */
+static int tcmi_shadowtask_verify_migration(struct tcmi_task *self, struct tcmi_msg *resp)
+{
+	int err = -EINVAL;
+	pid_t remote_pid;
+
+	if (!resp) {
+		mdbg(ERR3, "No response from guest task has arrived..");
+		goto exit0;
+	}
+	switch (tcmi_msg_id(resp)) {
+		/* regular version */
+	case TCMI_GUEST_STARTED_PROCMSG_ID:
+		remote_pid = tcmi_guest_started_procmsg_guest_pid(TCMI_GUEST_STARTED_PROCMSG(resp));
+		mdbg(INFO3, "Confirmation from guesttask - task migrated, local PID %d, guest PID %d", tcmi_task_local_pid(self), remote_pid);
+		if ( remote_pid == -1 ) {
+		    err = -EINVAL;
+		} else {
+		  tcmi_task_set_remote_pid(self, remote_pid);
+		  err = 0;
+		}
+		break;
+		/* error version */
+	case TCMI_MSG_FLG_SET_ERR(TCMI_GUEST_STARTED_PROCMSG_ID):
+		mdbg(ERR3, "Stub hasn't been started, migration failed..");
+		break;
+	default:
+		mdbg(ERR3, "Unexpected response from the guest task: %x", tcmi_msg_id(resp));
+		break;
+	}
+	/* error handling */
+ exit0:
+	return err;
+}
+
+
+/**
+ * \<\<private\>\> Processes the PPM_P emigrate process message.
+ *
+ * The remote PID is extracted from the emigration message and stored
+ * in the guest task. The checkpoint name is also extracted and passed
+ * to the task helper to schedule a restart. This also sets the
+ * checkpoint image as the most recent checkpoint of the task.
+ *
+ * A response is sent back that will contain the guest task local
+ * PID. This PID is needed for further communication between the
+ * shadow and guest tasks.
+ *
+ * The restart is only scheduled and will be processed upon next
+ * iteration of the method pump. 
+ *
+ * @param *self - this guest task instance
+ * @param *m - PPM_P migrate back guest request
+ * @return TASK_KEEP_PUMPING if the restart has been successfully
+ * scheduled
+ */
+static int tcmi_shadowtask_process_ppm_p_migr_back_guestreq_procmsg(struct tcmi_task *self, 
+								   struct tcmi_msg *m)
+{
+	char *ckpt_name;
+
+	/* extract the checkpoint name */
+	ckpt_name =  tcmi_ppm_p_migr_back_guestreq_procmsg_ckpt_name
+		(TCMI_PPM_P_MIGR_BACK_GUESTREQ_PROCMSG(m));
+		
+	mdbg(INFO2, "Processing migrate back request, remote PID=%d, checkpoint: '%s'",
+		     tcmi_task_remote_pid(self), ckpt_name);
+
+	director_migrated_home(tcmi_task_local_pid(self));
+	
+	/* schedules process restart from a checkpoint image */
+	if (tcmi_taskhelper_restart(self, ckpt_name) < 0) {
+		mdbg(ERR3, "Cannot setup task restart!!");
+		goto exit0;
+
+	}
+	return TCMI_TASK_KEEP_PUMPING;
+		
+	/* error handling */
+ exit0:
+	return TCMI_TASK_KILL_ME;
+}
+
+/** \<\<private\>\> Custom free method */
+static void tcmi_shadowtask_free(struct tcmi_task* self)
+{
+}
+
+
+/** Return type of task. Only for setting task type to kernel task_struct. Polymorphism 
+ * cannot be used in kernel, bacause tcmi_task is defined outside of kernel. */
+enum tcmi_task_type tcmi_shadowtask_get_type(void)
+{
+	return shadow;
+}
+
+/** TCMI task operations that support polymorphism */
+static struct tcmi_task_ops shadowtask_ops = {
+	.process_msg = tcmi_shadowtask_process_msg,
+	.emigrate_ppm_p = tcmi_shadowtask_emigrate_ppm_p,
+	.emigrate_npm = tcmi_shadowtask_emigrate_npm,
+	.migrateback_ppm_p = tcmi_shadowtask_migrateback_ppm_p,
+	.execve = tcmi_shadowtask_execve,
+	.get_type = tcmi_shadowtask_get_type,
+	.do_signal = tcmi_shadowtask_do_signal,
+	.free = tcmi_shadowtask_free
+};
+
+/**
+ * @}
+ */
--- linux-3.7.1_original/clondike/src/tcmi/task/tcmi_shadowtask.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/task/tcmi_shadowtask.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,116 @@
+/**
+ * @file tcmi_shadowtask.h - TCMI shadow task, migrated process abstraction on CCN
+ *                      
+ * 
+ *
+ *
+ * Date: 04/26/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_shadowtask.h,v 1.9 2008/05/02 19:59:20 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_SHADOWTASK_H
+#define _TCMI_SHADOWTASK_H
+
+#include "tcmi_task.h"
+
+/** @defgroup tcmi_shadowtask_class tcmi_shadowtask class 
+ * 
+ * @ingroup tcmi_task_class
+ *
+ * This class is an abstraction for a migrated process on CCN. It
+ * represents the residual dependency that the migrated process has
+ * towards its originating node(CCN).  This class also does all the
+ * migration work including migration back to CCN (merging the shadow
+ * with the process migrating home). For this purpose, there are
+ * various methods that implement various types of migration:
+ * - preemptive migration using physical checkpoint image
+ * (tcmi_shadowtask_*_ppm_p())
+ * - preemptive migration using virtual checkpoint image
+ * (tcmi_shadowtask_*_ppm_v())
+ * - non-preemptive migration via execve hook
+ * (tcmi_shadowtask_*_npm())
+ *
+ * @{
+ */
+
+/** Compound structure for the shadow task. */
+struct tcmi_shadowtask {
+	/** parent class instance. */
+	struct tcmi_task super;
+};
+
+
+/** Casts to the task instance. */
+#define TCMI_SHADOWTASK(t) ((struct tcmi_shadowtask*)t)
+
+/** \<\<public\>\> Creates a new shadow task. */
+extern struct tcmi_task* tcmi_shadowtask_new(pid_t local_pid, struct tcmi_migman* migman,
+					     struct kkc_sock *sock, 
+					     struct tcmi_ctlfs_entry *d_migproc, 
+					     struct tcmi_ctlfs_entry *d_migman);
+
+
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_SHADOWTASK_PRIVATE
+
+/** Processes a message. */
+static int tcmi_shadowtask_process_msg(struct tcmi_task *self, struct tcmi_msg *m);
+
+/** Emigrates a task to a PEN. */
+static int tcmi_shadowtask_emigrate_ppm_p(struct tcmi_task *self);
+
+/** Migrates a task back to CCN. */
+static int tcmi_shadowtask_migrateback_ppm_p(struct tcmi_task *self);
+
+/** Execve notification when merging shadow with migrating process on CCN. */
+static int tcmi_shadowtask_execve(struct tcmi_task *self);
+
+/** Handles a specified signal. */
+static int tcmi_shadowtask_do_signal(struct tcmi_task *self, unsigned long signr, siginfo_t *info);
+
+/** Verifies a successful task migration. */
+static int tcmi_shadowtask_verify_migration(struct tcmi_task *self, struct tcmi_msg *resp);
+
+/** Processes a migrate back request. */
+static int tcmi_shadowtask_process_ppm_p_migr_back_guestreq_procmsg(struct tcmi_task *self, 
+								   struct tcmi_msg *m);
+/** Custom free method */
+static void tcmi_shadowtask_free(struct tcmi_task* self);
+
+static void tcmi_shadowtask_vfork_done(struct tcmi_task *self);
+
+/** Return a task type */
+static enum tcmi_task_type tcmi_shadowtask_get_type(void);
+
+/** TCMI task operations that support polymorphism. */
+static struct tcmi_task_ops shadowtask_ops;
+
+#endif /* TCMI_SHADOWTASK_PRIVATE */
+
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_SHADOWTASK_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/task/tcmi_task.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/task/tcmi_task.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,948 @@
+/**
+ * @file tcmi_task.c - common functionality for TCMI shadow and guest tasks.
+ *                      
+ * 
+ *
+ *
+ * Date: 04/25/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_task.c,v 1.11 2009-01-20 14:23:10 andrep1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/* needed, so that execve is visible */
+int errno = 0;
+#define __KERNEL_SYSCALLS__
+#include <linux/unistd.h> 
+#include <asm/uaccess.h>
+#include <linux/kmod.h>
+
+#include <linux/hardirq.h>
+#include <linux/syscalls.h>
+
+
+#define TCMI_TASK_PRIVATE
+#include "tcmi_task.h"
+#include <tcmi/manager/tcmi_migman.h>
+
+#include "tcmi_taskhelper.h"
+
+/** TODO: Move this somewhere to arch */
+#if defined(__x86_64__)
+/* static inline _syscall3(int, execve, const char *, filename, char *const *, argv, char *const *, envp); */
+
+int clondike_execve(const char *filename, char *const argv[], char *const envp[]);
+
+static inline int copyof_kernel_execve(const char *filename, char *const argv[], char *const envp[]) {
+	return clondike_execve(filename, argv, envp);
+}
+
+#endif
+
+/* static inline _syscall3(int, execve, const char *, filename, char *const *, argv, char *const *, envp); */
+
+/*inline int kernel_execve(const char *filename, char *const argv[], char *const envp[])
+{
+	mm_segment_t fs = get_fs();
+	int ret;
+
+	WARN_ON(segment_eq(fs, USER_DS));
+	ret = execve(filename, (char **)argv, (char **)envp);
+	if (ret)
+		ret = errno;
+
+	return ret;
+}*/
+
+
+/** 2^8 elements in the transaction process hash */
+#define TRANSACTION_ORDER 8
+
+/** Initializes the task. 
+ * Task initialization requires:
+ * - setting PID's (remote PID is set to 0 it will be updated
+ * once the migration is finished)
+ * - getting an extra reference to the communication socket
+ * - getting an extra reference to the associated migration manager
+ * - initializing method and message queues
+ * - create transaction slot vector
+ * - creating directory in migproc using the local PID as its name
+ * - creating symlink to the migration manager directory
+ * - creating remote PID TCMI ctlfs file
+ * - default exit code is set to 0, this might change when
+ * the guest task terminates and sends back its exit code.
+ * - setting all execve context to NULL (file, argv, envp)
+ * - initialize the completion synchronization element, so that
+ * the task instantiator (usually the migration component) can be 
+ * notified when the task has been picked up by the associated process.
+ * Also reset the picked_up flag. This is used for atomic check if the task
+ * might have been pickedup short after the timeout.
+ * - setting operations for the specific task
+ *
+ * @param *self - this task instance
+ * @param local_pid - local PID on CCN or PEN
+ * @param migman - migration manager that maintains this task (can be null)
+ * @param *sock - socket used for communication with guest task on PEN
+ * or shadow task on CCN resp.
+ * @param *d_migproc - directory where ctlfs entries of migrated
+ * processes reside
+ * @param *d_migman - TCMI ctlfs directory of the migration manager
+ * responsible for this task
+ * @param *ops - task specific operations
+ * @return 0 upon success
+ */
+int tcmi_task_init(struct tcmi_task *self, pid_t local_pid, struct tcmi_migman* migman,
+		   struct kkc_sock *sock, 
+		   struct tcmi_ctlfs_entry *d_migproc, struct tcmi_ctlfs_entry *d_migman,
+		   struct tcmi_task_ops *ops)
+{
+	int err = -EINVAL;
+
+	self->local_pid = local_pid;
+	self->migman = tcmi_migman_get(migman);
+	self->remote_pid = 0;
+	self->sock = kkc_sock_get(sock);
+
+	self->execve_count = 0;
+	self->peer_lost = 0;
+
+	self->d_migman_root = d_migman;
+	self->f_remote_pid_rev = NULL;
+	tcmi_queue_init(&self->method_queue);
+	tcmi_queue_init(&self->msg_queue);
+
+	if (!ops) {
+		mdbg(ERR3, "Missing task operations!");
+		goto exit0;
+	}
+
+	if (!(self->transactions = tcmi_slotvec_hnew(TRANSACTION_ORDER))) {
+		mdbg(ERR3, "Can't create transactions slotvector!");
+		err = -ENOMEM;
+		goto exit0;
+	}
+
+	if (!(self->d_task = 
+	      tcmi_ctlfs_dir_new(d_migproc, TCMI_PERMS_DIR, "%d", local_pid))) {
+		mdbg(ERR3, "Can't create migproc entry for %d", local_pid);
+		goto exit1;
+	}
+
+	if (!(self->s_migman = 
+	      tcmi_ctlfs_symlink_new(self->d_task, d_migman, "migman"))) {
+		mdbg(ERR3, "Can't create symlink to migration manager for %d", local_pid);
+		goto exit2;
+	}
+
+	if (!(self->f_remote_pid = 
+	      tcmi_ctlfs_intfile_new(self->d_task, TCMI_PERMS_FILE_R,
+				     self, tcmi_task_show_remote_pid, NULL,
+				     sizeof(pid_t), "remote-pid"))) {
+		mdbg(ERR3, "Can't create remote PID file entry for %d", local_pid);
+		goto exit3;
+	}
+
+	if ( migman && tcmi_migman_add_task(migman, self) ) {
+		mdbg(ERR3, "Can't add task to migman tasks struct: lpid %d", local_pid);
+		goto exit4;
+	}
+
+	self->exit_code = 0;
+	atomic_set(&self->ref_count, 1);
+
+	self->ckpt_pathname = NULL;
+	self->argv = NULL;
+	self->envp = NULL;
+
+	init_completion(&self->picked_up);
+	self->picked_up_flag = 0;
+	self->ops = ops;
+
+	minfo(INFO4, "Initialized TCMI task PID=%d, %p", local_pid, self);
+	return 0;
+
+	/* error handling */
+ exit4:
+	tcmi_ctlfs_entry_put(self->f_remote_pid);
+ exit3:
+	tcmi_ctlfs_entry_put(self->s_migman);
+ exit2:
+	tcmi_ctlfs_entry_put(self->d_task);
+ exit1:
+	tcmi_slotvec_put(self->transactions);
+ exit0:
+	kkc_sock_put(self->sock);
+	tcmi_migman_put(self->migman);
+	return err;
+}
+
+
+/** 
+ * \<\<public\>\> Releases the instance. 
+ * - calls custom free method for a specific task
+ * - destroys all ctlfs files, directories, symlinks
+ * - destroys the transaction slot vector
+ * - empties the message queue
+ * - empties the method queue
+ * - releases the execve context (execve filename, argv, envp) 
+ *
+ * @param *self - pointer to this task instance
+ */
+void tcmi_task_put(struct tcmi_task *self)
+{
+	/* Used for destruction of messages and methods. */
+	struct tcmi_msg *m;
+	struct tcmi_method_wrapper *w;
+
+	if (self && atomic_dec_and_test(&self->ref_count)) {
+		mdbg(INFO4, "Destroying TCMI task PID=%d, %p", 
+		     tcmi_task_local_pid(self), self);
+		/* instance specific free method */
+		if (self->ops->free)
+			self->ops->free(self);
+		kkc_sock_put(self->sock);
+		/* destroy all ctlfs entries */
+		tcmi_ctlfs_file_unregister(self->f_remote_pid);
+		tcmi_ctlfs_entry_put(self->f_remote_pid);
+		tcmi_ctlfs_entry_put(self->s_migman);
+		tcmi_ctlfs_entry_put(self->d_task);
+		tcmi_ctlfs_entry_put(self->f_remote_pid_rev);
+
+		if (!tcmi_slotvec_empty(self->transactions))
+			mdbg(WARN2, "Task %d, destroying non-empty transactions slotvector!!",
+			     self->local_pid);
+		tcmi_slotvec_put(self->transactions);
+
+		/* destroy remaining messages in the queue. */
+		while (!tcmi_queue_empty(&self->msg_queue)) {
+			tcmi_queue_remove_entry(&self->msg_queue, m, node);
+			mdbg(INFO3, "Task %d, destroying message %x",
+			     tcmi_task_local_pid(self), tcmi_msg_id(m));
+			tcmi_msg_put(m);
+		}
+		/* destroy remaining methods in the queue. */
+		while (!tcmi_queue_empty(&self->method_queue)) {
+			tcmi_queue_remove_entry(&self->method_queue, w, node);
+			mdbg(INFO3, "Task %d, destroying method wrapper %p",
+			     tcmi_task_local_pid(self), w);
+			tcmi_method_wrapper_put(w);
+		}
+		minfo(INFO3, "Releasing execve context");
+		tcmi_task_release_execve_context(self);
+		minfo(INFO3, "Done..");
+		tcmi_migman_remove_task(self->migman, self);
+		minfo(INFO3, "Removed from migman tasks done");
+		tcmi_migman_put(self->migman);
+		kfree(self);
+	}
+}
+
+
+
+/** 
+ * \<\<public\>\> Submits a method for execution. 
+ * Creates a new method wrapper with the specified data and delegates
+ * all work to tcmi_task_add_wrapper
+ *
+ * @param *self - pointer to this task instance
+ * @param *method - pointer to the method that is to be submitted
+ * @param *data - argument for the submitted method
+ * @param size - size of the argument in bytes
+ */
+void tcmi_task_submit_method(struct tcmi_task *self, tcmi_method_t *method, 
+			     void *data, int size)
+{
+	struct tcmi_method_wrapper *wr;
+
+	if (!(wr = tcmi_method_wrapper_new(method, data, size))) {
+		mdbg(ERR3, "Can't create method wrapper");
+		goto exit0;
+	}
+
+	tcmi_task_add_wrapper(self, wr);
+ exit0:
+	return;
+}
+
+/** 
+ * \<\<public\>\> Flushes all pending methods in the queue submits a method for execution. 
+ * This operation must be atomic - under a queue lock, all methods are
+ * removed and a new wrapper is added to the method queue.
+ *
+ * @param *self - pointer to this task instance
+ * @param *method - pointer to the method that is to be submitted
+ * @param *data - argument for the submitted method
+ * @param size - size of the argument in bytes
+ */
+void tcmi_task_flush_and_submit_method(struct tcmi_task *self, tcmi_method_t *method, 
+				       void *data, int size)
+{
+	struct tcmi_method_wrapper *wr, *old_w;
+	if (!(wr = tcmi_method_wrapper_new(method, data, size))) {
+		mdbg(ERR3, "Can't create method wrapper");
+		goto exit0;
+	}
+
+	tcmi_queue_lock(&self->method_queue);
+	/* flush everything in the queue. */
+	while (!tcmi_queue_empty(&self->method_queue)) {
+		__tcmi_queue_remove_entry(&self->method_queue, old_w, node);
+		tcmi_method_wrapper_put(old_w);
+	}
+	/* append the requested method into the queue. */
+	__tcmi_queue_add(&self->method_queue, &wr->node);
+
+	tcmi_queue_unlock(&self->method_queue);
+	mdbg(INFO3, "Flushed method queue and submitted new method in atomic=%d", in_atomic());
+ exit0:
+	return;
+}
+
+
+/** 
+ * \<\<public\>\> Processes all methods in the queue.  This method is
+ * used as a method pump, it keeps on unwrapping methods from the
+ * queue and executing them until one of them returns a results
+ * different from TCMI_TASK_KEEP_PUMPING. This result is communicated
+ * to the component that controls this particular task (usually the
+ * migration component). Every iteration, the signals are also
+ * handled. This might also influence the method pump and terminate
+ * it.
+ *
+ * The method wrapper is released once the method is executed only if
+ * there was no execve problem. To explain this: some methods perform
+ * an execve operation - in which case, the execution context changes
+ * immediately. Therefore, these methods have to discard the method
+ * wrapper on their own. Should the execve fail, they have already
+ * discarded the wrapper and thus have on control over it. In that
+ * case, the returned error is TCMI_TASK_EXECVE_FAILED_KILL_ME and we
+ * have to prevent releasing this method wrapper.
+ *
+ * The specific task method that had been executed had a
+ * chance to get an extra reference and resubmit the method wrapper
+ * into the method queue.
+ *
+ * @param *self - pointer to this task instance
+ * @return result of the last executed method
+ */
+int tcmi_task_process_methods(struct tcmi_task *self)
+{
+	int res = TCMI_TASK_KEEP_PUMPING;
+	struct tcmi_method_wrapper *w;
+
+	while ((!tcmi_queue_empty(&self->method_queue)) && 
+	       (res == TCMI_TASK_KEEP_PUMPING)) {
+		/* handle any pending signals */
+		if ((res = tcmi_taskhelper_do_signals(self)) != TCMI_TASK_KEEP_PUMPING)
+			break;
+
+		/* get next method to proces */
+		tcmi_queue_remove_entry(&self->method_queue, w, node);
+		/* unwrap & destroy the method wrapper excluding the execve failure */
+		if ((res = tcmi_method_wrapper_call(w, self)) != 
+		    TCMI_TASK_EXECVE_FAILED_KILL_ME) {			
+			mdbg(INFO3, "Execve have NOT failed.");
+			tcmi_method_wrapper_put(w);
+		} else {
+			mdbg(INFO3, "Execve have failed.");
+		}
+	}
+
+	mdbg(INFO3, "Process methods finished with res %d", res);
+
+	return res;
+}
+
+
+
+/** 
+ * \<\<public\>\> Called from method queue - Processes one message
+ * from the message queue.
+ *
+ * - Waits for the message to arrive or a signal to wake us up.
+ * - Upon message arrival, the message is processed (delegated to the
+ * task specific method if any) and discarded.  
+ * - Eventually, the method resubmits itself into the method queue
+ * reusing the method wrapper iff the result of the message processing
+ * is TCMI_TASK_KEEP_PUMPING.
+ *
+ * Optionally, this method can take an integer argument (argument to wrapper).
+ * This argument specifies, whether we should be waiting for new messages, if there
+ * is no message, or not. By default, this method waits for messages and in the
+ * end it resubmits itself. If wait for messages is false, and there are no messages
+ * this method returns.
+ *
+ * @param *self - pointer to this task instance
+ * @param *wr - method wrapper used to store the method in the 
+ * method queue
+ * @return result of the last executed method
+ */
+int tcmi_task_process_msg(void *self, struct tcmi_method_wrapper *wr)
+{
+	int res = TCMI_TASK_KEEP_PUMPING;
+	int err;
+	struct tcmi_msg *m; /* message that is being processed */
+	struct tcmi_task *self_tsk = TCMI_TASK(self);
+	int wait_for_messages = 1;
+
+	if ( tcmi_method_wrapper_data(wr) ) {
+		wait_for_messages = *(int*)tcmi_method_wrapper_data(wr);
+	}
+
+	// No msgs and we do not want to wait?
+	if ( !wait_for_messages && tcmi_queue_empty(&self_tsk->msg_queue) )
+		return res;
+
+	if ((err = tcmi_queue_wait_on_empty_interruptible(&self_tsk->msg_queue)) < 0) {
+		mdbg(INFO3, "Signal arrived %d", err);
+		goto exit0;
+	}
+	tcmi_queue_remove_entry(&self_tsk->msg_queue, m, node);
+	/* process the message that has arrived */
+	if (m) {
+		mdbg(INFO3, "Processing message..%x", tcmi_msg_id(m));
+		if (self_tsk->ops->process_msg)
+			res = self_tsk->ops->process_msg(self_tsk, m);
+		/* discard the mesage*/
+		tcmi_msg_put(m);
+	}
+
+ exit0:
+	/* resubmit the process_msg method. */
+	if (res == TCMI_TASK_KEEP_PUMPING) {
+		/* This is to have an extra reference for resubmitting */
+		tcmi_method_wrapper_get(wr);
+		/* resubmit the method. */
+		tcmi_task_add_wrapper(self_tsk, wr);
+	}
+	return res;
+
+}
+
+/**
+ * \<\<public\>\> Called from method queue - Sends a message to peer task.
+ * The method is primarily designed for retransmission of messages in case the original transimision failed due to pending signals.
+ *
+ * @param *self - pointer to this task instance
+ * @param *wr - method wrapper used to store the method in the 
+ * method queue
+ * @return result of the task specific emigrate method or 
+ * TCMI_TASK_KEEP_PUMPING
+ */
+int tcmi_task_send_message(void *self, struct tcmi_method_wrapper *wr)
+{
+  	int res = TCMI_TASK_KEEP_PUMPING;
+	int send_res;
+	struct tcmi_task *self_tsk = TCMI_TASK(self);
+	struct tcmi_msg *resp = *((struct tcmi_msg**)tcmi_method_wrapper_data(wr));
+	
+	//ERESTARTSYS
+	send_res = tcmi_task_send_anonymous_msg(self_tsk, resp);
+	if ( send_res == -ERESTARTSYS ) {
+	  minfo(ERR3, "Signal arrived while sending message, will retransmit later.");
+	  tcmi_msg_get(resp);
+	  tcmi_task_submit_method(self, tcmi_task_send_message, resp, sizeof(struct tcmi_msg));	  
+	} else if ( send_res != 0 ) {
+	  minfo(ERR3, "Sending of message has failed with error: %d. The message will NOT be retransmitted.", send_res);
+	} else {
+	  mdbg(INFO3, "Message send");
+	}
+	
+	tcmi_msg_put( resp );
+	
+	return res;
+}
+
+/** 
+ * \<\<public\>\> Called from method queue - Emigrates a task to a PEN
+ * - PPM w/ physical checkpoint.  All the work is delegated to the
+ * task specific emigrate method.
+ *
+ * @param *self - pointer to this task instance
+ * @param *wr - method wrapper used to store the method in the 
+ * method queue
+ * @return result of the task specific emigrate method or 
+ * TCMI_TASK_KEEP_PUMPING
+ */
+int tcmi_task_emigrate_ppm_p(void *self, struct tcmi_method_wrapper *wr)
+{
+	int res = TCMI_TASK_KEEP_PUMPING;
+	struct tcmi_task *self_tsk = TCMI_TASK(self);
+
+	mdbg(INFO3, "Task - local pid %d, remote pid %d, emigrating",
+	     tcmi_task_local_pid(self_tsk), tcmi_task_remote_pid(self_tsk));
+
+	if (self_tsk->ops->emigrate_ppm_p)
+		res = self_tsk->ops->emigrate_ppm_p(self_tsk);
+	return res;
+}
+
+/** 
+ * \<\<public\>\> Called from method queue - Migrates a task back to
+ * CCN - PPM w/ physical checkpoint.  All the work is delegated to the
+ * task specific emigrate method.
+ *
+ * @param *self - pointer to this task instance
+ * @param *wr - method wrapper used to store the method in the 
+ * method queue
+ * @return result of the task specific migrate back method or 
+ * TCMI_TASK_KEEP_PUMPING
+ */
+int tcmi_task_migrateback_ppm_p(void *self, struct tcmi_method_wrapper *wr)
+{
+	int res = TCMI_TASK_KEEP_PUMPING;
+	struct tcmi_task *self_tsk = TCMI_TASK(self);
+
+	mdbg(INFO3, "Task - local pid %d, remote pid %d, migrating back",
+	     tcmi_task_local_pid(self_tsk), tcmi_task_remote_pid(self_tsk));
+
+	if (self_tsk->ops->migrateback_ppm_p)
+		res = self_tsk->ops->migrateback_ppm_p(self_tsk);
+	return res;
+}
+
+/** 
+ * \<\<public\>\> Called from method queue - Emigrates a task to a PEN
+ * - PPM w/ virtual checkpoint.  All the work is delegated to the task
+ * specific emigrate method.
+ *
+ * @param *self - pointer to this task instance
+ * @param *wr - method wrapper used to store the method in the 
+ * method queue
+ * @return result of the task specific emigrate method or 
+ * TCMI_TASK_KEEP_PUMPING
+ */
+int tcmi_task_emigrate_ppm_v(void *self, struct tcmi_method_wrapper *wr)
+{
+	int res = TCMI_TASK_KEEP_PUMPING;
+	struct tcmi_task *self_tsk = TCMI_TASK(self);
+
+	mdbg(INFO3, "Task - local pid %d, remote pid %d, emigrating",
+	     tcmi_task_local_pid(self_tsk), tcmi_task_remote_pid(self_tsk));
+
+	if (self_tsk->ops->emigrate_ppm_v)
+		res = self_tsk->ops->emigrate_ppm_v(self_tsk);
+	return res;
+}
+
+/** 
+ * \<\<public\>\> Called from method queue - Migrates a task back to
+ * CCN - PPM w/ virtual checkpoint.  All the work is delegated to the
+ * task specific emigrate method.
+ *
+ * @param *self - pointer to this task instance
+ * @param *wr - method wrapper used to store the method in the 
+ * method queue
+ * @return result of the task specific migrate back method or 
+ * TCMI_TASK_KEEP_PUMPING
+ */
+int tcmi_task_migrateback_ppm_v(void *self, struct tcmi_method_wrapper *wr)
+{
+	int res = TCMI_TASK_KEEP_PUMPING;
+	struct tcmi_task *self_tsk = TCMI_TASK(self);
+
+	mdbg(INFO3, "Task - local pid %d, remote pid %d, migrating back",
+	     tcmi_task_local_pid(self_tsk), tcmi_task_remote_pid(self_tsk));
+
+	if (self_tsk->ops->migrateback_ppm_v)
+		res = self_tsk->ops->migrateback_ppm_v(self_tsk);
+	return res;
+}
+
+/** 
+ * \<\<public\>\> Called from method queue - Emigrates a task to a PEN
+ * - NPM.  All the work is delegated to the task specific emigrate
+ * method.
+ *
+ * @param *self - pointer to this task instance
+ * @param *wr - method wrapper used to store the method in the 
+ * method queue
+ * @return result of the task specific emigrate method or 
+ * TCMI_TASK_KEEP_PUMPING
+ */
+int tcmi_task_emigrate_npm(void *self, struct tcmi_method_wrapper *wr)
+{
+	int res = TCMI_TASK_KEEP_PUMPING;
+	struct tcmi_task *self_tsk = TCMI_TASK(self);
+	struct tcmi_npm_params* npm_params = *((struct tcmi_npm_params**)tcmi_method_wrapper_data(wr));
+
+	mdbg(INFO3, "Task - local pid %d, remote pid %d, emigrating",
+	     tcmi_task_local_pid(self_tsk), tcmi_task_remote_pid(self_tsk));
+
+	if (self_tsk->ops->emigrate_npm)
+		res = self_tsk->ops->emigrate_npm(self_tsk, npm_params);
+	return res;
+}
+
+/** 
+ * \<\<public\>\> Called from method queue - Migrates a task back to
+ * CCN - NPM.  work is delegated to the task specific emigrate method.
+ *
+ * @param *self - pointer to this task instance
+ * @param *wr - method wrapper used to store the method in the 
+ * method queue
+ * @return result of the task specific migrate back method or 
+ * TCMI_TASK_KEEP_PUMPING
+ */
+int tcmi_task_migrateback_npm(void *self, struct tcmi_method_wrapper *wr)
+{
+	int res = TCMI_TASK_KEEP_PUMPING;
+	struct tcmi_task *self_tsk = TCMI_TASK(self);
+	struct tcmi_npm_params* npm_params = tcmi_method_wrapper_data(wr);	
+
+	mdbg(INFO3, "Task - local pid %d, remote pid %d, migrating back",
+	     tcmi_task_local_pid(self_tsk), tcmi_task_remote_pid(self_tsk));
+
+	if (self_tsk->ops->migrateback_npm)
+		res = self_tsk->ops->migrateback_npm(self_tsk, npm_params);
+	return res;
+}
+
+/** 
+ * \<\<public\>\> Called from method queue - Exits a task.  This
+ * method is primarily intended terminate the main method processing
+ * loop of the task. The task is then removed from its migration
+ * manager and destroyed. Task specific method has the chance to
+ * communicate this to its counter part. E.g. a guest task sends an
+ * exit code to the associated shadow process on the CCN.
+ *
+ * The method wrapper might contain an exit code. If so, it is communicated
+ * to the specific task method. The default exit code is 0.
+ *
+ * @param *self - pointer to this task instance
+ * @param *wr - method wrapper that stores the requested exit code.
+ * @return result of the task specific exit method or 
+ * TCMI_TASK_REMOVE_AND_LET_ME_GO
+ */
+int tcmi_task_exit(void *self, struct tcmi_method_wrapper *wr)
+{
+	int res = TCMI_TASK_REMOVE_AND_LET_ME_GO;
+	struct tcmi_task *self_tsk = TCMI_TASK(self);
+	long *pcode, code;
+	minfo(INFO3, "Doing exit");
+	/* extract the exit code if any. */
+	pcode = (long*)tcmi_method_wrapper_data(wr);
+	code = (pcode ? *pcode : 0);
+
+	minfo(INFO3, "Executing custom exit method");
+	if (self_tsk->ops->exit)
+		res = self_tsk->ops->exit(self_tsk, code);
+	minfo(INFO3, "Executed custom exit method");
+
+	return res;
+}
+
+
+/**
+ * \<\<private\>\> Class method - copies an array of strings terminated by NULL
+ * string (standard argv/envp format) into the destination
+ * array. Destination array are released and new memory for the
+ * strings is allocated. The idea how the array in the task
+ * will be organized is sketched below.
+ *
+ * @param ***dst - pointer(*) to the destination array(**) (should be
+ * &self->argv or &self->envp
+ * @param **src - source array of strings
+ * @return 0 upon success
+ */
+static inline int tcmi_task_copy_strings(char ***dst, char **src)
+{
+	/* auxiliary storage when computing argv/envp length's */
+	char **tmp_src = src;
+	/* refers to current string being processed */
+	char *src_data;
+	/* used when copying the strings over */ 
+	char **new_src;
+	/* number of elements and total size of all elements in bytes */
+	unsigned int src_len = 0, src_size = 0;
+
+
+	/* calculate the number of elements and total array size, so
+	 * that we can allocate it all at once */
+	for(;*tmp_src != NULL;src_len++, src_size += strlen(*tmp_src) + 1, tmp_src++);
+	/* account for the terminating NULL */
+	src_len++;
+	
+	mdbg(INFO3, "src count %d, src size %d", src_len, src_size);
+
+	if (!(new_src = *dst = (char**)kmalloc((sizeof(char*) * src_len) + src_size, GFP_KERNEL))) {
+		mdbg(ERR3, "Can't allocate memory for src array!!");
+		goto exit0;
+	}
+
+	/* copy the src array over */
+	/* compute the start of the data section for src */
+	src_data = (char*) *dst + (sizeof(char*) * src_len);
+	for (tmp_src = src; *tmp_src != NULL; tmp_src++, new_src++) {
+		mdbg(INFO4, "Copying '%s', length %lu", *tmp_src, (unsigned long)strlen(*tmp_src));
+		strcpy(src_data, *tmp_src);
+		*new_src = src_data;
+		src_data += strlen(*tmp_src) + 1;
+	}
+	*new_src = NULL; /* each array terminated by NULL as required by execve */
+	return 0;
+
+	/* error handling */
+ exit0:
+	return -EINVAL;
+}
+
+/**
+ * \<\<public\>\> Prepares execution of a file given the arrays of arguments and
+ * environment.  Allocates memory for all execve parameters and copies
+ * the parameters into the instance.  The main purpose of this method
+ * is setup everything for execve. After using this method, the caller
+ * is able to release all memory resources and issue
+ * tcmi_task_execve().
+ *
+ * To reduce the overhead when releasing the argv/envp arrays of the task,
+ * the layout of each array is as follows. All strings are put
+ * at the end of the array.
+ *
+ \verbatim
+ +-------------+
+ | pointer  0  |--+
+ +-------------+  |
+ | pointer  1  |--------------------+
+ +-------------+  |                 |
+ .             .  |                 |
+ .             .  |                 |
+ +-------------+  |                 |
+ | pointer  n  |---------------------------------------------+
+ +-------------+  |                 |                        |
+ | NULL        |  |                 |                        |
+ +-------------+--V-----------------V------------------------V----------+
+ | "string 0 goes up here\0", "string 1 here\0", ..., "string n here\0" |
+ +----------------------------------------------------------------------+
+
+ \endverbatim 
+ * This code can be used to printout the argv/envp arrays for testing.
+ \verbatim
+	int i;
+	mdbg(INFO3, "Environ test");
+	for(i = 0; self->argv[i] != NULL; i++)
+		mdbg(INFO3, "ARGV[%d]='%s'", i, self->argv[i]);
+
+	for(i = 0; self->envp[i] != NULL; i++)
+		mdbg(INFO3, "ENVP[%d]='%s'", i, self->envp[i]); 
+
+ \endverbatim
+ *
+ * @param *self - pointer to this task instance
+ * @param *file
+ * @param **argv - arguments list terminated by NULL
+ * @param **envp - environment strings terminated by NULL
+ * @return 0 upon success, otherwise -ENOEXEC
+ */
+int tcmi_task_prepare_execve(struct tcmi_task *self, char *file, char **argv, char **envp)
+{
+	/* release the old context first. */
+	tcmi_task_release_execve_context(self);
+
+	if (!(self->ckpt_pathname = (char*)kmalloc(strlen(file) + 1, GFP_ATOMIC))) {
+		mdbg(ERR3, "Can't allocate memory for execve file '%s'", file);
+		goto exit0;
+	}
+	strcpy(self->ckpt_pathname, file);
+	if (tcmi_task_copy_strings(&self->argv, argv) < 0) {
+		mdbg(ERR3, "Failed copying ARGV array for file '%s'", file);
+		goto exit1;
+	}
+	if (tcmi_task_copy_strings(&self->envp, envp) < 0) {
+		mdbg(ERR3, "Failed copying ENVP array for file '%s'", file);
+		goto exit2;
+	}
+	mdbg(INFO4, "Allocated TCMI task execve context(%s, %p, %p) PID=%d, %p", 
+	     self->ckpt_pathname, self->argv, self->envp, tcmi_task_local_pid(self), self);
+	return 0;
+
+	/* error handling */
+ exit2:
+	kfree(self->argv);
+	self->argv = NULL;
+ exit1:
+	kfree(self->ckpt_pathname);
+	self->ckpt_pathname = NULL;
+ exit0:
+	return -ENOEXEC;
+}
+
+/**
+ * \<\<public\>\> Executes the file that has been previously setup for
+ * execution.  Prior to performing the exec, it is necessary to
+ * discard the method wrapper as the method pump won't resume anymore
+ * in this context. Also the instance specific execve method is
+ * called. This allows a particular TCMI task to get ready for an
+ * upcoming execve.
+ *
+ * @param *self - pointer to this task instance
+ * @param *wr - method wrapper that carried this method in the queue.
+ * @return - doesn't return upon succesful execve, otherwise 
+ * TCMI_TASK_EXECVE_FAILED_KILL_ME to inform the method pump to quit
+ * without discarding the method wrapper as we have already done so.
+ */
+int tcmi_task_execve(void *self, struct tcmi_method_wrapper *wr)
+{
+	int err = 0;
+	mm_segment_t oldfs;
+	struct tcmi_task *self_tsk = TCMI_TASK(self);
+
+memory_sanity_check("Sanity check on execve");
+	
+	mdbg(INFO2, "Performing exec on '%s' Args: %p ([0] -> %p) Envp: %p ([0] -> %p) in atomic=%d", self_tsk->ckpt_pathname, self_tsk->argv, self_tsk->argv[0], self_tsk->envp, self_tsk->envp[0], in_atomic());
+	/* discard the method wrapper prior to doing anything */
+	tcmi_method_wrapper_put(wr);
+	/* instance specific execve notification */
+	if (self_tsk->ops->execve)
+		err = self_tsk->ops->execve(self_tsk);
+	if (err < 0) {
+		mdbg(ERR3, "Task specific execve failed!");
+		goto exit0;
+	}
+	oldfs = get_fs();
+	set_fs(KERNEL_DS);
+
+	//mm_segment_t fs = get_fs();
+memory_sanity_check("Sanity check on execve - just before the call");
+	if ((err = copyof_kernel_execve(self_tsk->ckpt_pathname, self_tsk->argv,
+	/* if ((err = execve(self_tsk->ckpt_pathname, self_tsk->argv, */
+			  self_tsk->envp)) < 0) {
+		minfo(ERR3, "Execve failed!!! %d, errno=%d", err, errno);
+	}
+	set_fs(oldfs);
+
+	mdbg(INFO2, "Exec done!");
+
+	/* error handling */
+ exit0:
+	return TCMI_TASK_EXECVE_FAILED_KILL_ME;
+}
+
+/** @addtogroup tcmi_task_class
+ *
+ * @{
+ */
+/** 
+ * \<\<private\>\> Read method for the TCMI ctlfs - reports remote
+ * PID.  For a shadow process, the remote PID is the identifier of the
+ * guest process on PEN and vica versa.
+ *
+ * @param *obj - pointer to this task instance
+ * @param *data - pointer where the PID is to be stored.
+ * @return 0 upon success
+ */
+static int tcmi_task_show_remote_pid(void *obj, void *data)
+{
+	struct tcmi_task *self = TCMI_TASK(obj);
+	int *remote_pid = (int*) data;
+	
+	*remote_pid = tcmi_task_remote_pid(self);
+
+	return 0;
+}
+
+
+/** 
+ * \<\<private\>\> Releases the execve context (execve file, argv,
+ * envp) Since the argv/envp have allocated a linear chunks of memory
+ * (including all strings) we need to issue only 1 kfree/vfree for
+ * each and don't need to scan the array releasing each string
+ * separate. Releasing is atomic as this method is also used when
+ * preparing a new execve context (tcmi_task_prepare_execve()).
+ *
+ * @param *self - pointer to this task instance
+ */
+static void tcmi_task_release_execve_context(struct tcmi_task *self)
+{
+	char *tmp1, **tmp2;
+	mdbg(INFO4, "Destroying TCMI task execve context(%p, %p, %p) PID=%d, %p", 
+	     self->ckpt_pathname, self->argv, self->envp, tcmi_task_local_pid(self), self);
+	tmp1 = self->ckpt_pathname;
+	self->ckpt_pathname = NULL;
+	kfree(tmp1);
+
+	tmp2 = self->argv;
+	self->argv = NULL;
+	kfree(tmp2);
+
+	
+	tmp2 = self->envp;
+	self->envp = NULL;
+	kfree(tmp2);
+}
+
+/** 
+ * \<\<public\>\> Delivers a specified message.  Asks the message to
+ * deliver itself into a message queue or associate itself with a
+ * matching transaction. The result is communicated back.
+ *
+ * If the message is delivered sucessfully, an enter to the migration mode
+ * is requested.
+ *
+ * @param *self - pointer to this task instance
+ * @param *m - message to be delivered.
+ * @return 0 when the message has been successfully delivered.
+ */
+int tcmi_task_deliver_msg(struct tcmi_task *self, struct tcmi_msg *m)
+{
+	int res = tcmi_msg_deliver(m, &self->msg_queue, self->transactions);
+	if ( res ) {
+		minfo(ERR3, "Failed to deliver the message: errno=%d", res);
+
+		return res;
+	}
+
+	// Request migration mode only for proc messages with enforce migmode flag specified
+	if (TCMI_MSG_GROUP(tcmi_msg_id(m)) == TCMI_MSG_GROUP_PROC && tcmi_procmsg_enforce_migmode(TCMI_PROCMSG(m)) ) {
+		mdbg(INFO4, "Message successfully delivered, requesting migration mode for pid: %d", tcmi_task_local_pid(self));	
+		// TODO: Nasty workaround.. this should likely by in a guest task specific code, since it makes no sense for shadow
+		if ( tcmi_queue_empty(&self->method_queue) ) { 
+			int wait_for_msg = 0;
+			// If there is no method in method queue, there is nothing that would process the message, so we have to submit the processing method into the queue
+			tcmi_task_submit_method(self, tcmi_task_process_msg, &wait_for_msg, sizeof(int));
+		}
+		tcmi_taskhelper_enter_mig_mode(self);
+	}
+
+	return 0;
+}
+
+/**
+ * \<\<public\>\> Accessor of id of the migration manager associated with this task.
+ * 
+ * @param *self - pointer to this task instance
+ * @return migration manager id
+ */
+u_int32_t tcmi_task_migman_id(struct tcmi_task *self)
+{
+	return self->migman ? tcmi_migman_id(self->migman) : -1;
+}
+
+/**
+ * \<\<public\>\> Accessor of vector slot index of the migration manager associated with this task.
+ */
+u_int tcmi_task_migman_slot_index(struct tcmi_task *self) {
+	return self->migman ? tcmi_migman_slot_index(self->migman) : -1;
+}
+
+/**
+ * @}
+ */
--- linux-3.7.1_original/clondike/src/tcmi/task/tcmi_method_wrapper.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/task/tcmi_method_wrapper.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,189 @@
+/**
+ * @file tcmi_method_wrapper.h - artificial class that is used when 
+ *                               submitting object methods
+ * 
+ *
+ *
+ * Date: 04/25/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_method_wrapper.h,v 1.3 2007/10/07 15:54:00 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_METHOD_WRAPPER_H
+#define _TCMI_METHOD_WRAPPER_H
+
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <asm/atomic.h>
+
+#include <dbg.h>
+
+/** @defgroup tcmi_method_wrapper_class tcmi_method_wrapper class 
+ * 
+ * @ingroup tcmi_task_group
+ * 
+ * This artificial class is used for queueing methods to an arbitrary
+ * object. It contains the method to be called and a node to link
+ * the instance into a queue. In addition, there is data stored inside
+ * the wrapper. The wrapper instance itself is passed as the method
+ * argument, so that target object can extract the data.
+ *
+ * @{
+ */
+
+/** Forward declaration */
+struct tcmi_method_wrapper;
+
+/** Describes the method that can be submitted into the method queue. */
+typedef int tcmi_method_t(void*, struct tcmi_method_wrapper*);
+
+/** Compound structure that describes the method. */
+struct tcmi_method_wrapper {
+	/** node to link the wrapper in a queue. */
+	struct list_head node;
+	/** method stored in the wrapper. */
+	tcmi_method_t *method;
+	/** data passed as an argument to the method. */
+	void *data;
+
+	/** Instance reference counter. */
+	atomic_t ref_count;
+};
+
+/**
+ * \<\<public\>\> Creates a new wrapper for the specified method. If
+ * the data argument is non-NULL, it will also allocate space for the
+ * data and copy 'size' bytes over.
+ *
+ * @param method - method that the wrapper holds
+ * @param data - data that is used as method argumet
+ * @param size - size of the data 
+ * @return new method wrapper instance or NULL
+ */
+static inline struct tcmi_method_wrapper* tcmi_method_wrapper_new(tcmi_method_t *method, 
+								  void *data, int size)
+{
+	struct tcmi_method_wrapper *wrapper;
+
+	if (!(wrapper = (struct tcmi_method_wrapper*)kmalloc(sizeof(struct tcmi_method_wrapper), 
+							     GFP_KERNEL))) {
+		mdbg(ERR3, "Can't allocate memory for the wrapper");
+		goto exit0;
+	}
+	INIT_LIST_HEAD(&wrapper->node);
+	wrapper->method = method;
+	wrapper->data = NULL;
+	/* copy the data over if any specified. */
+	if (data && size) {
+		if (!(wrapper->data = vmalloc(size))) {
+			mdbg(ERR3, "Can't allocate memory for the wrapper data");
+			goto exit1;
+		}
+		memcpy(wrapper->data, data, size);
+	}
+	atomic_set(&wrapper->ref_count, 1);
+
+	mdbg(INFO4, "Created method wrapper %p", wrapper);
+	return wrapper;
+
+	/* error handling */
+ exit1:
+	kfree(wrapper);
+ exit0:
+	return NULL;
+}
+
+/** 
+ * \<\<public\>\> Method wrapper accessor. Increments the reference
+ * counter
+ * 
+ * @param *self - pointer to this method wrapper instance
+ * @return - self
+ */
+static inline struct tcmi_method_wrapper* tcmi_method_wrapper_get(struct tcmi_method_wrapper *self)
+{
+	if (!self)
+		return NULL;
+	atomic_inc(&self->ref_count);
+	return self;
+}
+
+/**
+ * \<\<public\>\> Decrements the reference counter, when the count
+ * reaches 0, the instance is destroyed.
+ *
+ * @param *self - pointer to this method wrapper instance
+ */
+static inline void tcmi_method_wrapper_put(struct tcmi_method_wrapper *self)
+{
+	if (!self)
+		return;
+
+	if (atomic_dec_and_test(&self->ref_count)) {
+		list_del_init(&self->node);
+		mdbg(INFO4, "Destroying method wrapper %p", self);
+		vfree(self->data);
+		kfree(self);
+	}
+
+}
+
+/**
+ * \<\<public\>\> Calls the method that resides in the wrapper. The
+ * target object is specified as the parameter
+ *
+ * @param *self - pointer to this method wrapper instance
+ * @param *obj - object whose method is to be called
+ * @return status of the called method
+ */
+static inline int tcmi_method_wrapper_call(struct tcmi_method_wrapper *self, void *obj)
+{
+	int ret = 0;
+
+	if (self && self->method) {
+		ret = self->method(obj, self);
+	}
+	return ret;
+
+}
+
+/**
+ * \<\<public\>\> Accessor for the data stored in the method wrapper.
+ *
+ * @param *self - pointer to this method wrapper instance
+ * @return pointer to the data
+ */
+static inline void* tcmi_method_wrapper_data(struct tcmi_method_wrapper *self)
+{
+	return self->data;
+}
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_METHOD_WRAPPER_PRIVATE
+#endif /* TCMI_METHOD_WRAPPER_PRIVATE */
+
+
+/**
+ * @}
+ */
+
+
+#endif /* _TCMI_METHOD_WRAPPER_H */
--- linux-3.7.1_original/clondike/src/tcmi/task/tcmi_guesttask.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/task/tcmi_guesttask.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,438 @@
+/**
+ * @file tcmi_guesttask.c - TCMI guesttask, migrated process abstraction on PEN
+ *                      
+ * 
+ *
+ *
+ * Date: 04/26/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_guesttask.c,v 1.13 2009-04-06 21:48:46 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <tcmi/comm/tcmi_messages_dsc.h>
+#include <tcmi/migration/tcmi_migcom.h>
+#include <tcmi/manager/tcmi_migman.h>
+
+#include "tcmi_taskhelper.h"
+
+#define TCMI_GUESTTASK_PRIVATE
+#include "tcmi_guesttask.h"
+
+#include <proxyfs/proxyfs_helper.h>
+
+#include <director/director.h>
+
+/** 
+ * \<\<public\>\> Instance constructor.
+ * - allocates a new instance.
+ * - delegates its initialization to the super class.
+ *
+ * @param local_pid - local PID on PEN
+ * @param migman - The migration manager that maintains this task
+ * @param *sock - socket used for communication with shadow task on CCN
+ * @param *d_migproc - directory where ctlfs entries of migrated
+ * processes reside
+ * @param *d_migman - TCMI ctlfs directory of the migration manager
+ * responsible for this task
+ * @return 0 upon success
+ */
+struct tcmi_task* tcmi_guesttask_new(pid_t local_pid, struct tcmi_migman* migman,
+				    struct kkc_sock *sock, 
+				    struct tcmi_ctlfs_entry *d_migproc, 
+				    struct tcmi_ctlfs_entry *d_migman)
+{
+	struct tcmi_guesttask *task;
+	minfo(INFO2, "Creating new TCMI guest task");
+	if (!(task = TCMI_GUESTTASK(kmalloc(sizeof(struct tcmi_guesttask), 
+						   GFP_ATOMIC)))) {
+		mdbg(ERR3, "Can't allocate memory for TCMI ppm guest task");
+		goto exit0;
+	}
+	if (tcmi_task_init(TCMI_TASK(task), local_pid, migman, sock, 
+			   d_migproc, d_migman, &guesttask_ops) < 0) {
+		mdbg(ERR3, "TCMI ppm guest task initialization failed!");
+		goto exit1;
+	}
+
+	return TCMI_TASK(task);
+
+	/* error handling */
+ exit1:
+	kfree(task);
+ exit0:
+	return NULL;
+}
+
+/** @addtogroup tcmi_guesttask_class
+ *
+ * @{
+ */
+
+/** 
+ * \<\<private\>\> Processes a message specified by the caller.
+ * It handles:
+ * - physical emigration request - this is special - as the guest
+ * should turn eventually into a migrated process.
+ *
+ *
+ * @param *self - pointer to this task instance
+ * @param *m - message to be processed
+ * @return depends on the type of message that has been processed
+ */
+static int tcmi_guesttask_process_msg(struct tcmi_task *self, struct tcmi_msg *m)
+{
+	int res = TCMI_TASK_KEEP_PUMPING;
+	/* struct tcmi_guesttask *self_tsk = TCMI_GUESTTASK(self); */
+
+memory_sanity_check("On process message");
+
+	switch (tcmi_msg_id(m)) {
+		/* task PPM phys. migration request */
+	case TCMI_P_EMIGRATE_MSG_ID:
+		res = tcmi_guesttask_process_p_emigrate_msg(self, m);
+		break;
+	case TCMI_PPM_P_MIGR_BACK_SHADOWREQ_PROCMSG_ID:
+		/* dispose the message not needed anymore. */
+		tcmi_msg_put(m);
+		/* Is there some better way to invoke self migration home? If we call directly migrate back of this task the method queue won't be flushed as in the case of this call. */
+		tcmi_migcom_migrate_home_ppm_p(tcmi_task_local_pid(self));
+		break;
+	default:
+		mdbg(ERR3, "Unexpected message from the guest task: %x", tcmi_msg_id(m));
+		break;
+	}
+
+memory_sanity_check("After process message");
+
+	return res;
+}
+
+/** 
+ * \<\<private\>\> Emigrates a task to a PEN.
+ *
+ * @param *self - pointer to this task instance
+ * @return result of the task specific emigrate method or 
+ * TCMI_TASK_KEEP_PUMPING
+ */
+static int tcmi_guesttask_emigrate_p(struct tcmi_task *self)
+{
+	int res = TCMI_TASK_KEEP_PUMPING;
+/*	struct tcmi_guesttask *self_tsk = TCMI_GUESTTASK(self);*/
+
+	return res;
+}
+
+/**
+ * Internal helper method for performing both npm/ppm physical migration back to ccn.
+ *
+ * @return 0 on success, error code otherwise
+ */
+static int tcmi_guesttask_migrateback_p(struct tcmi_task* self, struct tcmi_npm_params* npm_params) {
+	struct tcmi_msg *req;
+
+	mdbg(INFO2, "Process '%s' - guest local PID %d, migrating back (npm params: %p)", current->comm, tcmi_task_local_pid(self), npm_params);
+
+	if (tcmi_taskhelper_checkpoint(self, npm_params) < 0) {
+		mdbg(ERR3, "Failed to create a checkpoint");
+		goto exit0;
+	}
+	tcmi_taskhelper_flushfiles();
+	if (!(req = tcmi_ppm_p_migr_back_guestreq_procmsg_new_tx(tcmi_task_remote_pid(self), tcmi_task_ckpt_name(self)))) {
+		mdbg(ERR3, "Error creating a migration back message");
+		goto exit0;
+	}
+	if (tcmi_task_check_peer_lost(self, tcmi_task_send_anonymous_msg(self, req)) < 0) {
+		mdbg(ERR3, "Failed to send message!!");
+		goto exit1;
+	}
+
+	director_migrated_home(tcmi_task_local_pid(self));
+	
+	return 0;
+ exit1:
+	tcmi_msg_put(req);
+ exit0:
+	return -EFAULT;
+}
+
+/** 
+ * \<\<private\>\> Migrates a task back to CCN using PPM with physical
+ * checkpoint image. This requires:
+ * - creating a new checkpoint of the current process (task helper job)
+ * - flush open files of the current process (prevents write conflicts
+ * after checkpoint restart)
+ * - communicating the checkpoint name to the shadow
+ * - terminating (via KILL_ME status)
+ *
+ * There are two modes how the migration back can be initiated:
+ * -# PEN decides to migrate the task back - in that case, the
+ * migration back message is sent as a request (trans_id is set
+ * to invalid)
+ * -# CCN decides to migrate the task back - the migration back
+ * message is sent back as a response and as such is associated with a
+ * transaction.
+ * This method handles the first case.
+ * @TODO: The second method is also handled here, but not exactly as described.. CCN send asynchronous request to migrate back and
+ * then the guest initiates the processing of migration back.. we should likely rework it on transactional case described above
+ *
+ * @param *self - pointer to this task instance
+ * @return TCMI_KILL_ME in either case (should it fail or not) as we want
+ * the task away from the PEN.
+ */
+static int tcmi_guesttask_migrateback_ppm_p(struct tcmi_task *self)
+{
+	tcmi_guesttask_migrateback_p(self, NULL);
+	// Migration back was requested so we kill in either case
+	return TCMI_TASK_KILL_ME;
+}
+
+/**
+ * Handles non-preemptive migration back of guest tasks
+ */
+int tcmi_guesttask_migrateback_npm(struct tcmi_task *self, struct tcmi_npm_params* npm_params)
+{
+	int res = tcmi_guesttask_migrateback_p(self, npm_params);
+
+	if ( res ) {
+		// npm migration has failed => continue with execution locally (we may try pre-emptive migration later and if that fails we kill the task)
+		return TCMI_TASK_REMOVE_AND_LET_ME_GO;
+	}
+
+	// migration home succeeded => remove and kill guest task
+	return TCMI_TASK_KILL_ME;
+}
+
+
+/** 
+ * \<\<private\>\> Exit notification for the shadow on CCN.  This
+ * method is scheduled by the exit system call hook that also invokes
+ * the migration mode handler. It sends an exit process control
+ * message to the shadow. No response is expected, the message content
+ * is the exit code. The method terminates with
+ * TCMI_TASK_REMOVE_AND_LET_ME_GO - explained below
+ *
+ * @return TCMI_TASK_REMOVE_AND_LET_ME_GO, so that the migration component
+ * destroys this task. It doesn't itentionally return TCMI_TASK_KILL_ME
+ * as it would cause another round of exit, this time using complete_and_exit()
+ */
+static int tcmi_guesttask_exit(struct tcmi_task *self, long code)
+{
+	struct tcmi_msg *m;
+	
+	/** Sync proxyfs files only if peer is alive, else this call makes no sense */
+	if ( !self->peer_lost )
+	    proxyfs_sync_files_on_exit();
+
+	mdbg(INFO2, "Stub process '%s' local PID=%d terminating", 
+	      current->comm, current->pid);
+	if (!(m = tcmi_exit_procmsg_new_tx(tcmi_task_remote_pid(self), code))) {
+		mdbg(ERR3, "Can't create error message");
+		goto exit0;
+	}
+	/* send it as anonymous since no response is expected. */
+	tcmi_task_send_anonymous_msg(self, m);
+	/* dispose the message not needed anymore. */
+	tcmi_msg_put(m);
+ exit0:
+	return TCMI_TASK_REMOVE_AND_LET_ME_GO;
+}
+
+/**
+ * \<\<private\>\> Processes a specified signal.  Currently only
+ * SIGKILL signal is handled that causes the task to terminate
+ * returned status for the method pump - TCMI_TASK_KILL_ME.  Final
+ * solution should do a full signal handling and communicate with the
+ * shadow too.
+ *
+ * @param *self - pointer to this task instance 
+ * @param signr - signal that is to be processed
+ * @param *info - info for signal to be processed
+ *
+ * @return TCMI_TASK_KEEP_PUMPING on any signal but SIGKILL
+ */
+static int tcmi_guesttask_do_signal(struct tcmi_task *self, unsigned long signr, siginfo_t *info)
+{
+	int res = TCMI_TASK_KEEP_PUMPING;
+
+	mdbg(INFO2, "Stub is processing signal %lu", signr);
+	if (signr == SIGKILL || signr == SIGQUIT || signr == SIGINT) {
+		tcmi_task_set_exit_code(self, signr);
+		// We have to return keep pumping, because following do_exit call will invoke exit hook and it should be handled by the method pump!
+		res = TCMI_TASK_KEEP_PUMPING;
+	}
+
+	return res;
+}
+
+
+/**
+ * \<\<private\>\> Processes the physical emigrate process message (both NPM and PPM)
+ *
+ * The remote PID is extracted from the emigration message and stored
+ * in the guest task. The checkpoint name is also extracted and passed
+ * to the task helper to schedule a restart. This also sets the
+ * checkpoint image as the most recent checkpoint of the task.
+ *
+ * A response is sent back that will contain the guest task local
+ * PID. This PID is needed for further communication between the
+ * shadow and guest tasks.
+ *
+ * The restart is only scheduled and will be processed upon next
+ * iteration of the method pump. 
+ *
+ * @param *self - this guest task instance
+ * @param *m - Physical emigration message that will be proceseed
+ * @return TCMI_TASK_KEEP_PUMPING if the restart has been successfully
+ * scheduled
+ */
+static int tcmi_guesttask_process_p_emigrate_msg(struct tcmi_task *self, 
+						    struct tcmi_msg *m)
+{
+	struct tcmi_msg *resp;
+	pid_t remote_pid;
+	char *ckpt_name;
+
+	/* extract the remote PID */
+	remote_pid = tcmi_p_emigrate_msg_reply_pid(TCMI_P_EMIGRATE_MSG(m));
+	tcmi_task_set_remote_pid(self, remote_pid);
+	/* extract the checkpoint name */
+	ckpt_name =  tcmi_p_emigrate_msg_ckpt_name(TCMI_P_EMIGRATE_MSG(m));
+		
+	mdbg(INFO2, "Processing emigration request, remote PID=%d, checkpoint: '%s'", tcmi_task_remote_pid(self), ckpt_name);
+
+memory_sanity_check("On processing");
+
+	/* schedules process restart from a checkpoint image */
+	if (tcmi_taskhelper_restart(self, ckpt_name) < 0) {
+		/* report a problem */
+		if (!(resp = tcmi_err_procmsg_new_tx(TCMI_GUEST_STARTED_PROCMSG_ID, 
+						     tcmi_msg_req_id(m), -ENOEXEC,
+						     tcmi_task_remote_pid(self)))) {
+						    
+			mdbg(ERR3, "Cannot create a guest error response!!");
+			goto exit0;
+		} 
+		memory_sanity_check("After restart");
+	}	
+	/* restart successfully scheduled, respond with our local PID */
+	else {
+		if (!(resp = tcmi_guest_started_procmsg_new_tx(tcmi_msg_req_id(m), 
+							      tcmi_task_remote_pid(self), 
+							      tcmi_task_local_pid(self)))) {
+			mdbg(ERR3, "Cannot create a guest response!!");
+			goto exit0;
+		}
+		memory_sanity_check("After restart 2");
+	}
+	/* preliminary announce - the guest has been started (execve still might fail) */
+	tcmi_task_check_peer_lost(self, tcmi_task_send_anonymous_msg(self, resp));
+	tcmi_msg_put(resp);
+	
+	
+	return TCMI_TASK_KEEP_PUMPING;
+		
+	/* error handling */
+ exit0:
+	return TCMI_TASK_KILL_ME;
+}
+
+int tcmi_guesttask_post_fork(struct tcmi_task* self, struct tcmi_task* child, long fork_result, pid_t remote_child_pid) {
+	struct tcmi_msg *m;
+
+	if ( fork_result < 0 ) {
+		// Notify CCN about fork-failed
+		// We're reusing exit msg here, but it may be better to introduce a specific event for this, right?
+		if (!(m = tcmi_exit_procmsg_new_tx(remote_child_pid, fork_result))) {
+			mdbg(ERR3, "Can't create failed-fork exit message");
+			goto exit0;
+		}
+	} else {
+		BUG_ON(child == NULL); // If fork succeeded, child cannot be null, right?
+
+		tcmi_task_set_remote_pid(child, remote_child_pid);		
+
+		if (!(m = tcmi_guest_started_procmsg_new_tx(TCMI_TRANSACTION_INVAL_ID, 
+							      tcmi_task_remote_pid(child), 
+							      tcmi_task_local_pid(child)))) {
+			mdbg(ERR3, "Cannot create a guest response in post-fork!");
+			goto exit0;
+		}		
+	}
+
+	tcmi_task_send_anonymous_msg(self, m);
+	tcmi_msg_put(m);
+
+	return 0;
+
+exit0:
+	// TODO: Some better failure handling? Shall we stop this task, if we've failed to inform CCN that it is running? CCN does not know it's ID in this case...
+	return -EINVAL;
+}
+
+/** \<\<public\>\> Used to set proper tid after a new process was forked.. it must be run in that process context */
+int tcmi_guesttask_post_fork_set_tid(void *self, struct tcmi_method_wrapper *wr) {
+	int res = TCMI_TASK_KEEP_PUMPING;
+	struct tcmi_task *self_tsk = TCMI_TASK(self);
+
+	mdbg(INFO3, "Task - remote pid %d being set after fork",
+	     tcmi_task_remote_pid(self_tsk));
+
+        if (current->set_child_tid) {
+		mdbg(INFO3, "Tid set required");	     	
+                put_user(tcmi_task_remote_pid(self_tsk), current->set_child_tid);
+	}
+
+	if ( thread_group_leader(current) ) { // Proxyfs file names changing is required only for group leaders
+		// TODO: Make a separate method for this, it does not belong here
+		// Modifies proxyfs file references to references specific to this task
+		if ( proxyfs_clone_file_names(tcmi_task_remote_pid(self_tsk)) ) {
+			mdbg(INFO3, "Task proxy fs clonning has failed. Pid %d", tcmi_task_remote_pid(self_tsk));
+			// We cannot simply return KILL_ME here.. this would remove current TCMI task and kill the process,
+			// but the exit hook won't be called!
+			force_sig(SIGKILL, current);
+		}
+	}
+
+	return res;
+}
+
+
+/** Return type of task. Only for setting task type to kernel task_struct. Polymorphism 
+ * cannot be used in kernel, bacause tcmi_task is defined outside of kernel. */
+static enum tcmi_task_type tcmi_guesttask_get_type(void){
+	return guest;
+}
+
+/** TCMI task operations that support polymorphism */
+static struct tcmi_task_ops guesttask_ops = {
+	.process_msg = tcmi_guesttask_process_msg,
+	.emigrate_ppm_p = tcmi_guesttask_emigrate_p,	
+	.migrateback_ppm_p = tcmi_guesttask_migrateback_ppm_p,
+	.migrateback_npm = tcmi_guesttask_migrateback_npm,
+	.exit = tcmi_guesttask_exit,
+	.get_type = tcmi_guesttask_get_type,
+	.do_signal = tcmi_guesttask_do_signal
+};
+
+/**
+ * @}
+ */
--- linux-3.7.1_original/clondike/src/tcmi/task/tcmi_guesttask.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/task/tcmi_guesttask.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,116 @@
+/**
+ * @file tcmi_guesttask.h - TCMI guesttask, migrated process abstraction on PEN
+ *                      
+ * 
+ *
+ *
+ * Date: 04/26/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_guesttask.h,v 1.6 2007/10/20 14:24:20 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_GUESTTASK_H
+#define _TCMI_GUESTTASK_H
+
+#include "tcmi_task.h"
+
+/** @defgroup tcmi_guesttask_class tcmi_guesttask class 
+ * 
+ * @ingroup tcmi_task_class
+ * 
+ * This class is an abstraction for an 'immigrated' process on PEN. It
+ * represents the migrated process, so that the TCMI framework is able
+ * to control it.
+ *
+ * This class also does all the migration work including migration back
+ * to CCN. For this purpose, there are various methods that implement 
+ * various types of migration:
+ * - preemptive migration using physical checkpoint image
+ * (tcmi_guesttask_*_ppm_p())
+ * - preemptive migration using virtual checkpoint image
+ * (tcmi_guesttask_*_ppm_v())
+ * - non-preemptive migration via execve hook
+ * (tcmi_guesttask_*_npm())
+ *
+ * @{
+ */
+
+/** Compound structure for the shadow task. */
+struct tcmi_guesttask {
+	/** parent class instance. */
+	struct tcmi_task super;
+
+};
+
+
+/** Casts to the task instance. */
+#define TCMI_GUESTTASK(t) ((struct tcmi_guesttask*)t)
+
+/** \<\<public\>\> Creates a new guest task. */
+extern struct tcmi_task* tcmi_guesttask_new(pid_t local_pid, struct tcmi_migman* migman,
+					   struct kkc_sock *sock, 
+					   struct tcmi_ctlfs_entry *d_migproc, 
+					   struct tcmi_ctlfs_entry *d_migman);
+
+
+/** \<\<public\>\> Called on post-fork hook on guest task that was forked (parent) */
+extern int tcmi_guesttask_post_fork(struct tcmi_task* self, struct tcmi_task* child, long fork_result, pid_t remote_child_pid);
+
+
+/** \<\<public\>\> Used to set proper tid after a new process was forked.. it must be run in that process context */
+extern int tcmi_guesttask_post_fork_set_tid(void *self, struct tcmi_method_wrapper *wr);
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_GUESTTASK_PRIVATE
+
+/** Processes a message. */
+static int tcmi_guesttask_process_msg(struct tcmi_task *self, struct tcmi_msg *m);
+
+/** Emigrates a task to a PEN - PPM w/ physical ckpt image. */
+//static int tcmi_guesttask_emigrate_ppm_p(struct tcmi_task *self);
+
+/** Migrates a task back to CCN - PPM w/ physical ckpt image. */
+static int tcmi_guesttask_migrateback_ppm_p(struct tcmi_task *self);
+
+/** Exit notification for the shadow on CCN. */
+static int tcmi_guesttask_exit(struct tcmi_task *self, long code);
+
+/** Handles a specified signal. */
+static int tcmi_guesttask_do_signal(struct tcmi_task *self, unsigned long signr, siginfo_t *info);
+
+/** Processes a PPM_P migration request. */
+static int tcmi_guesttask_process_p_emigrate_msg(struct tcmi_task *self, 
+						    struct tcmi_msg *m);
+/** Return a task type. */
+static enum tcmi_task_type tcmi_guesttask_get_type(void);
+
+/** TCMI task operations that support polymorphism */
+static struct tcmi_task_ops guesttask_ops;
+
+#endif /* TCMI_GUESTTASK_PRIVATE */
+
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_GUESTTASK_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_ppm_p_emigrate_msg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_ppm_p_emigrate_msg.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,251 @@
+/**
+ * @file tcmi_ppm_p_emigrate_msg.c - PPM_P emigration message.
+ *       
+ *                      
+ * 
+ *
+ *
+ * Date: 04/27/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_ppm_p_emigrate_msg.c,v 1.2 2007/07/02 02:26:17 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include <linux/slab.h>
+#include <linux/string.h>
+
+#include "tcmi_transaction.h"
+
+#include "tcmi_skelresp_msg.h"
+#define TCMI_PPM_P_EMIGRATE_MSG_PRIVATE
+#include "tcmi_ppm_p_emigrate_msg.h"
+
+
+#include <dbg.h>
+
+
+
+/** 
+ * \<\<public\>\> PPM_P message rx constructor.
+ * This method is called by the factory class.
+ *
+ * @param msg_id - message ID that will be used for this error message
+ * instance.
+ * @return a new error message or NULL.
+ */
+struct tcmi_msg* tcmi_ppm_p_emigrate_msg_new_rx(u_int32_t msg_id)
+{
+	struct tcmi_ppm_p_emigrate_msg *msg;
+
+	/* Check if the factory is building what it really thinks. */
+	if (msg_id != TCMI_PPM_P_EMIGRATE_MSG_ID) {
+		mdbg(ERR3, "Factory specified message ID(%x) doesn't match real ID(%x)",
+		     msg_id, TCMI_PPM_P_EMIGRATE_MSG_ID);
+		goto exit0;
+	}
+	/* Allocate the instance */
+	if (!(msg = TCMI_PPM_P_EMIGRATE_MSG(kmalloc(sizeof(struct tcmi_ppm_p_emigrate_msg), GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate test request message");
+		goto exit0;
+	}
+	/* Initialized the message for receiving. */
+	if (tcmi_msg_init_rx(TCMI_MSG(msg), TCMI_PPM_P_EMIGRATE_MSG_ID, &ppm_p_emigrate_msg_ops)) {
+		mdbg(ERR3, "Error initializing test request message %x", msg_id);
+		goto exit1;
+	}
+
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+}
+
+/** 
+ * \<\<public\>\> PPM_P emigration message tx constructor.
+ *
+ * An emigration message expects a response that will be delivered back
+ * to the originating task (usually a shadow process on CCN). Therefore,
+ * there has to be a transaction associated with it.
+ *
+ * Response message ID is TCMI_GUEST_STARTED_PROCMSG_ID.
+ *
+ *
+ * @param *transactions - storage for the new transaction
+ *
+ * @param reply_pid - denotes the pid that the reply to this message
+ * should be directed to. It is a key information for the receiving
+ * party in order to compose a valid response
+ * @param ckpt_name - checkpoint pathname - this has to be a valid location
+ * in the network filesystem, so that the receiving party can restart the process
+ * @return a new error ready for the transfer or NULL.
+ */
+struct tcmi_msg* tcmi_ppm_p_emigrate_msg_new_tx(struct tcmi_slotvec *transactions, 
+						pid_t reply_pid, char *ckpt_name)
+{
+	struct tcmi_ppm_p_emigrate_msg *msg;
+
+	if (!(msg = TCMI_PPM_P_EMIGRATE_MSG(kmalloc(sizeof(struct tcmi_ppm_p_emigrate_msg), GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate test request message");
+		goto exit0;
+	}
+	msg->pid_and_size.reply_pid = reply_pid;
+	msg->pid_and_size.size = strlen(ckpt_name) + 1;
+
+	if (!(msg->ckpt_name = (char*)kmalloc(msg->pid_and_size.size, GFP_KERNEL))) {
+		mdbg(ERR3, "Can't allocate memory for checkpoint name");
+		goto exit1;
+	}
+	strcpy(msg->ckpt_name, ckpt_name);
+	/* Initialize the message for transfer */
+	if (tcmi_msg_init_tx(TCMI_MSG(msg), TCMI_PPM_P_EMIGRATE_MSG_ID, &ppm_p_emigrate_msg_ops, 
+			     transactions, TCMI_GUEST_STARTED_PROCMSG_ID,
+			     TCMI_PPM_P_EMIGRATE_MSGTIMEOUT, TCMI_TRANSACTION_INVAL_ID)) {
+		mdbg(ERR3, "Error initializing test request message message");
+		goto exit2;
+	}
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit2:
+	kfree(msg->ckpt_name);
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+	
+}
+
+
+/** @addtogroup tcmi_ppm_p_emigrate_msg_class
+ *
+ * @{
+ */
+
+/**
+ * \<\<private\>\> Receives the message via a specified connection.
+ * Receiving the message requires reading the remote PID and
+ * checkpoint size.  Based on the size, allocate space for the
+ * checkpoint name string and read it to from the specified connection
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for receiving message data
+ * @return 0 when successfully received.
+ */
+static int tcmi_ppm_p_emigrate_msg_recv(struct tcmi_msg *self, struct kkc_sock *sock)
+{
+	int err = -EINVAL;
+	struct tcmi_ppm_p_emigrate_msg *self_msg = TCMI_PPM_P_EMIGRATE_MSG(self);
+	
+	/* Receive the remote PID and checkpoint name size */	
+	if ((err = kkc_sock_recv(sock, &self_msg->pid_and_size, 
+				 sizeof(self_msg->pid_and_size), KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to receive pid and size");
+		goto exit0;
+	}
+
+
+	if (!(self_msg->ckpt_name = (char*)kmalloc(self_msg->pid_and_size.size, GFP_KERNEL))) {
+		mdbg(ERR3, "Can't allocate memory for checkpoint name");
+		goto exit0;
+	}
+	
+	/* Receive the checkpoint name */	
+	if ((err = kkc_sock_recv(sock, self_msg->ckpt_name, 
+				 self_msg->pid_and_size.size, KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to receive checkpoint name");
+		goto exit0;
+	}
+	mdbg(INFO2, "PPM emigrate message received PID=%d, size=%d, ckptname='%s'",
+	     self_msg->pid_and_size.reply_pid, self_msg->pid_and_size.size, self_msg->ckpt_name);
+
+	return 0;
+	/* error handling*/
+ exit0:
+	return err;
+}
+
+/**
+ * \<\<private\>\> Sends the PPM_P emigration message
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for sending message data
+ * @return 0 when successfully sent.
+ */
+static int tcmi_ppm_p_emigrate_msg_send(struct tcmi_msg *self, struct kkc_sock *sock)
+{
+	int err;
+	struct tcmi_ppm_p_emigrate_msg *self_msg = TCMI_PPM_P_EMIGRATE_MSG(self);
+
+	
+	/* Receive the remote PID and checkpoint name size */	
+	if ((err = kkc_sock_send(sock, &self_msg->pid_and_size, 
+				 sizeof(self_msg->pid_and_size), KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to send pid and size");
+		goto exit0;
+	}
+
+	/* Receive the checkpoint name */	
+	if ((err = kkc_sock_send(sock, self_msg->ckpt_name, 
+				 self_msg->pid_and_size.size, KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to send checkpoint name");
+		goto exit0;
+	}
+
+	mdbg(INFO2, "PPM emigrate message sent PID=%d, size=%d, ckptname='%s'",
+	     self_msg->pid_and_size.reply_pid, self_msg->pid_and_size.size, self_msg->ckpt_name);
+
+	return 0;
+	/* error handling */
+ exit0:
+	return err;
+	
+}
+
+/**
+ * \<\<private\>\> Frees custom message resources.
+ * The checkpoint image name string is released from memory.
+ *
+ * @param *self - this message instance
+ */
+static void tcmi_ppm_p_emigrate_msg_free(struct tcmi_msg *self)
+{
+	struct tcmi_ppm_p_emigrate_msg *self_msg = TCMI_PPM_P_EMIGRATE_MSG(self);
+
+	mdbg(INFO3, "Freeing PPM emigrate message PID=%d, size=%d, ckptname='%s'",
+	     self_msg->pid_and_size.reply_pid, self_msg->pid_and_size.size, self_msg->ckpt_name);
+	kfree(self_msg->ckpt_name);
+}
+
+
+/** Message operations that support polymorphism. */
+static struct tcmi_msg_ops ppm_p_emigrate_msg_ops = {
+	.recv = tcmi_ppm_p_emigrate_msg_recv,
+	.send = tcmi_ppm_p_emigrate_msg_send,
+	.free = tcmi_ppm_p_emigrate_msg_free
+};
+
+
+/**
+ * @}
+ */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_transaction.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_transaction.c	2013-03-12 01:13:09.000000000 +0100
@@ -0,0 +1,402 @@
+/**
+ * @file tcmi_transaction.c - TCMI communication transaction.
+ *       
+ *                      
+ * 
+ *
+ *
+ * Date: 04/10/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_transaction.c,v 1.2 2007/07/02 02:26:17 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <linux/types.h>
+#include <linux/random.h>
+#include <linux/jiffies.h>
+#include <linux/slab.h>
+
+#define TCMI_TRANSACTION_PRIVATE
+#include "tcmi_transaction.h"
+
+
+#include <dbg.h>
+
+/** 
+ * \<\<public\>\> Creates a new transaction.
+ * Instance is created as follows:
+ * - allocate the instance
+ * - generate a transaction ID (random number)
+ * - initilialize wait queue for process(es) that is/are to be woken 
+ * up when:
+ *         - the transaction times out or
+ *         - when it is sucessfully completed
+ * - store timeout that will be activated when the transaction is
+ * started.
+ * - store the transaction in the transaction slot vector specified by
+ * the user
+ * - setup reference counter
+ * - clear transaction flags - the transaction owner will adjust the
+ * flags afterwards
+ * - one instance reference is for the timer and one instance
+ * reference is returned to the instantiator
+ *
+ * @param *transactions - storage for the transactions
+ * @param resp_id - response message ID - required for the transaction so that match
+ * the response upon completion.
+ * @param timeout - transaction time out
+ * @return new transaction or NULL
+ */
+struct tcmi_transaction* tcmi_transaction_new(struct tcmi_slotvec *transactions, 
+					      u_int32_t resp_id,
+					      unsigned long timeout)
+{
+	struct tcmi_transaction *trans;
+	/* hash of the transaction ID */
+	u_int hash;
+
+	if (!(trans = kmalloc(sizeof(struct tcmi_transaction), GFP_KERNEL))) {
+		mdbg(ERR3, "Can't allocate memory for a transaction");
+		goto exit0;
+	}
+	tcmi_transaction_gen_id(trans);
+	hash = tcmi_transaction_hash(trans->id, tcmi_slotvec_hashmask(transactions));
+
+	trans->resp_id = resp_id;
+	trans->state = TCMI_TRANSACTION_INIT;
+	trans->transactions = transactions;
+	init_waitqueue_head(&trans->wq);
+
+	/* setup the timer that handles transaction timeout */
+	init_timer(&trans->timer);
+	/* the expiration has to be added the current value of jiffies
+	 * when the timer is started, but this is upon transaction start */
+	trans->timer.expires = timeout; 
+	trans->timer.data = (unsigned long) trans;
+	trans->timer.function = tcmi_transaction_timer;
+	/* context will be filled in upon response arrival */
+	trans->context = NULL;
+	/* one reference goes the the transaction instantiator */
+	atomic_set(&trans->ref_count, 1);
+	atomic_set(&trans->flags, 0);
+	spin_lock_init(&trans->t_lock);
+
+	/* now, the transaction is ready to be inserted into the slot vector */
+	if (!(trans->slot = tcmi_slotvec_insert_at(transactions, hash, &trans->node))) {
+		minfo(ERR3, "Can't insert transaction into slot vector!");
+		goto exit1;
+	}
+	mdbg(INFO4, "Allocated transaction ID=%x, memory=%p", 
+	     tcmi_transaction_id(trans), trans);
+
+	return trans;
+
+	/* error handling */
+ exit1:
+	kfree(trans);
+ exit0:
+	return NULL;
+}
+
+
+/** 
+ * \<\<public\>\> Starts a transaction.  The transaction is started
+ * only if it is in INIT state.  The timer is started, so that a
+ * timeout can be handled automatically. The timer is assigned an extra
+ * reference for the transaction to prevent destruction of the transaction
+ * before the timer goes off in case of timeout.
+ *
+ * @param *self - this transaction instance
+ * @param flags - flags to be set on the running transaction
+ * @return 0 upon successful start of the transaction 
+ */
+int tcmi_transaction_start(struct tcmi_transaction *self, int flags)
+{
+	int err = 0;
+	tcmi_transaction_lock(self);
+	if (self->state != TCMI_TRANSACTION_INIT) {
+		mdbg(ERR3, "Can't start - transaction (ID=%x),"
+		     " not in INIT state! state=%d", self->id, self->state);
+		err = -EINVAL;
+		goto exit0;
+	}
+	/* reference counter for the timer */
+	tcmi_transaction_get(self);
+	tcmi_transaction_set_flags(self, flags);
+	self->timer.expires += jiffies;
+	self->state = TCMI_TRANSACTION_RUNNING;
+	mdbg(INFO3, "Starting transaction ID %x, response ID %x", 
+	     self->id, self->resp_id);
+	add_timer(&self->timer);
+
+ exit0:
+	tcmi_transaction_unlock(self);
+	return err;
+}
+
+/** 
+ * \<\<public\>\> Aborting the transaction requires:
+ * - deleting the timer and checking if it hasn't expired
+ * - if the timer has been deleted without expiring, it is necessary
+ * to drop the reference that the timer was retaining
+ * - proceed further if the transaction is in INIT or RUNNING state
+ * and change the state to ABORTED.
+ * - notifying the transaction owner
+ *
+ * @param *self - pointer to this transaction instance
+ * @return if the transaction has already been completed, it
+ * will return a valid context and doesn't change the transaction state.
+ * An aborted transaction has still its context set to NULL.
+ */
+void* tcmi_transaction_abort(struct tcmi_transaction *self)
+{
+	int put_needed = 0;
+  
+	del_timer_sync(&self->timer);
+	tcmi_transaction_lock(self);
+	if (!tcmi_transaction_is_expired(self)) {
+		mdbg(INFO3, "Transaction hasn't expired yet, dropping timer reference.");
+		tcmi_transaction_set_expired(self);
+		put_needed = 1;
+	}
+	/* Transaction can be aborted from RUNNING as well as from
+	 * INIT state. */
+	if (!tcmi_transaction_is_complete(self)) {
+		mdbg(INFO3, "Aborting..");
+		self->state = TCMI_TRANSACTION_ABORTED;
+		tcmi_transaction_notify_owner(self);
+	}
+	tcmi_transaction_unlock(self);
+
+	if ( put_needed ) {
+	    tcmi_transaction_put(self);
+	    return NULL;
+	}
+	
+	return self->context;
+}
+
+/** 
+ * \<\<public\>\> Completes a transaction and wakes up the processing
+ * thread.  The completion requires:
+ * - deleting the running timer and checking if it hasn't expired
+ * - if the timer has been deleted without expiring, it is necessary
+ * to drop the reference that the timer was retaining
+ * - proceed further if the transaction is in running state ONLY
+ * - verifying, that the response ID in the transaction matches
+ * caller's expected response ID. The transaction is aborted if those
+ * two ID's don't match as apparently a wrong response has
+ * arrived. 
+ * - upon successful completion, the context specified by the
+ * user, is associated with the transaction. That way, the transaction
+ * owner can read any data related to a particular transaction, when
+ * it picks up the completed transaction.
+ * - notifying the transaction owner
+ *
+ * Completing a transaction is performed under transaction lock being
+ * held.
+ *
+ * @param *self - this transaction instance
+ * @param *context - context that is to be assigned to 
+ * the transaction upon successful completion.
+ * @param resp_id - response message ID that must match the ID set
+ * initially in the transaction.
+ * @return 0 when sucessfully completed
+ */
+int tcmi_transaction_complete(struct tcmi_transaction *self, void *context, 
+			      u_int32_t resp_id)
+{
+	/* default is error */
+	int err = -EINVAL;
+	int put_needed = 0;
+	
+	del_timer_sync(&self->timer);
+	tcmi_transaction_lock(self);
+	if (!tcmi_transaction_is_expired(self)) {
+		mdbg(INFO3, "Transaction hasn't expired yet, dropping timer reference.");
+		tcmi_transaction_set_expired(self);
+		put_needed = 1;
+	}
+	mdbg(INFO3, "Transaction state: %d", tcmi_transaction_state(self));
+	if (!tcmi_transaction_is_running(self)) {
+		mdbg(INFO3, "Can't complete-transaction ID %x is not running!", self->id);
+		goto exit0;
+	}
+	if (self->resp_id == resp_id) {
+		mdbg(INFO3, "Successfully completing transaction ID %x", self->id);
+		self->state = TCMI_TRANSACTION_COMPLETE;
+		self->context = context;
+		err = 0;
+	}
+	else {
+		self->state = TCMI_TRANSACTION_ABORTED;
+		mdbg(ERR4, "Aborting transaction ID %x, resp_id(%x)"
+		     "doesn't match the expected resp_id(%x)!", 
+		     self->id, resp_id, self->resp_id);
+	}
+	/* In every case notify the transaction owner*/
+	tcmi_transaction_notify_owner(self);
+
+ exit0:
+	tcmi_transaction_unlock(self);
+	
+	if ( put_needed )
+	    tcmi_transaction_put(self);
+
+	return err;
+}
+
+/**
+ * \<\<public\>\> Tries to find a transaction based on its ID.  This
+ * is a class method that tries to find a transaction instance. It
+ * computes a hash of the transaction ID and searches the slot at
+ * index equal to the hash value. 
+ * 
+ * The access to the transaction is serialized via the slotvector that
+ * is being searched.
+ *
+ * @param *transactions - slot vector where to perform the search
+ * @param trans_id - ID used when searching for the transaction.
+ * @return transaction if found or NULL
+ */
+struct tcmi_transaction* tcmi_transaction_lookup(struct tcmi_slotvec *transactions, 
+						 u_int32_t trans_id)
+{
+	u_int hash;
+	/* slot where the hash of the transaction ID points to */
+	struct tcmi_slot *slot;
+	struct tcmi_transaction *tran = NULL;
+	/* temporary storage for the slot elements, needed by the iterator */
+	tcmi_slot_node_t *nd; 
+
+	hash = tcmi_transaction_hash(trans_id, tcmi_slotvec_hashmask(transactions));
+
+	tcmi_slotvec_lock(transactions);
+	/* get the slot, the hash is pointing too */
+	if (!(slot = tcmi_slotvec_at(transactions, hash))) {
+		mdbg(ERR3, "Can't locate slot");
+		goto exit0;
+	}
+		
+	/* Search the slot for matching transaction */
+	tcmi_slot_for_each_entry(tran, nd, slot, node) {
+		if (tcmi_transaction_id(tran) == trans_id) {
+			minfo(INFO4,"Found matching transaction ID %x", trans_id);			
+			break;
+		}
+
+	}
+	/* succesfully found a transaction, adjust its reference counter */
+	if (tran)
+		tcmi_transaction_get(tran);
+
+	tcmi_slotvec_unlock(transactions);
+
+	return tran;
+
+/* error handling */
+ exit0:
+	tcmi_slotvec_unlock(transactions);
+	return NULL;
+}
+
+
+/** 
+ * \<\<public\>\> Releases the instance. Decrements reference counter
+ * and if it reaches 0, the transaction is removed from its slot and
+ * freed.
+ *
+ * @param *self - pointer to this instance
+ */
+void tcmi_transaction_put(struct tcmi_transaction *self)
+{
+	struct tcmi_slotvec *transactions;
+	
+	if ( !self ) 
+	    return;
+	
+	transactions = self->transactions;
+	
+	// Transactions slotvec lock used to guard against lookup/put races
+	tcmi_slotvec_lock(transactions);
+  
+	if (self && atomic_dec_and_test(&self->ref_count)) {
+		mdbg(INFO4, "Destroying transaction ID=%x, memory=%p", 
+		     tcmi_transaction_id(self), self);
+		tcmi_slot_remove(self->slot, &self->node);
+		kfree(self);
+	}
+	
+	tcmi_slotvec_unlock(transactions);
+}
+
+/** @addtogroup tcmi_transaction_class
+ *
+ * @{
+ */
+
+/** 
+ * \<\<private\>\> Generates a transaction ID.
+ *
+ * @param *self - this transaction instance
+ */
+static void tcmi_transaction_gen_id(struct tcmi_transaction *self)
+{
+	u_int32_t id = TCMI_TRANSACTION_INVAL_ID;
+
+	while (id == TCMI_TRANSACTION_INVAL_ID) {
+		get_random_bytes(&id, sizeof(u_int32_t));
+	}
+	self->id = id;
+	mdbg(INFO4, "Generated new transaction ID: %x", id);
+}
+
+/** 
+ * \<\<private\>\> Callback for the kernel timer that handles
+ * transaction timeouts.  This method is called upon timer expiration
+ * and means that no response has arrived so far, the transaction
+ * needs to be aborted.  Expired flag is set to indicate that the
+ * timer has executed. This  means that the 'complete' or 'abort'
+ * operations won't try to release the timer reference.
+ * 
+ * Also, the thread that handles the transaction is woken up. 
+ *
+ * Other transaction operations (complete, abort) are serialized with
+ * this method by means of del_timer_sync() - they cannot proceed any
+ * further until this method finishes.
+ *
+ * @param trans - pointer to the transaction instance
+ */
+static void tcmi_transaction_timer(unsigned long trans)
+{
+	struct tcmi_transaction *self = (struct tcmi_transaction*) trans;
+	self->state = TCMI_TRANSACTION_ABORTED;
+	mdbg(INFO3, "Transaction ID %x expired, aborting..", self->id);
+	tcmi_transaction_set_expired(self);
+	tcmi_transaction_notify_owner(self);
+
+	tcmi_transaction_put(self);
+}
+
+
+/**
+ * @}
+ */
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_authenticate_msg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_authenticate_msg.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,242 @@
+/**
+ * @file tcmi_authenticate_msg.c - TCMI authentication request
+ */
+#include <linux/slab.h>
+
+#include "tcmi_transaction.h"
+
+#include "tcmi_authenticate_resp_msg.h"
+#define TCMI_AUTHENTICATE_MSG_PRIVATE
+#include "tcmi_authenticate_msg.h"
+
+
+#include <dbg.h>
+
+
+
+/** 
+ * \<\<public\>\> Message rx constructor.
+ * This method is called by the factory class.
+ *
+ * @param msg_id - message ID that will be used for this message
+ * instance.
+ * @return a new message or NULL.
+ */
+struct tcmi_msg* tcmi_authenticate_msg_new_rx(u_int32_t msg_id)
+{
+	struct tcmi_authenticate_msg *msg;
+
+	/* Check if the factory is building what it really thinks. */
+	if (msg_id != TCMI_AUTHENTICATE_MSG_ID) {
+		mdbg(ERR3, "Factory specified message ID(%x) doesn't match real ID(%x)",
+		     msg_id, TCMI_AUTHENTICATE_MSG_ID);
+		goto exit0;
+	}
+	/* Allocate the instance */
+	if (!(msg = TCMI_AUTHENTICATE_MSG(kmalloc(sizeof(struct tcmi_authenticate_msg), GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate auth request message");
+		goto exit0;
+	}
+	
+	/* Initialized the message for receiving. */
+	if (tcmi_msg_init_rx(TCMI_MSG(msg), TCMI_AUTHENTICATE_MSG_ID, &authenticate_msg_ops)) {
+		mdbg(ERR3, "Error initializing authenticate request message %x", msg_id);
+		goto exit1;
+	}
+
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+}
+
+/** 
+ * \<\<public\>\> Auth message tx constructor.
+ *
+ *
+ * @param *transactions - storage for the new transaction
+ * @param pen_id Id of the requesting PEN
+ * @param pen_arch Architecture of PEN
+ * @return a new message ready for the transfer or NULL.
+ */
+struct tcmi_msg* tcmi_authenticate_msg_new_tx(struct tcmi_slotvec *transactions, u_int32_t pen_id, enum arch_ids pen_arch, char* auth_data, int size)
+{
+	struct tcmi_authenticate_msg *msg;
+
+	if (!(msg = TCMI_AUTHENTICATE_MSG(kmalloc(sizeof(struct tcmi_authenticate_msg), GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate authenticate request message");
+		goto exit0;
+	}
+	
+	msg->pen_id = pen_id;
+	msg->pen_arch = pen_arch;	
+	msg->size = size;
+
+	if ( size > 0 ) {
+		if (!(msg->auth_data = (char*)kmalloc(size, GFP_KERNEL))) {
+			mdbg(ERR3, "Can't allocate memory for checkpoint name");
+			goto exit1;
+		}
+		memcpy(msg->auth_data, auth_data, size);
+	} else {
+		msg->auth_data = NULL;
+	}
+
+	/* Initialize the message for transfer */
+	if (tcmi_msg_init_tx(TCMI_MSG(msg), TCMI_AUTHENTICATE_MSG_ID, &authenticate_msg_ops, 
+			     transactions, TCMI_AUTHENTICATE_RESP_MSG_ID,
+			     TCMI_DEFAULT_MSG_TIMEOUT, TCMI_TRANSACTION_INVAL_ID)) {
+		mdbg(ERR3, "Error initializing authenticate request message message");
+		goto exit2;
+	}
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit2:
+	kfree(msg->auth_data);
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+	
+}
+
+
+/** @addtogroup tcmi_authenticate_msg_class
+ *
+ * @{
+ */
+
+/**
+ * \<\<private\>\> Receives the message via a specified connection. 
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for receiving message data
+ * @return 0 when successfully received.
+ */
+static int tcmi_authenticate_msg_recv(struct tcmi_msg *self, struct kkc_sock *sock)
+{
+	int err = -EINVAL;
+	struct tcmi_authenticate_msg *self_msg = TCMI_AUTHENTICATE_MSG(self);
+
+	mdbg(INFO2, "Authenticate request message received");
+	
+	if ((err = kkc_sock_recv(sock, &self_msg->pen_id, 
+				 sizeof(self_msg->pen_id), KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to receive pen id");
+		goto exit0;
+	}
+
+	if ((err = kkc_sock_recv(sock, &self_msg->pen_arch, 
+				 sizeof(self_msg->pen_arch), KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to receive pen arch");
+		goto exit0;
+	}
+
+	if ((err = kkc_sock_recv(sock, &self_msg->size, 
+				 sizeof(self_msg->size), KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to receive size of auth data");
+		goto exit0;
+	}
+
+	if ( self_msg->size > 0 ) {
+		if (!(self_msg->auth_data = (char*)kmalloc(self_msg->size, GFP_KERNEL))) {
+			mdbg(ERR3, "Can't allocate memory for auth data.");
+			goto exit0;
+		}
+	
+		/* Receive the authentication data */	
+		if ((err = kkc_sock_recv(sock, self_msg->auth_data, 
+					self_msg->size, KKC_SOCK_BLOCK)) < 0) {
+			mdbg(ERR3, "Failed to receive checkpoint name");
+			goto exit0;
+		}	
+	} else {
+		self_msg->auth_data = NULL;
+	}
+
+	return 0;
+
+	/* error handling*/
+ exit0:
+	return err;
+}
+
+/**
+ * \<\<private\>\> Sends the message via a specified connection. 
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for sending message data
+ * @return 0 when successfully sent.
+ */
+static int tcmi_authenticate_msg_send(struct tcmi_msg *self, struct kkc_sock *sock)
+{
+	int err;
+	struct tcmi_authenticate_msg *self_msg = TCMI_AUTHENTICATE_MSG(self);
+
+	/* Receive the remote PID and checkpoint name size */	
+	if ((err = kkc_sock_send(sock, &self_msg->pen_id, 
+				 sizeof(self_msg->pen_id), KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to send pen id");
+		goto exit0;
+	}
+
+	if ((err = kkc_sock_send(sock, &self_msg->pen_arch, 
+				 sizeof(self_msg->pen_arch), KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to send pen arch");
+		goto exit0;
+	}
+
+	if ((err = kkc_sock_send(sock, &self_msg->size, 
+				 sizeof(self_msg->size), KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to send auth data size");
+		goto exit0;
+	}
+
+	if ( self_msg->size > 0 ) {
+		/* Send the authentication data */	
+		if ((err = kkc_sock_send(sock, self_msg->auth_data, 
+					self_msg->size, KKC_SOCK_BLOCK)) < 0) {
+			mdbg(ERR3, "Failed to send authentication data");
+			goto exit0;
+		}
+	}
+
+	mdbg(INFO2, "Authenticate request message sent. Pen ID=%d Arch=%d Auth data length=%d", self_msg->pen_id, self_msg->pen_arch, self_msg->size);
+
+	return 0;
+	/* error handling */
+ exit0:
+	return err;
+}
+
+/**
+ * \<\<private\>\> Frees custom message resources.
+ * The checkpoint image name string is released from memory.
+ *
+ * @param *self - this message instance
+ */
+static void tcmi_authenticate_msg_send_free(struct tcmi_msg *self)
+{
+	struct tcmi_authenticate_msg *self_msg = TCMI_AUTHENTICATE_MSG(self);	
+
+	mdbg(INFO3, "Freeing auth message");
+	kfree(self_msg->auth_data);
+}
+
+
+/** Message operations that support polymorphism. */
+static struct tcmi_msg_ops authenticate_msg_ops = {
+	.recv = tcmi_authenticate_msg_recv,
+	.send = tcmi_authenticate_msg_send,
+	.free = tcmi_authenticate_msg_send_free
+};
+
+
+/**
+ * @}
+ */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_p_emigrate_msg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_p_emigrate_msg.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,206 @@
+/**
+ * @file tcmi_p_emigrate_msg.h - PPM/NPM physical emigration message.
+ *       
+ *                      
+ * 
+ *
+ *
+ * Date: 04/27/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_p_emigrate_msg.h,v 1.2 2009-04-06 21:48:46 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_P_EMIGRATE_MSG_H
+#define _TCMI_P_EMIGRATE_MSG_H
+
+#include "tcmi_msg.h"
+
+/** @defgroup tcmi_p_emigrate_msg_class tcmi_p_emigrate_msg class
+ *
+ * @ingroup tcmi_msg_class
+ *
+ * This class represents a message for preemptive/non-preemtive process migration
+ * via a physical checkpoint image.  The migrating process sends this
+ * message to the PEN, that is responsible for creation of a guest
+ * process and finishing the migration. Should the migration fail, an
+ * error is generated and sent back as a reply.  This is a migration
+ * control message that will be received by the migration manager and
+ * passed onto the newly created guest. The response to this message
+ * is however a process control message (\link
+ * tcmi_guest_started_procmsg_class TCMI_GUEST_STARTED_PROCMSG
+ * \endlink) that will be directly routed to the sending task.
+ *
+ * The sending task specifies it's PID, so that the receiving guest can use
+ * it for further communication via process control connection. Also,
+ * the checkpoint file name is specified as part of the message.
+ *
+ * @{
+ */
+
+/** Compound structure, inherits from tcmi_msg_class */
+struct tcmi_p_emigrate_msg {
+	/** parent class instance. */
+	struct tcmi_msg super;
+	/** groups pid and size, so they can be sent/received at once. */
+	struct {
+		/** remote PID,  used for further communication. */
+		pid_t reply_pid;
+		/** size of the checkpoint name in bytes (including
+		    trailing zero) */
+		int32_t size;
+		/** size of the exec name in bytes (including
+		    trailing zero) */
+		int32_t exec_name_size;
+		/** effective user id of a process as seen by the node where it is running */
+		int16_t euid;
+		/** effective group id of a process as seen by the node where it is running */
+		int16_t egid;
+		/** fsuid of the process on the core node.. may be needed for DFS mount before the checkpoint is read */
+		int16_t fsuid;
+		/** fsgid of the process on the core node.. may be needed for DFS mount before the checkpoint is read */
+		int16_t fsgid;
+	} pid_and_size  __attribute__((__packed__));
+
+	/** name of the executable of the process. */
+	char *exec_name;
+	/** name of the checkpoint file. */
+	char *ckpt_name;
+};
+
+
+
+
+/** \<\<public\>\> Phys. emigrate message constructor for receiving. */
+extern struct tcmi_msg* tcmi_p_emigrate_msg_new_rx(u_int32_t msg_id);
+
+/** \<\<public\>\> Phys. emigrate message constructor for transferring. */
+extern struct tcmi_msg* tcmi_p_emigrate_msg_new_tx(struct tcmi_slotvec *transactions, 
+						       pid_t reply_pid, char *exec_name, char *ckpt_name, int16_t euid, int16_t egid, int16_t fsuid, int16_t fsgid);
+
+
+/** \<\<public\>\> Message descriptor for the factory class, there is no error
+ * handling as this is the starting request */
+#define TCMI_P_EMIGRATE_MSG_DSC TCMI_MSG_DSC(TCMI_P_EMIGRATE_MSG_ID, tcmi_p_emigrate_msg_new_rx, NULL)
+/** Response time out is set to 10 seconds*/
+#define TCMI_P_EMIGRATE_MSGTIMEOUT (10*HZ)
+
+/** Casts to the tcmi_p_emigrate_msg instance. */
+#define TCMI_P_EMIGRATE_MSG(m) ((struct tcmi_p_emigrate_msg*)m)
+
+/**
+ * \<\<public\>\> Remote PID accessor.
+ * 
+ * @param *self - this message instance
+ * @return remote PID
+ */
+static inline pid_t tcmi_p_emigrate_msg_reply_pid(struct tcmi_p_emigrate_msg *self)
+{
+	return self->pid_and_size.reply_pid;
+}
+
+/**
+ * \<\<public\>\> Executable name accessor.
+ * 
+ * @param *self - this message instance
+ * @return executable name string
+ */
+static inline char* tcmi_p_emigrate_msg_exec_name(struct tcmi_p_emigrate_msg *self)
+{
+	return self->exec_name;
+}
+
+/**
+ * \<\<public\>\> Checkpoint name accessor.
+ * 
+ * @param *self - this message instance
+ * @return checkpoint name string
+ */
+static inline char* tcmi_p_emigrate_msg_ckpt_name(struct tcmi_p_emigrate_msg *self)
+{
+	return self->ckpt_name;
+}
+
+/**
+ * \<\<public\>\> Fsuid accesses
+ * 
+ * @param *self - this message instance
+ * @return fsuid
+ */
+static inline int16_t tcmi_p_emigrate_msg_fsuid(struct tcmi_p_emigrate_msg *self)
+{
+	return self->pid_and_size.fsuid;
+}
+
+/**
+ * \<\<public\>\> Fsgid accesses
+ * 
+ * @param *self - this message instance
+ * @return fsgid
+ */
+static inline int16_t tcmi_p_emigrate_msg_fsgid(struct tcmi_p_emigrate_msg *self)
+{
+	return self->pid_and_size.fsgid;
+}
+
+/**
+ * \<\<public\>\> Fsuid accesses
+ * 
+ * @param *self - this message instance
+ * @return euid
+ */
+static inline int16_t tcmi_p_emigrate_msg_euid(struct tcmi_p_emigrate_msg *self)
+{
+	return self->pid_and_size.euid;
+}
+
+/**
+ * \<\<public\>\> Fsgid accesses
+ * 
+ * @param *self - this message instance
+ * @return egid
+ */
+static inline int16_t tcmi_p_emigrate_msg_egid(struct tcmi_p_emigrate_msg *self)
+{
+	return self->pid_and_size.egid;
+}
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_P_EMIGRATE_MSG_PRIVATE
+
+/** Receives the message via a specified connection. */
+static int tcmi_p_emigrate_msg_recv(struct tcmi_msg *self, struct kkc_sock *sock);
+
+/** Sends the message via a specified connection. */
+static int tcmi_p_emigrate_msg_send(struct tcmi_msg *self, struct kkc_sock *sock);
+
+/** Message operations that support polymorphism. */
+static struct tcmi_msg_ops p_emigrate_msg_ops;
+
+#endif /* TCMI_P_EMIGRATE_MSG_PRIVATE */
+
+
+/**
+ * @}
+ */
+
+
+#endif /* _TCMI_P_EMIGRATE_MSG_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_ppm_p_migr_back_guestreq_procmsg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_ppm_p_migr_back_guestreq_procmsg.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,248 @@
+/**
+ * @file tcmi_ppm_p_migr_back_guestreq_procmsg.c - migrate back request initiated by guest
+ *       
+ *                      
+ * 
+ *
+ *
+ * Date: 05/04/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_ppm_p_migr_back_guestreq_procmsg.c,v 1.3 2007/09/02 10:54:25 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include <linux/slab.h>
+#include <linux/string.h>
+
+#include "tcmi_transaction.h"
+
+#include "tcmi_skelresp_msg.h"
+#define TCMI_PPM_P_MIGR_BACK_GUESTREQ_PROCMSG_PRIVATE
+#include "tcmi_ppm_p_migr_back_guestreq_procmsg.h"
+
+
+#include <dbg.h>
+
+
+
+/** 
+ * \<\<public\>\> PPM_P message rx constructor.
+ * This method is called by the factory class.
+ *
+ * @param msg_id - message ID that will be used for this error message
+ * instance.
+ * @return a new error message or NULL.
+ */
+struct tcmi_msg* tcmi_ppm_p_migr_back_guestreq_procmsg_new_rx(u_int32_t msg_id)
+{
+	struct tcmi_ppm_p_migr_back_guestreq_procmsg *msg;
+
+	/* Check if the factory is building what it really thinks. */
+	if (msg_id != TCMI_PPM_P_MIGR_BACK_GUESTREQ_PROCMSG_ID) {
+		mdbg(ERR3, "Factory specified message ID(%x) doesn't match real ID(%x)",
+		     msg_id, TCMI_PPM_P_MIGR_BACK_GUESTREQ_PROCMSG_ID);
+		goto exit0;
+	}
+	/* Allocate the instance */
+	if (!(msg = TCMI_PPM_P_MIGR_BACK_GUESTREQ_PROCMSG(kmalloc(sizeof(struct tcmi_ppm_p_migr_back_guestreq_procmsg), 
+								 GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate test request message");
+		goto exit0;
+	}
+	/* Initialize the message for receiving. */
+	if (tcmi_procmsg_init_rx(TCMI_PROCMSG(msg), TCMI_PPM_P_MIGR_BACK_GUESTREQ_PROCMSG_ID, 
+				 &ppm_p_migr_back_guestreq_procmsg_ops)) {
+		mdbg(ERR3, "Error initializing test request message %x", msg_id);
+		goto exit1;
+	}
+
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+}
+
+/** 
+ * \<\<public\>\> Guest request for migration back tx constructor.
+ *
+ * Generates a one-way request message that contains 
+ * the checkpoint name.
+ *
+ *
+ * @param dst_pid - PID of the target process that will receive this message
+ * @param *ckpt_name - checkpoint name that will be wrapped in the message
+ * @return a new error ready for the transfer or NULL.
+ */
+struct tcmi_msg* tcmi_ppm_p_migr_back_guestreq_procmsg_new_tx(pid_t dst_pid, char *ckpt_name)
+{
+	struct tcmi_ppm_p_migr_back_guestreq_procmsg *msg;
+
+	if (!(msg = TCMI_PPM_P_MIGR_BACK_GUESTREQ_PROCMSG(kmalloc(sizeof(struct tcmi_ppm_p_migr_back_guestreq_procmsg), 
+								 GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't migrate back guest request message");
+		goto exit0;
+	}
+	msg->size = strlen(ckpt_name) + 1;
+
+	if (!(msg->ckpt_name = (char*)kmalloc(msg->size, GFP_KERNEL))) {
+		mdbg(ERR3, "Can't allocate memory for checkpoint name");
+		goto exit1;
+	}
+	strcpy(msg->ckpt_name, ckpt_name);
+
+	/* Initialize the message for transfer, no transaction
+	 * required, no timout, no response ID */
+	if (tcmi_procmsg_init_tx(TCMI_PROCMSG(msg), TCMI_PPM_P_MIGR_BACK_GUESTREQ_PROCMSG_ID,
+				 &ppm_p_migr_back_guestreq_procmsg_ops,
+				 dst_pid, 0,
+				 NULL, 0, 0, TCMI_TRANSACTION_INVAL_ID)) {
+		mdbg(ERR3, "Error initializing  migrate back guest request message");
+		goto exit2;
+	}
+
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit2:
+	kfree(msg->ckpt_name);
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+	
+}
+
+
+/** @addtogroup tcmi_ppm_p_migr_back_guestreq_procmsg_class
+ *
+ * @{
+ */
+
+/**
+ * \<\<private\>\> Receives the message via a specified connection.
+ * Receiving the message requires reading checkpoint size.  Based on
+ * the size, it allocates space for the checkpoint name string and reads it
+ * from the socket.
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for receiving message data
+ * @return 0 when successfully received.
+ */
+static int tcmi_ppm_p_migr_back_guestreq_procmsg_recv(struct tcmi_procmsg *self, struct kkc_sock *sock)
+{
+	int err = -EINVAL;
+	struct tcmi_ppm_p_migr_back_guestreq_procmsg *self_msg = TCMI_PPM_P_MIGR_BACK_GUESTREQ_PROCMSG(self);
+	
+	/* Receive the remote PID and checkpoint name size */	
+	if ((err = kkc_sock_recv(sock, &self_msg->size, 
+				 sizeof(self_msg->size), KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to receive pid and size");
+		goto exit0;
+	}
+
+
+	if (!(self_msg->ckpt_name = (char*)kmalloc(self_msg->size, GFP_KERNEL))) {
+		mdbg(ERR3, "Can't allocate memory for checkpoint name");
+		goto exit0;
+	}
+	
+	/* Receive the checkpoint name */	
+	if ((err = kkc_sock_recv(sock, self_msg->ckpt_name, 
+				 self_msg->size, KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to receive checkpoint name");
+		goto exit0;
+	}
+	mdbg(INFO2, "PPM_P migrate back guest request received guest PID=%d, size=%d, ckptname='%s'",
+	     tcmi_procmsg_dst_pid(self), self_msg->size, self_msg->ckpt_name);
+
+	return 0;
+	/* error handling*/
+ exit0:
+	return err;
+}
+
+/**
+ * \<\<private\>\> Sends the PPM_P migrate back guest request
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for sending message data
+ * @return 0 when successfully sent.
+ */
+static int tcmi_ppm_p_migr_back_guestreq_procmsg_send(struct tcmi_procmsg *self, struct kkc_sock *sock)
+{
+	int err;
+	struct tcmi_ppm_p_migr_back_guestreq_procmsg *self_msg = TCMI_PPM_P_MIGR_BACK_GUESTREQ_PROCMSG(self);
+
+	
+	/* Send the checkpoint name size */	
+	if ((err = kkc_sock_send(sock, &self_msg->size, 
+				 sizeof(self_msg->size), KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to send checkpoint size");
+		goto exit0;
+	}
+
+	/* Send the checkpoint name */	
+	if ((err = kkc_sock_send(sock, self_msg->ckpt_name, 
+				 self_msg->size, KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to send checkpoint name");
+		goto exit0;
+	}
+
+	mdbg(INFO2, "PPM_P migrate back guest request sent guest PID=%d, size=%d, ckptname='%s'",
+	     tcmi_procmsg_dst_pid(self), self_msg->size, self_msg->ckpt_name);
+
+	return 0;
+	/* error handling */
+ exit0:
+	return err;
+	
+}
+
+/**
+ * \<\<private\>\> Frees custom message resources.
+ * The checkpoint image name string is released from memory.
+ *
+ * @param *self - this message instance
+ */
+static void tcmi_ppm_p_migr_back_guestreq_procmsg_free(struct tcmi_procmsg *self)
+{
+	struct tcmi_ppm_p_migr_back_guestreq_procmsg *self_msg = TCMI_PPM_P_MIGR_BACK_GUESTREQ_PROCMSG(self);
+
+	mdbg(INFO3, "Freeing PPM guest migrate back message PID=%d, size=%d, ckptname='%s'",
+	     tcmi_procmsg_dst_pid(TCMI_PROCMSG(self)), self_msg->size, self_msg->ckpt_name);
+	kfree(self_msg->ckpt_name);
+}
+
+
+/** Message operations that support polymorphism. */
+static struct tcmi_procmsg_ops ppm_p_migr_back_guestreq_procmsg_ops = {
+	.recv = tcmi_ppm_p_migr_back_guestreq_procmsg_recv,
+	.send = tcmi_ppm_p_migr_back_guestreq_procmsg_send,
+	.free = tcmi_ppm_p_migr_back_guestreq_procmsg_free
+};
+
+
+/**
+ * @}
+ */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_msg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_msg.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,275 @@
+/**
+ * @file tcmi_msg.h - TCMI communication message.
+ *       
+ *                      
+ * 
+ *
+ *
+ * Date: 04/09/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_msg.h,v 1.4 2007/09/02 10:54:25 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_MSG_H
+#define _TCMI_MSG_H
+
+#include <linux/list.h>
+#include <asm/atomic.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+
+#include "tcmi_transaction.h"
+#include "tcmi_messages_id.h"
+
+#include <tcmi/lib/tcmi_slotvec.h>
+#include <tcmi/lib/tcmi_queue.h>
+
+#include <kkc/kkc_sock.h>
+
+/** @defgroup tcmi_msg_class tcmi_msg class
+ *
+ * @ingroup tcmi_comm_group
+ *
+ * This class represents a generic message in TCMI communication
+ * protocol. A message can be part of a \link tcmi_transaction_class
+ * transaction\endlink. For that reason it carries two extra ID's 
+ * -# a transaction request ID - identifies a transaction started
+ * by the sending party. The sending party expects a message with response
+ * transaction ID set to this value. This ID is assigned automatically
+ * upon message creation depending on a particular messagere type.
+ * -# a transaction response ID - this value comes from the
+ * transaction request ID of the original request message that the new
+ * message is replying to.  This ID has to be specified explicitely
+ * when building the response message.
+ *
+ * A message is instantiated always twice during its lifetime:
+ *
+ * - the sender builds the message based on parameters specified by
+ * the message instantiator.
+ * - the receiver performs message materialization from the data stream.
+ *
+ * These two cases are substantially different. In the first case the
+ * instantiator knows what message is to be built. While the receiver
+ * is left to the very last moment upon discovery of the message ID to build
+ * the message. A suitable solution to this problem is provided by a
+ * a \<\<factory\>\> design pattern. The message instantiation on the receiver
+ * side is carried out by \link tcmi_msg_factory_class message factory \endlink.
+ *
+ * A generic message consists of following parts:
+ * - message id - unique identifier that describes a particular message type.
+ * This is specified by particular subclasses.
+ * - transaction request ID - explained above
+ * - transaction response ID - explained above
+ *
+ * Generic message methods: 
+ * - init_rx - initializes a new message so that it is ready to be
+ * received.
+ * - init_tx - initializes a new message for sending based on
+ * parameters specified by the user.
+ * - recv - receives a message via a communication channel
+ * - send - sends out a message via a communication channel
+ * - deliver - delivers a request message to a queue or delivers a response
+ * message to a transaction and completes the transaction.
+ *
+ * A particular message of the protocol then provides following interface:
+ * - new_rx - this method is registered with the factory class, so that
+ * the build process is fully automated.
+ * - new_rx_err - also registered with the factory class, provides an
+ * alternate(error) version of the message.
+ * - new_tx - builds a message based on parameters specified by the user
+ *
+ * @{
+ */
+
+/** A coumpound structure that carries a generic TCMI message. */
+struct tcmi_msg {
+	/** message id */
+	u_int32_t msg_id;
+	/** groups transactions ID's, so that they are sent at once */
+	struct {
+		/** request transaction ID */
+		u_int32_t req;
+		/** response transaction ID */
+		u_int32_t resp;
+	} trans_id  __attribute__((__packed__));
+	/** transaction associated with the message */
+	struct tcmi_transaction *transaction;
+
+	/** message operations */
+	struct tcmi_msg_ops *msg_ops;
+
+	/** reference counter */
+	atomic_t ref_count;
+	/** list entry for the message queue */
+	struct list_head node;
+
+};
+
+/** Message operations that support polymorphism. */
+struct tcmi_msg_ops {
+	/** Receives the message via a specified connection. */
+	int (*recv)(struct tcmi_msg*, struct kkc_sock*);
+	/** Sends the message via a specified connection. */
+	int (*send)(struct tcmi_msg*, struct kkc_sock*);
+	/** Frees custom message resources. The destruction of the
+	 * actual message instance is handled internally by this
+	 * class */
+	void (*free)(struct tcmi_msg*);
+};
+
+/** This descriptor is to be provided by every individual message
+ * class for the \link tcmi_msg_factory_class factory \endlink. */
+struct tcmi_msg_dsc {
+	/** message id */
+	u_int32_t msg_id;
+	/** Builds the regular version of the message */
+	struct tcmi_msg* (*new_rx)(u_int32_t msg_id);
+	/** Builds the error version of the message */
+	struct tcmi_msg* (*new_rx_err)(u_int32_t msg_id);
+};
+
+/** Macro that fills the descriptor */
+#define TCMI_MSG_DSC(id, new_rx_m, new_rx_err_m)			\
+{.msg_id = id, .new_rx = new_rx_m, .new_rx_err = new_rx_err_m}
+/*{.msg_id = id, .new_rx = new_rx_m, .new_rx_err = new_rx_err_m}*/
+
+
+/** Message transaction default timeout set to 60 seconds*/
+#define TCMI_DEFAULT_MSG_TIMEOUT 60*HZ
+
+/** Casts to the tcmi_msg instance. */
+#define TCMI_MSG(m) ((struct tcmi_msg*)m)
+
+/** \<\<public\>\> Initializes the message for receiving. */
+extern int tcmi_msg_init_rx(struct tcmi_msg *self, u_int32_t msg_id,
+			    struct tcmi_msg_ops *msg_ops);
+
+/** \<\<public\>\> Initializes the message for transferring. */
+extern int tcmi_msg_init_tx(struct tcmi_msg *self, u_int32_t msg_id, 
+			    struct tcmi_msg_ops *msg_ops,
+			    struct tcmi_slotvec *transactions, u_int32_t resp_msg_id,
+			    u_int timeout,
+			    u_int32_t resp_trans_id);
+/** \<\<public\>\> Receives the message via a specified connection. */
+extern int tcmi_msg_recv(struct tcmi_msg *, struct kkc_sock *sock);
+
+/** \<\<public\>\> Sends a message via a specified connection. */
+extern int tcmi_msg_send_anonymous(struct tcmi_msg *self, struct kkc_sock *sock);
+
+/** \<\<public\>\> Sends a message via a specified connection and waits for the response. */
+extern int tcmi_msg_send_and_receive(struct tcmi_msg *self, struct kkc_sock *sock, 
+				     struct tcmi_msg **resp);
+
+
+/**\<\<public\>\>  Message delivers itself.*/
+extern int tcmi_msg_deliver(struct tcmi_msg *self, struct tcmi_queue *requests, 
+			    struct tcmi_slotvec *transactions);
+
+/** \<\<public\>\> Class method - creates a message based on a descriptor. */
+extern struct tcmi_msg* tcmi_msg_new_rx(u_int32_t msg_id, struct tcmi_msg_dsc *dsc);
+
+/** 
+ * \<\<public\>\> Instance accessor, increments the reference count.
+ *
+ * @param *self - pointer to this message instance
+ */
+static inline struct tcmi_msg* tcmi_msg_get(struct tcmi_msg *self)
+{
+	if (self) {
+		atomic_inc(&self->ref_count);
+	}
+	return self;
+}
+
+/** 
+ * \<\<public\>\> Decrements reference counter, if it reaches 0 the
+ * custom free method is called if defined. Eventually, the instance
+ * is destroyed.
+ *
+ * The user is responsible for taking the message out of the message
+ * queue or detaching it from the transaction when needed.
+ *
+ * @param *self - pointer to this message instance
+ */
+static inline void tcmi_msg_put(struct tcmi_msg *self)
+{
+	if (!self)
+		return;
+	if (atomic_dec_and_test(&self->ref_count)) {
+		mdbg(INFO4, "Destroying message ID %x, %p", self->msg_id, self);
+		if(self->msg_ops && self->msg_ops->free) 
+			self->msg_ops->free(self);
+		tcmi_transaction_put(self->transaction);
+		kfree(self);
+	}
+}
+
+/** 
+ * \<\<public\>\> Message ID accessor.
+ *
+ * @param *self - pointer to this message instance
+ * @return message ID
+ */
+static inline u_int32_t tcmi_msg_id(struct tcmi_msg *self)
+{
+	return self->msg_id;
+}
+
+/** 
+ * \<\<public\>\> Message error ID accessor.
+ *
+ * @param *self - pointer to this message instance
+ * @return message ID extended with error flags
+ */
+static inline u_int32_t tcmi_msg_errid(struct tcmi_msg *self)
+{
+	return TCMI_MSG_FLG_SET_ERR(self->msg_id);
+}
+
+/** 
+ * \<\<public\>\> Request transaction ID accessor.  This is needed
+ * when constructing reply messages to set a proper response
+ * transaction ID.
+ *
+ * @param *self - pointer to this message instance
+ * @return message ID extended with error flags
+ */
+static inline u_int32_t tcmi_msg_req_id(struct tcmi_msg *self)
+{
+	return self->trans_id.req;
+}
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_MSG_PRIVATE
+
+/** Sends the message via a specified connection. */
+static int tcmi_msg_send(struct tcmi_msg *self, struct kkc_sock *sock, int flags);
+
+#endif /* TCMI_MSG_PRIVATE */
+
+
+/**
+ * @}
+ */
+
+
+#endif /* _TCMI_MSG_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_disconnect_msg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_disconnect_msg.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,132 @@
+/**
+ * @file tcmi_disconnect_msg.c - TCMI disconnection request
+ */
+#include <linux/slab.h>
+
+#include "tcmi_transaction.h"
+
+#define TCMI_DISCONNECT_MSG_PRIVATE
+#include "tcmi_disconnect_msg.h"
+
+
+#include <dbg.h>
+
+
+/** 
+ * \<\<public\>\> Message rx constructor.
+ * This method is called by the factory class.
+ *
+ * @param msg_id - message ID that will be used for this message
+ * instance.
+ * @return a new message or NULL.
+ */
+struct tcmi_msg* tcmi_disconnect_msg_new_rx(u_int32_t msg_id)
+{
+	struct tcmi_disconnect_msg *msg;
+
+	/* Check if the factory is building what it really thinks. */
+	if (msg_id != TCMI_DISCONNECT_MSG_ID) {
+		mdbg(ERR3, "Factory specified message ID(%x) doesn't match real ID(%x)",
+		     msg_id, TCMI_DISCONNECT_MSG_ID);
+		goto exit0;
+	}
+	/* Allocate the instance */
+	if (!(msg = TCMI_DISCONNECT_MSG(kmalloc(sizeof(struct tcmi_disconnect_msg), GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate disconnect request message");
+		goto exit0;
+	}
+	
+	/* Initialized the message for receiving. */
+	if (tcmi_msg_init_rx(TCMI_MSG(msg), TCMI_DISCONNECT_MSG_ID, &disconnect_msg_ops)) {
+		mdbg(ERR3, "Error initializing disconnect request message %x", msg_id);
+		goto exit1;
+	}
+
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+}
+
+/** 
+ * \<\<public\>\> Disconnect message tx constructor.
+ *
+ *
+ * @param *transactions - storage for the new transaction
+ * @return a new message ready for the transfer or NULL.
+ */
+struct tcmi_msg* tcmi_disconnect_msg_new_tx(void)
+{
+	struct tcmi_disconnect_msg *msg;
+
+	if (!(msg = TCMI_DISCONNECT_MSG(kmalloc(sizeof(struct tcmi_disconnect_msg), GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate disconnect request message");
+		goto exit0;
+	}
+	
+	/* Initialize the message for transfer */
+	if (tcmi_msg_init_tx(TCMI_MSG(msg), TCMI_DISCONNECT_MSG_ID, &disconnect_msg_ops, 
+			     NULL, 0,
+			     0, TCMI_TRANSACTION_INVAL_ID)) {
+		mdbg(ERR3, "Error initializing disconnect request message message");
+		goto exit1;
+	}
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+	
+}
+
+
+/** @addtogroup tcmi_disconnect_msg_class
+ *
+ * @{
+ */
+
+/**
+ * \<\<private\>\> Receives the message via a specified connection. 
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for receiving message data
+ * @return 0 when successfully received.
+ */
+static int tcmi_disconnect_msg_recv(struct tcmi_msg *self, struct kkc_sock *sock)
+{
+	mdbg(INFO2, "Disconnect message received");
+
+	return 0;
+}
+
+/**
+ * \<\<private\>\> Sends the message via a specified connection. 
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for sending message data
+ * @return 0 when successfully sent.
+ */
+static int tcmi_disconnect_msg_send(struct tcmi_msg *self, struct kkc_sock *sock)
+{
+	mdbg(INFO2, "Disconnect request message sent.");
+
+	return 0;
+}
+
+/** Message operations that support polymorphism. */
+static struct tcmi_msg_ops disconnect_msg_ops = {
+	.recv = tcmi_disconnect_msg_recv,
+	.send = tcmi_disconnect_msg_send,
+	.free = NULL,
+};
+
+
+/**
+ * @}
+ */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_err_procmsg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_err_procmsg.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,185 @@
+/**
+ * @file tcmi_err_procmsg.c - TCMI error message - carries an error status code.
+ *       
+ *                      
+ * 
+ *
+ *
+ * Date: 04/19/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_err_procmsg.c,v 1.3 2007/09/02 10:54:25 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include <linux/slab.h>
+
+#define TCMI_ERR_PROCMSG_PRIVATE
+#include "tcmi_err_procmsg.h"
+
+
+#include <dbg.h>
+
+
+
+/** 
+ * \<\<public\>\> Error process message rx constructor.  This
+ * constructor is made available for other process messages, so that
+ * they can specify it as their error constructor for \link
+ * tcmi_msg_factory_class the factory class \endlink.
+ *
+ * @param msg_id - message ID that will be used for this error message
+ * instance.
+ * @return a new error message or NULL.
+ */
+struct tcmi_msg* tcmi_err_procmsg_new_rx(u_int32_t msg_id)
+{
+	struct tcmi_err_procmsg *msg;
+
+	if (!(msg = TCMI_ERR_PROCMSG(kmalloc(sizeof(struct tcmi_err_procmsg), GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate memory for error message %x", msg_id);
+		goto exit0;
+	}
+	/* Initialized the message for receiving, message ID is
+	 * extended with error flags */
+	if (tcmi_procmsg_init_rx(TCMI_PROCMSG(msg), TCMI_MSG_FLG_SET_ERR(msg_id), &err_procmsg_ops)) {
+		mdbg(ERR3, "Error initializing error message %x", msg_id);
+		goto exit1;
+	}
+
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+}
+
+/** 
+ * \<\<public\>\> Error message constructor for transferring. 
+ *
+ * An error message is considered one way only and is usually used as a
+ * error response to some other process message. The user thus has to specify
+ * the transaction ID of the message that the error message is a response too.
+ * Messages with TCMI_TRANSACTION_INVAL_ID are possible too. No search
+ * for a matching transaction will be performed at the receiving party and
+ * the message will be queued in a regular request queue. 
+ *
+ * As for any other process message, the destination PID has to be specified
+ *
+ * @param msg_id - ID assigned to the error message, it will be extended
+ * with error flags, so that the message factory at the receiving party uses
+ * the above implemented tcmi_err_procmsg_new_rx() constructor.
+ * @param trans_id - transaction ID 
+ * @param err_code - error code that will be stored in the message
+ * @param dst_pid - destination process PID
+ * @return a new error ready for the transfer or NULL.
+ */
+struct tcmi_msg* tcmi_err_procmsg_new_tx(u_int32_t msg_id, u_int32_t trans_id, int err_code,
+					 pid_t dst_pid)
+{
+	struct tcmi_err_procmsg *msg;
+
+	if (!(msg = TCMI_ERR_PROCMSG(kmalloc(sizeof(struct tcmi_err_procmsg), GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate memory for error message %x", msg_id);
+		goto exit0;
+	}
+
+	/* Initialize the message for transfer, message ID is
+	 * extended with error flags, no transaction created or
+	 * response ID setup. Only the transaction ID, that will get
+	 * send along with the message, is set. */
+	if (tcmi_procmsg_init_tx(TCMI_PROCMSG(msg), TCMI_MSG_FLG_SET_ERR(msg_id), &err_procmsg_ops, 
+				 dst_pid, 0,
+				 NULL, 0, 0, trans_id)) {
+		mdbg(ERR3, "Error initializing error message %x", msg_id);
+		goto exit1;
+	}
+	msg->err_code = err_code;
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+	
+}
+
+
+/** @addtogroup tcmi_err_procmsg_class
+ *
+ * @{
+ */
+
+/**
+ * \<\<private\>\> Receives the message via a specified connection.
+ * Receiving the error process message requires reading the error code from
+ * the specified socket
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for receiving message data
+ * @return 0 when successfully received.
+ */
+static int tcmi_err_procmsg_recv(struct tcmi_procmsg *self, struct kkc_sock *sock)
+{
+	int err;
+	struct tcmi_err_procmsg *self_err = TCMI_ERR_PROCMSG(self);
+
+	err = kkc_sock_recv(sock, &self_err->err_code, 
+			    sizeof(self_err->err_code), KKC_SOCK_BLOCK);
+	mdbg(INFO3, "Received error code: %x", self_err->err_code);
+	
+	return err;
+}
+
+/**
+ * \<\<private\>\> Sends out the error code via specified socket.
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for receiving message data
+ * @return 0 when successfully sent.
+ */
+static int tcmi_err_procmsg_send(struct tcmi_procmsg *self, struct kkc_sock *sock)
+{
+	int err;
+	struct tcmi_err_procmsg *self_err = TCMI_ERR_PROCMSG(self);
+
+	err = kkc_sock_send(sock, &self_err->err_code, 
+			    sizeof(self_err->err_code), KKC_SOCK_BLOCK);
+
+	mdbg(INFO3, "Sent error code: %x", self_err->err_code);
+
+	return err;
+}
+
+
+
+/** Message operations that support polymorphism. */
+static struct tcmi_procmsg_ops err_procmsg_ops = {
+	.recv = tcmi_err_procmsg_recv,
+	.send = tcmi_err_procmsg_send
+};
+
+
+/**
+ * @}
+ */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_exit_procmsg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_exit_procmsg.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,104 @@
+/**
+ * @file tcmi_exit_procmsg.h - TCMI exit message, send by guest task from PEN
+ *       
+ *                      
+ * 
+ *
+ *
+ * Date: 04/27/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_exit_procmsg.h,v 1.3 2007/09/02 10:54:25 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_EXIT_PROCMSG_H
+#define _TCMI_EXIT_PROCMSG_H
+
+#include "tcmi_procmsg.h"
+
+/** @defgroup tcmi_exit_procmsg_class tcmi_exit_procmsg class
+ *
+ * @ingroup tcmi_procmsg_class
+ *
+ * This class represents an exit message that will be sent out by
+ * a guest process upon exit. The receiving shadow process has to take
+ * appropriate actions.
+ *
+ * @{
+ */
+
+/** Compound structure, inherits from tcmi_procmsg_class */
+struct tcmi_exit_procmsg {
+	/** parent class instance. */
+	struct tcmi_procmsg super;
+	/** exit code the message is carrying. */
+	int32_t code;
+};
+
+
+
+
+/** \<\<public\>\> Exit process message constructor for receiving. */
+extern struct tcmi_msg* tcmi_exit_procmsg_new_rx(u_int32_t msg_id);
+
+/** \<\<public\>\>  Exit process message constructor for transferring. */
+extern struct tcmi_msg* tcmi_exit_procmsg_new_tx(pid_t dst_pid, int32_t code);
+
+
+/** Message descriptor for the factory class, there is no error
+ * handling as this is the starting request */
+#define TCMI_EXIT_PROCMSG_DSC TCMI_MSG_DSC(TCMI_EXIT_PROCMSG_ID, tcmi_exit_procmsg_new_rx, NULL)
+
+/** Casts to the tcmi_exit_procmsg instance. */
+#define TCMI_EXIT_PROCMSG(m) ((struct tcmi_exit_procmsg*)m)
+
+/**
+ * Exit code accessor.
+ * 
+ * @param *self - this message instance
+ * @return exit code
+ */
+static inline int32_t tcmi_exit_procmsg_code(struct tcmi_exit_procmsg *self) 
+{
+	return self->code;
+}
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_EXIT_PROCMSG_PRIVATE
+
+/** Receives the message via a specified connection. */
+static int tcmi_exit_procmsg_recv(struct tcmi_procmsg *self, struct kkc_sock *sock);
+
+/** Sends the message via a specified connection. */
+static int tcmi_exit_procmsg_send(struct tcmi_procmsg *self, struct kkc_sock *sock);
+
+/** Message operations that support polymorphism. */
+static struct tcmi_procmsg_ops exit_procmsg_ops;
+
+#endif /* TCMI_EXIT_PROCMSG_PRIVATE */
+
+
+/**
+ * @}
+ */
+
+
+#endif /* _TCMI_EXIT_PROCMSG_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_signal_msg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_signal_msg.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,191 @@
+/**
+ * @file tcmi_signal_msg.c - TCMI skeleton message - example message implementation.
+ *       
+ *                      
+ * 
+ *
+ *
+ * Date: 04/11/2005
+ *
+ * Author: Petr Malat 
+ *
+ * $Id: tcmi_signal_msg.c,v 1.2 2007/09/02 10:54:25 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include <linux/slab.h>
+
+#include "tcmi_transaction.h"
+
+#define TCMI_SIGNAL_MSG_PRIVATE
+#include "tcmi_signal_msg.h"
+
+
+#include <dbg.h>
+
+
+
+/** 
+ * \<\<public\>\> Skeleton message rx constructor.
+ * This method is called by the factory class.
+ *
+ * @param msg_id - message ID that will be used for this error message
+ * instance.
+ * @return a new error message or NULL.
+ */
+struct tcmi_msg* tcmi_signal_msg_new_rx(u_int32_t msg_id)
+{
+	struct tcmi_signal_msg *msg;
+
+	/* Check if the factory is building what it really thinks. */
+	if (msg_id != TCMI_SIGNAL_MSG_ID) {
+		mdbg(ERR3, "Factory specified message ID(%x) doesn't match real ID(%x)",
+		     msg_id, TCMI_SIGNAL_MSG_ID);
+		goto exit0;
+	}
+	/* Allocate the instance */
+	if (!(msg = TCMI_SIGNAL_MSG(kmalloc(sizeof(struct tcmi_signal_msg), GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate signal message");
+		goto exit0;
+	}
+	/* Initialized the message for receiving. */
+	if (tcmi_msg_init_rx(TCMI_MSG(msg), TCMI_SIGNAL_MSG_ID, &skel_msg_ops)) {
+		mdbg(ERR3, "Error initializing signal message %x", msg_id);
+		goto exit1;
+	}
+
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+}
+
+/** 
+ * \<\<public\>\> Skeleton message tx constructor.
+ *
+ * The skeleton message can have a transaction associated with it =
+ * there is a response expected for this message by the
+ * sender. Therefore, the user specifies the transaction slot vector.
+ *
+ * When performing the generic tx init, the response message ID is
+ * specified (TCMI_RESPSIGNAL_MSG_ID) so that it will be associated with the
+ * transaction
+ *
+ * @param *transactions - storage for the new transaction(NULL for one-way messages)
+ * @return a new error ready for the transfer or NULL.
+ */
+struct tcmi_msg* tcmi_signal_msg_new_tx(struct tcmi_slotvec *transactions)
+{
+	struct tcmi_signal_msg *msg;
+
+	if (!(msg = TCMI_SIGNAL_MSG(kmalloc(sizeof(struct tcmi_signal_msg), GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate signal message");
+		goto exit0;
+	}
+
+	/* Initialize the message for transfer */
+	if (tcmi_msg_init_tx(TCMI_MSG(msg), TCMI_SIGNAL_MSG_ID, &skel_msg_ops, 
+			     transactions, 0,//TCMI_SIGNALRESP_MSG_ID,
+			     TCMI_SIGNAL_MSGTIMEOUT, TCMI_TRANSACTION_INVAL_ID)) {
+		mdbg(ERR3, "Error initializing signal message");
+		goto exit1;
+	}
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+	
+}
+
+
+/** @addtogroup tcmi_signal_msg_class
+ *
+ * @{
+ */
+
+/**
+ * \<\<private\>\> Receives the message via a specified connection. 
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for receiving message data
+ * @return 0 when successfully received.
+ */
+static int tcmi_signal_msg_recv(struct tcmi_msg *self, struct kkc_sock *sock)
+{
+	struct tcmi_signal_msg *self_msg = TCMI_SIGNAL_MSG(self);   
+	int err;
+
+	err = kkc_sock_recv(sock, &self_msg->pid, 
+			    sizeof(self_msg->pid) + sizeof(self_msg->info), KKC_SOCK_BLOCK);
+
+	mdbg(INFO2, "Signal message received(%d)", err);
+	
+	return 0;
+}
+
+/**
+ * \<\<private\>\> Receives the message via a specified connection. 
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for sending message data
+ * @return 0 when successfully sent.
+ */
+static int tcmi_signal_msg_send(struct tcmi_msg *self, struct kkc_sock *sock)
+{
+	struct tcmi_signal_msg *self_msg = TCMI_SIGNAL_MSG(self);   
+	int err;
+
+	err = kkc_sock_send(sock, &self_msg->pid, 
+			    sizeof(self_msg->pid) + sizeof(self_msg->info), KKC_SOCK_BLOCK);
+
+	mdbg(INFO2, "Signal message send(%d)", err);
+	
+
+	return 0;
+}
+
+struct tcmi_msg *tcmi_signal_msg_new(pid_t pid, siginfo_t *info)
+{
+	struct tcmi_msg *self;
+
+	self = tcmi_signal_msg_new_tx(NULL);
+
+	if(self){
+		TCMI_SIGNAL_MSG(self)->pid = pid;
+		memcpy(&TCMI_SIGNAL_MSG(self)->info, info, sizeof(siginfo_t));
+	}
+	return self;
+}
+
+/** Message operations that support polymorphism. */
+static struct tcmi_msg_ops skel_msg_ops = {
+	.recv = tcmi_signal_msg_recv,
+	.send = tcmi_signal_msg_send
+};
+
+
+/**
+ * @}
+ */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_generic_user_msg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_generic_user_msg.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,225 @@
+/**
+ * @file tcmi_generic_user_msg.c - Generic user message
+ */
+#include <linux/slab.h>
+
+#include "tcmi_transaction.h"
+
+#define TCMI_GENERIC_USER_MSG_PRIVATE
+#include "tcmi_generic_user_msg.h"
+
+
+#include <dbg.h>
+
+
+
+/** 
+ * \<\<public\>\> Message rx constructor.
+ * This method is called by the factory class.
+ *
+ * @param msg_id - message ID that will be used for this message
+ * instance.
+ * @return a new message or NULL.
+ */
+struct tcmi_msg* tcmi_generic_user_msg_new_rx(u_int32_t msg_id)
+{
+	struct tcmi_generic_user_msg *msg;
+
+	/* Check if the factory is building what it really thinks. */
+	if (msg_id != TCMI_GENERIC_USER_MSG_ID) {
+		mdbg(ERR3, "Factory specified message ID(%x) doesn't match real ID(%x)",
+		     msg_id, TCMI_GENERIC_USER_MSG_ID);
+		goto exit0;
+	}
+	/* Allocate the instance */
+	if (!(msg = TCMI_GENERIC_USER_MSG(kmalloc(sizeof(struct tcmi_generic_user_msg), GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate generic user message");
+		goto exit0;
+	}
+	
+	/* Initialized the message for receiving. */
+	if (tcmi_msg_init_rx(TCMI_MSG(msg), TCMI_GENERIC_USER_MSG_ID, &generic_user_msg_ops)) {
+		mdbg(ERR3, "Error initializing generic user message %x", msg_id);
+		goto exit1;
+	}
+
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+}
+
+/** 
+ * \<\<public\>\> Message tx constructor.
+ *
+ *
+ * @param node_id Id of the requesting node
+ * @return a new message ready for the transfer or NULL.
+ */
+struct tcmi_msg* tcmi_generic_user_msg_new_tx(u_int32_t node_id, char* user_data, int size)
+{
+	struct tcmi_generic_user_msg *msg;
+
+	if (!(msg = TCMI_GENERIC_USER_MSG(kmalloc(sizeof(struct tcmi_generic_user_msg), GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate generic user message");
+		goto exit0;
+	}
+	
+	msg->node_id = node_id;
+	msg->size = size;
+
+	if ( size > 0 ) {
+		if (!(msg->user_data = (char*)kmalloc(size, GFP_KERNEL))) {
+			mdbg(ERR3, "Can't allocate memory for user data message");
+			goto exit1;
+		}
+		memcpy(msg->user_data, user_data, size);
+	} else {
+		msg->user_data = NULL;
+	}
+
+	/* Initialize the message for transfer */
+	if (tcmi_msg_init_tx(TCMI_MSG(msg), TCMI_GENERIC_USER_MSG_ID, &generic_user_msg_ops, 
+			     NULL, 0,
+			     0, TCMI_TRANSACTION_INVAL_ID)) {
+		mdbg(ERR3, "Error initializing generic user message");
+		goto exit2;
+	}
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit2:
+	kfree(msg->user_data);
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+	
+}
+
+
+/** @addtogroup tcmi_generic_user_msg_class
+ *
+ * @{
+ */
+
+/**
+ * \<\<private\>\> Receives the message via a specified connection. 
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for receiving message data
+ * @return 0 when successfully received.
+ */
+static int tcmi_generic_user_msg_recv(struct tcmi_msg *self, struct kkc_sock *sock)
+{
+	int err = -EINVAL;
+	struct tcmi_generic_user_msg *self_msg = TCMI_GENERIC_USER_MSG(self);
+
+	mdbg(INFO2, "Generic user message received");
+	
+	if ((err = kkc_sock_recv(sock, &self_msg->node_id, 
+				 sizeof(self_msg->node_id), KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to receive node id");
+		goto exit0;
+	}
+
+	if ((err = kkc_sock_recv(sock, &self_msg->size, 
+				 sizeof(self_msg->size), KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to receive size of user data");
+		goto exit0;
+	}
+
+	if ( self_msg->size > 0 ) {
+		if (!(self_msg->user_data = (char*)kmalloc(self_msg->size, GFP_KERNEL))) {
+			mdbg(ERR3, "Can't allocate memory for user data.");
+			goto exit0;
+		}
+	
+		/* Receive the user data */	
+		if ((err = kkc_sock_recv(sock, self_msg->user_data, 
+					self_msg->size, KKC_SOCK_BLOCK)) < 0) {
+			mdbg(ERR3, "Failed to receive user data");
+			goto exit0;
+		}	
+	} else {
+		self_msg->user_data = NULL;
+	}
+
+	return 0;
+
+	/* error handling*/
+ exit0:
+	return err;
+}
+
+/**
+ * \<\<private\>\> Sends the message via a specified connection. 
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for sending message data
+ * @return 0 when successfully sent.
+ */
+static int tcmi_generic_user_msg_send(struct tcmi_msg *self, struct kkc_sock *sock)
+{
+	int err;
+	struct tcmi_generic_user_msg *self_msg = TCMI_GENERIC_USER_MSG(self);
+
+	if ((err = kkc_sock_send(sock, &self_msg->node_id, 
+				 sizeof(self_msg->node_id), KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to send node id");
+		goto exit0;
+	}
+
+	if ((err = kkc_sock_send(sock, &self_msg->size, 
+				 sizeof(self_msg->size), KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to send user data size");
+		goto exit0;
+	}
+
+	if ( self_msg->size > 0 ) {
+		/* Send the user data */	
+		if ((err = kkc_sock_send(sock, self_msg->user_data, 
+					self_msg->size, KKC_SOCK_BLOCK)) < 0) {
+			mdbg(ERR3, "Failed to send user data");
+			goto exit0;
+		}
+	}
+
+	mdbg(INFO2, "User data message sent. Pen ID=%d Auth data length=%d", self_msg->node_id, self_msg->size);
+
+	return 0;
+	/* error handling */
+ exit0:
+	return err;
+}
+
+/**
+ * \<\<private\>\> Frees custom message resources.
+ * The checkpoint image name string is released from memory.
+ *
+ * @param *self - this message instance
+ */
+static void tcmi_generic_user_msg_send_free(struct tcmi_msg *self)
+{
+	struct tcmi_generic_user_msg *self_msg = TCMI_GENERIC_USER_MSG(self);	
+
+	mdbg(INFO3, "Freeing user message");
+	kfree(self_msg->user_data);
+}
+
+
+/** Message operations that support polymorphism. */
+static struct tcmi_msg_ops generic_user_msg_ops = {
+	.recv = tcmi_generic_user_msg_recv,
+	.send = tcmi_generic_user_msg_send,
+	.free = tcmi_generic_user_msg_send_free
+};
+
+
+/**
+ * @}
+ */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_messages_id.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_messages_id.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,148 @@
+/**
+ * @file tcmi_messages_id.h - This is a list of all identifiers of  migration messages.
+ *
+ *       
+ *                      
+ * 
+ *
+ *
+ * Date: 04/12/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_messages_id.h,v 1.7 2008/05/02 19:59:20 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_MIG_MESSAGES_ID_H
+#define _TCMI_MIG_MESSAGES_ID_H
+
+/** @defgroup tcmi_messages_id message ID's
+ *
+ * @ingroup tcmi_comm_group
+ *
+ * Message ID has 3 components:
+ *
+ * - bits 31-30 - message flags
+ *              - 0 - regular message
+ *              - 1 - error message
+ *              - 2 - reserved
+ *              - 3 - reserved
+ * - bits 29-16 - message group ID. Initially, there are 2 groups:
+ *              - 0 - migration control connection messages
+ *              - 1 - process control messages
+ *
+ * - bits 15-0  - a unique message index within a particular
+ *              group.
+ \verbatim
+   31   30 29       16 15         0
+   +------+-----------+-----------+
+   | flgs |   group   |   index   |
+   +------+-----------+-----------+
+           \                     /
+            \                   /
+             \                 /
+              \               /
+               \             / 
+                 message type - used when associating
+   a response message with a transaction
+ \endverbatim
+ * @{
+ */
+/** There are 2^index_bits messages */
+#define TCMI_MSG_INDEX_BITS     16
+/** There are 2^group_bits message groups */
+#define TCMI_MSG_GROUP_BITS     14
+/** There are 2^flg_bits flags available */
+#define TCMI_MSG_FLG_BITS       2
+/** Total number of bits reserved for message identification. */
+#define TCMI_MSG_TYPE_BITS      (TCMI_MSG_GROUP_BITS + TCMI_MSG_INDEX_BITS) 
+
+/** Mask for the message index */
+#define TCMI_MSG_INDEX_MSK      ((1 << TCMI_MSG_INDEX_BITS) - 1)
+/** Extracts message index */
+#define TCMI_MSG_INDEX(msg_id) (msg_id & TCMI_MSG_INDEX_MSK)
+/** Mask for the group */
+#define TCMI_MSG_GROUP_MSK      ((1 << TCMI_MSG_GROUP_BITS) - 1)
+/** Extracts group number */
+#define TCMI_MSG_GROUP(msg_id) ((msg_id >> TCMI_MSG_INDEX_BITS) & TCMI_MSG_GROUP_MSK)
+/** Mask for the message type */
+#define TCMI_MSG_TYPE_MSK       ((1 << TCMI_MSG_TYPE_BITS) - 1)
+/** Extracts the message type */
+#define TCMI_MSG_TYPE(msg_id)  (msg_id & TCMI_MSG_TYPE_MSK)
+/** Mask for the flag bits */
+#define TCMI_MSG_FLG_MSK        ((1 << TCMI_MSG_FLG_BITS) - 1)
+/** Extracts the message flags */
+#define TCMI_MSG_FLG(msg_id)   ((msg_id >> TCMI_MSG_TYPE_BITS) & TCMI_MSG_FLG_MSK)
+/** Flag shift */
+#define TCMI_MSG_FLG_SHIFT      TCMI_MSG_TYPE_BITS
+/** Sets a specified group */
+#define TCMI_MSG_SET_GRP(grp)  (grp << TCMI_MSG_INDEX_BITS)
+
+/** Regular message flag */
+#define TCMI_MSG_REGFLGS        0
+/** Error message flag */
+#define TCMI_MSG_ERRFLGS        1
+/** Sets an error flag */
+#define TCMI_MSG_FLG_SET_ERR(id)    (id | (TCMI_MSG_ERRFLGS << TCMI_MSG_FLG_SHIFT))
+
+
+/** Message groups - each group has a unique ID. */
+enum {
+	TCMI_MSG_GROUP_MIG  = 0, /* TCMI migration messages */
+	TCMI_MSG_GROUP_PROC,     /* TCMI process control messages */
+	TCMI_MSG_GROUP_LAST,
+	TCMI_MSG_GROUP_ANY  = 0xffffffff
+};
+
+/********** Following enums define message types within each group *********/
+
+/** TCMI Migration messages */
+enum {
+	TCMI_SKEL_MSG_ID = TCMI_MSG_SET_GRP(TCMI_MSG_GROUP_MIG), /* TCMI test message */
+	TCMI_SKELRESP_MSG_ID,                                    /* TCMI test response message */
+	TCMI_AUTHENTICATE_MSG_ID,						 /* TCMI authentication request */
+	TCMI_AUTHENTICATE_RESP_MSG_ID,                                    /* TCMI authentication response */
+	TCMI_DISCONNECT_MSG_ID,						 /* TCMI disconnect request */
+	TCMI_P_EMIGRATE_MSG_ID,                              	 /* TCMI phys. emigration message */
+	TCMI_SIGNAL_MSG_ID,                                      /* TCMI signal message */
+        TCMI_GENERIC_USER_MSG_ID,                            /* Generic user message */
+	TCMI_LAST_MSG_ID                                         /* Last ID */
+};
+
+/** TCMI Process control messages */
+enum {
+	TCMI_SKEL_PROCMSG_ID = TCMI_MSG_SET_GRP(TCMI_MSG_GROUP_PROC), /* TCMI test process message */
+	TCMI_SKELRESP_PROCMSG_ID,                                     /* TCMI test response process message */
+	TCMI_EXIT_PROCMSG_ID,                                         /* TCMI guest task exit mesage */
+	TCMI_VFORK_DONE_PROCMSG_ID,                                   /* TCMI guest task execved -> parent vfork is completed */
+	TCMI_GUEST_STARTED_PROCMSG_ID,                                /* TCMI guest task has been started */
+	TCMI_PPM_P_MIGR_BACK_GUESTREQ_PROCMSG_ID,                     /* TCMI migrate back guest request*/
+	TCMI_PPM_P_MIGR_BACK_SHADOWREQ_PROCMSG_ID,                     /* TCMI migrate back request from shadow task */
+	TCMI_RPC_PROCMSG_ID,                                          /* TCMI RPC mesage */
+	TCMI_RPCRESP_PROCMSG_ID,                                      /* TCMI RPC response mesage */
+
+	TCMI_LAST_PROCMSG_ID                                          /* Last ID */
+};
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_MIG_MESSAGES_ID_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_msg_factory.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_msg_factory.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,64 @@
+/**
+ * @file tcmi_msg_factory.h - TCMI message factory message.
+ *       
+ *                      
+ * 
+ *
+ *
+ * Date: 04/09/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_msg_factory.h,v 1.2 2007/07/02 02:26:17 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_MSG_FACTORY_H
+#define _TCMI_MSG_FACTORY_H
+
+#include "tcmi_msg.h"
+
+/** @defgroup tcmi_msg_factory_class tcmi_msg_factory class
+ *
+ * @ingroup tcmi_comm_group
+ *
+ * This \<\<singleton\>\> class is responsible for message
+ * materialization based on message ID. In addition it provides an
+ * optional verification whether the specified message ID belongs
+ * to the requested message group.
+ *
+ * @{
+ */
+
+
+/** \<\<public\>\> Materializes the message. */
+extern struct tcmi_msg* tcmi_msg_factory(u_int32_t msg_id, u_int32_t msg_group);
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_MSG_FACTORY_PRIVATE
+
+#endif /* TCMI_MSG_FACTORY_PRIVATE */
+
+
+/**
+ * @}
+ */
+
+
+#endif /* _TCMI_MSG_FACTORY_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_generic_user_procmsg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_generic_user_procmsg.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,225 @@
+/**
+ * @file tcmi_generic_user_procmsg.c - Generic user message
+ */
+#include <linux/slab.h>
+
+#include "tcmi_transaction.h"
+
+#define TCMI_GENERIC_USER_MSG_PRIVATE
+#include "tcmi_generic_user_procmsg.h"
+
+
+#include <dbg.h>
+
+
+
+/** 
+ * \<\<public\>\> Message rx constructor.
+ * This method is called by the factory class.
+ *
+ * @param msg_id - message ID that will be used for this message
+ * instance.
+ * @return a new message or NULL.
+ */
+struct tcmi_msg* tcmi_generic_user_procmsg_new_rx(u_int32_t msg_id)
+{
+	struct tcmi_generic_user_procmsg *msg;
+
+	/* Check if the factory is building what it really thinks. */
+	if (msg_id != TCMI_GENERIC_USER_PROCMSG_ID) {
+		mdbg(ERR3, "Factory specified message ID(%x) doesn't match real ID(%x)",
+		     msg_id, TCMI_GENERIC_USER_PROCMSG_ID);
+		goto exit0;
+	}
+	/* Allocate the instance */
+	if (!(msg = TCMI_GENERIC_USER_PROCMSG(kmalloc(sizeof(struct tcmi_generic_user_procmsg), GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate generic user message");
+		goto exit0;
+	}
+	
+	/* Initialized the message for receiving. */
+	if (tcmi_msg_init_rx(TCMI_MSG(msg), TCMI_GENERIC_USER_PROCMSG_ID, &generic_user_procmsg_ops)) {
+		mdbg(ERR3, "Error initializing generic user message %x", msg_id);
+		goto exit1;
+	}
+
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+}
+
+/** 
+ * \<\<public\>\> Message tx constructor.
+ *
+ *
+ * @param node_id Id of the requesting node
+ * @return a new message ready for the transfer or NULL.
+ */
+struct tcmi_msg* tcmi_generic_user_procmsg_new_tx(u_int32_t node_id, char* user_data, int size)
+{
+	struct tcmi_generic_user_procmsg *msg;
+
+	if (!(msg = TCMI_GENERIC_USER_PROCMSG(kmalloc(sizeof(struct tcmi_generic_user_procmsg), GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate generic user message");
+		goto exit0;
+	}
+	
+	msg->node_id = node_id;
+	msg->size = size;
+
+	if ( size > 0 ) {
+		if (!(msg->user_data = (char*)kmalloc(size, GFP_KERNEL))) {
+			mdbg(ERR3, "Can't allocate memory for user data message");
+			goto exit1;
+		}
+		memcpy(msg->user_data, user_data, size);
+	} else {
+		msg->user_data = NULL;
+	}
+
+	/* Initialize the message for transfer */
+	if (tcmi_msg_init_tx(TCMI_MSG(msg), TCMI_GENERIC_USER_PROCMSG_ID, &generic_user_procmsg_ops, 
+			     NULL, 0,
+			     0, TCMI_TRANSACTION_INVAL_ID)) {
+		mdbg(ERR3, "Error initializing generic user message");
+		goto exit2;
+	}
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit2:
+	kfree(msg->user_data);
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+	
+}
+
+
+/** @addtogroup tcmi_generic_user_msg_class
+ *
+ * @{
+ */
+
+/**
+ * \<\<private\>\> Receives the message via a specified connection. 
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for receiving message data
+ * @return 0 when successfully received.
+ */
+static int tcmi_generic_user_procmsg_recv(struct tcmi_msg *self, struct kkc_sock *sock)
+{
+	int err = -EINVAL;
+	struct tcmi_generic_user_procmsg *self_msg = TCMI_GENERIC_USER_PROCMSG(self);
+
+	mdbg(INFO2, "Generic user message received");
+	
+	if ((err = kkc_sock_recv(sock, &self_msg->node_id, 
+				 sizeof(self_msg->node_id), KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to receive node id");
+		goto exit0;
+	}
+
+	if ((err = kkc_sock_recv(sock, &self_msg->size, 
+				 sizeof(self_msg->size), KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to receive size of user data");
+		goto exit0;
+	}
+
+	if ( self_msg->size > 0 ) {
+		if (!(self_msg->user_data = (char*)kmalloc(self_msg->size, GFP_KERNEL))) {
+			mdbg(ERR3, "Can't allocate memory for user data.");
+			goto exit0;
+		}
+	
+		/* Receive the user data */	
+		if ((err = kkc_sock_recv(sock, self_msg->user_data, 
+					self_msg->size, KKC_SOCK_BLOCK)) < 0) {
+			mdbg(ERR3, "Failed to receive user data");
+			goto exit0;
+		}	
+	} else {
+		self_msg->user_data = NULL;
+	}
+
+	return 0;
+
+	/* error handling*/
+ exit0:
+	return err;
+}
+
+/**
+ * \<\<private\>\> Sends the message via a specified connection. 
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for sending message data
+ * @return 0 when successfully sent.
+ */
+static int tcmi_generic_user_procmsg_send(struct tcmi_msg *self, struct kkc_sock *sock)
+{
+	int err;
+	struct tcmi_generic_user_procmsg *self_msg = TCMI_GENERIC_USER_PROCMSG(self);
+
+	if ((err = kkc_sock_send(sock, &self_msg->node_id, 
+				 sizeof(self_msg->node_id), KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to send node id");
+		goto exit0;
+	}
+
+	if ((err = kkc_sock_send(sock, &self_msg->size, 
+				 sizeof(self_msg->size), KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to send user data size");
+		goto exit0;
+	}
+
+	if ( self_msg->size > 0 ) {
+		/* Send the user data */	
+		if ((err = kkc_sock_send(sock, self_msg->user_data, 
+					self_msg->size, KKC_SOCK_BLOCK)) < 0) {
+			mdbg(ERR3, "Failed to send user data");
+			goto exit0;
+		}
+	}
+
+	mdbg(INFO2, "User data message sent. Pen ID=%d Auth data length=%d", self_msg->node_id, self_msg->size);
+
+	return 0;
+	/* error handling */
+ exit0:
+	return err;
+}
+
+/**
+ * \<\<private\>\> Frees custom message resources.
+ * The checkpoint image name string is released from memory.
+ *
+ * @param *self - this message instance
+ */
+static void tcmi_generic_user_procmsg_send_free(struct tcmi_msg *self)
+{
+	struct tcmi_generic_user_procmsg *self_msg = TCMI_GENERIC_USER_PROCMSG(self);	
+
+	mdbg(INFO3, "Freeing user message");
+	kfree(self_msg->user_data);
+}
+
+
+/** Message operations that support polymorphism. */
+static struct tcmi_msg_ops generic_user_procmsg_ops = {
+	.recv = tcmi_generic_user_procmsg_recv,
+	.send = tcmi_generic_user_procmsg_send,
+	.free = tcmi_generic_user_procmsg_send_free
+};
+
+
+/**
+ * @}
+ */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_err_procmsg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_err_procmsg.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,111 @@
+/**
+ * @file tcmi_err_procmsg.h - TCMI error message - carries an error status code.
+ *       
+ *                      
+ * 
+ *
+ *
+ * Date: 04/19/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_err_procmsg.h,v 1.2 2007/07/02 02:26:17 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_ERR_PROCMSG_H
+#define _TCMI_ERR_PROCMSG_H
+
+#include "tcmi_procmsg.h"
+
+/** @defgroup tcmi_err_procmsg_class tcmi_err_procmsg class
+ *
+ * @ingroup tcmi_procmsg_class
+ *
+ * This class represents a generic error process message. It carries an error
+ * code and can be used as response to any regular process message that has
+ * registered its rx constructor as the error rx constructor with the
+ * message factory. Unlike other messages, it doesn't define a fixed
+ * message ID. Instead the transfer message constructor
+ * (tcmi_err_procmsg_new_tx()) allows specifying a message ID that would
+ * carry the regular response message.
+ * 
+ * The constructor only sets error flags in the message ID.  The
+ * receiving party identifies the message based on the regular
+ * response ID. The message flags indicating an error make \link
+ * tcmi_msg_factory_class the message factory \endlink use the error rx
+ * constructor.  After delivery, the error message can be processed
+ * and the error code extracted.
+ *
+ * @{
+ */
+
+/** Compound structure, inherits from tcmi_msg_class */
+struct tcmi_err_procmsg {
+	/** parent class instance. */
+	struct tcmi_procmsg super;
+	/** error code that the message is carrying. */
+	int err_code;
+};
+
+
+/** \<\<public\>\> Error process message, constructor for receiving. */
+extern struct tcmi_msg* tcmi_err_procmsg_new_rx(u_int32_t msg_id);
+
+/** \<\<public\>\> Error process message, constructor for transferring. */
+extern struct tcmi_msg* tcmi_err_procmsg_new_tx(u_int32_t msg_id, u_int32_t trans_id, int err_code,
+						pid_t dst_pid);
+
+/** Casts to the tcmi_err_procmsg instance. */
+#define TCMI_ERR_PROCMSG(m) ((struct tcmi_err_procmsg*)m)
+
+/** 
+ * \<\<public\>\> Error code accessor.
+ *
+ * @param *self - pointer to this message instance
+ * @return error code that the message is carrying
+ */
+static inline int tcmi_err_procmsg_code(struct tcmi_procmsg *self)
+{
+	return TCMI_ERR_PROCMSG(self)->err_code;
+}
+
+
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_ERR_PROCMSG_PRIVATE
+
+/** Receives the message via a specified connection. */
+static int tcmi_err_procmsg_recv(struct tcmi_procmsg *self, struct kkc_sock *sock);
+
+/** Sends the message via a specified connection. */
+static int tcmi_err_procmsg_send(struct tcmi_procmsg *self, struct kkc_sock *sock);
+
+/** Message operations that support polymorphism. */
+static struct tcmi_procmsg_ops err_procmsg_ops;
+
+#endif /* TCMI_ERR_PROCMSG_PRIVATE */
+
+
+/**
+ * @}
+ */
+
+
+#endif /* _TCMI_ERR_PROCMSG_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_guest_started_procmsg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_guest_started_procmsg.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,184 @@
+/**
+ * @file tcmi_guest_started_procmsg.c - response from the guest task when it is succesfully started
+ *       
+ *                      
+ * 
+ *
+ *
+ * Date: 04/27/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_guest_started_procmsg.c,v 1.3 2007/09/02 10:54:25 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include <linux/slab.h>
+
+#include "tcmi_transaction.h"
+
+#define TCMI_GUEST_STARTED_PROCMSG_PRIVATE
+#include "tcmi_guest_started_procmsg.h"
+
+
+#include <dbg.h>
+
+
+
+/** 
+ * \<\<public\>\> Guest started message rx constructor.
+ * This method is called by the factory class.
+ *
+ * @param msg_id - message ID, to check with the actual response
+ * process message ID.
+ *
+ * @return a new guest started process message or NULL.
+ */
+struct tcmi_msg* tcmi_guest_started_procmsg_new_rx(u_int32_t msg_id)
+{
+	struct tcmi_guest_started_procmsg *msg;
+
+	/* Check if the factory is building what it really thinks. */
+	if (msg_id != TCMI_GUEST_STARTED_PROCMSG_ID) {
+		mdbg(ERR3, "Factory specified process message ID(%x) doesn't match real ID(%x)",
+		     msg_id, TCMI_GUEST_STARTED_PROCMSG_ID);
+		goto exit0;
+	}
+	if (!(msg = TCMI_GUEST_STARTED_PROCMSG(kmalloc(sizeof(struct tcmi_guest_started_procmsg), 
+						      GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate guest started process message");
+		goto exit0;
+	}
+	/* initialize the message for receiving */
+	if (tcmi_procmsg_init_rx(TCMI_PROCMSG(msg), TCMI_GUEST_STARTED_PROCMSG_ID, 
+				 &guest_started_procmsg_ops)) {
+		mdbg(ERR3, "Error initializing process message %x", msg_id);
+		goto exit1;
+	}
+
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+}
+
+/** 
+ * \<\<public\>\> Guest started process message tx constructor.
+ *
+ * The response message requires specifying the local PID(guest PID)
+ * of the sender in addition to the destination PID used for routing.
+ *
+ * @param trans_id - transaction ID that this message is replying to.
+ * @param dst_pid - destination process PID
+ * @param guest_pid - PID of the sending process
+ * @return a new test response message for the transfer or NULL.
+ */
+struct tcmi_msg* tcmi_guest_started_procmsg_new_tx(u_int32_t trans_id, pid_t dst_pid, 
+						  pid_t guest_pid)
+{
+	struct tcmi_guest_started_procmsg *msg;
+
+	if (!(msg = TCMI_GUEST_STARTED_PROCMSG(kmalloc(sizeof(struct tcmi_guest_started_procmsg), 
+						  GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate testing message");
+		goto exit0;
+	}
+
+	/* Initialize the message for transfer, no transaction
+	 * required, no timout, no response ID */
+	if (tcmi_procmsg_init_tx(TCMI_PROCMSG(msg), TCMI_GUEST_STARTED_PROCMSG_ID, &guest_started_procmsg_ops,
+				 dst_pid, 0,
+				 NULL, 0, 0, trans_id)) {
+		mdbg(ERR3, "Error initializing testing response message");
+		goto exit1;
+	}
+	msg->guest_pid = guest_pid;
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+	
+}
+
+
+/** @addtogroup tcmi_guest_started_procmsg_class
+ *
+ * @{
+ */
+
+/**
+ * \<\<private\>\> Receives the message via a specified connection. 
+ * Receiving the guest started process message requires reading guest PID from the
+ * specified connection.
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for receiving message data
+ * @return 0 when successfully received.
+ */
+static int tcmi_guest_started_procmsg_recv(struct tcmi_procmsg *self, struct kkc_sock *sock)
+{
+	int err;
+	struct tcmi_guest_started_procmsg *self_msg = TCMI_GUEST_STARTED_PROCMSG(self);
+
+	err = kkc_sock_recv(sock, &self_msg->guest_pid, 
+			    sizeof(self_msg->guest_pid), KKC_SOCK_BLOCK);
+
+	mdbg(INFO3, "Received guest PID %d", self_msg->guest_pid);
+	
+	return err;
+}
+
+/**
+ * \<\<private\>\> Sends the message via a specified connection. 
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for receiving message data
+ * @return 0 when successfully sent.
+ */
+static int tcmi_guest_started_procmsg_send(struct tcmi_procmsg *self, struct kkc_sock *sock)
+{
+	int err;
+	struct tcmi_guest_started_procmsg *self_msg = TCMI_GUEST_STARTED_PROCMSG(self);
+
+	err = kkc_sock_send(sock, &self_msg->guest_pid, 
+			    sizeof(self_msg->guest_pid), KKC_SOCK_BLOCK);
+
+	mdbg(INFO3, "Sent guest PID %d", self_msg->guest_pid);
+
+	return err;
+}
+
+
+
+/** Message operations that support polymorphism. */
+static struct tcmi_procmsg_ops guest_started_procmsg_ops = {
+	.recv = tcmi_guest_started_procmsg_recv,
+	.send = tcmi_guest_started_procmsg_send
+};
+
+
+/**
+ * @}
+ */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_skelresp_msg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_skelresp_msg.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,171 @@
+/**
+ * @file tcmi_skelresp_msg.c - TCMI error message - carries an error status code.
+ *       
+ *                      
+ * 
+ *
+ *
+ * Date: 04/11/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_skelresp_msg.c,v 1.2 2007/07/02 02:26:17 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include <linux/slab.h>
+
+#include "tcmi_transaction.h"
+
+#define TCMI_SKELRESP_MSG_PRIVATE
+#include "tcmi_skelresp_msg.h"
+
+
+#include <dbg.h>
+
+
+
+/** 
+ * \<\<public\>\> Skeleton response message rx constructor.
+ * This method is called by the factory class.
+ *
+ * @param msg_id - message ID that will be used for this error message
+ * instance.
+ * @return a new error message or NULL.
+ */
+struct tcmi_msg* tcmi_skelresp_msg_new_rx(u_int32_t msg_id)
+{
+	struct tcmi_skelresp_msg *msg;
+
+	/* Check if the factory is building what it really thinks. */
+	if (msg_id != TCMI_SKELRESP_MSG_ID) {
+		mdbg(ERR3, "Factory specified message ID(%x) doesn't match real ID(%x)",
+		     msg_id, TCMI_SKELRESP_MSG_ID);
+		goto exit0;
+	}
+	if (!(msg = TCMI_SKELRESP_MSG(kmalloc(sizeof(struct tcmi_skelresp_msg), 
+					    GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate testing message");
+		goto exit0;
+	}
+	/* Initialized the message for receiving, message ID is extended with error flags */
+	if (tcmi_msg_init_rx(TCMI_MSG(msg), TCMI_SKELRESP_MSG_ID, &skelresp_msg_ops)) {
+		mdbg(ERR3, "Error initializing testing message %x", msg_id);
+		goto exit1;
+	}
+
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+}
+
+/** 
+ * \<\<public\>\> Skeleton response message tx constructor.
+ *
+ * The testing response message is a one-way message, no transaction
+ * is needs to be started, the user only needs to specify the
+ * transaction ID that it is the reply to.
+ *
+ * When performing the generic tx init, the response message ID is
+ * specified (TCMI_SKELRESP_MSG_ID)
+ *
+ * @param trans_id - transaction ID that this message is replying to.
+ * @return a new test response message for the transfer or NULL.
+ */
+struct tcmi_msg* tcmi_skelresp_msg_new_tx(u_int32_t trans_id)
+{
+	struct tcmi_skelresp_msg *msg;
+
+	if (!(msg = TCMI_SKELRESP_MSG(kmalloc(sizeof(struct tcmi_skelresp_msg), 
+					    GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate testing message");
+		goto exit0;
+	}
+
+	/* Initialize the message for transfer, no transaction
+	 * required, no timout, no response ID */
+	if (tcmi_msg_init_tx(TCMI_MSG(msg), TCMI_SKELRESP_MSG_ID, &skelresp_msg_ops, 
+			     NULL, 0, 0, trans_id)) {
+		mdbg(ERR3, "Error initializing testing response message");
+		goto exit1;
+	}
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+	
+}
+
+
+/** @addtogroup tcmi_skelresp_msg_class
+ *
+ * @{
+ */
+
+/**
+ * \<\<private\>\> Receives the message via a specified connection. 
+ * Receiving the erro message requires reading the error code from the specified
+ * connection 
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for receiving message data
+ * @return 0 when successfully received.
+ */
+static int tcmi_skelresp_msg_recv(struct tcmi_msg *self, struct kkc_sock *sock)
+{
+	/* struct tcmi_skelresp_msg *self_msg = TCMI_SKELRESP_MSG(self); */
+	mdbg(INFO3, "Testing response message received");
+	
+	return 0;
+}
+
+/**
+ * \<\<private\>\> Receives the message via a specified connection. 
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for sending message data
+ * @return 0 when successfully sent.
+ */
+static int tcmi_skelresp_msg_send(struct tcmi_msg *self, struct kkc_sock *sock)
+{
+	/* struct tcmi_skelresp_msg *self_msg = TCMI_SKELRESP_MSG(self); */
+	mdbg(INFO3, "Testing response message sent");
+
+	return 0;
+}
+
+
+
+/** Message operations that support polymorphism. */
+static struct tcmi_msg_ops skelresp_msg_ops = {
+	.recv = tcmi_skelresp_msg_recv,
+	.send = tcmi_skelresp_msg_send
+};
+
+
+/**
+ * @}
+ */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_procmsg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_procmsg.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,143 @@
+/**
+ * @file tcmi_procmsg.h - TCMI process control communication message
+ *       
+ *                      
+ * 
+ *
+ *
+ * Date: 04/19/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_procmsg.h,v 1.3 2007/09/02 10:54:25 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_PROCMSG_H
+#define _TCMI_PROCMSG_H
+
+#include <linux/types.h> 
+
+#include "tcmi_msg.h"
+
+/** @defgroup tcmi_procmsg_class tcmi_procmsg class
+ *
+ * @ingroup tcmi_msg_class
+ *
+ * This class represents a generic process message. Process message,
+ * in addition to regular migration message, carries a target
+ * process PID. This PID will be used by the receiving party for message
+ * delivery. The only functionality provided by this class is
+ * to send/receive the process ID and notify the specific procmsg
+ * via send/receive/free operations.
+ * 
+ *
+ * @{
+ */
+
+/** Compound structure, inherits from tcmi_msg_class */
+struct tcmi_procmsg {
+	/** parent class instance */
+	struct tcmi_msg super;
+	/** destination process PID */
+	pid_t dst_pid;
+	/** == 1, if the we should switch to migration mode after recieving this message */
+	u_int8_t enforce_migmode;
+	/** proc message operations */
+	struct tcmi_procmsg_ops *msg_ops;
+};
+
+
+/** Process message operations that support polymorphism. */
+struct tcmi_procmsg_ops {
+	/** Receives the message via a specified connection. */
+	int (*recv)(struct tcmi_procmsg*, struct kkc_sock*);
+	/** Sends the message via a specified connection. */
+	int (*send)(struct tcmi_procmsg*, struct kkc_sock*);
+	/** Frees custom message resources. The destruction of the
+	 * actual message instance is handled internally by this
+	 * class */
+	void (*free)(struct tcmi_procmsg*);
+};
+
+
+/** \<\<public\>\> Initializes the process message for receiving. */
+extern int tcmi_procmsg_init_rx(struct tcmi_procmsg *self, u_int32_t msg_id,
+				struct tcmi_procmsg_ops *procmsg_ops);
+
+/** \<\<public\>\> Initializes the process message for transferring. */
+extern int tcmi_procmsg_init_tx(struct tcmi_procmsg *self, u_int32_t msg_id, 
+				struct tcmi_procmsg_ops *procmsg_ops,
+				pid_t dst_pid, u_int8_t enforce_migmode,
+				struct tcmi_slotvec *transactions, u_int32_t resp_msg_id,
+				u_int timeout,
+				u_int32_t resp_trans_id);
+
+/** 
+ * \<\<public\>\> Destination PID accessor.
+ *
+ * @param *self - this proc message instance
+ * @return destination PID
+ */
+static inline pid_t tcmi_procmsg_dst_pid(struct tcmi_procmsg *self)
+{
+	return self->dst_pid;
+}
+
+/** 
+ * \<\<public\>\> Getter of flag idicating whether we should switch to migmode or not
+ *
+ * @param *self - this proc message instance
+ * @return 1 if we should switch to migmode, 0 otherwise
+ */
+static inline pid_t tcmi_procmsg_enforce_migmode(struct tcmi_procmsg *self)
+{
+	return self->enforce_migmode;
+}
+
+
+/** Casts to the tcmi_procmsg instance. */
+#define TCMI_PROCMSG(m) ((struct tcmi_procmsg*)m)
+
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_PROCMSG_PRIVATE
+
+/** Receives the process message via a specified connection. */
+static int tcmi_procmsg_recv(struct tcmi_msg *self, struct kkc_sock *sock);
+
+/** Sends the process message via a specified connection. */
+static int tcmi_procmsg_send(struct tcmi_msg *self, struct kkc_sock *sock);
+
+/** Frees process message resources. */
+static void tcmi_procmsg_free(struct tcmi_msg *self);
+
+
+/** Message operations that support polymorphism. */
+static struct tcmi_msg_ops procmsg_ops;
+
+#endif  /* TCMI_PROCMSG_PRIVATE */
+
+
+/**
+ * @}
+ */
+
+
+#endif /* _TCMI_PROCMSG_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_skelresp_msg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_skelresp_msg.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,97 @@
+/**
+ * @file tcmi_skelresp_msg.h - TCMI test response message - can be used as skeleton
+ *                             for response message.
+ *       
+ *                      
+ * 
+ *
+ *
+ * Date: 04/11/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_skelresp_msg.h,v 1.2 2007/07/02 02:26:17 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_SKELRESP_MSG_H
+#define _TCMI_SKELRESP_MSG_H
+
+#include "tcmi_msg.h"
+#include "tcmi_err_msg.h"
+
+/** @defgroup tcmi_skelresp_msg_class tcmi_skelresp_msg class
+ *
+ * @ingroup tcmi_msg_class
+ *
+ * This class represents a test message and is intended to be used
+ * as a skeleton when implementing new messages in the TCMI protocol.
+ * To implement a new message the same steps need to be
+ * done as in case of a request message. In addition the instance should be
+ * aware of what messages it is a reply to.
+ *
+ * @{
+ */
+
+/** Compound structure, inherits from tcmi_msg_class */
+struct tcmi_skelresp_msg {
+	/** parent class instance */
+	struct tcmi_msg super;
+};
+
+
+
+
+/** \<\<public\>\> Skeleton response message rx constructor. */
+extern struct tcmi_msg* tcmi_skelresp_msg_new_rx(u_int32_t msg_id);
+
+/** \<\<public\>\> Test response message tx constructor. */
+extern struct tcmi_msg* tcmi_skelresp_msg_new_tx(u_int32_t trans_id);
+
+
+
+
+/** Message descriptor for the factory class, for error handling we used tcmi_errmsg_class */
+#define TCMI_SKELRESP_MSG_DSC \
+TCMI_MSG_DSC(TCMI_SKELRESP_MSG_ID, tcmi_skelresp_msg_new_rx, tcmi_err_msg_new_rx)
+
+/** Casts to the tcmi_skelresp_msg instance. */
+#define TCMI_SKELRESP_MSG(m) ((struct tcmi_skelresp_msg*)m)
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_SKELRESP_MSG_PRIVATE
+
+/** Receives the message via a specified connection. */
+static int tcmi_skelresp_msg_recv(struct tcmi_msg *self, struct kkc_sock *sock);
+
+/** Sends the message via a specified connection. */
+static int tcmi_skelresp_msg_send(struct tcmi_msg *self, struct kkc_sock *sock);
+
+/** Message operations that support polymorphism. */
+static struct tcmi_msg_ops skelresp_msg_ops;
+
+#endif /* TCMI_SKELRESP_MSG_PRIVATE */
+
+
+/**
+ * @}
+ */
+
+
+#endif /* _TCMI_SKELRESP_MSG_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_rpcresp_procmsg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_rpcresp_procmsg.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,400 @@
+/**
+ * @file tcmi_rpcresp_procmsg.c - TCMI error message - carries an error status code.
+ *       
+ *                      
+ * 
+ *
+ *
+ * Date: 20/04/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: tcmi_rpcresp_procmsg.c,v 1.6 2007/10/11 21:00:26 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2007 Petr Malat
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <dbg.h>
+#include <tcmi/task/tcmi_task.h>
+#include "tcmi_transaction.h"
+#include "tcmi_rpc_procmsg.h"
+
+#define TCMI_RPCRESP_PROCMSG_PRIVATE
+#include "tcmi_rpcresp_procmsg.h"
+
+
+#define SIZE_OF_ELEM_SIZE (self_msg->nmemb*sizeof(*(self_msg->elem_size)))
+#define SIZE_OF_ELEM_FREE (self_msg->nmemb*sizeof(*(self_msg->elem_free)))
+#define SIZE_OF_ELEM_BASE (self_msg->nmemb*sizeof(*(self_msg->elem_base)))
+
+
+
+/** 
+ * \<\<public\>\> RPC response message rx constructor.
+ *
+ * @param msg_id - message ID, to check with the actual response
+ * process message ID.
+ *
+ * @return a new rpc response process message or NULL.
+ */
+struct tcmi_msg* tcmi_rpcresp_procmsg_new_rx(u_int32_t msg_id)
+{
+	struct tcmi_rpcresp_procmsg *msg;
+
+	/* Check if the factory is building what it really thinks. */
+	if (msg_id != TCMI_RPCRESP_PROCMSG_ID) {
+		mdbg(ERR3, "Factory specified process message ID(%x) doesn't match real ID(%x)",
+		     msg_id, TCMI_RPCRESP_PROCMSG_ID);
+		goto exit0;
+	}
+	if (!(msg = TCMI_RPCRESP_PROCMSG(kmalloc(sizeof(struct tcmi_rpcresp_procmsg), 
+						  GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate RPC process message");
+		goto exit0;
+	}
+	msg->elem_free = NULL;
+	/* Initialized the message for receiving, message ID is extended with error flags */
+	if (tcmi_procmsg_init_rx(TCMI_PROCMSG(msg), TCMI_RPCRESP_PROCMSG_ID, 
+				 &rpcresp_procmsg_ops)) {
+		mdbg(ERR3, "Error initializing process message %x", msg_id);
+		goto exit1;
+	}
+
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+}
+
+/** 
+ * \<\<public\>\> Create response to rpc message
+ *
+ * @param m - message we are responding to
+ * @param rtn_code - value returned by RPC
+ * @param ... - size of the first arg., pointer to the first arg., size of the second arg. 
+ * pointer to the second arg. etc... ended by 0
+ *
+ * @return a new rpc response process message or NULL.
+ */
+struct tcmi_msg* tcmi_rpcresp_procmsg_create(struct tcmi_msg *m, long rtn_code, ...){
+	struct tcmi_rpcresp_procmsg *self_msg;
+	u_int16_t nmemb, i;
+	va_list args;
+
+	if ( !(self_msg = TCMI_RPCRESP_PROCMSG( tcmi_rpcresp_procmsg_new_tx(tcmi_msg_req_id(m), 
+						tcmi_task_remote_pid(current->tcmi.tcmi_task) ))) ){
+		mdbg(ERR3, "Error creating RPC response message");
+		return NULL;
+	}
+
+	va_start(args, rtn_code);
+	for(nmemb = 0; nmemb < TCMI_RPC_MAXPARAMS && va_arg(args, size_t) != 0; nmemb++ ) {
+		void* arg = va_arg(args, void*);
+		mdbg(INFO3, "Arg addr: %p", arg);
+		if ( arg == NULL ) {
+			mdbg(ERR3, "Null argument[%d] in RPC!", nmemb);
+			return NULL;
+		}
+	}	
+	va_end(args);
+	mdbg(INFO3, "creating RPC response message nmemb: %u, rtn: %ld", nmemb, rtn_code);
+
+	self_msg->nmemb = nmemb;
+	self_msg->rpcnum = tcmi_rpc_procmsg_num( TCMI_RPC_PROCMSG(m) );
+	self_msg->rtn_code = rtn_code;
+
+	if(nmemb > 0){
+		if( (self_msg->elem_free = kmalloc(SIZE_OF_ELEM_SIZE + 
+				SIZE_OF_ELEM_BASE + SIZE_OF_ELEM_FREE, GFP_KERNEL)) == NULL){
+			mdbg(ERR3, "Error creating RPC response message");
+			return NULL;
+		}
+		self_msg->elem_size = (void*)(self_msg->elem_free) + SIZE_OF_ELEM_FREE;
+		self_msg->elem_base = (void*)(self_msg->elem_size) + SIZE_OF_ELEM_SIZE;
+
+		va_start(args, rtn_code);
+		for(i = 0; i < nmemb; i++ ){
+			self_msg->elem_size[i] = (unsigned long)va_arg(args, size_t);
+			self_msg->elem_base[i] = va_arg(args, void*);
+			self_msg->elem_free[i] = TCMI_RPCRESP_PROCMSG_DONTFREE;
+			mdbg(INFO3, "Adding parametr #%d: at %p size %lu", i, self_msg->elem_base[i], (unsigned long)self_msg->elem_size[i] );
+		}
+		va_end(args);
+	}
+
+
+	return TCMI_MSG(self_msg);
+}
+
+/** 
+ * \<\<public\>\> Create and send rpc_proc_msg and return response
+ *
+ * @param rpcnum - RPC number
+ * @param ... - size of the first arg., pointer to the first arg., size of the second arg. 
+ * pointer to the second arg. etc... ended by 0
+ *
+ * @return a new rpc response process message or NULL.
+ */
+struct tcmi_msg* tcmi_rpcresp_procmsg_get_response(unsigned int rpcnum, ...){
+	struct tcmi_msg *m, *r = NULL;
+	va_list args;
+	size_t arg_size;
+	u_int32_t elem_size[TCMI_RPC_MAXPARAMS];
+	//unsigned long elem_free[TCMI_RPC_MAXPARAMS];
+       	void* elem_base[TCMI_RPC_MAXPARAMS];
+	u_int16_t nmemb;
+	struct tcmi_task* task;
+	
+	task = current->tcmi.tcmi_task;
+	va_start(args, rpcnum);
+
+	if ( (m = tcmi_rpc_procmsg_new_tx( tcmi_task_transactions(task), 
+					tcmi_task_remote_pid(task) )) == NULL ) 
+	{
+		mdbg(ERR3, "Can't create rpc message");
+		goto exit0;
+	}
+
+	for(nmemb = 0; nmemb < TCMI_RPC_MAXPARAMS && 
+			(arg_size = va_arg(args, size_t)) != 0; nmemb++ ){
+		elem_size[nmemb] = arg_size;
+		elem_base[nmemb] = va_arg(args, void*);
+		//elem_free[nmemb] = TCMI_RPCRESP_PROCMSG_DONTFREE;
+		mdbg(INFO3, "Adding parametr #%d: at %p size %lu", nmemb, elem_base[nmemb], (unsigned long)elem_size[nmemb] );
+	}	
+
+	TCMI_RPC_PROCMSG(m)->rpcnum = rpcnum;
+	TCMI_RPC_PROCMSG(m)->nmemb = nmemb;
+	TCMI_RPC_PROCMSG(m)->elem_size = elem_size;
+	TCMI_RPC_PROCMSG(m)->elem_base = elem_base;
+	//TCMI_RPC_PROCMSG(m)->elem_free = elem_free;
+	
+	tcmi_task_send_and_receive_msg(task, m, &r);
+
+	TCMI_RPC_PROCMSG(m)->elem_size = NULL;/* Prevent calling free on staticaly allocated resources*/
+	TCMI_RPC_PROCMSG(m)->free_data = false;
+	TCMI_RPC_PROCMSG(m)->nmemb = 0;
+
+	tcmi_msg_put(m);
+
+exit0:  va_end(args);
+	return r;
+}
+/** 
+ * \<\<public\>\> RPC response process message tx constructor.
+ *
+ * @param trans_id - transaction ID that this message is replying to.
+ * @param dst_pid - destination process PID
+ * @return a new test response message for the transfer or NULL.
+ */
+struct tcmi_msg* tcmi_rpcresp_procmsg_new_tx(u_int32_t trans_id, pid_t dst_pid)
+{
+	struct tcmi_rpcresp_procmsg *msg;
+
+	if (!(msg = TCMI_RPCRESP_PROCMSG(kmalloc(sizeof(struct tcmi_rpcresp_procmsg), 
+						  GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate RPC response message");
+		goto exit0;
+	}
+	msg->nmemb = 0;
+	msg->elem_free = NULL;
+	/* Initialize the message for transfer, no transaction
+	 * required, no timout, no response ID */
+	if (tcmi_procmsg_init_tx(TCMI_PROCMSG(msg), TCMI_RPCRESP_PROCMSG_ID, &rpcresp_procmsg_ops,
+				 dst_pid, 0,
+				 NULL, 0, 0, trans_id)) {
+		mdbg(ERR3, "Error initializing RPC response message");
+		goto exit1;
+	}
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+	
+}
+
+
+/** @addtogroup tcmi_rpcresp_procmsg_class
+ *
+ * @{
+ */
+
+/**
+ * \<\<private\>\> Receives the message via a specified connection. 
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for receiving message data
+ * @return 0 when successfully received.
+ *
+ * WARNING: Memory for data is allocated at one time, so when freeing free() must be called 
+ * on elem_base[0]. It's done automatically in last mdg_put();
+ */
+static int tcmi_rpcresp_procmsg_recv(struct tcmi_procmsg *self, struct kkc_sock *sock)
+{
+	/* struct tcmi_rpcresp_procmsg *self_msg = TCMI_RPCRESP_PROCMSG(self); */
+	int err, data_size, total, i;
+	struct tcmi_rpcresp_procmsg *self_msg = TCMI_RPCRESP_PROCMSG(self);
+
+	err = kkc_sock_recv(sock, &self_msg->rpcnum, 
+			    sizeof(self_msg->rpcnum) + sizeof(self_msg->nmemb) + 
+			    sizeof(self_msg->rtn_code), KKC_SOCK_BLOCK);
+	if( err < 0 ) {
+		mdbg(ERR3, "Error receiving RPC message header. Error code: %d", err);
+		return err;
+	}
+	total = err;
+	
+	if( self_msg->nmemb > 0 ){
+		/* Allocate memory for array of elements size and array of pointers to elements */
+		if( (self_msg->elem_free = kmalloc(SIZE_OF_ELEM_SIZE + 
+				SIZE_OF_ELEM_BASE + SIZE_OF_ELEM_FREE, GFP_KERNEL)) == NULL){
+			mdbg(ERR3, "Can't create rpc message");
+		}
+		self_msg->elem_size = (void*)(self_msg->elem_free) + SIZE_OF_ELEM_FREE;
+		self_msg->elem_base = (void*)(self_msg->elem_size) + SIZE_OF_ELEM_SIZE;
+		self_msg->elem_base[0] = NULL;
+
+		err = kkc_sock_recv(sock, self_msg->elem_size, SIZE_OF_ELEM_SIZE, KKC_SOCK_BLOCK);
+		if( err < 0 ) {
+			mdbg(ERR3, "Error receiving RPC#%d message elem size. Error code: %d", self_msg->rpcnum, err);
+			 return err;
+		}
+		total += err;
+
+		/* Allocate memory for data */
+		for(data_size = 0, i = 0; i < self_msg->nmemb; data_size += self_msg->elem_size[i++]);
+		if( (self_msg->elem_base[0] = kmalloc( data_size, GFP_KERNEL ) ) == NULL){
+			mdbg(ERR3, "Can't create rpc message2");
+		}
+		self_msg->elem_free[0] = TCMI_RPCRESP_PROCMSG_KFREE; /* We allocated data, so we have to free it */
+
+		err = kkc_sock_recv(sock, self_msg->elem_base[0], data_size, KKC_SOCK_BLOCK);
+		if( err < 0 ) {
+			mdbg(ERR3, "Error receiving RPC#%d message elements. Error code: %d", self_msg->rpcnum, err);	
+			return err;
+		}
+		total += err;
+
+		for( i = 1; i < self_msg->nmemb; i++ ){
+			self_msg->elem_base[i] = self_msg->elem_base[i-1] + self_msg->elem_size[i-1];
+			self_msg->elem_free[i] = TCMI_RPCRESP_PROCMSG_DONTFREE;
+		}
+	}
+	mdbg(INFO3, "Received RPC#%d response message (%d Bytes)", self_msg->rpcnum, total);
+	
+	return 0;
+}
+
+/**
+ * \<\<private\>\> Receives the message via a specified connection. 
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for sending message data
+ * @return 0 when successfully sent.
+ */
+static int tcmi_rpcresp_procmsg_send(struct tcmi_procmsg *self, struct kkc_sock *sock)
+{
+	int err, total, i;
+	struct tcmi_rpcresp_procmsg *self_msg = TCMI_RPCRESP_PROCMSG(self); 
+
+	err = kkc_sock_send(sock, &self_msg->rpcnum, 
+			    sizeof(self_msg->rpcnum) + sizeof(self_msg->nmemb) + 
+			    sizeof(self_msg->rtn_code), KKC_SOCK_BLOCK);
+	if( err < 0 ) {
+		mdbg(ERR3, "Error sending RPC#%d message header. Error code: %d", self_msg->rpcnum, err);
+		return err;
+	}
+	total = err;
+
+	if( self_msg->nmemb > 0 ){
+		err = kkc_sock_send(sock, self_msg->elem_size, SIZE_OF_ELEM_SIZE, KKC_SOCK_BLOCK);
+		if( err < 0 ) {
+			mdbg(ERR3, "Error sending RPC#%d message elem size. Error code: %d", self_msg->rpcnum, err);
+			return err;
+		}
+		total += err;
+
+		for( i = 0; i < self_msg->nmemb; i++ ){
+			err = kkc_sock_send(sock, self_msg->elem_base[i],
+					self_msg->elem_size[i], KKC_SOCK_BLOCK);
+
+			if( err < 0 ) {
+				mdbg(ERR3, "Error sending RPC#%d message element[%d]. Error code: %d", self_msg->rpcnum, i, err);
+				return err;
+			}
+			total += err;
+		}
+	}
+	mdbg(INFO3, "Sent RPC#%d message (%d Bytes)", self_msg->rpcnum, total);
+
+	return 0;
+}
+
+/**
+ * \<\<private\>\> Frees RPC message resources
+ *
+ * @param *self - this message instance
+ */
+static void tcmi_rpcresp_procmsg_free(struct tcmi_procmsg *self)
+{
+	struct tcmi_rpcresp_procmsg *self_msg = TCMI_RPCRESP_PROCMSG(self);
+	int i;
+	if( self_msg->nmemb ){
+		for( i = 0; i < self_msg->nmemb; i++ ){
+			switch( self_msg->elem_free[i] ){
+				case TCMI_RPCRESP_PROCMSG_DONTFREE:
+					mdbg(INFO3, "Skipping unallocate of #%d data at %p size %lu", 
+							i, self_msg->elem_base[i], (unsigned long)self_msg->elem_size[i]);
+					break;
+				case TCMI_RPCRESP_PROCMSG_KFREE:
+					mdbg(INFO3, "Freeing (kfree) data #%d at %p size %lu", 
+							i, self_msg->elem_base[i], (unsigned long)self_msg->elem_size[i]);
+					kfree(self_msg->elem_base[i]);
+					break;
+				case TCMI_RPCRESP_PROCMSG_VFREE:
+					mdbg(INFO3, "Freeing (vfree) data #%d at %p size %lu", 
+							i, self_msg->elem_base[i], (unsigned long)self_msg->elem_size[i]);
+					vfree(self_msg->elem_base[i]);
+					break;
+				default:
+					mdbg(ERR3, "Unknown action in %p->elem_free[%d]", self_msg, i);
+			}
+		}
+		kfree(self_msg->elem_free);
+	}
+}
+
+/** Message operations that support polymorphism. */
+static struct tcmi_procmsg_ops rpcresp_procmsg_ops = {
+	.recv = tcmi_rpcresp_procmsg_recv,
+	.send = tcmi_rpcresp_procmsg_send,
+	.free = tcmi_rpcresp_procmsg_free
+};
+
+
+/**
+ * @}
+ */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_procmsg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_procmsg.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,206 @@
+/**
+ * @file tcmi_procmsg.c - TCMI process control communication message
+ *       
+ *                      
+ * 
+ *
+ *
+ * Date: 04/19/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_procmsg.c,v 1.3 2007/09/02 10:54:25 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#define TCMI_PROCMSG_PRIVATE
+#include "tcmi_procmsg.h"
+
+
+#include <dbg.h>
+
+
+
+/** 
+ * \<\<public\>\> Initializes the process message for receiving.  The
+ * message operations specific to a particular process message class
+ * are stored in the instance, Regular tcmi message is supplied with
+ * generic proc message operations that handle the polymorphism
+ * further.
+ *
+ * @param *self - pointer to this message instance
+ * @param msg_id - ID of a particular message type
+ * @param *msg_ops - pointer to a particular process message 
+ * operations
+ * @return 0 upon success
+ */
+int tcmi_procmsg_init_rx(struct tcmi_procmsg *self, u_int32_t msg_id,
+			 struct tcmi_procmsg_ops *msg_ops)
+{
+	self->msg_ops = msg_ops;
+	/* Initialized the message for receiving. */
+	return tcmi_msg_init_rx(TCMI_MSG(self), msg_id, &procmsg_ops); 
+}
+
+/** 
+ * \<\<public\>\> Initializes the message for transferring.  Similar
+ * to rx version - the message operations specific to a particular
+ * process message class are stored in the instance, Regular tcmi
+ * message is supplied with generic proc message operations that
+ * handle the polymorphism further.
+ *
+ * @param *self - pointer to this message instance
+ * @param msg_id - ID of a particular message type
+ * @param *msg_ops - pointer to a particular process message specific operations
+ * @param dst_pid - destination process ID - filled in the header
+ * @param enfoce_migmode - do we require switch to migration mode upon recieving of this message?
+ * @param *transactions - storage for the new transaction(NULL for one-way messages)
+ * @param resp_msg_id - response message ID - required for the transaction
+ * if the transaction expires(NULL for one-way messages)
+ * @param timeout - transaction time out (0 for one-way messages)
+ * @param resp_trans_id - response transaction ID - used when
+ * this message is a response to a particular request. The user must set
+ * this ID based on the value ofr req_trans_id of the previously received message.
+ * @return 0 upon success
+ */
+int tcmi_procmsg_init_tx(struct tcmi_procmsg *self, u_int32_t msg_id, 
+			 struct tcmi_procmsg_ops *msg_ops,
+			 pid_t dst_pid, u_int8_t enforce_migmode,
+			 struct tcmi_slotvec *transactions, u_int32_t resp_msg_id,
+			 u_int timeout,
+			 u_int32_t resp_trans_id)
+{
+	self->dst_pid = dst_pid;
+	self->msg_ops = msg_ops;
+	self->enforce_migmode = enforce_migmode;
+	/* Initialize the message for transfer */
+	return tcmi_msg_init_tx(TCMI_MSG(self), msg_id, &procmsg_ops,
+				transactions, resp_msg_id,
+				timeout, resp_trans_id);
+}
+
+
+/** @addtogroup tcmi_procmsg_class
+ *
+ * @{
+ */
+
+/**
+ * \<\<private\>\> Receives the message via a specified connection. 
+ * Receiving the erro message requires reading the error code from the specified
+ * connection 
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for receiving message data
+ * @return 0 when successfully received.
+ */
+static int tcmi_procmsg_recv(struct tcmi_msg *self, struct kkc_sock *sock)
+{
+	int err;
+	struct tcmi_procmsg *self_proc = TCMI_PROCMSG(self);
+	struct tcmi_procmsg_ops *ops = self_proc->msg_ops;
+
+	if ((err = kkc_sock_recv(sock, &self_proc->dst_pid, 
+				 sizeof(self_proc->dst_pid), 
+				 KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to receive dest. PID");
+		goto exit0;
+	}
+
+	if ((err = kkc_sock_recv(sock, &self_proc->enforce_migmode, 
+				 sizeof(self_proc->enforce_migmode), 
+				 KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to receive enforce migmode flag");
+		goto exit0;
+	}
+
+	mdbg(INFO3, "Received process message (PID=%u)", self_proc->dst_pid);
+	if (ops && ops->recv)
+		err = ops->recv(self_proc, sock);
+
+	/* error handling */
+ exit0:
+	return err;
+}
+
+/**
+ * \<\<private\>\> Sends the message via a specified connection. 
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for sending message data
+ * @return 0 when successfully sent.
+ */
+static int tcmi_procmsg_send(struct tcmi_msg *self, struct kkc_sock *sock)
+{
+	int err;
+	struct tcmi_procmsg *self_proc = TCMI_PROCMSG(self);
+	struct tcmi_procmsg_ops *ops = self_proc->msg_ops;
+
+	if ((err = kkc_sock_send(sock, &self_proc->dst_pid, 
+				 sizeof(self_proc->dst_pid), 
+				 KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to send dest. PID");
+		goto exit0;
+	}
+
+	if ((err = kkc_sock_send(sock, &self_proc->enforce_migmode, 
+				 sizeof(self_proc->enforce_migmode), 
+				 KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to send enforce migmode flag");
+		goto exit0;
+	}
+
+	mdbg(INFO3, "Sent process message (PID=%u)", self_proc->dst_pid);
+	if (ops && ops->send)
+		err = ops->send(self_proc, sock);
+
+	/* error handling */
+ exit0:
+	return err;
+}
+
+/**
+ * \<\<private\>\> Frees custom message resources
+ * All work is delegated to a specific process message method
+ *
+ * @param *self - this message instance
+ */
+static void tcmi_procmsg_free(struct tcmi_msg *self)
+{
+	struct tcmi_procmsg *self_proc = TCMI_PROCMSG(self);
+	struct tcmi_procmsg_ops *ops = self_proc->msg_ops;
+
+	mdbg(INFO3, "Freeing process message (PID=%u)", self_proc->dst_pid);
+	if (ops && ops->free)
+		ops->free(self_proc);
+}
+
+
+/** Message operations that support polymorphism. */
+static struct tcmi_msg_ops procmsg_ops = {
+	.recv = tcmi_procmsg_recv,
+	.send = tcmi_procmsg_send,
+	.free = tcmi_procmsg_free
+};
+
+
+/**
+ * @}
+ */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_generic_user_procmsg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_generic_user_procmsg.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,103 @@
+/**
+ * @file tcmi_generic_user_msg.h - generic userspace message.
+ */
+
+#ifndef TCMI_GENERIC_USER_PROCMSG_H
+#define TCMI_GENERIC_USER_PROCMSG_H
+
+#include "tcmi_msg.h"
+
+/** @defgroup tcmi_generic_user_class tcmi_generic_user_procmsg class
+ *
+ * @ingroup tcmi_msg_class
+ *
+ * This message can be send both by PEN or CCN. It can contain any data that are passed from user space to the director of peer node.
+ * 
+ * @{
+ */
+
+/** Generic user message structure */
+struct tcmi_generic_user_procmsg {
+	/** parent class instance. */
+	struct tcmi_msg super;
+	/** Id of the requestor PEN or CCN */
+	u_int32_t node_id;
+
+	/** User passed data. Opaque to the kernel part, this is purely user space responsibilithy to provide and parse those. */
+	char *user_data;
+	/** Size of user data */
+	u_int32_t size;
+};
+
+
+
+
+/** \<\<public\>\> Message consutructor for receiving. */
+extern struct tcmi_msg* tcmi_generic_user_procmsg_new_rx(u_int32_t msg_id);
+
+/** \<\<public\>\> Message constructor for transferring. */
+extern struct tcmi_msg* tcmi_generic_user_procmsg_new_tx(u_int32_t node_id, char* user_data, int size);
+
+
+/** \<\<public\>\> Message descriptor for the factory class, there is no error
+ * handling as this is the starting request */
+#define TCMI_GENERIC_USER_PROCMSG_DSC TCMI_MSG_DSC(TCMI_GENERIC_USER_PROCMSG_ID, tcmi_generic_user_procmsg_new_rx, NULL)
+
+/** Casts to the tcmi_generic_user_msg instance. */
+#define TCMI_GENERIC_USER_PROCMSG(m) ((struct tcmi_generic_user_procmsg*)m)
+
+/**
+ * \<\<public\>\> Node id getter
+ * 
+ * @param *self - this message instance
+ * @return Node id
+ */
+static inline u_int32_t tcmi_generic_user_procmsg_node_id(struct tcmi_generic_user_procmsg *self)
+{
+	return self->node_id;
+}
+
+/**
+ * \<\<public\>\> User data length getter
+ * 
+ * @param *self - this message instance
+ * @return data length
+ */
+static inline u_int32_t tcmi_generic_user_procmsg_user_data_size(struct tcmi_generic_user_procmsg *self)
+{
+	return self->size;
+}
+
+/**
+ * \<\<public\>\> User data data getter
+ * 
+ * @param *self - this message instance
+ * @return User data
+ */
+static inline char* tcmi_generic_user_procmsg_user_data(struct tcmi_generic_user_procmsg *self)
+{
+	return self->user_data;
+}
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_GENERIC_USER_MSG_PRIVATE
+
+/** Receives the message via a specified connection. */
+static int tcmi_generic_user_procmsg_recv(struct tcmi_msg *self, struct kkc_sock *sock);
+
+/** Sends the message via a specified connection. */
+static int tcmi_generic_user_procmsg_send(struct tcmi_msg *self, struct kkc_sock *sock);
+
+/** Message operations that support polymorphism. */
+static struct tcmi_msg_ops generic_user_procmsg_ops;
+
+#endif
+
+
+/**
+ * @}
+ */
+
+
+#endif
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_exit_procmsg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_exit_procmsg.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,180 @@
+/**
+ * @file tcmi_exit_procmsg.c - TCMI exit message, send by guest task from PEN
+ *       
+ *                      
+ * 
+ *
+ *
+ * Date: 04/27/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_exit_procmsg.c,v 1.3 2007/09/02 10:54:25 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include <linux/slab.h>
+
+#include "tcmi_transaction.h"
+
+#define TCMI_EXIT_PROCMSG_PRIVATE
+#include "tcmi_exit_procmsg.h"
+
+
+#include <dbg.h>
+
+
+
+/** 
+ * \<\public\>\> Exit message rx constructor.
+ * This method is called by the factory class.
+ *
+ * @param msg_id - message ID - used for verification
+ * instance.
+ * @return a new error message or NULL.
+ */
+struct tcmi_msg* tcmi_exit_procmsg_new_rx(u_int32_t msg_id)
+{
+	struct tcmi_exit_procmsg *msg;
+
+	/* Check if the factory is building what it really thinks. */
+	if (msg_id != TCMI_EXIT_PROCMSG_ID) {
+		mdbg(ERR3, "Factory specified message ID(%x) doesn't match real ID(%x)",
+		     msg_id, TCMI_EXIT_PROCMSG_ID);
+		goto exit0;
+	}
+	/* Allocate the instance */
+	if (!(msg = TCMI_EXIT_PROCMSG(kmalloc(sizeof(struct tcmi_exit_procmsg), GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate test request message");
+		goto exit0;
+	}
+	/* Initialized the message for receiving. */
+	if (tcmi_procmsg_init_rx(TCMI_PROCMSG(msg), TCMI_EXIT_PROCMSG_ID, &exit_procmsg_ops)) {
+		mdbg(ERR3, "Error initializing test request message %x", msg_id);
+		goto exit1;
+	}
+
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+}
+
+/** 
+ * \<\public\>\> Exit message tx constructor.
+ *
+ * The exit message has no transaction associated. The user specifies
+ * the desired exit code and the destination PID only.
+ *
+ *
+ * @param dst_pid - destination process PID
+ * @param code - exit code 
+ * @return a new error ready for the transfer or NULL.
+ */
+struct tcmi_msg* tcmi_exit_procmsg_new_tx(pid_t dst_pid, int32_t code)
+{
+	struct tcmi_exit_procmsg *msg;
+
+	if (!(msg = TCMI_EXIT_PROCMSG(kmalloc(sizeof(struct tcmi_exit_procmsg), GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate test request message");
+		goto exit0;
+	}
+
+	/* Initialize the message for transfer, no transaction to be
+	 * created, no response expected, no timeout for response, not a reply to any transaction */
+	if (tcmi_procmsg_init_tx(TCMI_PROCMSG(msg), TCMI_EXIT_PROCMSG_ID, &exit_procmsg_ops, 
+				 dst_pid, 0,
+				 NULL, 0, 
+				 0, TCMI_TRANSACTION_INVAL_ID)) {
+		mdbg(ERR3, "Error initializing test request message message");
+		goto exit1;
+	}
+	msg->code = code;
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+	
+}
+
+
+/** @addtogroup tcmi_exit_procmsg_class
+ *
+ * @{
+ */
+
+/**
+ * \<\<private\>\> Receives the message via a specified connection. 
+ * Receiving the exit code requires reading the error code from the specified
+ * connection 
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for receiving message data
+ * @return 0 when successfully received.
+ */
+static int tcmi_exit_procmsg_recv(struct tcmi_procmsg *self, struct kkc_sock *sock)
+{
+	int err;
+	struct tcmi_exit_procmsg *self_msg = TCMI_EXIT_PROCMSG(self);
+
+	err = kkc_sock_recv(sock, &self_msg->code, 
+			    sizeof(self_msg->code), KKC_SOCK_BLOCK);
+	mdbg(INFO3, "Received exit code: %lu", (long)self_msg->code);
+	
+	return err;
+}
+
+/**
+ * \<\<private\>\> Sends the exit code via a specified connection. 
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for receiving message data
+ * @return 0 when successfully sent.
+ */
+static int tcmi_exit_procmsg_send(struct tcmi_procmsg *self, struct kkc_sock *sock)
+{
+	int err;
+	struct tcmi_exit_procmsg *self_msg = TCMI_EXIT_PROCMSG(self); 
+
+	err = kkc_sock_send(sock, &self_msg->code, 
+			    sizeof(self_msg->code), KKC_SOCK_BLOCK);
+
+	mdbg(INFO3, "Sent exit code: %lu", (long)self_msg->code);
+
+	return err;
+}
+
+
+
+/** Message operations that support polymorphism. */
+static struct tcmi_procmsg_ops exit_procmsg_ops = {
+	.recv = tcmi_exit_procmsg_recv,
+	.send = tcmi_exit_procmsg_send
+};
+
+
+/**
+ * @}
+ */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_skel_procmsg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_skel_procmsg.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,174 @@
+/**
+ * @file tcmi_skel_procmsg.c - TCMI skeleton message - example message implementation.
+ *       
+ *                      
+ * 
+ *
+ *
+ * Date: 04/19/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_skel_procmsg.c,v 1.3 2007/09/02 10:54:25 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include <linux/slab.h>
+
+#include "tcmi_transaction.h"
+
+#define TCMI_SKEL_PROCMSG_PRIVATE
+#include "tcmi_skel_procmsg.h"
+
+
+#include <dbg.h>
+
+
+
+/** 
+ * \<\<public\>\> Skeleton message rx constructor.
+ * This method is called by the factory class.
+ *
+ * @param msg_id - message ID that will be used for this error message
+ * instance.
+ * @return a new error message or NULL.
+ */
+struct tcmi_msg* tcmi_skel_procmsg_new_rx(u_int32_t msg_id)
+{
+	struct tcmi_skel_procmsg *msg;
+
+	/* Check if the factory is building what it really thinks. */
+	if (msg_id != TCMI_SKEL_PROCMSG_ID) {
+		mdbg(ERR3, "Factory specified message ID(%x) doesn't match real ID(%x)",
+		     msg_id, TCMI_SKEL_PROCMSG_ID);
+		goto exit0;
+	}
+	/* Allocate the instance */
+	if (!(msg = TCMI_SKEL_PROCMSG(kmalloc(sizeof(struct tcmi_skel_procmsg), GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate test request message");
+		goto exit0;
+	}
+	/* Initialized the message for receiving. */
+	if (tcmi_procmsg_init_rx(TCMI_PROCMSG(msg), TCMI_SKEL_PROCMSG_ID, &skel_procmsg_ops)) {
+		mdbg(ERR3, "Error initializing test request message %x", msg_id);
+		goto exit1;
+	}
+
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+}
+
+/** 
+ * \<\<public\>\> Skeleton message tx constructor.
+ *
+ * The testing message can have a transaction associated with it =
+ * there is a response expected for this message by the
+ * sender. Therefore, the user specifies the transaction slot vector.
+ *
+ * When performing the generic proc tx init, the response message ID is
+ * specified (TCMI_RESPSKEL_PROCMSG_ID) so that it will be associated with the
+ * transaction. Also, the generic tx initializer is supplied with the destination
+ * process ID.
+ *
+ * @param *transactions - storage for the new transaction(NULL for one-way messages)
+ * @param dst_pid - destination process PID
+ * @return a new error ready for the transfer or NULL.
+ */
+struct tcmi_msg* tcmi_skel_procmsg_new_tx(struct tcmi_slotvec *transactions, pid_t dst_pid)
+{
+	struct tcmi_skel_procmsg *msg;
+
+	if (!(msg = TCMI_SKEL_PROCMSG(kmalloc(sizeof(struct tcmi_skel_procmsg), GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate test request message");
+		goto exit0;
+	}
+
+	/* Initialize the message for transfer */
+	if (tcmi_procmsg_init_tx(TCMI_PROCMSG(msg), TCMI_SKEL_PROCMSG_ID, &skel_procmsg_ops, 
+				 dst_pid, 0,
+				 transactions, TCMI_SKELRESP_PROCMSG_ID,
+				 TCMI_SKEL_PROCMSGTIMEOUT, TCMI_TRANSACTION_INVAL_ID)) {
+		mdbg(ERR3, "Error initializing test request message message");
+		goto exit1;
+	}
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+	
+}
+
+
+/** @addtogroup tcmi_skel_procmsg_class
+ *
+ * @{
+ */
+
+/**
+ * \<\<private\>\> Receives the message via a specified connection. 
+ * Receiving the erro message requires reading the error code from the specified
+ * connection 
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for receiving message data
+ * @return 0 when successfully received.
+ */
+static int tcmi_skel_procmsg_recv(struct tcmi_procmsg *self, struct kkc_sock *sock)
+{
+	/* struct tcmi_skel_procmsg *self_msg = TCMI_SKEL_PROCMSG(self); */  
+	mdbg(INFO2, "Test request process message received");
+	
+	return 0;
+}
+
+/**
+ * \<\<private\>\> Receives the message via a specified connection. 
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for sending message data
+ * @return 0 when successfully sent.
+ */
+static int tcmi_skel_procmsg_send(struct tcmi_procmsg *self, struct kkc_sock *sock)
+{
+	/* struct tcmi_skel_procmsg *self_msg = TCMI_SKEL_PROCMSG(self); */
+	mdbg(INFO2, "Test request process message sent");
+
+	return 0;
+}
+
+
+
+/** Message operations that support polymorphism. */
+static struct tcmi_procmsg_ops skel_procmsg_ops = {
+	.recv = tcmi_skel_procmsg_recv,
+	.send = tcmi_skel_procmsg_send
+};
+
+
+/**
+ * @}
+ */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_ppm_p_emigrate_msg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_ppm_p_emigrate_msg.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,139 @@
+/**
+ * @file tcmi_ppm_p_emigrate_msg.h - PPM_P emigration message.
+ *       
+ *                      
+ * 
+ *
+ *
+ * Date: 04/27/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_ppm_p_emigrate_msg.h,v 1.3 2007/09/02 10:54:25 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_PPM_P_EMIGRATE_MSG_H
+#define _TCMI_PPM_P_EMIGRATE_MSG_H
+
+#include "tcmi_msg.h"
+
+/** @defgroup tcmi_ppm_p_emigrate_msg_class tcmi_ppm_p_emigrate_msg class
+ *
+ * @ingroup tcmi_msg_class
+ *
+ * This class represents a message for preemptive process migration
+ * via a physical checkpoint image.  The migrating process sends this
+ * message to the PEN, that is responsible for creation of a guest
+ * process and finishing the migration. Should the migration fail, an
+ * error is generated and sent back as a reply.  This is a migration
+ * control message that will be received by the migration manager and
+ * passed onto the newly created guest. The response to this message
+ * is however a process control message (\link
+ * tcmi_guest_started_procmsg_class TCMI_GUEST_STARTED_PROCMSG
+ * \endlink) that will be directly routed to the sending task.
+ *
+ * The sending task specifies it's PID, so that the receiving guest can use
+ * it for further communication via process control connection. Also,
+ * the checkpoint file name is specified as part of the message.
+ *
+ *
+ *
+ * @{
+ */
+
+/** Compound structure, inherits from tcmi_msg_class */
+struct tcmi_ppm_p_emigrate_msg {
+	/** parent class instance. */
+	struct tcmi_msg super;
+	/** groups pid and size, so they can be sent/received at once. */
+	struct {
+		/** remote PID,  used for further communication. */
+		pid_t reply_pid;
+		/** size of the checkpoint name in bytes (including
+		    trailing zero) */
+		int32_t size;
+	} pid_and_size  __attribute__((__packed__));
+	/** name of the checkpoint file. */
+	char *ckpt_name;
+};
+
+
+
+
+/** \<\<public\>\> PPM phys. emigrate message constructor for receiving. */
+extern struct tcmi_msg* tcmi_ppm_p_emigrate_msg_new_rx(u_int32_t msg_id);
+
+/** \<\<public\>\> PPM phys. emigrate message constructor for transferring. */
+extern struct tcmi_msg* tcmi_ppm_p_emigrate_msg_new_tx(struct tcmi_slotvec *transactions, 
+						       pid_t reply_pid, char *ckpt_name);
+
+
+/** \<\<public\>\> Message descriptor for the factory class, there is no error
+ * handling as this is the starting request */
+#define TCMI_PPM_P_EMIGRATE_MSG_DSC TCMI_MSG_DSC(TCMI_PPM_P_EMIGRATE_MSG_ID, tcmi_ppm_p_emigrate_msg_new_rx, NULL)
+/** Response time out is set to 60 seconds*/
+#define TCMI_PPM_P_EMIGRATE_MSGTIMEOUT 60*HZ
+
+/** Casts to the tcmi_ppm_p_emigrate_msg instance. */
+#define TCMI_PPM_P_EMIGRATE_MSG(m) ((struct tcmi_ppm_p_emigrate_msg*)m)
+
+/**
+ * \<\<public\>\> Remote PID accessor.
+ * 
+ * @param *self - this message instance
+ * @return remote PID
+ */
+static inline pid_t tcmi_ppm_p_emigrate_msg_reply_pid(struct tcmi_ppm_p_emigrate_msg *self)
+{
+	return self->pid_and_size.reply_pid;
+}
+
+/**
+ * \<\<public\>\> Checkpoint name accessor.
+ * 
+ * @param *self - this message instance
+ * @return checkpoint name string
+ */
+static inline char* tcmi_ppm_p_emigrate_msg_ckpt_name(struct tcmi_ppm_p_emigrate_msg *self)
+{
+	return self->ckpt_name;
+}
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_PPM_P_EMIGRATE_MSG_PRIVATE
+
+/** Receives the message via a specified connection. */
+static int tcmi_ppm_p_emigrate_msg_recv(struct tcmi_msg *self, struct kkc_sock *sock);
+
+/** Sends the message via a specified connection. */
+static int tcmi_ppm_p_emigrate_msg_send(struct tcmi_msg *self, struct kkc_sock *sock);
+
+/** Message operations that support polymorphism. */
+static struct tcmi_msg_ops ppm_p_emigrate_msg_ops;
+
+#endif /* TCMI_PPM_P_EMIGRATE_MSG_PRIVATE */
+
+
+/**
+ * @}
+ */
+
+
+#endif /* _TCMI_PPM_P_EMIGRATE_MSG_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_err_msg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_err_msg.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,109 @@
+/**
+ * @file tcmi_err_msg.h - TCMI error message - carries an error status code.
+ *       
+ *                      
+ * 
+ *
+ *
+ * Date: 04/11/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_err_msg.h,v 1.3 2007/09/02 10:54:25 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_ERR_MSG_H
+#define _TCMI_ERR_MSG_H
+
+#include "tcmi_msg.h"
+
+/** @defgroup tcmi_err_msg_class tcmi_err_msg class
+ *
+ * @ingroup tcmi_msg_class
+ *
+ * This class represents a generic error message. It carries an error
+ * code and can be used as response to any regular message that has
+ * registered its rx constructor as the error rx constructor with the
+ * message factory. Unlike other messages, it doesn't define a fixed
+ * message ID. Instead the transfer message constructor
+ * (tcmi_err_msg_new_tx()) allows specifying a message ID that would
+ * carry the regular response message.
+ * 
+ * The constructor only sets error flags in the message ID.  The
+ * receiving party identifies the message based on the regular
+ * response ID. The message flags indicating an error make \link
+ * tcmi_msg_factory_class the message factory \endlink use the error rx
+ * constructor.  After delivery, the error message can be processed
+ * and the error code extracted.
+ *
+ * @{
+ */
+
+/** Compound structure, inherits from tcmi_msg_class */
+struct tcmi_err_msg {
+	/** parent class instance. */
+	struct tcmi_msg super;
+	/** error code that the message is carrying. */
+	int32_t err_code;
+};
+
+
+/** \<\<public\>\> Error message, constructor for receiving. */
+extern struct tcmi_msg* tcmi_err_msg_new_rx(u_int32_t msg_id);
+
+/** \<\<public\>\> Error message, constructor for transferring. */
+extern struct tcmi_msg* tcmi_err_msg_new_tx(u_int32_t msg_id, u_int32_t trans_id, int32_t err_code);
+
+/** Casts to the tcmi_err_msg instance. */
+#define TCMI_ERR_MSG(m) ((struct tcmi_err_msg*)m)
+
+/** 
+ * \<\<public\>\> Error code accessor.
+ *
+ * @param *self - pointer to this message instance
+ * @return error code that the message is carrying
+ */
+static inline int32_t tcmi_err_msg_code(struct tcmi_msg *self)
+{
+	return TCMI_ERR_MSG(self)->err_code;
+}
+
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_ERR_MSG_PRIVATE
+
+/** Receives the message via a specified connection. */
+static int tcmi_err_msg_recv(struct tcmi_msg *self, struct kkc_sock *sock);
+
+/** Sends the message via a specified connection. */
+static int tcmi_err_msg_send(struct tcmi_msg *self, struct kkc_sock *sock);
+
+/** Message operations that support polymorphism. */
+static struct tcmi_msg_ops err_msg_ops;
+
+#endif /* TCMI_ERR_MSG_PRIVATE */
+
+
+/**
+ * @}
+ */
+
+
+#endif /* _TCMI_ERR_MSG_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_msg_factory.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_msg_factory.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,84 @@
+/**
+ * @file tcmi_msg_factory.c - TCMI message factory message.
+ *       
+ *                      
+ * 
+ *
+ *
+ * Date: 04/09/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_msg_factory.c,v 1.2 2007/07/02 02:26:17 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#define TCMI_MSG_FACTORY_PRIVATE
+#include "tcmi_msg_factory.h"
+#include "tcmi_messages_dsc.h"
+
+#include <dbg.h>
+
+/** 
+ * \<\<public\>\> Materializes the message.
+ * Initially, a verification is performed whether the message ID belongs to the
+ * requested message group. This way, unexpected messages from a wrong message
+ * group won't get materialized.
+ *
+ * Once a proper message descriptor is retrieved, the message creation
+ * is delegated to the \link tcmi_msg_class protocol message super class \endlink
+ * 
+ * @param msg_id - Full identifier of the message including flags.
+ * @param msg_group - this is for verification, when the factory user wants to make sure
+ * the message comes from a particular message group
+ * @return message instance or NULL
+ */
+extern struct tcmi_msg* tcmi_msg_factory(u_int32_t msg_id, u_int32_t msg_group)
+{
+	struct tcmi_msg *msg = NULL;
+	u_int32_t group_id = TCMI_MSG_GROUP(msg_id);
+	u_int32_t index = TCMI_MSG_INDEX(msg_id);
+	
+	/* check if the requested group matches the message */
+	if ((group_id != msg_group) && (msg_group != TCMI_MSG_GROUP_ANY)) {
+		mdbg(ERR3, "Requested message ID (%x), doesn't match the requested group(%x)",
+		     TCMI_MSG_GROUP(msg_id), msg_group);
+		goto exit0;
+
+	}
+	/* check if the group id is valid and the index identifies a
+	 * message within a group */
+	if (!((group_id < TCMI_MSG_GROUP_LAST) &&
+	     (index < msg_groups[group_id].msg_count))) {
+		mdbg(ERR3, "Invalid message group(%d) or index(%d)",
+		     group_id, index);
+		goto exit0;
+	}
+	mdbg(INFO3, "Found a valid message group(%d) and index(%d), msg_count=%d",
+	     group_id, index, msg_groups[group_id].msg_count);
+	if (!(msg = tcmi_msg_new_rx(msg_id, &msg_groups[group_id].dsc[index]))) {
+		mdbg(ERR3, "Failed to allocate a new message ID %x", msg_id);
+	}
+		
+	return msg;
+
+	/* error handling */
+ exit0:
+	return NULL;
+}
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_authenticate_resp_msg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_authenticate_resp_msg.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,199 @@
+/**
+ * @file tcmi_authenticate_resp_msg.c - TCMI authenticate response message
+ */
+#include <linux/slab.h>
+
+#include "tcmi_transaction.h"
+
+#define TCMI_AUTHENTICATE_RESP_MSG_PRIVATE
+#include "tcmi_authenticate_resp_msg.h"
+
+
+#include <dbg.h>
+
+
+
+/** 
+ * \<\<public\>\> Authenticate response message rx constructor.
+ * This method is called by the factory class.
+ *
+ * @param msg_id - message ID that will be used for this error message
+ * instance.
+ * @return a new message or NULL.
+ */
+struct tcmi_msg* tcmi_authenticate_resp_msg_new_rx(u_int32_t msg_id)
+{
+	struct tcmi_authenticate_resp_msg *msg;
+
+	/* Check if the factory is building what it really thinks. */
+	if (msg_id != TCMI_AUTHENTICATE_RESP_MSG_ID) {
+		mdbg(ERR3, "Factory specified message ID(%x) doesn't match real ID(%x)",
+		     msg_id, TCMI_AUTHENTICATE_RESP_MSG_ID);
+		goto exit0;
+	}
+	if (!(msg = TCMI_AUTHENTICATE_RESP_MSG(kmalloc(sizeof(struct tcmi_authenticate_resp_msg), 
+					    GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate auth resp message");
+		goto exit0;
+	}
+	/* Initialized the message for receiving, message ID is extended with error flags */
+	if (tcmi_msg_init_rx(TCMI_MSG(msg), TCMI_AUTHENTICATE_RESP_MSG_ID, &authenticate_resp_msg_ops)) {
+		mdbg(ERR3, "Error initializing auth resp message %x", msg_id);
+		goto exit1;
+	}
+
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+}
+
+/** 
+ * \<\<public\>\> Authenticate response message tx constructor.
+ *
+ *
+ * @param trans_id - transaction ID that this message is replying to.
+ * @param ccn_id - ID of this CCN
+ * @param ccn_arch - Architecture of CCN
+ * @param result_code Result of the authentication
+ * @param mount_params Paremeters of the distributed FS mount to be performed on PEN side
+ * @return a new test response message for the transfer or NULL.
+ */
+struct tcmi_msg* tcmi_authenticate_resp_msg_new_tx(u_int32_t trans_id, u_int32_t ccn_id, enum arch_ids ccn_arch, int8_t result_code, struct fs_mount_params* mount_params)
+{
+	struct tcmi_authenticate_resp_msg *msg;
+
+	if (!(msg = TCMI_AUTHENTICATE_RESP_MSG(kmalloc(sizeof(struct tcmi_authenticate_resp_msg), 
+					    GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate auth resp message");
+		goto exit0;
+	}
+
+	msg->ccn_id = ccn_id;
+	msg->ccn_arch = ccn_arch;
+	msg->result_code = result_code;
+	msg->mount_params = *mount_params;
+
+	if (tcmi_msg_init_tx(TCMI_MSG(msg), TCMI_AUTHENTICATE_RESP_MSG_ID, &authenticate_resp_msg_ops, 
+			     NULL, 0, 0, trans_id)) {
+		mdbg(ERR3, "Error initializing authenticate response message");
+		goto exit1;
+	}
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+	
+}
+
+
+/** @addtogroup tcmi_authenticate_resp_msg_class
+ *
+ * @{
+ */
+
+/**
+ * \<\<private\>\> Receives the message via a specified connection. 
+ * Receiving the erro message requires reading the error code from the specified
+ * connection 
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for receiving message data
+ * @return 0 when successfully received.
+ */
+static int tcmi_authenticate_resp_msg_recv(struct tcmi_msg *self, struct kkc_sock *sock)
+{
+	int err;
+	struct tcmi_authenticate_resp_msg *self_msg = TCMI_AUTHENTICATE_RESP_MSG(self);
+	mdbg(INFO3, "Authenticate response message received");
+
+	if ((err = kkc_sock_recv(sock, &self_msg->ccn_id, 
+				 sizeof(self_msg->ccn_id), KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to receive ccn id");
+		goto exit0;
+	}
+
+	if ((err = kkc_sock_recv(sock, &self_msg->ccn_arch, 
+				 sizeof(self_msg->ccn_arch), KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to receive ccn arch");
+		goto exit0;
+	}
+
+	if ((err = kkc_sock_recv(sock, &self_msg->result_code, 
+				 sizeof(self_msg->result_code), KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to receive result_code");
+		goto exit0;
+	}
+
+	if ((err = kkc_sock_recv(sock, &self_msg->mount_params, 
+				 sizeof(self_msg->mount_params), KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to receive mount params");
+		goto exit0;
+	}
+	
+	return 0;
+exit0:
+	return err;
+}
+
+/**
+ * \<\<private\>\> Receives the message via a specified connection. 
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for sending message data
+ * @return 0 when successfully sent.
+ */
+static int tcmi_authenticate_resp_msg_send(struct tcmi_msg *self, struct kkc_sock *sock)
+{
+	int err;
+	struct tcmi_authenticate_resp_msg *self_msg = TCMI_AUTHENTICATE_RESP_MSG(self);
+	mdbg(INFO3, "Authenticate response message sent");
+
+	if ((err = kkc_sock_send(sock, &self_msg->ccn_id, 
+				 sizeof(self_msg->ccn_id), KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to send ccn id");
+		goto exit0;
+	}
+
+	if ((err = kkc_sock_send(sock, &self_msg->ccn_arch, 
+				 sizeof(self_msg->ccn_arch), KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to send ccn arch");
+		goto exit0;
+	}
+
+	if ((err = kkc_sock_send(sock, &self_msg->result_code, 
+				 sizeof(self_msg->result_code), KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to send result code");
+		goto exit0;
+	}
+
+	if ((err = kkc_sock_send(sock, &self_msg->mount_params, 
+				 sizeof(self_msg->mount_params), KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to send mount_params");
+		goto exit0;
+	}
+
+	return 0;
+exit0:
+	return err;
+}
+
+
+
+/** Message operations that support polymorphism. */
+static struct tcmi_msg_ops authenticate_resp_msg_ops = {
+	.recv = tcmi_authenticate_resp_msg_recv,
+	.send = tcmi_authenticate_resp_msg_send
+};
+
+
+/**
+ * @}
+ */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_msg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_msg.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,464 @@
+/**
+ * @file tcmi_msg.c - TCMI communication message.
+ *       
+ *                      
+ * 
+ *
+ *
+ * Date: 04/10/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_msg.c,v 1.3 2008/01/17 14:36:44 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <linux/kernel.h>
+
+#define TCMI_MSG_PRIVATE
+#include "tcmi_msg.h"
+
+
+#include <dbg.h>
+
+/** Shared initialization fuction of both rx and tx messages */
+static int tcmi_msg_init_shared(struct tcmi_msg *self, u_int32_t msg_id, struct tcmi_msg_ops *msg_ops) {
+	mdbg(INFO4, "Initialized message ID=%u, %p", msg_id, self);
+	self->msg_id = msg_id;
+	/* initially no transaction associated with the message */
+	self->trans_id.req = TCMI_TRANSACTION_INVAL_ID;
+	self->trans_id.resp = TCMI_TRANSACTION_INVAL_ID;
+	self->transaction = NULL;
+
+	self->msg_ops = msg_ops;
+	atomic_set(&self->ref_count, 1);
+
+	/* initialize list head for message queueing */
+	INIT_LIST_HEAD(&self->node);
+	return 0;
+}  
+
+/** 
+ * \<\<public\>\> Initializes the message for receiving.
+ *
+ * @param *self - pointer to this message instance
+ * @param msg_id - ID of a particular message type
+ * @param *msg_ops - pointer to the message operations
+ * @return 0 upon success
+ */
+int tcmi_msg_init_rx(struct tcmi_msg *self, u_int32_t msg_id,
+		     struct tcmi_msg_ops *msg_ops)
+{
+  return tcmi_msg_init_shared(self, msg_id, msg_ops);
+}
+
+/** 
+ * \<\<public\>\> Initializes the message for transferring.  For
+ * oneway messages sets only message ID and message operations and
+ * associated transaction ID (for responses).  If there is a response
+ * expected, sets up a new transaction.
+ *
+ * @param *self - pointer to this message instance
+ * @param msg_id - ID of a particular message type
+ * @param *msg_ops - pointer to the message specific operations
+ * @param *transactions - storage for the new transaction(NULL for one-way messages)
+ * @param resp_msg_id - response message ID - required for the transaction
+ * if the transaction expires(NULL for one-way messages)
+ * @param timeout - transaction time out (0 for one-way messages)
+ * @param resp_trans_id - response transaction ID - used when
+ * this message is a response to a particular request. The user must set
+ * this ID based on the value ofr req_trans_id of the previously received message.
+ * @return 0 upon success
+ */
+int tcmi_msg_init_tx(struct tcmi_msg *self, u_int32_t msg_id, 
+		     struct tcmi_msg_ops *msg_ops,
+		     struct tcmi_slotvec *transactions, u_int32_t resp_msg_id,
+		     u_int timeout,
+		     u_int32_t resp_trans_id)
+{
+	int error = 0;
+	/* basic init is the same as when receiving a message */
+	tcmi_msg_init_shared(self, msg_id, msg_ops);
+	/* transaction ID, needed if this message is a response to a previously sent message */
+	self->trans_id.resp = resp_trans_id;
+	/* setup transaction when needed */
+	if (transactions) {
+		if (!(self->transaction = 
+		      tcmi_transaction_new(transactions, 
+					   TCMI_MSG_TYPE(resp_msg_id), timeout))) {
+			mdbg(ERR3, "Can't create a new transaction for message(ID=%x)", msg_id);
+			error = -1;
+		}
+		/* when a transaction was requested, set proper
+		 * request ID, so that the receiving is able to reply
+		 */
+		else
+			self->trans_id.req = tcmi_transaction_id(self->transaction);
+	}
+	return error;
+}
+
+
+/** 
+ * \<\<public\>\> Sends a message via a specified connection.  Sending
+ * an anonymous message means, that if there is a transaction
+ * associated with the message, the response message will be delivered
+ * into regular message queue. This is typically used when the sending
+ * thread doesn't want to process the response message itself, but
+ * still wants the response to be checked against the transaction.
+ *
+ * The actual work is delegated to tcmi_msg_send() specifying the
+ * anonymous flag.  Then the transaction instance is released as the
+ * sending thread doesn't needed it. The status of the send operation is
+ * communicated to the user.
+ *
+ * This method is also to be used for sending one-way request messages.
+ * 
+ * @param *self - pointer to this message instance
+ * @param *sock - KKC socket used for sending message data
+ * be set in the transaction.
+ * @return 0 upon success
+ */
+int tcmi_msg_send_anonymous(struct tcmi_msg *self, struct kkc_sock *sock)
+{
+	int err;
+	err = tcmi_msg_send(self, sock, TCMI_TRANS_FLAGS_ANONYMOUS);
+	return err;
+}
+
+
+/** 
+ * \<\<public\>\> Sends a message via a specified connection and waits
+ * for the response.  This method is used when the message being sent
+ * out has a transaction and a response is expected. The calling
+ * thread blocks until a valid response arrives or the transaction
+ * expires.
+ *
+ * The actual work is delegated to tcmi_msg_send() specifying no extra
+ * flags for the transaction. The thread is then put to sleep waiting
+ * for completion of the transaction. When its woken up again, the transaction
+ * has:
+ * - been aborted - the user gets NULL in the response message parameter 
+ * OR
+ * - been completed - the response is extracted from the transaction context
+ * OR
+ * - a signal has arrived, in that case the transaction will be aborted,
+ * but there is still a chance that the response has arrived in the mean time
+ * and completed the transaction. In that rare case, the abort fails
+ * and returns a valid transaction context, which is our response message.
+ * The transaction stays marked as complete.
+ *
+ * The transaction is eventually released.
+ * 
+ * The case when there is no transaction associated with the message
+ * is handled correctly - method terminates right after sending out the message.
+ *
+ * @param *self - pointer to this message instance
+ * @param *sock - KKC socket used for sending message data
+ * @param **resp - contains response message or NULL if the transaction
+ * is aborted
+ * @return 0 upon success
+ */
+int tcmi_msg_send_and_receive(struct tcmi_msg *self, struct kkc_sock *sock, 
+			      struct tcmi_msg **resp)
+{
+	int err = 0;
+	int ret;
+	/* increment the reference counter, does nothing when NULL */
+	struct tcmi_transaction *trans = self->transaction;
+	*resp = NULL;
+
+	/* try sending the data first, quit on error or no transaction */
+	err = tcmi_msg_send(self, sock, 0);
+	if (!self->transaction || err < 0)
+		goto exit0;
+
+	/* wait till the transaction expires */
+	ret = tcmi_transaction_wait_interruptible(trans);
+	switch (ret) {
+	case TCMI_TRANSACTION_ABORTED:
+			mdbg(INFO3, "Transaction has been aborted, no response arrived");
+		break;
+
+	case TCMI_TRANSACTION_COMPLETE:
+			mdbg(INFO3, "Transaction complete, picking up the response");
+			*resp = TCMI_MSG(tcmi_transaction_context(trans));
+		break;
+		/* Aborting a transaction upon a signal arrival must
+		 * be atomic, it will fail if the transaction has been
+		 * completed in the meantime and thus the method returns a valid
+		 * transaction context and transaction stays in 'COMPLETE' state */
+	case -ERESTARTSYS:
+	default:
+		mdbg(INFO3, "Signal arrived, result %d. Check if we abort the transaction..", ret);
+		*resp = TCMI_MSG(tcmi_transaction_abort(trans));
+		/* communicate the -ERESTARTSYS to the caller */
+		err = ret;
+		break;
+	}
+
+ exit0:
+	return err;
+}
+
+
+/** 
+ * \<\<public\>\> Receives a message via a specified connection.
+ * - reads the transaction ID from the connection
+ * - calls the receive method of the child class
+ *
+ * The transaction ID is temporarily stored in the instance and will
+ * be used upon delivery when searching for the corresponding
+ * transaction.
+ *
+ * @param *self - pointer to this message instance
+ * @param *sock - KKC socket used for receiving message data
+ * @return >=0 upon success.Unlike tcmi_msg_send() we don't convert a
+ * >=0 result to 0 as this will never get communicated to the user.
+ * The \link tcmi_comm.c::tcmi_comm_thread receiving thread \endlink
+ * is the only component that should use this method.
+ */
+int tcmi_msg_recv(struct tcmi_msg *self, struct kkc_sock *sock)
+
+{
+	int err = 0;
+	struct tcmi_msg_ops *ops = self->msg_ops;
+	if ((err = kkc_sock_rcv_lock_interruptible(sock))) {
+		mdbg(ERR3, "Socket lock - interrupted by a signal %d", err);
+		goto exit0;
+	}
+	/* Receive the transaction ID part */	
+	if ((err = kkc_sock_recv(sock, &self->trans_id, 
+				 sizeof(self->trans_id), KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to receive transaction ID's");
+		goto exit1;
+	}
+
+	mdbg(INFO3, "Receiving message(ID=%x req=%x resp=%x)", 
+	     self->msg_id, self->trans_id.req, self->trans_id.resp);
+	/* */
+	if (ops && ops->recv) 
+		err = ops->recv(self, sock);
+	kkc_sock_rcv_unlock(sock);
+	return err;
+
+	/* error handling */
+ exit1:
+	kkc_sock_rcv_unlock(sock);
+ exit0:
+	return err;
+}
+
+/** 
+ * \<\<public\>\> A message always delivers itself. A delivery of a
+ * message depends on the message type. If it is the request part of
+ * the message or a one-way message, then the receiving party/thread
+ * wants to have it in the associated message queue. If it is a
+ * response to a previously sent message and the receiving
+ * party/thread expects it, it will get associated with its
+ * transaction.
+ *
+ * - a message is of request type if it has a request transaction
+ * ID. In that case, it will be appended to the regular request queue
+ * and the queue processing thread will pick it up.
+ * - a message is of response type - has a response transaction ID. In
+ * that case, it will find its transaction. On success, it will
+ * associate itself with the transaction and complete it. Completing
+ * the transaction is handled by \link
+ * tcmi_transaction.c::tcmi_transaction_complete() the transaction
+ * class \endlink internally.
+ * - in addition, if the transaction is marked anonymous (nobody is
+ * synchronously waiting for the response), the message will also
+ * be delivered into the regular message queue.
+ *
+ * @param *self - pointer to this message instance
+ * @param *requests - queue where the message is stored if it is not a
+ * response to other message. 
+ * @param *transactions - contains all active transactions, the message
+ * tries to find its matching transaction.
+ * @return 0 upon success
+ */
+int tcmi_msg_deliver(struct tcmi_msg *self, struct tcmi_queue *requests, 
+		     struct tcmi_slotvec *transactions)
+{
+	int error = 0;
+	/* storage for the potential transaction associated with the message */
+	struct tcmi_transaction *tran;
+	/* request message handling */
+	if (self->trans_id.resp == TCMI_TRANSACTION_INVAL_ID) {
+		mdbg(INFO3, "Adding message(ID=%x req=%x resp=%x) to the request queue", 
+		     self->msg_id, self->trans_id.req, self->trans_id.resp);
+		tcmi_queue_add(requests, &self->node);
+	}
+	/* response message handling */
+	else {
+		/* search for the transaction */
+		if (!(tran = tcmi_transaction_lookup(transactions, self->trans_id.resp))) {
+			mdbg(ERR3, "Message(ID=%x req=%x resp=%x) - "
+			     "can't find response transaction ID among transactions",
+			     self->msg_id, self->trans_id.req, self->trans_id.resp);
+			error = -1;
+			goto exit0;
+		}
+		/* store the transaction in the message, reference
+		 * counter has been increased by the successful
+		 * lookup */
+		self->transaction = tran;
+		/* try completing it - only message type from the
+		* message ID is taken, to verify that the message
+		* being delivered matches the message expected by the
+		* transaction */
+		if (tcmi_transaction_complete(tran, self, TCMI_MSG_TYPE(self->msg_id))) {
+			mdbg(ERR3, "Error completing transaction %x", 
+			     tcmi_transaction_id(tran));
+			error = -EINVAL;
+			goto exit0;
+		}
+		if (tcmi_transaction_is_anon(tran)) {
+			mdbg(INFO3, "Detected anonymous transaction, queueing the message too..");
+			tcmi_queue_add(requests, &self->node);
+		}
+		mdbg(INFO3, "Message (ID=%x req=%x resp=%x) delivered, transaction completed", 
+		     self->msg_id, self->trans_id.req, self->trans_id.resp);
+	}
+	
+	/* error handling */
+ exit0:
+	return error;
+}
+
+/** 
+ * \<\<public\>\> Class method - creates a message based on a
+ * descriptor.  Verifies, that the message type in the message ID
+ * matches the one in the selected descriptor. Then, based on message
+ * ID flags calles the regular rx constructor or error rx constructor.
+ * This method is meant to be called by the message factory.
+ *
+ * @param msg_id - this message ID is for verification
+ * @param *dsc - descriptor of a message that is to be built
+ * @return new message instance or NULL
+ */
+struct tcmi_msg* tcmi_msg_new_rx(u_int32_t msg_id, struct tcmi_msg_dsc *dsc)
+{
+	struct tcmi_msg *msg = NULL;
+
+	if (TCMI_MSG_TYPE(msg_id) != TCMI_MSG_TYPE(dsc->msg_id)) {
+		mdbg(ERR3, "Requested message ID type(%x) doesn't match the descriptor(%x)",
+		     TCMI_MSG_TYPE(msg_id), TCMI_MSG_TYPE(dsc->msg_id));
+		goto exit0;
+	}
+	/* based on message flags call the regular or error rx constructor */
+	switch (TCMI_MSG_FLG(msg_id)) {
+	case TCMI_MSG_REGFLGS:
+		if (!dsc->new_rx) {
+			mdbg(ERR3, "Regular rx message constructor not present, bailing out..");
+			goto exit0;
+		}
+		msg = dsc->new_rx(msg_id);
+		break;
+	case TCMI_MSG_ERRFLGS:
+		if (!dsc->new_rx_err) {
+			mdbg(ERR3, "Error rx message constructor not present, bailing out..");
+			goto exit0;
+		}
+		msg = dsc->new_rx_err(msg_id);
+		break;
+	default:
+		mdbg(ERR3, "Unexpected message flags value in message ID %x", msg_id);
+	}
+	return msg;
+	/* error handling */
+ exit0:
+	return NULL;
+}
+
+/** @addtogroup tcmi_msg_class
+ *
+ * @{
+ */
+
+/** 
+ * \<\<private\>\> Sends a message via a specified connection.
+ * Sending a message requires following steps:
+ * - activate the transaction(if any)
+ * - send message ID,
+ * - send transaction ID(or TCMI_TRANSACTION_INVAL_ID for oneway messages)
+ * - call a specific message method
+ *
+ * It is necessary to lock the socket, so that the message won't get
+ * intermixed with some other.
+ * 
+ * @param *self - pointer to this message instance
+ * @param *sock - KKC socket used for sending message data
+ * @param flags - if the message has a transaction, these are additional flags to 
+ * be set in the transaction.
+ * @return 0 upon success
+ */
+static int tcmi_msg_send(struct tcmi_msg *self, struct kkc_sock *sock, int flags)
+{
+	int err = 0;
+	struct tcmi_msg_ops *ops = self->msg_ops;
+	struct tcmi_transaction *trans = self->transaction;
+
+	/** try to start the transaction */
+	if (trans && (err = tcmi_transaction_start(trans, flags))) {
+		mdbg(ERR3, "Failed to start the transaction %d", err);
+		goto exit0;
+	}
+
+	/* Send message ID*/
+	mdbg(INFO3, "Sending message(Msg=%p ID=%x req=%x resp=%x), transaction started: %d", 
+	     self, self->msg_id, self->trans_id.req, self->trans_id.resp, (trans!=NULL));
+	if ((err = kkc_sock_snd_lock_interruptible(sock))) {
+		mdbg(ERR3, "Socket lock - interrupted by a signal %d", err);
+		goto exit0;
+	}
+	if ((err = kkc_sock_send(sock, &self->msg_id, 
+				 sizeof(self->msg_id), KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to send message ID: %d. Err: %d", self->msg_id, err);
+		goto exit1;
+	}
+	/* Send transaction ID's */
+	if ((err = kkc_sock_send(sock, &self->trans_id, 
+				 sizeof(self->trans_id), KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to send transaction ID's");
+		goto exit1;
+	}
+	/* Send the actual message content */	
+	if (ops && ops->send) {
+		err = ops->send(self, sock);
+	}
+
+	/* convert the result to 0 if no error has occured this is
+	 * because the number of bytes sent has no meaning for us anymore */
+	err = min(err, 0);
+	kkc_sock_snd_unlock(sock);
+
+	return err;
+	/* error handling */
+ exit1:
+	kkc_sock_snd_unlock(sock);
+ exit0:
+	return err;
+}
+
+
+/**
+ * @}
+ */
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_rpcresp_procmsg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_rpcresp_procmsg.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,166 @@
+/**
+ * @file tcmi_rpcresp_procmsg.h - TCMI RPC response process message 
+ * 
+ *
+ *
+ * Date: 20/04/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: tcmi_rpcresp_procmsg.h,v 1.5 2007/10/11 21:00:26 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_RPCRESP_PROCMSG_H
+#define _TCMI_RPCRESP_PROCMSG_H
+
+#include "tcmi_procmsg.h"
+#include "tcmi_err_procmsg.h"
+#include <tcmi/syscall/tcmi_rpc.h>
+
+/** @defgroup tcmi_rpcresp_procmsg_class tcmi_rpcresp_procmsg class
+ *
+ * @ingroup tcmi_procmsg_class
+ *
+ * @TODO: Updadate comment
+ * @{
+ */
+
+/** Compound structure, inherits from tcmi_procmsg_class */
+struct tcmi_rpcresp_procmsg 
+{
+	/** parent class instance */
+	struct tcmi_procmsg super;
+	/** RPC number */
+	u_int16_t rpcnum;
+	/** Number of memory elements */
+	u_int16_t nmemb;
+	/** Return code of remote procedure */
+	int64_t rtn_code;
+	/** Array describing how to free elements on msg_put */
+	u_int8_t *elem_free;
+	/** Array with size of elements */
+	u_int32_t *elem_size;
+	/** Array of pointers to elements */ 
+	void **elem_base;
+} __attribute__((__packed__));
+
+/** \<\<public\>\> RPC response process message rx constructor. */
+extern struct tcmi_msg* tcmi_rpcresp_procmsg_new_rx(u_int32_t msg_id);
+
+/** \<\<public\>\> RPC response process message tx constructor. */
+extern struct tcmi_msg* tcmi_rpcresp_procmsg_new_tx(u_int32_t trans_id, pid_t dst_pid);
+
+/** \<\<public\>\> Get pointer do data
+ * @param *self  - this message instance
+ * @param index  - index of data which we want
+ *
+ * @return pointer to data or NULL if index is out of range
+ */
+static inline void* tcmi_rpcresp_procmsg_data_base(struct tcmi_rpcresp_procmsg *self, unsigned int index)
+{
+	if(index < self->nmemb)
+		return self->elem_base[index];
+	mdbg(ERR3, "Trying to acces beyond array boundary");
+	return NULL;
+}
+
+/** \<\<public\>\> Get RPC parameter size. 
+ * @param *self  - this message instance
+ * @param index  - index of data which size we want
+ *
+ * @return RPC parameter size or 0 if index is out of range
+ */
+static inline unsigned long tcmi_rpcresp_procmsg_data_size(struct tcmi_rpcresp_procmsg *self, unsigned int index)
+{
+	if(index < self->nmemb)
+		return self->elem_size[index];
+	mdbg(ERR3, "Trying to acces beyond array boundary");
+	return 0;
+}
+
+/** \<\<public\>\> Set if and how data will be freed on last put
+ * @param *self  - this message instance
+ * @param index  - index of data which put action we are going to set
+ * @param action - one of  #TCMI_RPCRESP_PROCMSG_DONTFREE, #TCMI_RPCRESP_PROCMSG_KFREE or #TCMI_RPCRESP_PROCMSG_VFREE 
+ */
+static inline void tcmi_rpcresp_procmsg_free_on_put(struct tcmi_rpcresp_procmsg *self, unsigned int index, int action)
+{
+	if(index < self->nmemb)
+		self->elem_free[index] = action;
+	else
+		mdbg(ERR3, "Trying to acces beyond array boundary");
+}
+
+/** \<\<public\>\> Don't free data on put */
+#define TCMI_RPCRESP_PROCMSG_DONTFREE 1
+/** \<\<public\>\> Free data using kfree on put */
+#define TCMI_RPCRESP_PROCMSG_KFREE 2
+/** \<\<public\>\> Free data usinf vfree on put */
+#define TCMI_RPCRESP_PROCMSG_VFREE 3
+
+/** \<\<public\>\> Creates and sends rpc_proc_msg and returns response */
+struct tcmi_msg* tcmi_rpcresp_procmsg_get_response(unsigned int rpcnum, ...);
+
+/** \<\<public\>\> Create response to rpc message */
+struct tcmi_msg* tcmi_rpcresp_procmsg_create(struct tcmi_msg *m, long rtn_code, ...);
+
+/** \<\<public\>\> Return RPC return code. */
+static inline long tcmi_rpcresp_procmsg_rtn(struct tcmi_rpcresp_procmsg *self)
+{
+	return self->rtn_code;
+}
+
+/** \<\<public\>\> Return RPC number. */
+static inline int tcmi_rpcresp_procmsg_num(struct tcmi_rpcresp_procmsg *self)
+{
+	return self->rpcnum;
+}
+
+/** Message descriptor for the factory class, for error handling we used tcmi_errmsg_class */
+#define TCMI_RPCRESP_PROCMSG_DSC \
+TCMI_MSG_DSC(TCMI_RPCRESP_PROCMSG_ID, tcmi_rpcresp_procmsg_new_rx, tcmi_err_procmsg_new_rx)
+
+/** Casts to the tcmi_rpcresp_procmsg instance. */
+#define TCMI_RPCRESP_PROCMSG(m) ((struct tcmi_rpcresp_procmsg*)m)
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_RPCRESP_PROCMSG_PRIVATE
+
+/** Receives the message via a specified connection. */
+static int tcmi_rpcresp_procmsg_recv(struct tcmi_procmsg *self, struct kkc_sock *sock);
+
+/** Sends the message via a specified connection. */
+static int tcmi_rpcresp_procmsg_send(struct tcmi_procmsg *self, struct kkc_sock *sock);
+
+/** Frees RPC message resources */
+static void tcmi_rpcresp_procmsg_free(struct tcmi_procmsg *self);
+
+/** Message operations that support polymorphism. */
+static struct tcmi_procmsg_ops rpcresp_procmsg_ops;
+
+#endif /* TCMI_RPCRESP_PROCMSG_PRIVATE */
+
+
+/**
+ * @}
+ */
+
+
+#endif /* _TCMI_RPCRESP_PROCMSG_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_skelresp_procmsg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_skelresp_procmsg.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,175 @@
+/**
+ * @file tcmi_skelresp_procmsg.c - TCMI error message - carries an error status code.
+ *       
+ *                      
+ * 
+ *
+ *
+ * Date: 04/19/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_skelresp_procmsg.c,v 1.3 2007/09/02 10:54:25 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include <linux/slab.h>
+
+#include "tcmi_transaction.h"
+
+#define TCMI_SKELRESP_PROCMSG_PRIVATE
+#include "tcmi_skelresp_procmsg.h"
+
+
+#include <dbg.h>
+
+
+
+/** 
+ * \<\<public\>\> Test response message rx constructor.  This method is
+ * called by the factory class.
+ *
+ * @param msg_id - message ID, to check with the actual response
+ * process message ID.
+ *
+ * @return a new skeleton response process message or NULL.
+ */
+struct tcmi_msg* tcmi_skelresp_procmsg_new_rx(u_int32_t msg_id)
+{
+	struct tcmi_skelresp_procmsg *msg;
+
+	/* Check if the factory is building what it really thinks. */
+	if (msg_id != TCMI_SKELRESP_PROCMSG_ID) {
+		mdbg(ERR3, "Factory specified process message ID(%x) doesn't match real ID(%x)",
+		     msg_id, TCMI_SKELRESP_PROCMSG_ID);
+		goto exit0;
+	}
+	if (!(msg = TCMI_SKELRESP_PROCMSG(kmalloc(sizeof(struct tcmi_skelresp_procmsg), 
+						  GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate testing process message");
+		goto exit0;
+	}
+	/* Initialized the message for receiving, message ID is extended with error flags */
+	if (tcmi_procmsg_init_rx(TCMI_PROCMSG(msg), TCMI_SKELRESP_PROCMSG_ID, 
+				 &skelresp_procmsg_ops)) {
+		mdbg(ERR3, "Error initializing process message %x", msg_id);
+		goto exit1;
+	}
+
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+}
+
+/** 
+ * \<\<public\>\> Testing response process message tx constructor.
+ *
+ * The testing response process message is a one-way message, no transaction
+ * is needs to be started, the user only needs to specify the
+ * transaction ID that it is the reply to and the destination process PID.
+ *
+ * When performing the generic tx init, the response message ID is
+ * specified (TCMI_SKELRESP_PROCMSG_ID) along with the destination PID.
+ *
+ * @param trans_id - transaction ID that this message is replying to.
+ * @param dst_pid - destination process PID
+ * @return a new test response message for the transfer or NULL.
+ */
+struct tcmi_msg* tcmi_skelresp_procmsg_new_tx(u_int32_t trans_id, pid_t dst_pid)
+{
+	struct tcmi_skelresp_procmsg *msg;
+
+	if (!(msg = TCMI_SKELRESP_PROCMSG(kmalloc(sizeof(struct tcmi_skelresp_procmsg), 
+						  GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate testing message");
+		goto exit0;
+	}
+
+	/* Initialize the message for transfer, no transaction
+	 * required, no timout, no response ID */
+	if (tcmi_procmsg_init_tx(TCMI_PROCMSG(msg), TCMI_SKELRESP_PROCMSG_ID, &skelresp_procmsg_ops,
+				 dst_pid, 0,
+				 NULL, 0, 0, trans_id)) {
+		mdbg(ERR3, "Error initializing testing response message");
+		goto exit1;
+	}
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+	
+}
+
+
+/** @addtogroup tcmi_skelresp_procmsg_class
+ *
+ * @{
+ */
+
+/**
+ * \<\<private\>\> Receives the message via a specified connection. 
+ * Receiving the erro message requires reading the error code from the specified
+ * connection 
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for receiving message data
+ * @return 0 when successfully received.
+ */
+static int tcmi_skelresp_procmsg_recv(struct tcmi_procmsg *self, struct kkc_sock *sock)
+{
+	/* struct tcmi_skelresp_procmsg *self_msg = TCMI_SKELRESP_PROCMSG(self); */
+	mdbg(INFO3, "Testing response process message received");
+	
+	return 0;
+}
+
+/**
+ * \<\<private\>\> Receives the message via a specified connection. 
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for sending message data
+ * @return 0 when successfully sent.
+ */
+static int tcmi_skelresp_procmsg_send(struct tcmi_procmsg *self, struct kkc_sock *sock)
+{
+	/* struct tcmi_skelresp_procmsg *self_msg = TCMI_SKELRESP_PROCMSG(self); */
+	mdbg(INFO3, "Testing response process message sent");
+
+	return 0;
+}
+
+
+
+/** Message operations that support polymorphism. */
+static struct tcmi_procmsg_ops skelresp_procmsg_ops = {
+	.recv = tcmi_skelresp_procmsg_recv,
+	.send = tcmi_skelresp_procmsg_send
+};
+
+
+/**
+ * @}
+ */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_guest_started_procmsg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_guest_started_procmsg.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,110 @@
+/**
+ * @file tcmi_guest_started_procmsg.h - response from the guest task when it is succesfully started
+ *       
+ *                      
+ * 
+ *
+ *
+ * Date: 04/27/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_guest_started_procmsg.h,v 1.2 2007/07/02 02:26:17 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_GUEST_STARTED_PROCMSG_H
+#define _TCMI_GUEST_STARTED_PROCMSG_H
+
+#include "tcmi_procmsg.h"
+#include "tcmi_err_procmsg.h"
+
+/** @defgroup tcmi_guest_started_procmsg_class tcmi_guest_started_procmsg class
+ *
+ * @ingroup tcmi_procmsg_class
+ *
+ * This class represents a message that is sent to the migration initiator as a
+ * response to a migration request.
+ * The main purpose is to communicate the PID of the guest process to the migration
+ * initiator. 
+ *
+ * @{
+ */
+
+/** Compound structure, inherits from tcmi_procmsg_class */
+struct tcmi_guest_started_procmsg {
+	/** parent class instance */
+	struct tcmi_procmsg super;
+	/** guest PID,  used for further communication. */
+	pid_t guest_pid;
+};
+
+
+
+
+/** \<\<public\>\> Guest started message rx constructor. */
+extern struct tcmi_msg* tcmi_guest_started_procmsg_new_rx(u_int32_t msg_id);
+
+/** \<\<public\>\> Guest started message tx constructor. */
+extern struct tcmi_msg* tcmi_guest_started_procmsg_new_tx(u_int32_t trans_id, pid_t dst_pid, 
+							 pid_t guest_pid);
+
+
+
+
+/** Message descriptor for the factory class, for error handling we used tcmi_errmsg_class */
+#define TCMI_GUEST_STARTED_PROCMSG_DSC \
+TCMI_MSG_DSC(TCMI_GUEST_STARTED_PROCMSG_ID, tcmi_guest_started_procmsg_new_rx, tcmi_err_procmsg_new_rx)
+
+/** Casts to the tcmi_guest_started_procmsg instance. */
+#define TCMI_GUEST_STARTED_PROCMSG(m) ((struct tcmi_guest_started_procmsg*)m)
+
+/**
+ * \<\<public\>\> Stub PID accessor.
+ * 
+ * @param *self - this message instance
+ * @return guest PID
+ */
+static inline pid_t tcmi_guest_started_procmsg_guest_pid(struct tcmi_guest_started_procmsg *self)
+{
+	return self->guest_pid;
+}
+
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_GUEST_STARTED_PROCMSG_PRIVATE
+
+/** Receives the message via a specified connection. */
+static int tcmi_guest_started_procmsg_recv(struct tcmi_procmsg *self, struct kkc_sock *sock);
+
+/** Sends the message via a specified connection. */
+static int tcmi_guest_started_procmsg_send(struct tcmi_procmsg *self, struct kkc_sock *sock);
+
+/** Message operations that support polymorphism. */
+static struct tcmi_procmsg_ops guest_started_procmsg_ops;
+
+#endif /* TCMI_GUEST_STARTED_PROCMSG_PRIVATE */
+
+
+/**
+ * @}
+ */
+
+
+#endif /* _TCMI_GUEST_STARTED_PROCMSG_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_disconnect_msg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_disconnect_msg.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,65 @@
+/**
+ * @file tcmi_disconnect_msg.h - disconnect message
+ */
+
+#ifndef TCMI_DISCONNECT_MSG_H
+#define TCMI_DISCONNECT_MSG_H
+
+#include "tcmi_msg.h"
+#include <arch/arch_ids.h>
+
+/** @defgroup tcmi_disconnect_msg_class tcmi_disconnect_msg class
+ *
+ * @ingroup tcmi_msg_class
+ *
+ * This message is send by PEN or CCN when it is going to disconnect from its peer. It serves as a notification, to tell the peer it shall as well terminate the connection.
+ * In addition, if send from CCN to PEN, the PEN should as a resonpse first try to migrate back all tasks from a peer core node.
+ *
+ * @{
+ */
+
+/** Disconnect message structure */
+struct tcmi_disconnect_msg {
+	/** parent class instance. */
+	struct tcmi_msg super;
+};
+
+
+
+
+/** \<\<public\>\> Disconnect message consutructor for receiving. */
+extern struct tcmi_msg* tcmi_disconnect_msg_new_rx(u_int32_t msg_id);
+
+/** \<\<public\>\> Disconnect message constructor for transferring. */
+extern struct tcmi_msg* tcmi_disconnect_msg_new_tx(void);
+
+
+/** \<\<public\>\> Message descriptor for the factory class, there is no error
+ * handling as this is the starting request */
+#define TCMI_DISCONNECT_MSG_DSC TCMI_MSG_DSC(TCMI_DISCONNECT_MSG_ID, tcmi_disconnect_msg_new_rx, NULL)
+
+/** Casts to the tcmi_disconnect_msg instance. */
+#define TCMI_DISCONNECT_MSG(m) ((struct tcmi_disconnect_msg*)m)
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_DISCONNECT_MSG_PRIVATE
+
+/** Receives the message via a specified connection. */
+static int tcmi_disconnect_msg_recv(struct tcmi_msg *self, struct kkc_sock *sock);
+
+/** Sends the message via a specified connection. */
+static int tcmi_disconnect_msg_send(struct tcmi_msg *self, struct kkc_sock *sock);
+
+/** Message operations that support polymorphism. */
+static struct tcmi_msg_ops disconnect_msg_ops;
+
+#endif
+
+
+/**
+ * @}
+ */
+
+
+#endif
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_messages_dsc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_messages_dsc.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,137 @@
+/**
+ * @file tcmi_messages_dsc.h - A list of descriptors of all TCMI messages and
+ * their groups.
+ *       
+ *                      
+ * 
+ *
+ *
+ * Date: 04/12/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_messages_dsc.h,v 1.7 2008/05/02 19:59:20 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_MESSAGES_DSC_H
+#define _TCMI_MESSAGES_DSC_H
+
+#include "tcmi_msg.h"
+
+/* migration messages */
+#include "tcmi_skel_msg.h"
+#include "tcmi_skelresp_msg.h"
+#include "tcmi_signal_msg.h"
+#include "tcmi_p_emigrate_msg.h"
+#include "tcmi_authenticate_msg.h"
+#include "tcmi_authenticate_resp_msg.h"
+#include "tcmi_disconnect_msg.h"
+
+/* process messages */
+#include "tcmi_skel_procmsg.h"
+#include "tcmi_skelresp_procmsg.h"
+#include "tcmi_exit_procmsg.h"
+#include "tcmi_rpc_procmsg.h"
+#include "tcmi_rpcresp_procmsg.h"
+#include "tcmi_guest_started_procmsg.h"
+#include "tcmi_ppm_p_migr_back_guestreq_procmsg.h"
+#include "tcmi_ppm_p_migr_back_shadowreq_procmsg.h"
+#include "tcmi_vfork_done_procmsg.h"
+#include "tcmi_generic_user_msg.h"
+
+/** @defgroup tcmi_messages_dsc message descriptors
+ *
+ * @ingroup tcmi_comm_group
+ *
+ * Message descriptors are internally used by tcmi_msg_factory_class
+ * when materializing messages that are being received. In future, this
+ * file will be automatically generated based on all tcmi message
+ * declarations.
+ *
+ * @{
+ */
+
+/** Describes a group of messages. */
+struct tcmi_msg_group {
+	/** array of message descriptors within a group */
+	struct tcmi_msg_dsc *dsc;
+	/** message count in the group */
+	u_int32_t msg_count;
+};
+
+
+#ifdef TCMI_MSG_FACTORY_PRIVATE
+
+/******* M I G R A T I O N  C O N T R O L  M E S S A G E S *********/
+
+/** Individual descriptors of migration messages(sent via migration
+ * control control connection */
+static struct tcmi_msg_dsc mig_messages[] = {
+	TCMI_SKEL_MSG_DSC,
+	TCMI_SKELRESP_MSG_DSC,
+	TCMI_AUTHENTICATE_MSG_DSC,
+	TCMI_AUTHENTICATE_RESP_MSG_DSC,
+	TCMI_DISCONNECT_MSG_DSC,
+	TCMI_P_EMIGRATE_MSG_DSC,
+	TCMI_SIGNAL_MSG_DSC,
+	TCMI_GENERIC_USER_MSG_DSC,
+};
+
+
+/********* P R O C E S S  C O N T R O L  M E S S A G E S ***********/
+/** Individual descriptors of process messages(sent via process
+ * control connection */
+static struct tcmi_msg_dsc proc_messages[] = {
+	TCMI_SKEL_PROCMSG_DSC,
+	TCMI_SKELRESP_PROCMSG_DSC,
+	TCMI_EXIT_PROCMSG_DSC,
+	TCMI_VFORK_DONE_PROCMSG_DSC,
+	TCMI_GUEST_STARTED_PROCMSG_DSC,
+	TCMI_PPM_P_MIGR_BACK_GUESTREQ_PROCMSG_DSC,
+	TCMI_PPM_P_MIGR_BACK_SHADOWREQ_PROCMSG_DSC,
+	TCMI_RPC_PROCMSG_DSC,
+	TCMI_RPCRESP_PROCMSG_DSC,	
+};
+
+
+
+/****************** M E S S A G E  G R O U P S *********************/
+/** List of supported groups, new message groups are to be added here */
+static struct tcmi_msg_group msg_groups[] = {
+	{
+	 .dsc = mig_messages,
+	 .msg_count = TCMI_MSG_INDEX(TCMI_LAST_MSG_ID)
+	},
+	{
+	 .dsc = proc_messages,
+	 .msg_count = TCMI_MSG_INDEX(TCMI_LAST_PROCMSG_ID)
+	}
+};
+
+
+
+#endif /* TCMI_MSG_FACTORY_PRIVATE */
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_MESSAGES_DSC_H */
+
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_p_emigrate_msg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_p_emigrate_msg.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,286 @@
+/**
+ * @file tcmi_p_emigrate_msg.c - NPM/PPM physical emigration message.
+ *       
+ *                      
+ * 
+ *
+ *
+ * Date: 04/27/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_p_emigrate_msg.c,v 1.2 2009-04-06 21:48:46 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include <linux/slab.h>
+#include <linux/string.h>
+
+#include "tcmi_transaction.h"
+
+#include "tcmi_skelresp_msg.h"
+#define TCMI_P_EMIGRATE_MSG_PRIVATE
+#include "tcmi_p_emigrate_msg.h"
+
+
+#include <dbg.h>
+
+
+
+/** 
+ * \<\<public\>\> Physical message rx constructor.
+ * This method is called by the factory class.
+ *
+ * @param msg_id - message ID that will be used for this error message
+ * instance.
+ * @return a new error message or NULL.
+ */
+struct tcmi_msg* tcmi_p_emigrate_msg_new_rx(u_int32_t msg_id)
+{
+	struct tcmi_p_emigrate_msg *msg;
+
+	/* Check if the factory is building what it really thinks. */
+	if (msg_id != TCMI_P_EMIGRATE_MSG_ID) {
+		mdbg(ERR3, "Factory specified message ID(%x) doesn't match real ID(%x)",
+		     msg_id, TCMI_P_EMIGRATE_MSG_ID);
+		goto exit0;
+	}
+	/* Allocate the instance */
+	if (!(msg = TCMI_P_EMIGRATE_MSG(kmalloc(sizeof(struct tcmi_p_emigrate_msg), GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate test request message");
+		goto exit0;
+	}
+	/* Initialized the message for receiving. */
+	if (tcmi_msg_init_rx(TCMI_MSG(msg), TCMI_P_EMIGRATE_MSG_ID, &p_emigrate_msg_ops)) {
+		mdbg(ERR3, "Error initializing test request message %x", msg_id);
+		goto exit1;
+	}
+
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+}
+
+/** 
+ * \<\<public\>\> Physical emigration message tx constructor.
+ *
+ * An emigration message expects a response that will be delivered back
+ * to the originating task (usually a shadow process on CCN). Therefore,
+ * there has to be a transaction associated with it.
+ *
+ * Response message ID is TCMI_GUEST_STARTED_PROCMSG_ID.
+ *
+ *
+ * @param *transactions - storage for the new transaction
+ *
+ * @param reply_pid - denotes the pid that the reply to this message
+ * should be directed to. It is a key information for the receiving
+ * party in order to compose a valid response
+ * @param ckpt_name - checkpoint pathname - this has to be a valid location
+ * in the network filesystem, so that the receiving party can restart the process
+ * @return a new error ready for the transfer or NULL.
+ */
+struct tcmi_msg* tcmi_p_emigrate_msg_new_tx(struct tcmi_slotvec *transactions, 
+						       pid_t reply_pid, char *exec_name, char *ckpt_name, int16_t euid, int16_t egid, int16_t fsuid, int16_t fsgid)
+{
+	struct tcmi_p_emigrate_msg *msg;
+
+	if (!(msg = TCMI_P_EMIGRATE_MSG(kmalloc(sizeof(struct tcmi_p_emigrate_msg), GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate test request message");
+		goto exit0;
+	}
+	msg->pid_and_size.reply_pid = reply_pid;
+	msg->pid_and_size.euid = euid;
+	msg->pid_and_size.egid = egid;
+	msg->pid_and_size.fsuid = fsuid;
+	msg->pid_and_size.fsgid = fsgid;
+	msg->pid_and_size.size = strlen(ckpt_name) + 1;
+	msg->pid_and_size.exec_name_size = strlen(exec_name) + 1;
+
+	if (!(msg->ckpt_name = (char*)kmalloc(msg->pid_and_size.size, GFP_KERNEL))) {
+		mdbg(ERR3, "Can't allocate memory for checkpoint name");
+		goto exit1;
+	}
+
+	if (!(msg->exec_name = (char*)kmalloc(msg->pid_and_size.exec_name_size, GFP_KERNEL))) {
+		mdbg(ERR3, "Can't allocate memory for exec name");
+		goto exit2;
+	}
+
+	strcpy(msg->ckpt_name, ckpt_name);
+	strcpy(msg->exec_name, exec_name);
+	/* Initialize the message for transfer */
+	if (tcmi_msg_init_tx(TCMI_MSG(msg), TCMI_P_EMIGRATE_MSG_ID, &p_emigrate_msg_ops, 
+			     transactions, TCMI_GUEST_STARTED_PROCMSG_ID,
+			     TCMI_P_EMIGRATE_MSGTIMEOUT, TCMI_TRANSACTION_INVAL_ID)) {
+		mdbg(ERR3, "Error initializing test request message message");
+		goto exit3;
+	}
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit3:
+	kfree(msg->exec_name);
+ exit2:
+	kfree(msg->ckpt_name);
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+	
+}
+
+
+/** @addtogroup tcmi_p_emigrate_msg_class
+ *
+ * @{
+ */
+
+/**
+ * \<\<private\>\> Receives the message via a specified connection.
+ * Receiving the message requires reading the remote PID and
+ * checkpoint size.  Based on the size, allocate space for the
+ * checkpoint name string and read it to from the specified connection
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for receiving message data
+ * @return 0 when successfully received.
+ */
+static int tcmi_p_emigrate_msg_recv(struct tcmi_msg *self, struct kkc_sock *sock)
+{
+	int err = -EINVAL;
+	struct tcmi_p_emigrate_msg *self_msg = TCMI_P_EMIGRATE_MSG(self);
+	
+	/* Receive the remote PID and checkpoint name size */	
+	if ((err = kkc_sock_recv(sock, &self_msg->pid_and_size, 
+				 sizeof(self_msg->pid_and_size), KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to receive pid and size");
+		goto exit0;
+	}
+
+
+	if (!(self_msg->ckpt_name = (char*)kmalloc(self_msg->pid_and_size.size, GFP_KERNEL))) {
+		mdbg(ERR3, "Can't allocate memory for checkpoint name");
+		goto exit0;
+	}
+
+	if (!(self_msg->exec_name = (char*)kmalloc(self_msg->pid_and_size.exec_name_size, GFP_KERNEL))) {
+		mdbg(ERR3, "Can't allocate memory for checkpoint name");
+		goto exit0;
+	}
+	
+	/* Receive the checkpoint name */	
+	if ((err = kkc_sock_recv(sock, self_msg->ckpt_name, 
+				 self_msg->pid_and_size.size, KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to receive checkpoint name");
+		goto exit0;
+	}
+
+	/* Receive the exec name */	
+	if ((err = kkc_sock_recv(sock, self_msg->exec_name, 
+				 self_msg->pid_and_size.exec_name_size, KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to receive exec name");
+		goto exit0;
+	}
+
+	mdbg(INFO2, "Physical emigrate message received PID=%d, size=%d, ckptname='%s'",
+	     self_msg->pid_and_size.reply_pid, self_msg->pid_and_size.size, self_msg->ckpt_name);
+
+	return 0;
+	/* error handling*/
+ exit0:
+	return err;
+}
+
+/**
+ * \<\<private\>\> Sends the physical emigration message
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for sending message data
+ * @return 0 when successfully sent.
+ */
+static int tcmi_p_emigrate_msg_send(struct tcmi_msg *self, struct kkc_sock *sock)
+{
+	int err;
+	struct tcmi_p_emigrate_msg *self_msg = TCMI_P_EMIGRATE_MSG(self);
+
+	
+	/* Receive the remote PID and checkpoint name size */	
+	if ((err = kkc_sock_send(sock, &self_msg->pid_and_size, 
+				 sizeof(self_msg->pid_and_size), KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to send pid and size");
+		goto exit0;
+	}
+
+	/* Send the checkpoint name */	
+	if ((err = kkc_sock_send(sock, self_msg->ckpt_name, 
+				 self_msg->pid_and_size.size, KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to send checkpoint name");
+		goto exit0;
+	}
+
+	/* Send the exec name */	
+	if ((err = kkc_sock_send(sock, self_msg->exec_name, 
+				 self_msg->pid_and_size.exec_name_size, KKC_SOCK_BLOCK)) < 0) {
+		mdbg(ERR3, "Failed to send exec name");
+		goto exit0;
+	}
+
+	mdbg(INFO2, "Physical emigrate message sent PID=%d, size=%d, ckptname='%s'",
+	     self_msg->pid_and_size.reply_pid, self_msg->pid_and_size.size, self_msg->ckpt_name);
+
+	return 0;
+	/* error handling */
+ exit0:
+	return err;
+	
+}
+
+/**
+ * \<\<private\>\> Frees custom message resources.
+ * The checkpoint image name string is released from memory.
+ *
+ * @param *self - this message instance
+ */
+static void tcmi_p_emigrate_msg_free(struct tcmi_msg *self)
+{
+	struct tcmi_p_emigrate_msg *self_msg = TCMI_P_EMIGRATE_MSG(self);
+
+	mdbg(INFO3, "Freeing physical emigrate message PID=%d, size=%d, ckptname='%s'",
+	     self_msg->pid_and_size.reply_pid, self_msg->pid_and_size.size, self_msg->ckpt_name);
+	kfree(self_msg->ckpt_name);
+	kfree(self_msg->exec_name);
+}
+
+
+/** Message operations that support polymorphism. */
+static struct tcmi_msg_ops p_emigrate_msg_ops = {
+	.recv = tcmi_p_emigrate_msg_recv,
+	.send = tcmi_p_emigrate_msg_send,
+	.free = tcmi_p_emigrate_msg_free
+};
+
+
+/**
+ * @}
+ */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_ppm_p_migr_back_shadowreq_procmsg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_ppm_p_migr_back_shadowreq_procmsg.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,138 @@
+/**
+ * @file tcmi_ppm_p_migr_back_shadowreq_procmsg.c - migrate back request initiated by shadow
+ */       
+
+#include <linux/slab.h>
+#include <linux/string.h>
+
+#include "tcmi_transaction.h"
+
+#include "tcmi_skelresp_msg.h"
+#define TCMI_PPM_P_MIGR_BACK_SHADOWREQ_PROCMSG_PRIVATE
+#include "tcmi_ppm_p_migr_back_shadowreq_procmsg.h"
+
+#include <dbg.h>
+
+
+/** 
+ * \<\<public\>\> PPM_P message rx constructor.
+ * This method is called by the factory class.
+ *
+ * @param msg_id - message ID that will be used for this error message
+ * instance.
+ * @return a new error message or NULL.
+ */
+struct tcmi_msg* tcmi_ppm_p_migr_back_shadowreq_procmsg_new_rx(u_int32_t msg_id)
+{
+	struct tcmi_ppm_p_migr_back_shadowreq_procmsg *msg;
+
+	/* Check if the factory is building what it really thinks. */
+	if (msg_id != TCMI_PPM_P_MIGR_BACK_SHADOWREQ_PROCMSG_ID) {
+		mdbg(ERR3, "Factory specified message ID(%x) doesn't match real ID(%x)",
+		     msg_id, TCMI_PPM_P_MIGR_BACK_SHADOWREQ_PROCMSG_ID);
+		goto exit0;
+	}
+	/* Allocate the instance */
+	if (!(msg = TCMI_PPM_P_MIGR_BACK_SHADOWREQ_PROCMSG(kmalloc(sizeof(struct tcmi_ppm_p_migr_back_shadowreq_procmsg), 
+								 GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate migrate back shadow request message");
+		goto exit0;
+	}
+	/* Initialize the message for receiving. */
+	if (tcmi_procmsg_init_rx(TCMI_PROCMSG(msg), TCMI_PPM_P_MIGR_BACK_SHADOWREQ_PROCMSG_ID, 
+				 &ppm_p_migr_back_shadowreq_procmsg_ops)) {
+		mdbg(ERR3, "Error initializing migrate back shadow request message %x", msg_id);
+		goto exit1;
+	}
+
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+}
+
+/** 
+ * \<\<public\>\> Shadow request for migration back tx constructor.
+ *
+ * Generates a one-way request message
+ *
+ * @param dst_pid - PID of the target process that will receive this message
+ * @return a new message ready for the transfer or NULL.
+ */
+struct tcmi_msg* tcmi_ppm_p_migr_back_shadowreq_procmsg_new_tx(pid_t dst_pid)
+{
+	struct tcmi_ppm_p_migr_back_shadowreq_procmsg *msg;
+
+	if (!(msg = TCMI_PPM_P_MIGR_BACK_SHADOWREQ_PROCMSG(kmalloc(sizeof(struct tcmi_ppm_p_migr_back_shadowreq_procmsg), 
+								 GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't create migrate back shadow request message");
+		goto exit0;
+	}
+
+	/* Initialize the message for transfer, no transaction
+	 * required, no timout, no response ID */
+	if (tcmi_procmsg_init_tx(TCMI_PROCMSG(msg), TCMI_PPM_P_MIGR_BACK_SHADOWREQ_PROCMSG_ID,
+				 &ppm_p_migr_back_shadowreq_procmsg_ops,
+				 dst_pid, 1,
+				 NULL, 0, 0, TCMI_TRANSACTION_INVAL_ID)) {
+		mdbg(ERR3, "Error initializing migrate back shadow request message");
+		goto exit1;
+	}
+
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+	
+}
+
+/** @addtogroup tcmi_ppm_p_migr_back_guestreq_procmsg_class
+ *
+ * @{
+ */
+
+/**
+ * \<\<private\>\> Receives the message via a specified connection.
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for receiving message data
+ * @return 0 when successfully received.
+ */
+static int tcmi_ppm_p_migr_back_shadowreq_procmsg_recv(struct tcmi_procmsg *self, struct kkc_sock *sock)
+{
+	mdbg(INFO2, "PPM_P migrate back shadow request received guest PID=%d",
+	     tcmi_procmsg_dst_pid(self));
+
+	return 0;
+}
+
+/**
+ * \<\<private\>\> Sends the PPM_P migrate back shadow request
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for sending message data
+ * @return 0 when successfully sent.
+ */
+static int tcmi_ppm_p_migr_back_shadowreq_procmsg_send(struct tcmi_procmsg *self, struct kkc_sock *sock)
+{
+	mdbg(INFO2, "PPM_P migrate back shadow request sent guest PID=%d",
+	     tcmi_procmsg_dst_pid(self));
+
+	return 0;
+}
+
+/** Message operations that support polymorphism. */
+static struct tcmi_procmsg_ops ppm_p_migr_back_shadowreq_procmsg_ops = {
+	.recv = tcmi_ppm_p_migr_back_shadowreq_procmsg_recv,
+	.send = tcmi_ppm_p_migr_back_shadowreq_procmsg_send,
+};
+
+/**
+ * @}
+ */
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_skel_msg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_skel_msg.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,106 @@
+/**
+ * @file tcmi_skel_msg.h - TCMI test communication message - can be used as skeleton
+ *                       for other messages.
+ *       
+ *                      
+ * 
+ *
+ *
+ * Date: 04/11/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_skel_msg.h,v 1.2 2007/07/02 02:26:17 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_SKEL_MSG_H
+#define _TCMI_SKEL_MSG_H
+
+#include "tcmi_msg.h"
+
+/** @defgroup tcmi_skel_msg_class tcmi_skel_msg class
+ *
+ * @ingroup tcmi_msg_class
+ *
+ * This class represents a test message and is intended to be used
+ * as a skeleton when implementing new messages in the TCMI protocol.
+ * To implement a new message following steps need to be done:
+ * - Implement the constructors
+ *   - new_tx - functionality to allocate a message for transfer based on 
+ *   custom parameters specific to each message type. Use init_tx for initialization
+ *   of the super class instance data
+ *   - new_rx - same, but for reception, therefore, no parameters are specified. If needed
+ *   compare the supplied message ID, with the official message ID assigned to this type
+ *   of message.
+ *   - new_rx_err - A custom build of error message can be specified or some generic
+ *   new_rx_err message constructor can be used.
+ * - Choose a message identifier and append it to a proper group in tcmi_messages_id.h
+ * - Declare a new message descriptor, append it into tcmi_messages_dsc.h 
+ * - Implement custom operations if needed.
+ * @{
+ */
+
+/** Compound structure, inherits from tcmi_msg_class */
+struct tcmi_skel_msg {
+	/** parent class instance */
+	struct tcmi_msg super;
+};
+
+
+
+
+/** \<\<public\>\> Skeleton message constructor for receiving. */
+extern struct tcmi_msg* tcmi_skel_msg_new_rx(u_int32_t msg_id);
+
+/** \<\<public\>\> Skeleton message constructor for transferring. */
+extern struct tcmi_msg* tcmi_skel_msg_new_tx(struct tcmi_slotvec *transactions);
+
+
+/** Message descriptor for the factory class, there is no error
+ * handling as this is the starting request */
+#define TCMI_SKEL_MSG_DSC TCMI_MSG_DSC(TCMI_SKEL_MSG_ID, tcmi_skel_msg_new_rx, NULL)
+/** Skeleton message transaction timeout set to 5 seconds*/
+#define TCMI_SKEL_MSGTIMEOUT 5*HZ
+
+/** Casts to the tcmi_skel_msg instance. */
+#define TCMI_SKEL_MSG(m) ((struct tcmi_skel_msg*)m)
+
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_SKEL_MSG_PRIVATE
+
+/** Receives the message via a specified connection. */
+static int tcmi_skel_msg_recv(struct tcmi_msg *self, struct kkc_sock *sock);
+
+/** Sends the message via a specified connection. */
+static int tcmi_skel_msg_send(struct tcmi_msg *self, struct kkc_sock *sock);
+
+/** Message operations that support polymorphism. */
+static struct tcmi_msg_ops skel_msg_ops;
+
+#endif /* TCMI_SKEL_MSG_PRIVATE */
+
+
+/**
+ * @}
+ */
+
+
+#endif /* _TCMI_SKEL_MSG_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_skel_msg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_skel_msg.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,170 @@
+/**
+ * @file tcmi_skel_msg.c - TCMI skeleton message - example message implementation.
+ *       
+ *                      
+ * 
+ *
+ *
+ * Date: 04/11/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_skel_msg.c,v 1.2 2007/07/02 02:26:17 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include <linux/slab.h>
+
+#include "tcmi_transaction.h"
+
+#include "tcmi_skelresp_msg.h"
+#define TCMI_SKEL_MSG_PRIVATE
+#include "tcmi_skel_msg.h"
+
+
+#include <dbg.h>
+
+
+
+/** 
+ * \<\<public\>\> Skeleton message rx constructor.
+ * This method is called by the factory class.
+ *
+ * @param msg_id - message ID that will be used for this error message
+ * instance.
+ * @return a new error message or NULL.
+ */
+struct tcmi_msg* tcmi_skel_msg_new_rx(u_int32_t msg_id)
+{
+	struct tcmi_skel_msg *msg;
+
+	/* Check if the factory is building what it really thinks. */
+	if (msg_id != TCMI_SKEL_MSG_ID) {
+		mdbg(ERR3, "Factory specified message ID(%x) doesn't match real ID(%x)",
+		     msg_id, TCMI_SKEL_MSG_ID);
+		goto exit0;
+	}
+	/* Allocate the instance */
+	if (!(msg = TCMI_SKEL_MSG(kmalloc(sizeof(struct tcmi_skel_msg), GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate test request message");
+		goto exit0;
+	}
+	/* Initialized the message for receiving. */
+	if (tcmi_msg_init_rx(TCMI_MSG(msg), TCMI_SKEL_MSG_ID, &skel_msg_ops)) {
+		mdbg(ERR3, "Error initializing test request message %x", msg_id);
+		goto exit1;
+	}
+
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+}
+
+/** 
+ * \<\<public\>\> Skeleton message tx constructor.
+ *
+ * The skeleton message can have a transaction associated with it =
+ * there is a response expected for this message by the
+ * sender. Therefore, the user specifies the transaction slot vector.
+ *
+ * When performing the generic tx init, the response message ID is
+ * specified (TCMI_RESPSKEL_MSG_ID) so that it will be associated with the
+ * transaction
+ *
+ * @param *transactions - storage for the new transaction(NULL for one-way messages)
+ * @return a new error ready for the transfer or NULL.
+ */
+struct tcmi_msg* tcmi_skel_msg_new_tx(struct tcmi_slotvec *transactions)
+{
+	struct tcmi_skel_msg *msg;
+
+	if (!(msg = TCMI_SKEL_MSG(kmalloc(sizeof(struct tcmi_skel_msg), GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate test request message");
+		goto exit0;
+	}
+
+	/* Initialize the message for transfer */
+	if (tcmi_msg_init_tx(TCMI_MSG(msg), TCMI_SKEL_MSG_ID, &skel_msg_ops, 
+			     transactions, TCMI_SKELRESP_MSG_ID,
+			     TCMI_SKEL_MSGTIMEOUT, TCMI_TRANSACTION_INVAL_ID)) {
+		mdbg(ERR3, "Error initializing test request message message");
+		goto exit1;
+	}
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+	
+}
+
+
+/** @addtogroup tcmi_skel_msg_class
+ *
+ * @{
+ */
+
+/**
+ * \<\<private\>\> Receives the message via a specified connection. 
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for receiving message data
+ * @return 0 when successfully received.
+ */
+static int tcmi_skel_msg_recv(struct tcmi_msg *self, struct kkc_sock *sock)
+{
+	/* struct tcmi_skel_msg *self_msg = TCMI_SKEL_MSG(self); */  
+	mdbg(INFO2, "Skeleton request message received");
+	
+	return 0;
+}
+
+/**
+ * \<\<private\>\> Receives the message via a specified connection. 
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for sending message data
+ * @return 0 when successfully sent.
+ */
+static int tcmi_skel_msg_send(struct tcmi_msg *self, struct kkc_sock *sock)
+{
+	/* struct tcmi_skel_msg *self_msg = TCMI_SKEL_MSG(self); */
+	mdbg(INFO2, "Skeleton request message sent");
+
+	return 0;
+}
+
+
+
+/** Message operations that support polymorphism. */
+static struct tcmi_msg_ops skel_msg_ops = {
+	.recv = tcmi_skel_msg_recv,
+	.send = tcmi_skel_msg_send
+};
+
+
+/**
+ * @}
+ */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_comm.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_comm.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,133 @@
+/**
+ * @file tcmi_comm.h - TCMI communication communication component.
+ *       
+ *                      
+ * 
+ *
+ *
+ * Date: 04/16/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_comm.h,v 1.2 2007/07/02 02:26:17 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_COMM_H
+#define _TCMI_COMM_H
+
+#include <asm/atomic.h>
+
+#include "tcmi_msg.h"
+#include <kkc/kkc_sock.h>
+
+/** @defgroup tcmi_comm_class tcmi_comm class
+ *
+ * @ingroup tcmi_comm_group
+ *
+ * This class provides functionality to receive and deliver messages
+ * via a specified connection. The base of each instance is a separate
+ * thread receiving messages via specified connection. The user also
+ * specifies a method along with a parameter to be called upon
+ * reception of each message. This method is responsible for message
+ * delivery.
+ *
+ * @{
+ */
+
+/** Message delivery callback method type */
+typedef int deliver_method_t (void*, struct tcmi_msg*);
+
+/** Compound structure that holds reference to the connection and the
+ * user method. */
+struct tcmi_comm {
+	/** reference counter */
+	atomic_t ref_count;
+
+	/** communication socket used for receiving */
+	struct kkc_sock *sock;
+
+	/** message delivery method */
+	deliver_method_t *deliver;
+
+	/** object whose method is to be called for message
+	 * delivery. */
+	void *obj;
+
+	/** preferred group of messages that will be received. */
+	int msg_group;
+
+	/** message receiving thread */
+	struct task_struct *thread;
+};
+
+/** Casts to the tcmi_comm instance. */
+#define TCMI_COMM(c) ((struct tcmi_comm*)c)
+
+/** \<\<public\>\> TCMI communication component constructor. */
+extern struct tcmi_comm* tcmi_comm_new(struct kkc_sock *sock, deliver_method_t *method,
+				       void *obj, int msg_group);
+
+
+
+/** \<\<public\>\> Decrements the reference counter. */
+extern void tcmi_comm_put(struct tcmi_comm *self);
+
+/** 
+ * \<\<public\>\> Instance accessor, increments the reference count.
+ *
+ * @param *self - pointer to this comm instance
+ */
+static inline struct tcmi_comm* tcmi_comm_get(struct tcmi_comm *self)
+{
+	if (self) {
+		atomic_inc(&self->ref_count);
+	}
+	return self;
+}
+
+/** This macro implements atomic check for thread stop request and
+ * puts the task to sleep until such request arrives. Note the order
+ * of operations, the change of the state must always be prior to
+ * checking if it should stop. Any other order is incorrect and might
+ * put the task to sleep indefinitely. Also, it is necessary to set
+ * the state to uninterruptible, so that the thread won't get woken up
+ * rightaway by a pending signal.
+ */
+#define wait_on_should_stop()				\
+do {							\
+	do {						\
+		schedule();				\
+		set_current_state(TASK_UNINTERRUPTIBLE);\
+	} while(!kthread_should_stop());		\
+	set_current_state(TASK_RUNNING);		\
+} while(0)
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_COMM_PRIVATE
+/** Receiving thread method. */
+static int tcmi_comm_thread(void *comm);
+/** Thread counter - used for receiving thread naming. */
+static int tcmi_comm_counter;
+#endif /* TCMI_COMM_PRIVATE */
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_COMM_H */
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_rpc_procmsg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_rpc_procmsg.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,127 @@
+/**
+ * @file tcmi_rpc_procmsg.h - TCMI rpc process communication message - used for rpcs forwarding.
+ *       
+ *                      
+ * 
+ *
+ *
+ * Date: 19/04/2007
+ *
+ * Author: Petr Malat 
+ *
+ * $Id: tcmi_rpc_procmsg.h,v 1.4 2007/09/03 01:17:58 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_RPC_PROCMSG_H
+#define _TCMI_RPC_PROCMSG_H
+
+#include "tcmi_procmsg.h"
+
+/** @defgroup tcmi_rpc_procmsg_class tcmi_rpc_procmsg class
+ *
+ * @ingroup tcmi_procmsg_class
+ *
+ * @relates tcmi_rpc_class
+ *
+ * This class represents RPC process control message and is intended to be used
+ * for system call forwarding .
+ *
+ * @{
+ */
+
+/** Compound structure, inherits from tcmi_procmsg_class */
+struct tcmi_rpc_procmsg {
+	/** parent class instance */
+	struct tcmi_procmsg super;
+	/** RPC number */
+	u_int16_t rpcnum;
+	/** Number of memory elements */
+	u_int16_t nmemb;
+	/** Array with size of elements */
+	u_int32_t *elem_size;
+	/** Array of pointers to elements */ 
+	void **elem_base;
+	/** Free data on put */
+	bool free_data;  // We don't send this
+} __attribute__((__packed__));
+
+
+/** \<\<public\>\> RPC process message constructor for receiving. */
+extern struct tcmi_msg* tcmi_rpc_procmsg_new_rx(u_int32_t msg_id);
+
+/** \<\<public\>\> RPC process message constructor for sending. */
+extern struct tcmi_msg* tcmi_rpc_procmsg_new_tx(struct tcmi_slotvec *transactions, 
+						 pid_t dst_pid);
+
+/** \<\<public\>\> Return RPC parameter. */
+static inline void* tcmi_rpc_procmsg_data_base(struct tcmi_rpc_procmsg *self, unsigned int index){
+	if(index < self->nmemb)
+		return self->elem_base[index];
+	mdbg(ERR3, "Trying to acces beyond array boundary");
+	return NULL;
+}
+
+/** \<\<public\>\> Return RPC parameter size. */
+static inline unsigned long tcmi_rpc_procmsg_data_size(struct tcmi_rpc_procmsg *self, unsigned int index){
+	if(index < self->nmemb)
+		return self->elem_size[index];
+	mdbg(ERR3, "Trying to acces beyond array boundary");
+	return 0;
+}
+
+/** \<\<public\>\> Return RPC number. */
+static inline int tcmi_rpc_procmsg_num (struct tcmi_rpc_procmsg *self){
+	return self->rpcnum;
+}
+
+/** Message descriptor for the factory class, there is no error
+ * handling as this is the starting request */
+#define TCMI_RPC_PROCMSG_DSC TCMI_MSG_DSC(TCMI_RPC_PROCMSG_ID, tcmi_rpc_procmsg_new_rx, NULL)
+/** RPC message transaction timeout set to 10 minutes*/
+#define TCMI_RPC_PROCMSGTIMEOUT 10*60*HZ
+
+/** Casts to the tcmi_rpc_procmsg instance. */
+#define TCMI_RPC_PROCMSG(m) ((struct tcmi_rpc_procmsg*)m)
+
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_RPC_PROCMSG_PRIVATE
+
+/** Receives the message via a specified connection. */
+static int tcmi_rpc_procmsg_recv(struct tcmi_procmsg *self, struct kkc_sock *sock);
+
+/** Sends the message via a specified connection. */
+static int tcmi_rpc_procmsg_send(struct tcmi_procmsg *self, struct kkc_sock *sock);
+
+/** Frees RPC message resources */
+static void tcmi_rpc_procmsg_free(struct tcmi_procmsg *self);
+
+/** Message operations that support polymorphism. */
+static struct tcmi_procmsg_ops rpc_procmsg_ops;
+
+#endif /* TCMI_RPC_PROCMSG_PRIVATE */
+
+
+/**
+ * @}
+ */
+
+
+#endif /* _TCMI_RPC_PROCMSG_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_err_msg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_err_msg.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,184 @@
+/**
+ * @file tcmi_err_msg.c - TCMI error message - carries an error status code.
+ *       
+ *                      
+ * 
+ *
+ *
+ * Date: 04/11/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_err_msg.c,v 1.3 2007/09/02 10:54:25 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include <linux/slab.h>
+
+#define TCMI_ERR_MSG_PRIVATE
+#include "tcmi_err_msg.h"
+
+
+#include <dbg.h>
+
+
+
+/** 
+ * \<\<public\>\> Error message rx constructor.  This constructor is
+ * made available for other messages, so that they can specify it as
+ * their error constructor for \link tcmi_msg_factory_class the
+ * factory class \endlink.
+ *
+ * @param msg_id - message ID that will be used for this error message
+ * instance.
+ * @return a new error message or NULL.
+ */
+struct tcmi_msg* tcmi_err_msg_new_rx(u_int32_t msg_id)
+{
+	struct tcmi_err_msg *msg;
+
+	if (!(msg = TCMI_ERR_MSG(kmalloc(sizeof(struct tcmi_err_msg), GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate memory for error message %x", msg_id);
+		goto exit0;
+	}
+	/* Initialized the message for receiving, message ID is
+	 * extended with error flags */
+	if (tcmi_msg_init_rx(TCMI_MSG(msg), TCMI_MSG_FLG_SET_ERR(msg_id), &err_msg_ops)) {
+		mdbg(ERR3, "Error initializing error message %x", msg_id);
+		goto exit1;
+	}
+
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+}
+
+/** 
+ * \<\<public\>\> Error message constructor for transferring.
+ *
+ * An error message is considered one way only and is usually used as a
+ * error response to some other message. The user thus has to specify
+ * the transaction ID of the message that the error message is a response too.
+ * Messages with TCMI_TRANSACTION_INVAL_ID are possible too. No search
+ * for a matching transaction will be performed at the receiving party and
+ * the message will be queued in a regular request queue.
+ *
+ * Basic part of instantation is the same as when creating an Rx version.
+ *
+ * @param msg_id - ID assigned to the error message, it will be extended
+ * with error flags, so that the message factory at the receiving party uses
+ * the above implemented tcmi_err_msg_new_rx() constructor.
+ * @param trans_id - transaction ID 
+
+ * @param err_code - error code that will be stored in the message
+ *
+ * @return a new error ready for the transfer or NULL.
+ */
+struct tcmi_msg* tcmi_err_msg_new_tx(u_int32_t msg_id, u_int32_t trans_id, int32_t err_code)
+{
+	struct tcmi_err_msg *msg;
+
+	if (!(msg = TCMI_ERR_MSG(kmalloc(sizeof(struct tcmi_err_msg), GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate memory for error message %x", msg_id);
+		goto exit0;
+	}
+
+	/* Initialize the message for transfer, message ID is
+	 * extended with error flags, no transaction created or
+	 * response ID setup. Only the transaction ID, that will get
+	 * send along with the message, is set. */
+	if (tcmi_msg_init_tx(TCMI_MSG(msg), TCMI_MSG_FLG_SET_ERR(msg_id), &err_msg_ops, 
+			     NULL, 0, 0, trans_id)) {
+		mdbg(ERR3, "Error initializing error message %x", msg_id);
+		goto exit1;
+	}
+	msg->err_code = err_code;
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+	
+}
+
+
+/** @addtogroup tcmi_err_msg_class
+ *
+ * @{
+ */
+
+/**
+ * \<\<private\>\> Receives the message via a specified connection.
+ * Receiving the error message requires reading the error code from
+ * the specified socket
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for receiving message data
+ * @return 0 when successfully received.
+ */
+static int tcmi_err_msg_recv(struct tcmi_msg *self, struct kkc_sock *sock)
+{
+	int err;
+	struct tcmi_err_msg *self_err = TCMI_ERR_MSG(self);
+
+	err = kkc_sock_recv(sock, &self_err->err_code, 
+			    sizeof(self_err->err_code), KKC_SOCK_BLOCK);
+	mdbg(INFO3, "Received error code: %x", self_err->err_code);
+	
+	return err;
+}
+
+/**
+ * \<\<private\>\> Sends out the error code via specified socket.
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for receiving message data
+ * @return 0 when successfully sent.
+ */
+static int tcmi_err_msg_send(struct tcmi_msg *self, struct kkc_sock *sock)
+{
+	int err;
+	struct tcmi_err_msg *self_err = TCMI_ERR_MSG(self);
+
+	err = kkc_sock_send(sock, &self_err->err_code, 
+			    sizeof(self_err->err_code), KKC_SOCK_BLOCK);
+
+	mdbg(INFO3, "Sent error code: %x", self_err->err_code);
+
+	return err;
+}
+
+
+
+/** Message operations that support polymorphism. */
+static struct tcmi_msg_ops err_msg_ops = {
+	.recv = tcmi_err_msg_recv,
+	.send = tcmi_err_msg_send
+};
+
+
+/**
+ * @}
+ */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_authenticate_resp_msg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_authenticate_resp_msg.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,117 @@
+/**
+ * @file tcmi_authenticate_resp_msg.h - authentication response message
+ */
+
+#ifndef TCMI_AUTHENTICATE_RESP_MSG_H
+#define TCMI_AUTHENTICATE_RESP_MSG_H
+
+#include "tcmi_msg.h"
+#include <arch/arch_ids.h>
+#include <tcmi/migration/fs/fs_mount_params.h>
+
+/** @defgroup tcmi_authenticate_resp_msg_class tcmi_authenticate_resp_msg class
+ *
+ * @ingroup tcmi_msg_class
+ *
+ * This message is send as a response to authentication request by the CCN to PEN
+ * 
+ * @{
+ */
+
+/** Authentication response message structure */
+struct tcmi_authenticate_resp_msg {
+	/** parent class instance. */
+	struct tcmi_msg super;
+	/** Id of the ccn that was asked for the authentication */
+	u_int32_t ccn_id;
+	/** Architecture of ccn */
+	enum arch_ids ccn_arch;
+	/** Parameters of the mount operation to be performed on task execve on PEN side */
+	struct fs_mount_params mount_params;
+	/** 0 if authentication succeeded, negative otherwise */
+	int8_t result_code;
+};
+
+
+
+
+/** \<\<public\>\> Authentication response message constructor for receiving. */
+extern struct tcmi_msg* tcmi_authenticate_resp_msg_new_rx(u_int32_t msg_id);
+
+/** \<\<public\>\> Authentication response message constructor for transferring. */
+extern struct tcmi_msg* tcmi_authenticate_resp_msg_new_tx(u_int32_t trans_id, 
+						       u_int32_t ccn_id, enum arch_ids ccn_arch, int8_t result_code, struct fs_mount_params* mount_params);
+
+
+/** \<\<public\>\> Message descriptor for the factory class */
+#define TCMI_AUTHENTICATE_RESP_MSG_DSC TCMI_MSG_DSC(TCMI_AUTHENTICATE_RESP_MSG_ID, tcmi_authenticate_resp_msg_new_rx, tcmi_err_msg_new_rx)
+
+/** Casts to the tcmi_authenticate_resp_msg instance. */
+#define TCMI_AUTHENTICATE_RESP_MSG(m) ((struct tcmi_authenticate_resp_msg*)m)
+
+/**
+ * \<\<public\>\> CCN id getter
+ * 
+ * @param *self - this message instance
+ * @return CCN id
+ */
+static inline u_int32_t tcmi_authenticate_resp_msg_ccn_id(struct tcmi_authenticate_resp_msg *self)
+{
+	return self->ccn_id;
+}
+
+/**
+ * \<\<public\>\> CCN architecture getter
+ * 
+ * @param *self - this message instance
+ * @return CCN architecture
+ */
+static inline enum arch_ids tcmi_authenticate_resp_msg_arch(struct tcmi_authenticate_resp_msg *self)
+{
+	return self->ccn_arch;
+}
+
+/**
+ * \<\<public\>\> Result code getter
+ * 
+ * @param *self - this message instance
+ * @return result code
+ */
+static inline int8_t tcmi_authenticate_resp_msg_result_code(struct tcmi_authenticate_resp_msg *self)
+{
+	return self->result_code;
+}
+
+/**
+ * \<\<public\>\> Mount params getter
+ * 
+ * @param *self - this message instance
+ * @return Mount params
+ */
+static inline struct fs_mount_params* tcmi_authenticate_resp_msg_mount_params(struct tcmi_authenticate_resp_msg *self) {
+	return &self->mount_params;
+}
+
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_AUTHENTICATE_RESP_MSG_PRIVATE
+
+/** Receives the message via a specified connection. */
+static int tcmi_authenticate_resp_msg_recv(struct tcmi_msg *self, struct kkc_sock *sock);
+
+/** Sends the message via a specified connection. */
+static int tcmi_authenticate_resp_msg_send(struct tcmi_msg *self, struct kkc_sock *sock);
+
+/** Message operations that support polymorphism. */
+static struct tcmi_msg_ops authenticate_resp_msg_ops;
+
+#endif
+
+
+/**
+ * @}
+ */
+
+
+#endif
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_signal_msg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_signal_msg.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,108 @@
+/**
+ * @file tcmi_signal_msg.h - TCMI signal communication message 
+ *                      
+ * 
+ *
+ *
+ * Date: 04/11/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_signal_msg.h,v 1.2 2007/09/02 10:54:25 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_SIGNAL_MSG_H
+#define _TCMI_SIGNAL_MSG_H
+
+#include "tcmi_msg.h"
+
+/** @defgroup tcmi_signal_msg_class tcmi_signal_msg class
+ *
+ * @ingroup tcmi_msg_class
+ *
+ * This class represents a test message and is intended to be used
+ * as a skeleton when implementing new messages in the TCMI protocol.
+ * To implement a new message following steps need to be done:
+ * - Implement the constructors
+ *   - new_tx - functionality to allocate a message for transfer based on 
+ *   custom parameters specific to each message type. Use init_tx for initialization
+ *   of the super class instance data
+ *   - new_rx - same, but for reception, therefore, no parameters are specified. If needed
+ *   compare the supplied message ID, with the official message ID assigned to this type
+ *   of message.
+ *   - new_rx_err - A custom build of error message can be specified or some generic
+ *   new_rx_err message constructor can be used.
+ * - Choose a message identifier and append it to a proper group in tcmi_messages_id.h
+ * - Declare a new message descriptor, append it into tcmi_messages_dsc.h 
+ * - Implement custom operations if needed.
+ * @{
+ */
+
+/** Compound structure, inherits from tcmi_msg_class */
+struct tcmi_signal_msg {
+	/** parent class instance */
+	struct tcmi_msg super;
+	/** Target PID */
+	pid_t pid;
+	/** Siginfo structure (we can use directly this structure as it is padded to be exactly 128 bytes) */
+	siginfo_t info;
+} __attribute__((__packed__));
+
+
+/** \<\<public\>\> Skeleton message constructor for receiving. */
+extern struct tcmi_msg* tcmi_signal_msg_new_rx(u_int32_t msg_id);
+
+/** \<\<public\>\> Skeleton message constructor for transferring. */
+extern struct tcmi_msg* tcmi_signal_msg_new_tx(struct tcmi_slotvec *transactions);
+
+/** \<\<public\>\> Construktor for sending with initialization */
+struct tcmi_msg *tcmi_signal_msg_new(pid_t pid, siginfo_t *info);
+
+/** Message descriptor for the factory class, there is no error
+ * handling as this is the starting request */
+#define TCMI_SIGNAL_MSG_DSC TCMI_MSG_DSC(TCMI_SIGNAL_MSG_ID, tcmi_signal_msg_new_rx, NULL)
+/** Skeleton message transaction timeout set to 5 seconds*/
+#define TCMI_SIGNAL_MSGTIMEOUT 5*HZ
+
+/** Casts to the tcmi_signal_msg instance. */
+#define TCMI_SIGNAL_MSG(m) ((struct tcmi_signal_msg*)m)
+
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_SIGNAL_MSG_PRIVATE
+
+/** Receives the message via a specified connection. */
+static int tcmi_signal_msg_recv(struct tcmi_msg *self, struct kkc_sock *sock);
+
+/** Sends the message via a specified connection. */
+static int tcmi_signal_msg_send(struct tcmi_msg *self, struct kkc_sock *sock);
+
+/** Message operations that support polymorphism. */
+static struct tcmi_msg_ops skel_msg_ops;
+
+#endif /* TCMI_SIGNAL_MSG_PRIVATE */
+
+
+/**
+ * @}
+ */
+
+
+#endif /* _TCMI_SIGNAL_MSG_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_ppm_p_migr_back_shadowreq_procmsg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_ppm_p_migr_back_shadowreq_procmsg.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,60 @@
+/**
+ * @file tcmi_ppm_p_migr_back_shadowreq_procmsg.h - migrate back request initiated by shadow
+ */
+#ifndef _TCMI_PPM_P_MIGR_BACK_SHADOWREQ_PROCMSG_H
+#define _TCMI_PPM_P_MIGR_BACK_SHADOWREQ_PROCMSG_H
+
+#include "tcmi_procmsg.h"
+#include "tcmi_err_procmsg.h"
+
+/** @defgroup tcmi_ppm_p_migr_back_shadowreq_procmsg_class tcmi_ppm_p_migr_back_shadowreq_procmsg class
+ *
+ * @ingroup tcmi_procmsg_class
+ *
+ * This class represents a message that is sent by a shadow task to the
+ * guest task as a request to migrate the process back to CCN
+ *
+ * @{
+ */
+
+/** Compound structure, inherits from tcmi_procmsg_class */
+struct tcmi_ppm_p_migr_back_shadowreq_procmsg {
+	/** parent class instance */
+	struct tcmi_procmsg super;
+};
+
+/** \<\<public\>\> Shadow request for migration back rx constructor. */
+extern struct tcmi_msg* tcmi_ppm_p_migr_back_shadowreq_procmsg_new_rx(u_int32_t msg_id);
+
+/** \<\<public\>\> Shadow request for migration back tx constructor. */
+extern struct tcmi_msg* tcmi_ppm_p_migr_back_shadowreq_procmsg_new_tx(pid_t dst_pid);
+
+/** Message descriptor for the factory class, for error handling we used tcmi_errmsg_class */
+#define TCMI_PPM_P_MIGR_BACK_SHADOWREQ_PROCMSG_DSC \
+TCMI_MSG_DSC(TCMI_PPM_P_MIGR_BACK_SHADOWREQ_PROCMSG_ID, tcmi_ppm_p_migr_back_shadowreq_procmsg_new_rx, tcmi_err_procmsg_new_rx)
+
+/** Casts to the tcmi_ppm_p_migr_back_shadowreq_procmsg instance. */
+#define TCMI_PPM_P_MIGR_BACK_SHADOWREQ_PROCMSG(m) ((struct tcmi_ppm_p_migr_back_shadowreq_procmsg*)m)
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_PPM_P_MIGR_BACK_SHADOWREQ_PROCMSG_PRIVATE
+
+/** Receives the message via a specified connection. */
+static int tcmi_ppm_p_migr_back_shadowreq_procmsg_recv(struct tcmi_procmsg *self, struct kkc_sock *sock);
+
+/** Sends the message via a specified connection. */
+static int tcmi_ppm_p_migr_back_shadowreq_procmsg_send(struct tcmi_procmsg *self, struct kkc_sock *sock);
+
+/** Message operations that support polymorphism. */
+static struct tcmi_procmsg_ops ppm_p_migr_back_shadowreq_procmsg_ops;
+
+#endif /* TCMI_PPM_P_MIGR_BACK_SHADOWREQ_PROCMSG_PRIVATE */
+
+
+/**
+ * @}
+ */
+
+#endif
+
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_skel_procmsg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_skel_procmsg.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,108 @@
+/**
+ * @file tcmi_skel_procmsg.h - TCMI test process communication message - can be used as skeleton
+ *                             for other process control messages.
+ *       
+ *                      
+ * 
+ *
+ *
+ * Date: 04/19/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_skel_procmsg.h,v 1.2 2007/07/02 02:26:17 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_SKEL_PROCMSG_H
+#define _TCMI_SKEL_PROCMSG_H
+
+#include "tcmi_procmsg.h"
+
+/** @defgroup tcmi_skel_procmsg_class tcmi_skel_procmsg class
+ *
+ * @ingroup tcmi_procmsg_class
+ *
+ * This class represents a test process control message and is intended to be used
+ * as a skeleton when implementing new process control messages in the TCMI protocol.
+ * To implement a new message following steps need to be done:
+ * - Implement the constructors:
+ *   - new_tx - functionality to allocate a message for transfer based on 
+ *   custom parameters specific to each message type. Use init_tx for initialization
+ *   of the super class instance data
+ *   - new_rx - same, but for reception, therefore, no parameters are specified. If needed
+ *   compare the supplied message ID, with the official message ID assigned to this type
+ *   of message.
+ *   - new_rx_err - A custom build of error message can be specified or some generic
+ *   new_rx_err message constructor can be used.
+ * - Choose a message identifier and append it to a proper group in tcmi_messages_id.h
+ * - Declare a new message descriptor, append it into tcmi_messages_dsc.h 
+ * - Implement custom operations if needed.
+ *
+ * @{
+ */
+
+/** Compound structure, inherits from tcmi_procmsg_class */
+struct tcmi_skel_procmsg {
+	/** parent class instance */
+	struct tcmi_procmsg super;
+};
+
+
+
+
+/** \<\<public\>\> Skeleton process message constructor for receiving. */
+extern struct tcmi_msg* tcmi_skel_procmsg_new_rx(u_int32_t msg_id);
+
+/** \<\<public\>\> Skeleton process message constructor for transferring. */
+extern struct tcmi_msg* tcmi_skel_procmsg_new_tx(struct tcmi_slotvec *transactions, 
+						 pid_t dst_pid);
+
+
+/** Message descriptor for the factory class, there is no error
+ * handling as this is the starting request */
+#define TCMI_SKEL_PROCMSG_DSC TCMI_MSG_DSC(TCMI_SKEL_PROCMSG_ID, tcmi_skel_procmsg_new_rx, NULL)
+/** Test message transaction timeout set to 5 seconds*/
+#define TCMI_SKEL_PROCMSGTIMEOUT 5*HZ
+
+/** Casts to the tcmi_skel_procmsg instance. */
+#define TCMI_SKEL_PROCMSG(m) ((struct tcmi_skel_procmsg*)m)
+
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_SKEL_PROCMSG_PRIVATE
+
+/** Receives the message via a specified connection. */
+static int tcmi_skel_procmsg_recv(struct tcmi_procmsg *self, struct kkc_sock *sock);
+
+/** Sends the message via a specified connection. */
+static int tcmi_skel_procmsg_send(struct tcmi_procmsg *self, struct kkc_sock *sock);
+
+/** Message operations that support polymorphism. */
+static struct tcmi_procmsg_ops skel_procmsg_ops;
+
+#endif /* TCMI_SKEL_PROCMSG_PRIVATE */
+
+
+/**
+ * @}
+ */
+
+
+#endif /* _TCMI_SKEL_PROCMSG_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_rpc_procmsg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_rpc_procmsg.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,257 @@
+/**
+ * @file tcmi_rpc_procmsg.c - TCMI rpc message.
+ *       
+ *                      
+ * 
+ *
+ *
+ * Date: 19/04/2007
+ *
+ * Author: Petr Malat
+ * 
+ * $Id: tcmi_rpc_procmsg.c,v 1.5 2008/01/17 14:36:44 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include <linux/slab.h>
+#include <dbg.h>
+#include "tcmi_transaction.h"
+
+#define TCMI_RPC_PROCMSG_PRIVATE
+#include "tcmi_rpc_procmsg.h"
+
+
+#define SIZE_OF_ELEM_SIZE (self_msg->nmemb*sizeof(*(self_msg->elem_size)))
+#define SIZE_OF_ELEM_BASE (self_msg->nmemb*sizeof(*(self_msg->elem_base)))
+
+/** 
+ * \<\<public\>\> RPC message rx constructor.
+ * This method is called by the factory class.
+ *
+ * @param msg_id - message ID that will be used for this RPC message
+ * instance.
+ * @return a new RPC message or NULL.
+ */
+struct tcmi_msg* tcmi_rpc_procmsg_new_rx(u_int32_t msg_id)
+{
+	struct tcmi_rpc_procmsg *msg;
+	mdbg(INFO3, "in tcmi_rpc_procmsg_new_rx()");
+
+	/* Check if the factory is building what it really thinks. */
+	if (msg_id != TCMI_RPC_PROCMSG_ID) {
+		mdbg(ERR3, "Factory specified message ID(%x) doesn't match real ID(%x)",
+		     msg_id, TCMI_RPC_PROCMSG_ID);
+		goto exit0;
+	}
+	/* Allocate the instance */
+	if (!(msg = TCMI_RPC_PROCMSG(kmalloc(sizeof(struct tcmi_rpc_procmsg), GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate RPC message");
+		goto exit0;
+	}
+	/* Initialized the message for receiving. */
+	if (tcmi_procmsg_init_rx(TCMI_PROCMSG(msg), TCMI_RPC_PROCMSG_ID, &rpc_procmsg_ops)) {
+		mdbg(ERR3, "Error initializing RPC message %x", msg_id);
+		goto exit1;
+	}
+	msg->free_data = 1;
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+}
+
+/** 
+ * \<\<public\>\> RPC message tx constructor.
+ *
+ * When performing the generic proc tx init, the response message ID is
+ * specified (TCMI_RESPRPC_PROCMSG_ID) so that it will be associated with the
+ * transaction. Also, the generic tx initializer is supplied with the destination
+ * process ID.
+ *
+ * @param *transactions - storage for the new transaction(NULL for one-way messages)
+ * @param dst_pid - destination process PID
+ * @return a new error ready for the transfer or NULL.
+ */
+struct tcmi_msg* tcmi_rpc_procmsg_new_tx(struct tcmi_slotvec *transactions, pid_t dst_pid)
+{
+	struct tcmi_rpc_procmsg *msg;
+
+	if (!(msg = TCMI_RPC_PROCMSG(kmalloc(sizeof(struct tcmi_rpc_procmsg), GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate RPC message");
+		goto exit0;
+	}
+	msg->free_data = 0;
+
+	/* Initialize the message for transfer */
+	if (tcmi_procmsg_init_tx(TCMI_PROCMSG(msg), TCMI_RPC_PROCMSG_ID, &rpc_procmsg_ops, 
+				 dst_pid, 0,
+				 transactions, TCMI_RPCRESP_PROCMSG_ID,
+				 TCMI_RPC_PROCMSGTIMEOUT, TCMI_TRANSACTION_INVAL_ID)) {
+		mdbg(ERR3, "Error initializing RPC message");
+		goto exit1;
+	}
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+	
+}
+
+/** @addtogroup tcmi_rpc_procmsg_class
+ *
+ * @{
+ */
+
+/**
+ * \<\<private\>\> Receives the RPC message via a specified connection. 
+ * Receiving the erro message requires reading the error code from the specified
+ * connection 
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for receiving message data
+ * @return 0 when successfully received.
+ */
+static int tcmi_rpc_procmsg_recv(struct tcmi_procmsg *self, struct kkc_sock *sock)
+{
+	int err, data_size, total, i;
+	struct tcmi_rpc_procmsg *self_msg = TCMI_RPC_PROCMSG(self);
+
+	err = kkc_sock_recv(sock, &self_msg->rpcnum, 
+			    sizeof(self_msg->rpcnum) + sizeof(self_msg->nmemb), KKC_SOCK_BLOCK) ;
+	if( err < 0 ) {
+		mdbg(ERR3, "Cannot read rpc message header");
+		return err;
+	}
+	total = err;
+	
+	if( self_msg->nmemb > 0 ){
+		/* Allocate memory for array of elements size and array of pointers to elements */
+		self_msg->elem_size = kmalloc(SIZE_OF_ELEM_SIZE + SIZE_OF_ELEM_BASE, GFP_KERNEL);
+		self_msg->elem_base = (void*)self_msg->elem_size + SIZE_OF_ELEM_SIZE;
+		self_msg->elem_base[0] = NULL;
+
+		err = kkc_sock_recv(sock, self_msg->elem_size, SIZE_OF_ELEM_SIZE, KKC_SOCK_BLOCK);
+		if( err < 0 ) {
+			mdbg(ERR3, "Cannot read elem size of RPC#%d", self_msg->rpcnum);
+			return err;
+		}
+
+		total += err;
+
+		/* Allocate memory for data */
+		for(data_size = 0, i = 0; i < self_msg->nmemb; data_size += self_msg->elem_size[i++]);
+		self_msg->elem_base[0] = kmalloc( data_size, GFP_KERNEL );
+
+		err = kkc_sock_recv(sock, self_msg->elem_base[0], data_size, KKC_SOCK_BLOCK);
+		if( err < 0 ) {
+			mdbg(ERR3, "Cannot read elements of RPC#%d (data_size %d)", self_msg->rpcnum, data_size);
+			return err;
+		}
+		total += err;
+
+		for( i = 1; i < self_msg->nmemb; i++ )
+			self_msg->elem_base[i] = self_msg->elem_base[i-1] + self_msg->elem_size[i-1];
+	}
+
+
+	mdbg(INFO3, "Received: RPC#%d message (%d Bytes, %d params)", self_msg->rpcnum, total, self_msg->nmemb);
+	
+	return 0;
+}
+
+/**
+ * \<\<private\>\> Sends the RPC message via a specified connection. 
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for sending message data
+ * @return 0 when successfully sent.
+ */
+static int tcmi_rpc_procmsg_send(struct tcmi_procmsg *self, struct kkc_sock *sock)
+{
+	int err, total, i;
+	struct tcmi_rpc_procmsg *self_msg = TCMI_RPC_PROCMSG(self); 
+
+	err = kkc_sock_send(sock, &self_msg->rpcnum, 
+			    sizeof(self_msg->rpcnum) + sizeof(self_msg->nmemb), KKC_SOCK_BLOCK) ;
+	if( err < 0 ) {
+		mdbg(ERR3, "Error sending RPC#%d message. Error code: %d", self_msg->rpcnum, err);
+		return err;
+	}
+
+	total = err;
+
+	if( self_msg->nmemb > 0 ){
+		err = kkc_sock_send(sock, self_msg->elem_size, SIZE_OF_ELEM_SIZE, KKC_SOCK_BLOCK);
+		if( err < 0 ) {
+			mdbg(ERR3, "Error sending RPC#%d message elem size. Error code: %d", self_msg->rpcnum, err);
+			return err;
+		}
+		total += err;
+
+		for( i = 0; i < self_msg->nmemb; i++ ){
+			err = kkc_sock_send(sock, self_msg->elem_base[i],
+					self_msg->elem_size[i], KKC_SOCK_BLOCK);
+
+			if( err < 0 ) {
+				mdbg(ERR3, "Error sending RPC#%d message elem[%d]. Error code: %d", self_msg->rpcnum, i, err);	
+				return err;
+			}
+			total += err;
+		}
+	}
+	mdbg(INFO3, "Sent: RPC#%d message (%d Bytes)", self_msg->rpcnum, total);
+
+	return 0;
+}
+
+/**
+ * \<\<private\>\> Frees RPC message resources
+ *
+ * @param *self - this message instance
+ */
+static void tcmi_rpc_procmsg_free(struct tcmi_procmsg *self)
+{
+	struct tcmi_rpc_procmsg *self_msg = TCMI_RPC_PROCMSG(self);
+	if ( !self_msg )
+		return;
+
+	if( self_msg->nmemb > 0 ){
+		if( self_msg->free_data == 1 ) kfree( self_msg->elem_base[0] ); /* frees all data */
+		kfree( self_msg->elem_size );    /* elem_base and elem_size are allocated in one time */
+	}
+}
+
+
+/** Message operations that support polymorphism. */
+static struct tcmi_procmsg_ops rpc_procmsg_ops = {
+	.recv = tcmi_rpc_procmsg_recv,
+	.send = tcmi_rpc_procmsg_send,
+	.free = tcmi_rpc_procmsg_free
+};
+
+
+/**
+ * @}
+ */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_skelresp_procmsg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_skelresp_procmsg.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,96 @@
+/**
+ * @file tcmi_skelresp_procmsg.h - TCMI test response process message - can be used as skeleton
+ *                                 for any response process message.
+ *       
+ *                      
+ * 
+ *
+ *
+ * Date: 04/19/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_skelresp_procmsg.h,v 1.2 2007/07/02 02:26:17 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_SKELRESP_PROCMSG_H
+#define _TCMI_SKELRESP_PROCMSG_H
+
+#include "tcmi_procmsg.h"
+#include "tcmi_err_procmsg.h"
+
+/** @defgroup tcmi_skelresp_procmsg_class tcmi_skelresp_procmsg class
+ *
+ * @ingroup tcmi_procmsg_class
+ *
+ * This class represents a test process message and is intended to be used
+ * as a skeleton response when implementing new response process messages in the TCMI protocol.
+ * To implement a new message the same steps need to be
+ * done as in case of a request message. In addition the instance should be
+ * aware of what messages it is a reply to.
+ * @{
+ */
+
+/** Compound structure, inherits from tcmi_procmsg_class */
+struct tcmi_skelresp_procmsg {
+	/** parent class instance */
+	struct tcmi_procmsg super;
+};
+
+
+
+
+/** \<\<public\>\> Skeleton response process message rx constructor. */
+extern struct tcmi_msg* tcmi_skelresp_procmsg_new_rx(u_int32_t msg_id);
+
+/** \<\<public\>\> Skeleton response process message tx constructor. */
+extern struct tcmi_msg* tcmi_skelresp_procmsg_new_tx(u_int32_t trans_id, pid_t dst_pid);
+
+
+
+
+/** Message descriptor for the factory class, for error handling we used tcmi_errmsg_class */
+#define TCMI_SKELRESP_PROCMSG_DSC \
+TCMI_MSG_DSC(TCMI_SKELRESP_PROCMSG_ID, tcmi_skelresp_procmsg_new_rx, tcmi_err_procmsg_new_rx)
+
+/** Casts to the tcmi_skelresp_procmsg instance. */
+#define TCMI_SKELRESP_PROCMSG(m) ((struct tcmi_skelresp_procmsg*)m)
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_SKELRESP_PROCMSG_PRIVATE
+
+/** Receives the message via a specified connection. */
+static int tcmi_skelresp_procmsg_recv(struct tcmi_procmsg *self, struct kkc_sock *sock);
+
+/** Sends the message via a specified connection. */
+static int tcmi_skelresp_procmsg_send(struct tcmi_procmsg *self, struct kkc_sock *sock);
+
+/** Message operations that support polymorphism. */
+static struct tcmi_procmsg_ops skelresp_procmsg_ops;
+
+#endif /* TCMI_SKELRESP_PROCMSG_PRIVATE */
+
+
+/**
+ * @}
+ */
+
+
+#endif /* _TCMI_SKELRESP_PROCMSG_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_generic_user_msg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_generic_user_msg.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,103 @@
+/**
+ * @file tcmi_generic_user_msg.h - generic userspace message.
+ */
+
+#ifndef TCMI_GENERIC_USER_MSG_H
+#define TCMI_GENERIC_USER_MSG_H
+
+#include "tcmi_msg.h"
+
+/** @defgroup tcmi_generic_user_class tcmi_generic_user_msg class
+ *
+ * @ingroup tcmi_msg_class
+ *
+ * This message can be send both by PEN or CCN. It can contain any data that are passed from user space to the director of peer node.
+ * 
+ * @{
+ */
+
+/** Generic user message structure */
+struct tcmi_generic_user_msg {
+	/** parent class instance. */
+	struct tcmi_msg super;
+	/** Id of the requestor PEN or CCN */
+	u_int32_t node_id;
+
+	/** User passed data. Opaque to the kernel part, this is purely user space responsibilithy to provide and parse those. */
+	char *user_data;
+	/** Size of user data */
+	u_int32_t size;
+};
+
+
+
+
+/** \<\<public\>\> Message consutructor for receiving. */
+extern struct tcmi_msg* tcmi_generic_user_msg_new_rx(u_int32_t msg_id);
+
+/** \<\<public\>\> Message constructor for transferring. */
+extern struct tcmi_msg* tcmi_generic_user_msg_new_tx(u_int32_t node_id, char* user_data, int size);
+
+
+/** \<\<public\>\> Message descriptor for the factory class, there is no error
+ * handling as this is the starting request */
+#define TCMI_GENERIC_USER_MSG_DSC TCMI_MSG_DSC(TCMI_GENERIC_USER_MSG_ID, tcmi_generic_user_msg_new_rx, NULL)
+
+/** Casts to the tcmi_generic_user_msg instance. */
+#define TCMI_GENERIC_USER_MSG(m) ((struct tcmi_generic_user_msg*)m)
+
+/**
+ * \<\<public\>\> Node id getter
+ * 
+ * @param *self - this message instance
+ * @return Node id
+ */
+static inline u_int32_t tcmi_generic_user_msg_node_id(struct tcmi_generic_user_msg *self)
+{
+	return self->node_id;
+}
+
+/**
+ * \<\<public\>\> User data length getter
+ * 
+ * @param *self - this message instance
+ * @return data length
+ */
+static inline u_int32_t tcmi_generic_user_msg_user_data_size(struct tcmi_generic_user_msg *self)
+{
+	return self->size;
+}
+
+/**
+ * \<\<public\>\> User data data getter
+ * 
+ * @param *self - this message instance
+ * @return User data
+ */
+static inline char* tcmi_generic_user_msg_user_data(struct tcmi_generic_user_msg *self)
+{
+	return self->user_data;
+}
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_GENERIC_USER_MSG_PRIVATE
+
+/** Receives the message via a specified connection. */
+static int tcmi_generic_user_msg_recv(struct tcmi_msg *self, struct kkc_sock *sock);
+
+/** Sends the message via a specified connection. */
+static int tcmi_generic_user_msg_send(struct tcmi_msg *self, struct kkc_sock *sock);
+
+/** Message operations that support polymorphism. */
+static struct tcmi_msg_ops generic_user_msg_ops;
+
+#endif
+
+
+/**
+ * @}
+ */
+
+
+#endif
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_vfork_done_procmsg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_vfork_done_procmsg.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,63 @@
+/**
+ * @file tcmi_vfork_done_procmsg.h - TCMI vfork done, send to notify about vfork completition
+ */
+#ifndef _TCMI_VFORK_DONE_PROCMSG_H
+#define _TCMI_VFORK_DONE_PROCMSG_H
+
+#include "tcmi_procmsg.h"
+
+/** @defgroup tcmi_vfork_done_procmsg_class tcmi_vfork_done_procmsg class
+ *
+ * @ingroup tcmi_procmsg_class
+ *
+ * This class represents an vfork done notification message.
+ *
+ * @{
+ */
+
+/** Compound structure, inherits from tcmi_procmsg_class */
+struct tcmi_vfork_done_procmsg {
+	/** parent class instance. */
+	struct tcmi_procmsg super;
+};
+
+
+
+
+/** \<\<public\>\> Vfork done process message constructor for receiving. */
+extern struct tcmi_msg* tcmi_vfork_done_procmsg_new_rx(u_int32_t msg_id);
+
+/** \<\<public\>\>  Vfork done process message constructor for transferring. */
+extern struct tcmi_msg* tcmi_vfork_done_procmsg_new_tx(pid_t dst_pid);
+
+
+/** Message descriptor for the factory class, there is no error
+ * handling as this is the starting request */
+#define TCMI_VFORK_DONE_PROCMSG_DSC TCMI_MSG_DSC(TCMI_VFORK_DONE_PROCMSG_ID, tcmi_vfork_done_procmsg_new_rx, NULL)
+
+/** Casts to the tcmi_vfork_done_procmsg instance. */
+#define TCMI_VFORK_DONE_PROCMSG(m) ((struct tcmi_vfork_done_procmsg*)m)
+
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_VFORK_DONE_PROCMSG_PRIVATE
+
+/** Receives the message via a specified connection. */
+static int tcmi_vfork_done_procmsg_recv(struct tcmi_procmsg *self, struct kkc_sock *sock);
+
+/** Sends the message via a specified connection. */
+static int tcmi_vfork_done_procmsg_send(struct tcmi_procmsg *self, struct kkc_sock *sock);
+
+/** Message operations that support polymorphism. */
+static struct tcmi_procmsg_ops vfork_done_procmsg_ops;
+
+#endif /* TCMI_VFORK_DONE_PROCMSG_PRIVATE */
+
+
+/**
+ * @}
+ */
+
+
+#endif /* _TCMI_VFORK_DONE_PROCMSG_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_comm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_comm.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,191 @@
+/**
+ * @file tcmi_comm.c - TCMI communication communication component.
+ *       
+ *                      
+ * 
+ *
+ *
+ * Date: 04/16/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_comm.c,v 1.2 2007/07/02 02:26:17 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <linux/kthread.h>
+
+#include "tcmi_msg_factory.h"
+
+#define TCMI_COMM_PRIVATE
+#include "tcmi_comm.h"
+
+#include <dbg.h>
+
+
+
+/** 
+ * \<\<public\>\> TCMI communication component constructor.
+ * - allocates the instance
+ * - starts a new message receiving thread thread
+ *
+ * @param *sock - pointer to the socket that is to be used for the
+ * communication
+ * @param *deliver - method to be called upon message delivery
+ * @param *obj - object whose method is to be called
+ * @param msg_group - preferred group of messages that
+ * are to be received - see tcmi_messages
+ * @return new communication component or NULL
+ */
+struct tcmi_comm* tcmi_comm_new(struct kkc_sock *sock, deliver_method_t *deliver, 
+				void *obj, int msg_group)
+{
+	struct tcmi_comm *comm;
+
+	if (!sock || !deliver) {
+		mdbg(ERR3, "Missing socket or delivery method");
+		goto exit0;
+	}
+	if (!(comm = TCMI_COMM(kmalloc(sizeof(struct tcmi_comm), GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate memory for communication component");
+		goto exit0;
+	}
+
+	atomic_set(&comm->ref_count, 1);
+	comm->sock = kkc_sock_get(sock);
+	comm->deliver = deliver;
+	comm->obj = obj;
+	comm->msg_group = msg_group;
+
+
+	comm->thread = kthread_run(tcmi_comm_thread, comm, 
+				   "tcmi_commd_%02d", tcmi_comm_counter++);
+	if (IS_ERR(comm->thread)) {
+		minfo(ERR2, "Failed to create a message receiving thread!");
+		goto exit1;
+	}
+	
+	mdbg(INFO4, "Created TCMI comm, preferred message group %d, memory=%p", 
+	     comm->msg_group, comm);
+	return comm;
+
+	/* error handling */
+ exit1:
+	kkc_sock_put(sock);
+	kfree(comm);
+ exit0:
+	return NULL;
+}
+
+
+
+/** 
+ * \<\<public\>\> Releases the instance. Decrements reference counter
+ * and if it reaches 0, it will:
+ * - stop the receiving thread by sending it a forced signal. The
+ * signal interrupts any blocking receive operation. Then we
+ * wait till the thread terminates.
+ * - release the socket instance
+ * - free the tcmi_comm instance
+ *
+ * @param *self - pointer to this instance
+ */
+void tcmi_comm_put(struct tcmi_comm *self)
+{
+	if (self && atomic_dec_and_test(&self->ref_count)) {
+		mdbg(INFO4, "Destroying TCMI comm, preferred message group %d, memory=%p", 
+		     self->msg_group, self);
+		/* stop the transaction thread */
+		force_sig(SIGTERM, self->thread);
+		/* ensures synchronous thread termination */
+		kthread_stop(self->thread);
+		kkc_sock_put(self->sock);
+		kfree(self);
+	}
+}
+
+/** @addtogroup tcmi_comm_class
+ *
+ * @{
+ */
+
+
+/** 
+ * \<\<private\>\> Messages receiving thread.
+ * - receives any messages on the connection that is part of the tcmi_comm
+ * instance
+ * - as long as no invalid ID or other error occurs
+ * or the main thread signals to quit it will be delivering messages to the
+ * subscribed object via its delivery method.
+ * - messages that are not successfully delivered are discarded
+ *
+ * The thread is always stopped synchronously with the instance
+ * destruction, therefore there is no need to account an extra
+ * reference for the thread.
+ *
+ * @param *comm - pointer to this communication instance
+ * @return 0 upon successful termination.
+ */
+static int tcmi_comm_thread(void *comm)
+{
+	struct tcmi_comm *self = TCMI_COMM(comm);
+	/* make local copies instance attributes, this saves one
+	 * dereference for each */
+	struct kkc_sock *sock = self->sock;
+	deliver_method_t *deliver = self->deliver;
+	int msg_group = self->msg_group;
+	void *obj = self->obj;
+	/* pointer to the message received */
+	struct tcmi_msg *m; 
+	u_int32_t msg_id;
+	int err = 0;
+
+	minfo(INFO3, "Receiving on socket local: '%s', remote: '%s'",
+	      kkc_sock_getsockname2(sock), kkc_sock_getpeername2(sock));
+	/* receive messages, checking for signals or stop request */
+	while (!(kthread_should_stop() || signal_pending(current))) {
+		if ((err = kkc_sock_recv(sock, &msg_id, sizeof(msg_id), KKC_SOCK_BLOCK)) < 0) {
+			minfo(ERR3, "Error receiving message ID, error code: %d, terminating", err);
+			break;
+		}
+		if (!(m = tcmi_msg_factory(msg_id, msg_group))) {
+			minfo(ERR3, "Error building message %x, terminating", msg_id);
+			break;
+		}
+		if ((err = tcmi_msg_recv(m, sock)) < 0) {
+			minfo(ERR3, "Error receiving message %x, error %d, terminating", msg_id, err);
+			break;
+		}
+		/* try to deliver, if it fails destroy the message */
+		if (deliver(obj, m) < 0)
+			tcmi_msg_put(m);
+	}
+	/* very important to sync with the the thread that is terminating us */
+	wait_on_should_stop();
+	mdbg(INFO3, "Message receiving thread terminating");
+	return err;
+}
+
+/** Thread counter - used for receiving thread naming. */
+static int tcmi_comm_counter = 0;
+
+/**
+ * @}
+ */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_ppm_p_migr_back_guestreq_procmsg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_ppm_p_migr_back_guestreq_procmsg.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,109 @@
+/**
+ * @file tcmi_ppm_p_migr_back_guestreq_procmsg.h - migrate back request initiated by guest
+ *       
+ *                      
+ * 
+ *
+ *
+ * Date: 05/04/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_ppm_p_migr_back_guestreq_procmsg.h,v 1.3 2007/09/02 10:54:25 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_PPM_P_MIGR_BACK_GUESTREQ_PROCMSG_H
+#define _TCMI_PPM_P_MIGR_BACK_GUESTREQ_PROCMSG_H
+
+#include "tcmi_procmsg.h"
+#include "tcmi_err_procmsg.h"
+
+/** @defgroup tcmi_ppm_p_migr_back_guestreq_procmsg_class tcmi_ppm_p_migr_back_guestreq_procmsg class
+ *
+ * @ingroup tcmi_procmsg_class
+ *
+ * This class represents a message that is sent by guest task to the
+ * shadow task as a request(announcement) to migrate the process back to CCN
+ *
+ * @{
+ */
+
+/** Compound structure, inherits from tcmi_procmsg_class */
+struct tcmi_ppm_p_migr_back_guestreq_procmsg {
+	/** parent class instance */
+	struct tcmi_procmsg super;
+	/** size of the checkpoint name in bytes (including trailing
+	    zero) */
+	int32_t size;
+	/** name of the checkpoint file. */
+	char *ckpt_name;
+};
+
+
+
+
+/** \<\<public\>\> Guest request for migration back rx constructor. */
+extern struct tcmi_msg* tcmi_ppm_p_migr_back_guestreq_procmsg_new_rx(u_int32_t msg_id);
+
+/** \<\<public\>\> Guest request for migration back tx constructor. */
+extern struct tcmi_msg* tcmi_ppm_p_migr_back_guestreq_procmsg_new_tx(pid_t dst_pid, char *ckpt_name);
+
+
+
+/** Message descriptor for the factory class, for error handling we used tcmi_errmsg_class */
+#define TCMI_PPM_P_MIGR_BACK_GUESTREQ_PROCMSG_DSC \
+TCMI_MSG_DSC(TCMI_PPM_P_MIGR_BACK_GUESTREQ_PROCMSG_ID, tcmi_ppm_p_migr_back_guestreq_procmsg_new_rx, tcmi_err_procmsg_new_rx)
+
+/** Casts to the tcmi_ppm_p_migr_back_guestreq_procmsg instance. */
+#define TCMI_PPM_P_MIGR_BACK_GUESTREQ_PROCMSG(m) ((struct tcmi_ppm_p_migr_back_guestreq_procmsg*)m)
+
+/**
+ * Checkpoint name accessor
+ * 
+ * @param *self - this message instance
+ * @return checkpoint name string
+ */
+static inline char* tcmi_ppm_p_migr_back_guestreq_procmsg_ckpt_name(struct tcmi_ppm_p_migr_back_guestreq_procmsg *self)
+{
+	return self->ckpt_name;
+}
+
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_PPM_P_MIGR_BACK_GUESTREQ_PROCMSG_PRIVATE
+
+/** Receives the message via a specified connection. */
+static int tcmi_ppm_p_migr_back_guestreq_procmsg_recv(struct tcmi_procmsg *self, struct kkc_sock *sock);
+
+/** Sends the message via a specified connection. */
+static int tcmi_ppm_p_migr_back_guestreq_procmsg_send(struct tcmi_procmsg *self, struct kkc_sock *sock);
+
+/** Message operations that support polymorphism. */
+static struct tcmi_procmsg_ops ppm_p_migr_back_guestreq_procmsg_ops;
+
+#endif /* TCMI_PPM_P_MIGR_BACK_GUESTREQ_PROCMSG_PRIVATE */
+
+
+/**
+ * @}
+ */
+
+
+#endif /* _TCMI_PPM_P_MIGR_BACK_GUESTREQ_PROCMSG_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_transaction.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_transaction.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,409 @@
+/**
+ * @file tcmi_transaction.h - TCMI communication transaction.
+ *       
+ *                      
+ * 
+ *
+ *
+ * Date: 04/09/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_transaction.h,v 1.2 2007/07/02 02:26:17 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_TRANSACTION_H
+#define _TCMI_TRANSACTION_H
+
+#include <asm/atomic.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/timer.h>
+#include <linux/errno.h>
+#include <linux/wait.h>
+
+#include <tcmi/lib/tcmi_slotvec.h>
+
+/** @defgroup tcmi_transaction_class tcmi_transaction class
+ *
+ * @ingroup tcmi_comm_group
+ *
+ * A transaction in communication is setup when a request message
+ * expects a certain response from the receiving party. This class
+ * provides the functionality to create, start and complete such 
+ * transaction.
+ *
+ * An example: A PEN node wants to register with a CCN. It will send
+ * a registration request towards the CCN. A new transaction is
+ * started on the PEN side by the thread creating the initial
+ * message. The transaction is assigned following attributes:
+ * - transaction ID
+ * - response message ID
+ * - response timeout
+ * - flags -
+ *   - anonymous - setting an anonymous flag means that the user doesn't
+ *   wait for the response synchronously. This flag is checked by
+ *   tcmi_msg.c::tcmi_msg_deliver() - see for details.
+ *   - expired - the timer upon timout marks the transaction
+ *   expired and sets it to aborted state. This flag is used
+ *   when checking whether the timer went off or not (needed for
+ *   transaction destruction).
+ *
+ * The CCN receives the registration request performs some
+ * authentication tasks and sends a reply back. The response message
+ * will carry the transaction ID. On PEN, the message is identified
+ * based on the transaction ID and successfully received. The message
+ * then completes the transaction, which in turn wakes up the thread
+ * waiting for the message.  Message delivery is closely coupled to
+ * transactions. See tcmi_msg.c::tcmi_msg_deliver().
+ *
+ * There are few stages in transaction lifetime:
+ * - INIT - this is the phase when the transaction is instantiated
+ * and inserted into a transaction slot vector, but not active yet
+ * - RUNNING - transaction is activated and the timout timer
+ * is running.
+ * - COMPLETE - transaction has been successfully finished, the context
+ * data is ready to be picked up by the transaction owner
+ * - ABORTED - if the transaction times out, the timer handler marks
+ * it aborted. The transaction owner is supposed to discard such transaction
+ *
+ * @{
+ */
+
+/** Describes the current state of the transaction:
+ */
+typedef enum {
+	TCMI_TRANSACTION_INIT,
+	TCMI_TRANSACTION_RUNNING,
+	TCMI_TRANSACTION_COMPLETE,
+	TCMI_TRANSACTION_ABORTED,
+} tcmi_trans_state_t;
+
+/** denotes an invalid transaction ID */
+#define TCMI_TRANSACTION_INVAL_ID 0
+
+/** Denotes a transaction, where nobody is waiting for the response */
+#define TCMI_TRANS_FLAGS_ANONYMOUS 0x00000001
+/** Denotes an expired transaction that hasn't been completed */
+#define TCMI_TRANS_FLAGS_EXPIRED   0x00000002
+
+
+/** Compound structure holding transaction attributes. */
+struct tcmi_transaction {
+
+	/** link for storing the transaction in a slot.  */
+	tcmi_slot_node_t node;
+	/** Slot where the transaction resides.  */
+	struct tcmi_slot *slot;
+
+	/** transaction ID. */
+	u_int32_t id;
+	
+	/** response ID - verified upon transaction completion. */
+	u_int32_t resp_id;
+
+
+	/** transaction state. */
+	tcmi_trans_state_t state;
+
+	/** Flags describe additional attributes of the transaction */
+	atomic_t flags;
+
+	/** Sleeping processes, that are to be notified upon
+	 * transaction time out or completion. */
+	wait_queue_head_t wq;
+
+	/** timer used for transaction timeouts. */
+	struct timer_list timer;
+
+	/** pointer to the transaction context data - assigned upon
+	 * successful completion. */
+	void *context;
+
+	/** reference counter. */
+	atomic_t ref_count;
+	/** spin lock - serializes access to the transaction. */
+	spinlock_t t_lock;
+	
+	/** Back-references to slotvec where the transaction is present.. used to get access to slotvec lock to guard agains lookup/put races. */
+	struct tcmi_slotvec *transactions;
+};
+
+/** \<\<public\>\> Creates a new transaction. */
+extern struct tcmi_transaction* tcmi_transaction_new(struct tcmi_slotvec *transactions, 
+						     u_int32_t resp_id,
+						     unsigned long timeout);
+/** \<\<public\>\> Starts a transaction. */
+extern int tcmi_transaction_start(struct tcmi_transaction *self, int flags);
+
+/** \<\<public\>\> Aborting the transaction. */
+extern void* tcmi_transaction_abort(struct tcmi_transaction *self);
+
+/** \<\<public\>\> Completes a transaction and wakes up the processing thread. */
+extern int tcmi_transaction_complete(struct tcmi_transaction *self, void *context, 
+				     u_int32_t type_id);
+
+/** \<\<public\>\> Tries to find a transaction based on its ID. */
+extern struct tcmi_transaction* tcmi_transaction_lookup(struct tcmi_slotvec *transactions, 
+							u_int32_t trans_id);
+
+/** \<\<public\>\> Releases the instance - serialized version. */
+extern void tcmi_transaction_put(struct tcmi_transaction *self);
+
+/**
+ * \<\<public\>\> Locks the instance data. Spin lock used - no sleeping allowed!
+ *
+ * @param *self - pointer to this transaction instance
+ */
+static inline void tcmi_transaction_lock(struct tcmi_transaction *self)
+{
+	spin_lock(&self->t_lock);
+}
+
+/**
+ * \<\<public\>\> Unlocks the instance data
+ *
+ * @param *self - pointer to this transaction instance
+ */
+static inline void tcmi_transaction_unlock(struct tcmi_transaction *self)
+{
+	spin_unlock(&self->t_lock);
+}
+
+
+/** 
+ * \<\<public\>\> Instance accessor. increments the reference counter.  The user is
+ * now guaranteed, that the instance stays in memory while he is using
+ * it. Assumes, the access is serialized by means of locking the slot
+ * where the instance resides.
+ *
+ * @param *self - pointer to this instance
+ * @return tcmi_transaction instance
+ */
+static inline struct tcmi_transaction* tcmi_transaction_get(struct tcmi_transaction *self)
+{
+	if (self)
+		atomic_inc(&self->ref_count);
+	return self;
+}
+
+
+/** 
+ * \<\<public\>\> Transaction ID accessor.
+ *
+ * @param *self - pointer to this transaction instance
+ * @return transaction ID
+ */
+static inline u_int32_t tcmi_transaction_id(struct tcmi_transaction *self)
+{
+	return self->id;
+}
+
+/** 
+ * \<\<public\>\> Transaction state accessor.
+ * The transaction should be locked by the caller, so that the transaction
+ * state doesn't change when making decisions based on it.
+ *
+ * @param *self - pointer to this transaction instance
+ * @return curren transaction state
+ */
+static inline tcmi_trans_state_t tcmi_transaction_state(struct tcmi_transaction *self)
+{
+	return self->state;
+}
+
+
+/**
+ * \<\<public\>\> Transaction context accessor.
+ *
+ * @param *self - pointer to this transaction instance
+ * @return pointer to the context associated with the transaction
+ */
+static inline void* tcmi_transaction_context(struct tcmi_transaction *self)
+{
+	return self->context;
+}
+
+/** 
+ * \<\<public\>\> Sets flags in the transaction that denote additional
+ * transaction attributes. Valid flags are:
+ * - TCMI_TRANS_FLAGS_DELETED - transaction marked for deletion
+ * - TCMI_TRANS_FLAGS_ANONYMOUS - transaction is anonymous, 
+ * - TCMI_TRANS_FLAGS_EXPIRED - timer has expired.
+ *
+ * @param *self - pointer to this transaction instance
+ * @param flags - additional flag setting 
+ */
+static inline void tcmi_transaction_set_flags(struct tcmi_transaction *self, int flags)
+{
+	atomic_set_mask(flags, &self->flags);
+}
+
+/** 
+ * \<\<public\>\> Checks on a complete transaction.
+ *
+ * @param *self - pointer to this transaction instance
+ * @return true if transaction has been successfully finished
+ */
+static inline int tcmi_transaction_is_complete(struct tcmi_transaction *self)
+{
+	return (self->state == TCMI_TRANSACTION_COMPLETE);
+}
+
+/** 
+ * \<\<public\>\> Checks on aborted transaction.
+ *
+ * @param *self - pointer to this transaction instance
+ * @return true if transaction has been aborted
+ */
+static inline int tcmi_transaction_is_aborted(struct tcmi_transaction *self)
+{
+	return (self->state == TCMI_TRANSACTION_ABORTED);
+}
+
+/** 
+ * \<\<public\>\> Checks on a running transaction.
+ *
+ * @param *self - pointer to this transaction instance
+ * @return true if transaction is still running..
+ */
+static inline int tcmi_transaction_is_running(struct tcmi_transaction *self)
+{
+	return (self->state == TCMI_TRANSACTION_RUNNING);
+}
+
+/** 
+ * \<\<public\>\> Checks on an anonymous transaction.
+ *
+ * @param *self - pointer to this transaction instance
+ * @return true if transaction is marked as anonymous.
+ */
+static inline int tcmi_transaction_is_anon(struct tcmi_transaction *self)
+{
+	return atomic_read(&self->flags) & TCMI_TRANS_FLAGS_ANONYMOUS;
+}
+
+
+/**
+ * \<\<public\>\> Waits on a transaction till it expires or is
+ * completed.
+ *
+ * @param *self - pointer to this transaction instance
+ * @return transaction status
+ */
+static inline int tcmi_transaction_wait(struct tcmi_transaction *self)
+{
+	int ret;
+	/* Sleep until the transaction times out or completes (response arrival) */
+	wait_event(self->wq, (tcmi_transaction_is_aborted(self) || 
+			      tcmi_transaction_is_complete(self)));
+	ret = tcmi_transaction_state(self);
+
+	return ret;
+}
+
+/**
+ * \<\<public\>\> Waits on a transaction till it expires or is
+ * completed, the task can be prematurely woken up by a signal.
+ *
+ * @param *self - pointer to this transaction instance
+ * @return transaction status or -ERESTARTSYS on signal arrival
+ */
+static inline int tcmi_transaction_wait_interruptible(struct tcmi_transaction *self)
+{
+	int ret = 0;
+	/* Sleep until the transaction times out or completes (response arrival) */
+	ret = wait_event_interruptible(self->wq, (tcmi_transaction_is_aborted(self) || 
+						  tcmi_transaction_is_complete(self)));
+	if (ret < 0) 
+		mdbg(INFO3, "Signal arrived");
+	else 
+		ret = tcmi_transaction_state(self);
+	return ret;
+}
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_TRANSACTION_PRIVATE
+
+/** Generates a transaction ID.*/
+static void tcmi_transaction_gen_id(struct tcmi_transaction *self);
+
+/** Callback for the kernel timer that handles transaction timeouts. */
+static void tcmi_transaction_timer(unsigned long trans);
+
+/** 
+ * \<\<private\>\> Checks on expired transaction.
+ *
+ * @param *self - pointer to this transaction instance
+ * @return true if transaction is marked as expired.
+ */
+static inline int tcmi_transaction_is_expired(struct tcmi_transaction *self)
+{
+	return atomic_read(&self->flags) & TCMI_TRANS_FLAGS_EXPIRED;
+}
+
+/** 
+ * \<\<private\>\> Marks the transaction as expired. This method is
+ * internally used by the timer when it goes off. It is needed when
+ * complete/abort operations drop the timer and check if reference
+ * counter needs to be adjusted.
+ *
+ * @param *self - pointer to this transaction instance
+ */
+static inline void tcmi_transaction_set_expired(struct tcmi_transaction *self)
+{
+	tcmi_transaction_set_flags(self, TCMI_TRANS_FLAGS_EXPIRED);
+}
+
+
+/**
+ * \<\<private\>\> Computes the hash value of the transaction ID.
+ * 
+ * The hash is computed as: ((trans_id >> 16) ^ trans_id) & hashmask
+ * @param trans_id - transaction ID to be hashed
+ * @param hashmask - hashmask limiting the maximum hash value.
+ */
+static inline u_int tcmi_transaction_hash(u_int32_t trans_id, u_int hashmask)
+{
+	return (((trans_id >> 16) ^ trans_id) & hashmask);
+}
+
+/** 
+ * \<\<private\>\> Notifies the transaction owner by waking up a
+ * corresponding thread.
+ * 
+ * @param *self - pointer to this transaction instance
+ */
+static inline void tcmi_transaction_notify_owner(struct tcmi_transaction *self)
+{
+
+	mdbg(INFO4, "Waking up transaction processing thread");
+	wake_up(&self->wq);
+}
+
+#endif /* TCMI_TRANSACTION_PRIVATE */
+
+
+/**
+ * @}
+ */
+
+
+#endif /* _TCMI_TRANSACTION_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_authenticate_msg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_authenticate_msg.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,118 @@
+/**
+ * @file tcmi_authenticate_msg.h - authenticate message
+ */
+
+#ifndef TCMI_AUTHENTICATE_MSG_H
+#define TCMI_AUTHENTICATE_MSG_H
+
+#include "tcmi_msg.h"
+#include <arch/arch_ids.h>
+
+/** @defgroup tcmi_authenticate_msg_class tcmi_authenticate_msg class
+ *
+ * @ingroup tcmi_msg_class
+ *
+ * This message is send by PEN when it wants authenticate to CCN.
+ * 
+ * @{
+ */
+
+/** Authentication message structure */
+struct tcmi_authenticate_msg {
+	/** parent class instance. */
+	struct tcmi_msg super;
+	/** Id of the requestor PEN */
+	u_int32_t pen_id;
+	/** Architecture of PEN */
+	enum arch_ids pen_arch;
+
+	/** Authentication data. Opaque to the kernel part, this is purely user space responsibilithy to provide and parse those. */
+	char *auth_data;
+	/** Size of authentication data */
+	u_int32_t size;
+};
+
+
+
+
+/** \<\<public\>\> Authentication message consutructor for receiving. */
+extern struct tcmi_msg* tcmi_authenticate_msg_new_rx(u_int32_t msg_id);
+
+/** \<\<public\>\> Authentication message constructor for transferring. */
+extern struct tcmi_msg* tcmi_authenticate_msg_new_tx(struct tcmi_slotvec *transactions, 
+						       u_int32_t pen_id, enum arch_ids pen_arch, char* auth_data, int size);
+
+
+/** \<\<public\>\> Message descriptor for the factory class, there is no error
+ * handling as this is the starting request */
+#define TCMI_AUTHENTICATE_MSG_DSC TCMI_MSG_DSC(TCMI_AUTHENTICATE_MSG_ID, tcmi_authenticate_msg_new_rx, NULL)
+
+/** Casts to the tcmi_authenticate_msg instance. */
+#define TCMI_AUTHENTICATE_MSG(m) ((struct tcmi_authenticate_msg*)m)
+
+/**
+ * \<\<public\>\> PEN id getter
+ * 
+ * @param *self - this message instance
+ * @return PEN id
+ */
+static inline u_int32_t tcmi_authenticate_msg_pen_id(struct tcmi_authenticate_msg *self)
+{
+	return self->pen_id;
+}
+
+/**
+ * \<\<public\>\> PEN architecture getter
+ * 
+ * @param *self - this message instance
+ * @return PEN architecture
+ */
+static inline enum arch_ids tcmi_authenticate_msg_arch(struct tcmi_authenticate_msg *self)
+{
+	return self->pen_arch;
+}
+
+/**
+ * \<\<public\>\> PEN authentication data length getter
+ * 
+ * @param *self - this message instance
+ * @return Authentication data length
+ */
+static inline u_int32_t tcmi_authenticate_msg_auth_data_size(struct tcmi_authenticate_msg *self)
+{
+	return self->size;
+}
+
+/**
+ * \<\<public\>\> PEN authentication data getter
+ * 
+ * @param *self - this message instance
+ * @return Authentication data
+ */
+static inline char* tcmi_authenticate_msg_auth_data(struct tcmi_authenticate_msg *self)
+{
+	return self->auth_data;
+}
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_AUTHENTICATE_MSG_PRIVATE
+
+/** Receives the message via a specified connection. */
+static int tcmi_authenticate_msg_recv(struct tcmi_msg *self, struct kkc_sock *sock);
+
+/** Sends the message via a specified connection. */
+static int tcmi_authenticate_msg_send(struct tcmi_msg *self, struct kkc_sock *sock);
+
+/** Message operations that support polymorphism. */
+static struct tcmi_msg_ops authenticate_msg_ops;
+
+#endif
+
+
+/**
+ * @}
+ */
+
+
+#endif
+
--- linux-3.7.1_original/clondike/src/tcmi/comm/tcmi_vfork_done_procmsg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/comm/tcmi_vfork_done_procmsg.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,134 @@
+/**
+ * @file tcmi_vfork_done_procmsg.c - TCMI vfork completition notification
+ *       
+ */
+#include <linux/slab.h>
+
+#include "tcmi_transaction.h"
+
+#define TCMI_VFORK_DONE_PROCMSG_PRIVATE
+#include "tcmi_vfork_done_procmsg.h"
+
+
+#include <dbg.h>
+
+
+
+/** 
+ * \<\public\>\> vfork_done message rx constructor.
+ * This method is called by the factory class.
+ *
+ * @param msg_id - message ID - used for verification
+ * instance.
+ * @return a new message or NULL.
+ */
+struct tcmi_msg* tcmi_vfork_done_procmsg_new_rx(u_int32_t msg_id)
+{
+	struct tcmi_vfork_done_procmsg *msg;
+
+	/* Check if the factory is building what it really thinks. */
+	if (msg_id != TCMI_VFORK_DONE_PROCMSG_ID) {
+		mdbg(ERR3, "Factory specified message ID(%x) doesn't match real ID(%x)",
+		     msg_id, TCMI_VFORK_DONE_PROCMSG_ID);
+		goto exit0;
+	}
+	/* Allocate the instance */
+	if (!(msg = TCMI_VFORK_DONE_PROCMSG(kmalloc(sizeof(struct tcmi_vfork_done_procmsg), GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate vfork_done request message");
+		goto exit0;
+	}
+	/* Initialized the message for receiving. */
+	if (tcmi_procmsg_init_rx(TCMI_PROCMSG(msg), TCMI_VFORK_DONE_PROCMSG_ID, &vfork_done_procmsg_ops)) {
+		mdbg(ERR3, "Error initializing test request message %x", msg_id);
+		goto exit1;
+	}
+
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+}
+
+/** 
+ * \<\public\>\> vfork_done message tx constructor.
+ *
+ * The vfork_done notification has no transaction associated.
+ *
+ *
+ * @param dst_pid - destination process PID
+ * @return a new message ready for the transfer or NULL.
+ */
+struct tcmi_msg* tcmi_vfork_done_procmsg_new_tx(pid_t dst_pid)
+{
+	struct tcmi_vfork_done_procmsg *msg;
+
+	if (!(msg = TCMI_VFORK_DONE_PROCMSG(kmalloc(sizeof(struct tcmi_vfork_done_procmsg), GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate vfork_done notification message");
+		goto exit0;
+	}
+
+	/* Initialize the message for transfer, no transaction to be
+	 * created, no response expected, no timeout for response, not a reply to any transaction */
+	if (tcmi_procmsg_init_tx(TCMI_PROCMSG(msg), TCMI_VFORK_DONE_PROCMSG_ID, &vfork_done_procmsg_ops, 
+				 dst_pid, 0,
+				 NULL, 0, 
+				 0, TCMI_TRANSACTION_INVAL_ID)) {
+		mdbg(ERR3, "Error initializing vfork_done notification message message");
+		goto exit1;
+	}
+	return TCMI_MSG(msg);
+
+	/* error handling */
+ exit1:
+	kfree(msg);
+ exit0:
+	return NULL;
+	
+}
+
+
+/** @addtogroup tcmi_vfork_done_procmsg_class
+ *
+ * @{
+ */
+
+/**
+ * \<\<private\>\> Receives the message via a specified connection. 
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for receiving message data
+ * @return 0 when successfully received.
+ */
+static int tcmi_vfork_done_procmsg_recv(struct tcmi_procmsg *self, struct kkc_sock *sock)
+{
+	return 0;
+}
+
+/**
+ * \<\<private\>\> Sends the vfork_done notification via a specified connection. 
+ *
+ * @param *self - this message instance
+ * @param *sock - KKC socket used for receiving message data
+ * @return 0 when successfully sent.
+ */
+static int tcmi_vfork_done_procmsg_send(struct tcmi_procmsg *self, struct kkc_sock *sock)
+{
+	return 0;
+}
+
+
+
+/** Message operations that support polymorphism. */
+static struct tcmi_procmsg_ops vfork_done_procmsg_ops = {
+	.recv = tcmi_vfork_done_procmsg_recv,
+	.send = tcmi_vfork_done_procmsg_send
+};
+
+
+/**
+ * @}
+ */
+
--- linux-3.7.1_original/clondike/src/tcmi/lib/tcmi_slot.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/lib/tcmi_slot.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,390 @@
+/**
+ * @file tcmi_slot.h - slot used as an SMP safe doubly link list
+ *                      
+ * 
+ *
+ *
+ * Date: 04/04/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_slot.h,v 1.2 2007/07/02 02:26:17 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef TCMI_SLOT_H
+#define TCMI_SLOT_H
+
+#include <linux/list.h>
+#include <linux/types.h>
+#include <linux/spinlock.h>
+
+#include <dbg.h>
+
+/** @defgroup tcmi_slot_class tcmi_slot class 
+ *
+ * @ingroup tcmi_lib_group
+ * 
+ * This class represents a slot that is part of a slot vector.  The
+ * slot contains a head of a doubly linked list. This list is used for
+ * storing objects. Objects within a slot are stored(linked together by
+ * means of tcmi_slot_node_t. Each slot is identified by its number. That way,
+ * the user can locate it in the \link tcmi_slotvec_class slot vector \endlink.
+ *
+ * Also the slots are internally linked together by the slot_list. The
+ * slot is inserted into used_ or unused_slots list. This allows fast
+ * allocation of empty slots. The unused_/used_slots list management
+ * is done by each slot on its own. The references to
+ * unused_/used_slots list are always shared by all slots within a
+ * particular slot vector.
+ *
+ * An typical object that wants to be stored in a slot will look like
+ * this:
+ * \verbatim
+ * struct object {
+ *	tcmi_slot_node_t node;
+ *       .
+ *       .
+ *      (other object data items)
+ * };
+ * 
+ * \endverbatim
+ * 
+ * @{
+ */
+/** \<\<public\>\> Extracts the actual entry from a slot node */
+#define tcmi_slot_entry(ptr, type, member) hlist_entry(ptr, type, member)
+
+/** 
+ * \<\<public\>\> Iterates through all nodes in the slot.
+ *
+ * @param node - every iteration points to a new node
+ * @param slot - slot that we are iterating through
+ */
+#define tcmi_slot_for_each(node, slot) hlist_for_each(node, &slot->head)
+
+/** 
+ * \<\<public\>\> Iterates through all nodes in the slot.  This is
+ * intended for traversals only, no removals should take place.  We
+ * still need to ensure the slot protection against concurrent
+ * manipulation from other threads.
+ * 
+ * @param object - every iteration points to a new object
+ * @param node - temporary storage for the current tcmi_slot_node_t 
+ * @param slot - slot that we are iterating through
+ * @param member - name of the list node member in the object
+ */
+#define tcmi_slot_for_each_entry(object, node, slot, member) \
+ hlist_for_each_entry(object, node, &slot->head, member)
+
+/** 
+ * \<\<public\>\> Iterates through all nodes in the slot - safe
+ * version.  This is a version safe against removals. If the current
+ * object, will be removed during the iteration, no issues will
+ * arise. We still need to ensure the slot protection against
+ * concurrent manipulation from other threads.
+ *
+ * @param object - every iteration points to a new object
+ * @param node - temporary storage for the current tcmi_slot_node_t 
+ * @param node2 - another temporary storage for the copy of the 
+ * previous node tcmi_slot_node_t 
+ * @param slot - slot that we are iterating through
+ * @param member - name of the list node member in the object
+ */
+#define tcmi_slot_for_each_entry_safe(object, node, node2, slot, member) \
+ hlist_for_each_entry_safe(object, node, node2, &slot->head, member)
+
+
+/** 
+ * \<\<public\>\> Returns the first object in the slot.
+ *
+ * @param object - will store the pointer to the object in the slot
+ * @param slot - from which to take the first object
+ * @param member - name of the list node member in the object
+ */
+#define tcmi_slot_find_first(object, slot, member)		\
+do {								\
+	tcmi_slot_node_t *__node; 				\
+	tcmi_slot_for_each_entry(object, __node, slot, member) 	\
+		break;						\
+} while(0)
+
+/** 
+ * \<\<public\>\> Removes the first object in the slot.  If the slot
+ * is empty, does nothing
+ *
+ * @param object - will store the pointer to the object in the slot
+ * @param slot - from which to take the first object
+ * @param member - name of the list node member in the object
+ */
+#define tcmi_slot_remove_first(object, slot, member)			\
+do {									\
+	tcmi_slot_node_t *__node; 					\
+	tcmi_slot_for_each_entry(object, __node, slot, member) {	\
+		__tcmi_slot_remove(slot, &object->member);		\
+		break;							\
+	}								\
+} while(0)
+
+/** A slot node is in fact a hlist node */
+typedef struct hlist_node tcmi_slot_node_t;
+
+/** Check for node being removed from the hlist */
+#define tcmi_slot_node_unhashed(n) hlist_unhashed(n)
+/**
+ * A slot compound structure. Contains the list of items stored
+ * items. Also there is another list head provided. This is for internal use
+ * by the tcmi_slotvec class.
+ */
+struct tcmi_slot {
+	/** The slot number */
+	u_int index;
+
+	/** used when linking slots in used or unused lists */
+	struct list_head slot_list;
+
+
+	/** head of the list of items stored in the slot */
+	struct hlist_head head;
+	/** Protects the slotvector from concurrent modification */
+	/* spinlock_t slot_lock; */
+
+	/* Following items come from the associated slot vector as we
+	 * want the slot to do the management of unused/used lists on its own */
+	/** list of unused slots */
+	struct list_head *unused_slots;
+	/** list of used slots */
+	struct list_head *used_slots;
+	/** Protects the unused/used_slots lists from concurrent
+	 * modification. Also, this lock is used when
+	 * modifying the slot itself. Maybe, it would be a good idea
+	 * to have a separate lock for each slot in addition to this
+	 * one. The drawback would be the increased size of the
+	 * slot. I will keep it like this for now */
+	spinlock_t *s_lock;
+	/** Technical field used for irq safe spinlocks */
+	unsigned long lock_flags;
+};
+
+/**
+ * Initializes a slot. Assigns it an index and appends it to the tail
+ * of the unused_slots list. The slot keeps track whether it is empty
+ * or not on its own. That's why we store the unused_slots and
+ * used_slots heads inside the slot. The spinlock protects those lists
+ * from concurrent modification. 
+ * 
+ * @param *self - pointer to this slot instance
+ * @param index - slot index
+ * @param unused_slots - head of the list of unused slots
+ * @param used_slots - head of the list of used slots
+ * @param *lock - pointer to the lock that will be used when
+ * synchronizing access to the slotvector where the slot resides.
+ */
+static inline void tcmi_slot_init(struct tcmi_slot *self, u_int index, 
+				  struct list_head *unused_slots,
+				  struct list_head *used_slots, spinlock_t *lock)
+{
+	self->index = index;
+	INIT_LIST_HEAD(&self->slot_list);
+	INIT_HLIST_HEAD(&self->head);	
+	self->unused_slots = unused_slots;
+	self->used_slots = used_slots;
+	self->s_lock = lock;
+	list_add_tail(&self->slot_list, unused_slots);
+}
+
+/** 
+ * \<\<public\>\> Checks if the slot is empty.
+ *
+ * @param *self - pointer to this slot instance
+ * @return 1 - when the slot is empty
+ */
+static inline int tcmi_slot_empty(struct tcmi_slot *self)
+{
+	return hlist_empty(&self->head);
+}
+
+/** 
+ * \<\<public\>\> Slot index accessor.
+ *
+ * @param *self - pointer to this slot instance
+ * @return slot index
+ */
+static inline u_int tcmi_slot_index(struct tcmi_slot *self)
+{
+	return self->index;
+}
+
+/**
+ * \<\<public\>\> Locks the slot data. Spin lock used - no sleeping
+ * allowed!
+ *
+ * @param *self - pointer to this slot instance
+ */
+static inline void tcmi_slot_lock(struct tcmi_slot *self)
+{
+	// Have to be irqsave to avoid possible safe->unsafe conflict in forks
+	spin_lock_irqsave(self->s_lock, self->lock_flags);
+}
+
+/**
+ * \<\<public\>\> Unlocks the instance data
+ *
+ * @param *self - pointer to this slot instance
+ */
+static inline void tcmi_slot_unlock(struct tcmi_slot *self)
+{
+	spin_unlock_irqrestore(self->s_lock, self->lock_flags);
+}
+
+/**
+ * \<\<private\>\> Moves a slot into the specified list.
+ *
+ * @param *self - pointer to this slot instance
+ * @param head - list where the slot should be moved
+ */
+static inline void tcmi_slot_move(struct tcmi_slot *self, struct list_head *head) 
+{
+	list_move(&self->slot_list, head);
+}
+
+/**
+ * \<\<private\>\> Moves a slot to the tail of the specified list.
+ *
+ * @param *self - pointer to this slot instance
+ * @param head - list where the slot should be moved
+ */
+static inline void tcmi_slot_move_tail(struct tcmi_slot *self, struct list_head *head) 
+{
+	list_move_tail(&self->slot_list, head);
+}
+
+/** 
+ * \<\<public\>\> Inserts a new node into the slot. It is necessary to
+ * acquire a lock to prevent races with other threads. The slot is
+ * also moved into the used_slots list. This might be considered as
+ * overhead operation if the slot is already in that list, but it
+ * simplifies the design. Otherwise we would need an extra flag
+ * indicating which list it is currently in. Also the operation is
+ * O(1), so the penalty is rather small.
+ *
+ * @param *self - pointer to this slot instance
+ * @param *node - pointer to the node to be added
+ *
+ */
+static inline void tcmi_slot_insert(struct tcmi_slot *self, tcmi_slot_node_t *node)
+{
+	tcmi_slot_lock(self);
+	mdbg(INFO4, "Inserted node %p into slot %d", node, self->index);
+	INIT_HLIST_NODE(node);
+	hlist_add_head(node, &self->head);
+	tcmi_slot_move(self, self->used_slots);
+	tcmi_slot_unlock(self);
+}
+
+
+/** 
+ * \<\<public\>\> Moves a slot among unused_slots.
+ *
+ * @param *self - pointer to this slot instance
+ */
+static inline void tcmi_slot_move_unused(struct tcmi_slot *self)
+{
+	tcmi_slot_move(self, self->unused_slots);
+}
+/** 
+ * \<\<public\>\> Removes a given node from a slot. No check is
+ * performed, whether the node belongs to this slot. If the slot
+ * becomes empty by removeing the node, it will be moved to the unused
+ * slot list.
+ *
+ * \note This method assumes the s_lock is held.
+ *
+ * @param *self - pointer to this slot instance
+ * @param *node - pointer to the node to be removed
+ */
+static inline void __tcmi_slot_remove(struct tcmi_slot *self, tcmi_slot_node_t *node)
+{
+	hlist_del_init(node);
+	if (tcmi_slot_empty(self)) {
+		tcmi_slot_move_unused(self);
+
+		mdbg(INFO4, "Slot %d is now empty, moving to unused slots", self->index);
+	}
+}
+
+/** 
+ * \<\<public\>\> Removes a given node from a slot. No check is
+ * performed, whether the node belongs to this slot. After locking the
+ * slot, the work is delegated to __tcmi_slot_remove().
+ *
+ * @param *self - pointer to this slot instance
+ * @param *node - pointer to the node to be removed
+ */
+static inline void tcmi_slot_remove(struct tcmi_slot *self, tcmi_slot_node_t *node)
+{
+	if (self) {
+		if ( spin_is_locked(self->s_lock) ) {
+		    __tcmi_slot_remove(self, node);
+		} else {
+		    tcmi_slot_lock(self);
+		    __tcmi_slot_remove(self, node);
+		    tcmi_slot_unlock(self);		  
+		}	  
+	}
+}
+
+
+/** 
+ * \<\<public\>\> Removes a given node from a slot. A check is
+ * performed whether the node belongs to this slot. The work is then
+ * delegated to tcmi_slot_remove().
+ *
+ * @param *self - pointer to this slot instance
+ * @param *node - pointer to the node to be removed
+ */
+static inline void tcmi_slot_remove_safe(struct tcmi_slot *self, tcmi_slot_node_t *node)
+{
+	struct hlist_node *slot_node;
+	int found = 0;
+	if (self) {
+		tcmi_slot_lock(self);
+		tcmi_slot_for_each(slot_node, self) {
+			if (slot_node == node) {
+				found = 1;
+				break;
+			}
+		}
+		if (found) {
+			mdbg(INFO4, "Found the node %p in slot %d", node, self->index);
+			__tcmi_slot_remove(self, node);
+		}
+		tcmi_slot_unlock(self);
+	}
+}
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_SLOT_PRIVATE
+
+#endif /* TCMI_SLOT_PRIVATE */
+
+
+/**
+ * @}
+ */
+#endif /* TCMI_SLOT_H */
--- linux-3.7.1_original/clondike/src/tcmi/lib/util.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/lib/util.h	2013-03-12 00:14:08.000000000 +0100
@@ -0,0 +1,39 @@
+#ifndef _LIB_UTIL_H
+#define _LIB_UTIL_H
+
+#include <linux/pid_namespace.h>
+#include <linux/namei.h>
+
+static inline struct task_struct* task_find_by_pid(pid_t pid) {
+	return pid_task(find_pid_ns(pid, current->nsproxy->pid_ns), PIDTYPE_PID);
+}
+
+/**
+ * Creates a new directory. Assumes, its parent directory already exists!!
+ * 
+ * Fix kernel 3.7.1
+ * Renamed first parameter path to name 
+ */
+static inline int mk_dir(const char* name, int mode) {
+	//struct nameidata nd;
+	struct dentry *dentry;
+  struct path path;
+	int err;
+  
+  //Commented function path_lookup by Jiri Rakosnik
+	//err = path_lookup(name, LOOKUP_PARENT ,&nd);
+	//if ( err ) {
+	//	return err;
+	//}
+
+	dentry = kern_path_create(AT_FDCWD, name, &path, 1);       // Used function kern_path_create instead of lookup_create and path_lookup, Potential problem!!!
+  //dentry = lookup_create(&nd, 1);
+        err = PTR_ERR(dentry);
+        if (IS_ERR(dentry))
+                return err;
+
+	err = vfs_mkdir(path.dentry->d_inode, dentry, mode);
+	return err;
+}
+
+#endif
--- linux-3.7.1_original/clondike/src/tcmi/lib/tcmi_sock.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/lib/tcmi_sock.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,202 @@
+/**
+ * @file tcmi_sock.c - A implementation of wrapper class for KKC listenings.
+ *                       
+ *                      
+ * 
+ *
+ *
+ * Date: 04/17/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_sock.c,v 1.2 2007/07/02 02:26:17 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <linux/string.h>
+
+#include <tcmi/ctlfs/tcmi_ctlfs.h>
+#include <tcmi/ctlfs/tcmi_ctlfs_file.h>
+
+#define TCMI_SOCK_PRIVATE
+#include "tcmi_sock.h"
+
+#include <dbg.h>
+
+
+
+/**
+ * \<\<public\>\> TCMI socket constructor.
+ * A listening is constructed as follows:
+ * - a new instance is allocated
+ * - a new socket directory is created in the root directory. The name
+ * of the directory is specified by the method caller.
+ * - localname, peername and archname control files are crated
+ *
+ * @param *root - directory which all listening control files and its
+ * main directory will reside in.
+ * @param *k_sock - KKC socket, that this instance is to present in ctlfs
+ * @param namefmt - nameformat string (printf style)
+ * @return - a new tcmi_sock instance or NULL
+ */
+extern struct tcmi_sock* tcmi_sock_new(struct tcmi_ctlfs_entry *root,
+				       struct kkc_sock *k_sock,
+				       const char namefmt[], ...)
+{
+	struct tcmi_sock *t_sock;
+	va_list args;
+	va_start(args, namefmt);
+	mdbg(INFO3, "Creating new TCMI socket");
+
+	if (!(t_sock = kmalloc(sizeof(struct tcmi_sock), GFP_KERNEL))) {
+		mdbg(ERR3, "Failed to allocate memory for tcmi socket '%s'",
+		     kkc_sock_getsockname2(k_sock));
+		goto exit0;
+	}
+	/* create KKC t_sock */
+	atomic_set(&t_sock->ref_count, 1);
+
+	t_sock->sock = kkc_sock_get(k_sock);
+
+	/* main t_sock directory named after the index of its slot */
+	if (!(t_sock->d_id = 
+	      tcmi_ctlfs_dir_vnew(root, TCMI_PERMS_DIR, namefmt, args)))
+		goto exit1;
+	if (!(t_sock->f_sockname = 
+	      tcmi_ctlfs_strfile_new(t_sock->d_id, TCMI_PERMS_FILE_R,
+				     t_sock, tcmi_sock_getsockname, NULL,
+				     KKC_SOCK_MAX_ADDR_LENGTH, "sockname")))
+		goto exit2;
+	if (!(t_sock->f_peername = 
+	      tcmi_ctlfs_strfile_new(t_sock->d_id, TCMI_PERMS_FILE_R,
+				     t_sock, tcmi_sock_getpeername, NULL,
+				     KKC_SOCK_MAX_ADDR_LENGTH, "peername")))
+		goto exit3;
+
+	if (!(t_sock->f_archname = 
+	      tcmi_ctlfs_strfile_new(t_sock->d_id, TCMI_PERMS_FILE_R,
+				     t_sock, tcmi_sock_getarchname, NULL,
+				     KKC_MAX_ARCH_LENGTH, "archname")))
+		goto exit4;
+
+	va_end(args);
+	mdbg(INFO4, "Allocated new TCMI socket memory=%p", t_sock);
+	return t_sock;
+
+	/* error handling */
+ exit4:
+	tcmi_ctlfs_file_unregister(t_sock->f_peername);
+	tcmi_ctlfs_entry_put(t_sock->f_peername);
+ exit3:
+	tcmi_ctlfs_file_unregister(t_sock->f_sockname);
+	tcmi_ctlfs_entry_put(t_sock->f_sockname);
+ exit2:
+	tcmi_ctlfs_entry_put(t_sock->d_id);
+ exit1:
+	kkc_sock_put(t_sock->sock);
+	kfree(t_sock);
+	va_end(args);
+ exit0:
+	return NULL;
+}
+
+
+/** 
+ * \<\<public\>\> Decrements the reference counter and if it reaches
+ * 0, the instance. Unregistering the file is safe as the access is
+ * internally serialized by TCMI ctlfs - the instance is removed from
+ * the file and drop its reference counter.
+ * 
+ * @param *self - pointer to this listening instance
+ */
+void tcmi_sock_put(struct tcmi_sock *self)
+{
+	if (self && atomic_dec_and_test(&self->ref_count)) {
+		mdbg(INFO4, "Destroying TCMI socket memory=%p", self);
+
+		tcmi_ctlfs_file_unregister(self->f_archname);
+		tcmi_ctlfs_entry_put(self->f_archname);
+
+		tcmi_ctlfs_file_unregister(self->f_peername);
+		tcmi_ctlfs_entry_put(self->f_peername);
+
+		tcmi_ctlfs_file_unregister(self->f_sockname);
+		tcmi_ctlfs_entry_put(self->f_sockname);
+
+		tcmi_ctlfs_entry_put(self->d_id);
+		kkc_sock_put(self->sock);
+		kfree(self);
+	}
+}
+
+/** @addtogroup tcmi_sock_class
+ *
+ * @{
+ */
+
+/** 
+ * \<\<private\>\> Asks the KKC socket to supply its localname.
+ * 
+ * @param *object - pointer to this tcmi socket instance
+ * @param *data - storage for the localname string
+ * @return 0 upon success
+ */
+static int tcmi_sock_getsockname(void *object, void *data)
+{
+	struct tcmi_sock *self = TCMI_SOCK(object);
+
+	kkc_sock_getsockname(self->sock, data, KKC_SOCK_MAX_ADDR_LENGTH);
+	return 0;
+}
+ 
+/** 
+ * \<\<private\>\> Asks the KKC socket to supply its peername.
+ * 
+ * @param *object - pointer to this tcmi socket instance
+ * @param *data - storage for the peername string
+ * @return 0 upon success
+ */
+static int tcmi_sock_getpeername(void *object, void *data)
+{
+	struct tcmi_sock *self = TCMI_SOCK(object);
+
+	kkc_sock_getpeername(self->sock, data, KKC_SOCK_MAX_ADDR_LENGTH);
+	return 0;
+}
+
+/** 
+ * \<\<private\>\> Asks the KKC socket to supply its peername.
+ * 
+ * @param *object - pointer to this tcmi socket instance
+ * @param *data - storage for the architecture string
+ * @return 0 upon success
+ */
+static int tcmi_sock_getarchname(void *object, void *data)
+{
+	struct tcmi_sock *self = TCMI_SOCK(object);
+
+	kkc_sock_getarchname(self->sock, data, KKC_MAX_ARCH_LENGTH);
+	return 0;
+}
+
+/**
+ * @}
+ */
+
+
--- linux-3.7.1_original/clondike/src/tcmi/lib/tcmi_sock.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/lib/tcmi_sock.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,171 @@
+/**
+ * @file tcmi_sock.h - A wrapper class for KKC listenings.
+ *                       
+ *                      
+ * 
+ *
+ *
+ * Date: 04/17/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_sock.h,v 1.3 2007/10/07 15:54:00 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_SOCK_H
+#define _TCMI_SOCK_H
+
+#include <asm/atomic.h>
+
+#include "tcmi_slot.h"
+#include <tcmi/ctlfs/tcmi_ctlfs_dir.h>
+#include <tcmi/ctlfs/tcmi_ctlfs_file.h>
+
+#include <kkc/kkc.h>
+
+/** @defgroup tcmi_sock_class tcmi_sock class 
+ *
+ * @ingroup tcmi_lib_group
+ * 
+ * This class is a wrapper for KKC socket. It provides a TCMI ctlfs
+ * user interface, that allows the user to read information about
+ * the socket - local name, peername and architecture.
+ *
+ * Sockets are meant to be stored in \link tcmi_slotvec_class a
+ * slot vector \endlink. For that reason they provide a slot node,
+ * so that they can be linked into the slotvector.
+ *
+ * There is no need for additional lock since access to the
+ * data structures from user space is serialized via the TCMI ctlfs
+ * files. Other kernel threads accessing the socket don't manipulate
+ * its internal datastructures, except for the last thread that
+ * destroys it. This protection is implemented by standard reference
+ * counting.
+ *
+ * @{
+ */
+
+/**
+ * A compound structure that holds the actual KKC listening.
+ */
+struct tcmi_sock {
+	/** A slot node, used for insertion the listening into a slot */
+	tcmi_slot_node_t node;
+
+	/** Instance reference counter. */
+	atomic_t ref_count;
+
+	/** TCMI ctlfs directory where there are the control files of
+	 * the listening. The name is based on slot index */
+	struct tcmi_ctlfs_entry *d_id;
+	/** TCMI ctlfs - shows the local socket address. */
+	struct tcmi_ctlfs_entry *f_sockname;
+	/** TCMI ctlfs - shows the remote socketa addres - meaningful
+	 * for connected sockets only. */
+	struct tcmi_ctlfs_entry *f_peername;
+	/** TCMI ctlfs - shows the architecture name. */
+	struct tcmi_ctlfs_entry *f_archname;
+
+	/** KKC socket contained in the instance. */
+	struct kkc_sock *sock;
+};
+
+/** \<\<public\>\> TCMI socket constructor. */
+extern struct tcmi_sock* tcmi_sock_new(struct tcmi_ctlfs_entry *root,
+				       struct kkc_sock *sock,
+				       const char namefmt[], ...);
+
+
+/** 
+ * \<\<public\>\> KKC socket accessor.  Reference counter of the KKC
+ * socket is not adjusted as the socket is part of the tcmi_sock
+ * instance. The caller is expected to have a valid reference to the
+ * tcmi_sock instance.
+ *
+ * @param *self - pointer to this instance
+ * @return tcmi_sock instance
+ */
+static inline struct kkc_sock* tcmi_sock_kkc_sock_get(struct tcmi_sock *self)
+{
+	if (!self)
+		return NULL;
+	return self->sock;
+}
+
+/** 
+ * \<\<public\>\> Instance accessor. increments the reference counter.
+ * The user is now guaranteed, that the instance stays in memory while
+ * he is using it.
+ *
+ * @param *self - pointer to this instance
+ * @return tcmi_sock instance
+ */
+static inline struct tcmi_sock* tcmi_sock_get(struct tcmi_sock *self)
+{
+	if (self) {
+/*		mdbg(CRIT4, "Incrementing ref. count(%d) of local:'%s', remote:'%s' (%p)", 
+		     atomic_read(&self->ref_count), 
+		     kkc_sock_getsockname2(tcmi_sock_kkc_sock_get(self)), 
+		     kkc_sock_getpeername2(tcmi_sock_kkc_sock_get(self)), self);
+*/
+		atomic_inc(&self->ref_count);
+	}
+	return self;
+}
+
+
+/** 
+ * \<\<public\>\> Sock node accessor.
+ *
+ * @param *self - pointer to this instance
+ * @return tcmi_slot_node
+ */
+static inline tcmi_slot_node_t* tcmi_sock_node(struct tcmi_sock *self)
+{
+	if (!self)
+		return NULL;
+	return &self->node;
+}
+
+/** \<\<public\>\> Releases the instance. */
+extern void tcmi_sock_put(struct tcmi_sock *self);
+
+/** Casts to a tcmi_sock instance */
+#define TCMI_SOCK(l) ((struct tcmi_sock *)l)
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_SOCK_PRIVATE
+
+/** Read method for the TCMI ctlfs - accessor for socketname string. */
+static int tcmi_sock_getsockname(void *object, void *data);
+/** Read method for the TCMI ctlfs - accessor for peername name string. */
+static int tcmi_sock_getpeername(void *object, void *data);
+/** Read method for the TCMI ctlfs - accessor for architecture name string. */
+static int tcmi_sock_getarchname(void *object, void *data);
+
+#endif /* TCMI_SOCK_PRIVATE */
+
+
+/**
+ * @}
+ */
+
+
+
+#endif /* _TCMI_SOCK_H */
--- linux-3.7.1_original/clondike/src/tcmi/lib/tcmi_queue.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/lib/tcmi_queue.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,323 @@
+/**
+ * @file tcmi_queue.h - Implements an SMP safe queue
+ *                      
+ * 
+ *
+ *
+ * Date: 04/10/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_queue.h,v 1.3 2007/09/02 10:54:43 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_QUEUE_H
+#define _TCMI_QUEUE_H
+
+#include <linux/list.h>
+#include <asm/atomic.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+#include <linux/wait.h>
+#include <linux/sched.h>
+
+#include <dbg.h>
+
+/** @defgroup tcmi_queue_class tcmi_queue class 
+ *
+ * @ingroup tcmi_lib_group
+ *
+ * The queue is implemented using a doubly linked list - provided by kernel.
+ * In addition, it contains a wait queue for process that want to be
+ * notified upon addition of a new element.
+ * Basic methods:
+ * - add - appends an element to the tail of the queue
+ * - empty - true if the queue is empty
+ * - remove_head - returns the element from the head of the queue and removes it -
+ *              this operation is atomic.
+ * - wait_on_empty - the calling process is put a sleep, until the queue
+ * contains at least 1 element. 
+ *
+ * @{
+ */
+
+/** Denotes whether the queue has been staticaly or dynamically
+ * created. This is needed if somebody issues a put on a static
+ * queue, so that no kfree is performed */
+typedef enum {
+	TCMI_QUEUE_STATIC,
+	TCMI_QUEUE_DYNAMIC
+} tcmi_queue_type_t;
+
+/** compound structure */
+struct tcmi_queue {
+	/** spin lock - serializes access to the queue */
+	spinlock_t q_lock;
+
+	/** The actual queue */
+	struct list_head queue;
+
+	/** reference counter for dynamically created queues */
+	atomic_t ref_count;
+
+	/** describes how the queue has been created */
+	tcmi_queue_type_t type;
+
+	/** Sleeping processes, that are to be notified upon addition
+	 * of a new element */
+	wait_queue_head_t wq;
+};
+
+
+
+
+/**
+ * \<\<public\>\> Queue initializer - for static allocation. The
+ * reference counter is set to 1.
+ *
+ * @param *self - pointer to this queue instance
+ *  
+ */
+static inline void tcmi_queue_init(struct tcmi_queue *self)
+{
+	atomic_set(&self->ref_count, 1);
+	spin_lock_init(&self->q_lock);
+	INIT_LIST_HEAD(&self->queue);
+	self->type = TCMI_QUEUE_STATIC;
+	init_waitqueue_head(&self->wq);
+}
+
+
+/**
+ * \<\<public\>\> Queue constructor.
+ *
+ * @return a new queue or NULL
+ */
+static inline struct tcmi_queue* tcmi_queue_new(void)
+{
+	struct tcmi_queue *q;
+	q = kmalloc(sizeof(struct tcmi_queue), GFP_ATOMIC);
+	if (!q) {
+		mdbg(ERR3, "Can't allocated memory for a queue");
+		goto exit0;
+	}
+	tcmi_queue_init(q);
+	/* mark the queue dynamic, so that it is released on the last 'put' */
+	q->type = TCMI_QUEUE_DYNAMIC;
+
+	mdbg(INFO4, "Allocated new queue %p", q);
+	return q;
+	/* error handling */
+ exit0:
+	return NULL;
+}
+
+/** 
+ * \<\<public\>\> Queue instance accessor. Increments the reference
+ * counter
+ * 
+ * @param *self - pointer to this queue instance
+ * @return - self
+ */
+static inline struct tcmi_queue* tcmi_queue_get(struct tcmi_queue *self)
+{
+	if (!self)
+		return NULL;
+	atomic_inc(&self->ref_count);
+	return self;
+}
+
+/**
+ * \<\<public\>\> Decrements the reference counter, when the count
+ * reaches 0, the instance is destroyed.
+ *
+ * @param *self - pointer to this queue instance
+ */
+static inline void tcmi_queue_put(struct tcmi_queue *self)
+{
+	if (!self)
+		return;
+
+	if (atomic_dec_and_test(&self->ref_count)) {
+		if (self->type == TCMI_QUEUE_STATIC)
+			mdbg(INFO4, "Released last reference to a static queue");
+		else {
+			mdbg(INFO4, "Released last reference to a dynamic queue %p", 
+			     self);
+			kfree(self);
+		}
+	}
+
+}
+
+/**
+ * \<\<public\>\> Locks the instance data. Spin lock used - no
+ * sleeping allowed!
+ *
+ * @param *self - pointer to this queue instance
+ */
+static inline void tcmi_queue_lock(struct tcmi_queue *self)
+{
+	spin_lock(&self->q_lock);
+}
+
+/**
+ * \<\<public\>\> Unlocks the instance data
+ *
+ * @param *self - pointer to this queue instance
+ */
+static inline void tcmi_queue_unlock(struct tcmi_queue *self)
+{
+	spin_unlock(&self->q_lock);
+}
+
+/**
+ * @return 1 when queue is empty
+ */
+static inline int tcmi_queue_empty(struct tcmi_queue *self)
+{
+	return list_empty(&self->queue);
+}
+
+/**
+ * \<\<public\>\> Adds an element to the queue - lock free version,
+ * assumes the lock is already held.  Wakes up a task from the wait
+ * queue, so that it can pickup the new element.
+ *
+ * @param *self - pointer to this queue instance
+ * @param *element - element to be added to the queue
+ */
+static inline void __tcmi_queue_add(struct tcmi_queue *self, struct list_head *element)
+{
+	list_add_tail(element, &self->queue);
+	wake_up(&self->wq);
+}
+
+/**
+ * \<\<public\>\> Locks the queue and appends a new element to the tail.
+ * @param *self - pointer to this queue instance
+ * @param *element - element to be added to the queue
+ */
+static inline void tcmi_queue_add(struct tcmi_queue *self, struct list_head *element)
+{
+	tcmi_queue_lock(self);
+	__tcmi_queue_add(self, element);
+	tcmi_queue_unlock(self);
+}
+
+/**
+ * \<\<public\>\> Removes an element in the head of the queue, assumes
+ * the lock is held already.
+ *
+ * @param *self - pointer to this queue instance
+ * @return - element in the head of the queue
+ */
+static inline struct list_head* __tcmi_queue_remove(struct tcmi_queue *self)
+{
+	struct list_head *element;
+	if (tcmi_queue_empty(self))
+		return NULL;
+	else {
+		element = self->queue.next;
+		list_del_init(element);
+		return (element);
+	}
+}
+
+/**
+ * \<\<public\>\> Locks the queue and removes removes an element in
+ * the head of the queue, assumes the lock is held already.
+ *
+ * @param *self - pointer to this queue instance
+ * @return - element in the head of the queue
+ */
+static inline struct list_head* tcmi_queue_remove(struct tcmi_queue *self)
+{
+	struct list_head *element;
+	tcmi_queue_lock(self);
+	element = __tcmi_queue_remove(self);
+	tcmi_queue_unlock(self);
+	return element;
+}
+
+/** 
+ * \<\<public\>\> Removes an entry from the head of the queue.
+ *
+ * @param self - pointer to this queue instance
+ * @param object - pointer that will hold the head element
+ * @param member - name of the member within the object used for queueing
+ */
+#define tcmi_queue_remove_entry(self, object, member)			\
+do {									\
+	struct list_head *__q_entry;					\
+	object = NULL;							\
+	if ((__q_entry = tcmi_queue_remove(self)))			\
+	    object = list_entry(__q_entry, typeof(*object), member);	\
+} while (0)
+
+/** 
+ * \<\<public\>\> Removes an entry from the head of the queue. Assumes
+ * the queue has already been locked.
+ *
+ * @param self - pointer to this queue instance
+ * @param object - pointer that will hold the head element
+ * @param member - name of the member within the object used for queueing
+ */
+#define __tcmi_queue_remove_entry(self, object, member)			\
+do {									\
+	struct list_head *__q_entry;					\
+	object = NULL;							\
+	if ((__q_entry = __tcmi_queue_remove(self)))			\
+	    object = list_entry(__q_entry, typeof(*object), member);	\
+} while (0)
+
+/**
+ * \<\<public\>\> Puts the calling process to sleep as long as the
+ * queue is empty.
+ *
+ * @param *self - pointer to this queue instance
+ * @return -ERESTARTSYS on signal arrival
+ */
+static inline int tcmi_queue_wait_on_empty_interruptible(struct tcmi_queue *self)
+{
+	/* Sleep until the queue is non empty */
+	return wait_event_interruptible_exclusive(self->wq, (!tcmi_queue_empty(self)));
+}
+
+/**
+ * \<\<public\>\> Puts the calling process to sleep as long as the
+ * queue is empty or the timeout expires.
+ *
+ * @param *self - pointer to this queue instance
+ * @param timeout - specified timeout
+ * @return -ERESTARTSYS on signal arrival or timeout (>0) if the timer went 
+ * off
+ */
+static inline int tcmi_queue_wait_on_empty_interruptible_timout(struct tcmi_queue *self, 
+								int timeout)
+{
+	/* Sleep until the queue is non empty */
+	return wait_event_interruptible_timeout(self->wq, (!tcmi_queue_empty(self)), 
+						timeout);
+}
+
+/**
+ * @}
+ */
+#endif /* _TCMI_QUEUE_H */
--- linux-3.7.1_original/clondike/src/tcmi/lib/tcmi_slotvec.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/lib/tcmi_slotvec.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,266 @@
+/**
+ * @file tcmi_slotvec.h - slot vector container used through out TCMI
+ *                      
+ * 
+ *
+ *
+ * Date: 04/04/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_slotvec.h,v 1.3 2007/07/29 17:32:51 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_SLOTVEC_H
+#define _TCMI_SLOTVEC_H
+
+#include <linux/list.h>
+#include <asm/atomic.h>
+#include <linux/spinlock.h>
+
+#include "tcmi_slot.h"
+
+/** @defgroup tcmi_slotvec_class tcmi_slotvec class 
+ *
+ * @ingroup tcmi_lib_group
+ * 
+ * This class represents a data structure widely used in
+ * implementation of TCMI. It is a vector of slots where each slot is
+ * head of a doubly linked list of the respective objects.
+ \verbatim
+    +-------+
+   0| slot  | -> object1 -> object 2 -> object 3...
+    +-------+
+   1| slot  | empty
+    +-------+
+   2| slot  | -> object 5 -> object 6...
+    +-------+
+   3| slot  | empty 
+    +-------+
+    .       .
+    .       .
+    .       .
+    +-------+
+    | slot  | -> objectX
+    +-------+
+   n| slot  | empty
+    +-------+
+ \endverbatim
+ *
+ * - The vector has limited size specified during initialization by
+ * the user. The benefit is that it provides O(1) access to all its
+ * slots based on index.  
+ * - Allows iterating through non-empty slots 
+ * - Allows allocating an empty slot with O(1) time complexity
+ * 
+ * The data structure internally keeps track of used and unused slots.
+ * The user can exclusively insert objects into empty slots
+ * only. This way, it can be used as a data structure describing some
+ * limited resource.  On the other hand(as seen in the figure), the
+ * user is able to insert new elements into any slots, thus yielding a
+ * hashtable. The user needs to select only a suitable hashing
+ * function. The general requirement on the hash function is to yield
+ * the index 0 to n-1 with an approximately uniform  distribution.
+ *
+ * Since the datastructure is expected to be accessed from multiple
+ * threads of execution a reference counting is implemented. The user
+ * should always access the slot vector by means of tcmi_slotvec_get()
+ * method and release the instance by means of tcmi_slotvec_put().
+ * The last accessing thread causes the slot vector to be freed from 
+ * memory.
+ * 
+ *@{
+ */
+
+/** 
+ * Iterates through all used slots in the slot vector.  This is
+ * intended for traversals only, no removals should take place.  We
+ * still need to ensure the slot vector protection against concurrent
+ * manipulation from other threads.
+ * 
+ * @param slot - every iteration points to a new object
+ * @param slotvec - slot vector we are iterating through
+ */
+#define tcmi_slotvec_for_each_used_slot(slot, slotvec) \
+ list_for_each_entry(slot, &slotvec->used_slots, slot_list)
+
+/** 
+ * \<\<public\>\> Iterates through all used slots in the slot vector -
+ * safe version.  This is a version safe against removals. If the
+ * current slot, will be removed during the iteration, no issues will
+ * arise. We still need to ensure the slot vector protection against
+ * concurrent manipulation from other threads.
+ * 
+ * @param slot - every iteration points to a new object
+ * @param slot2 - temporary storage for the current slot
+ * @param slotvec - slot vector we are iterating through
+ */
+#define tcmi_slotvec_for_each_used_slot_safe(slot, slot2, slotvec) \
+ list_for_each_entry_safe(slot, slot2, &slotvec->used_slots, slot_list)
+
+/** Extracts the actual slot from the list */
+#define tcmi_slotvec_entry(ptr, type, member) list_entry(ptr, type, member)
+
+
+/** 
+ * \<\<public\>\> Removes one entry from the slotvector and returns
+ * it.  Takes first used slot and obtains first element from it.
+ * Removes the element from the slot.
+ *
+ * @param slotvec - slotvector where the removal is to be done
+ * @param obj - a pointer where to store the object retrieved from
+ * @param member - name of the object member used for linking
+ * into the slot.
+ */
+#define tcmi_slotvec_remove_one_entry(slotvec, obj, member)	\
+do {								\
+	struct tcmi_slot *__slot;				\
+	obj = NULL;						\
+	tcmi_slotvec_for_each_used_slot(__slot, slotvec) {	\
+		tcmi_slot_remove_first(obj, __slot, member);	\
+		break;						\
+	}							\
+} while(0)
+
+/**
+ * A slot vector compound structure. Contains the used/unused slot lists
+ * and the actual vector.
+ */
+struct tcmi_slotvec {
+	/** The actual slot vector */
+	struct tcmi_slot *slots;
+	/** Number of slots in the vector */
+	u_int slot_count;
+	/** Hash mask - valid only when slot_count is \$2^order\$ and
+	 * the slot vector has been created by tcmi_slotvec_hnew(). */
+	u_int hashmsk;
+
+	/** list of unused slots */
+	struct list_head unused_slots;
+	/** list of used slots */
+	struct list_head used_slots;
+
+	/** reference counter */
+	atomic_t ref_count;
+
+	/** current instance reference - used when freeing */
+	/* struct tcmi_slotvec *this;*/
+	/** Protects the slotvector from concurrent modification */
+	spinlock_t s_lock;
+	/** Technical field used for irq safe spinlocks */
+	unsigned long lock_flags;
+};
+
+/** Allocates a new slot vector. */
+extern struct tcmi_slotvec* tcmi_slotvec_new(u_int size);
+
+/** Allocates a new slot vector with 2^order buckets. */
+extern struct tcmi_slotvec* tcmi_slotvec_hnew(u_int order);
+
+/** 
+ * Slot vector instance accessor. 
+ * Checks whether the instance is not currently being freed - if so,
+ * returns NULL. Otherwise increments the reference counter and
+ * returns self.
+ * 
+ * @param *self - pointer to this vector instance
+ * @return - self
+ */
+static inline struct tcmi_slotvec* tcmi_slotvec_get(struct tcmi_slotvec *self)
+{
+	if (!self)
+		return NULL;
+	atomic_inc(&self->ref_count);
+	return self;
+}
+
+/** \<\<public\>\> Releases the instance. */ 
+extern void tcmi_slotvec_put(struct tcmi_slotvec *self);
+
+/** \<\<public\>\> Accesses a slot at a given index. */
+extern struct tcmi_slot* tcmi_slotvec_at(struct tcmi_slotvec *self, u_int index);
+
+/** \<\<public\>\> Finds the first empty slot. */
+extern struct tcmi_slot* tcmi_slotvec_reserve_empty(struct tcmi_slotvec *self);
+
+/** \<\<public\>\> Inserts an item in a slot at a given index. */
+extern struct tcmi_slot* tcmi_slotvec_insert_at(struct tcmi_slotvec *self, u_int index,
+						struct hlist_node *node);
+/** \<\<public\>\> Inserts an item into an empty slot at a given index. */
+extern struct tcmi_slot* tcmi_slotvec_insert_at_empty(struct tcmi_slotvec *self,
+						      struct hlist_node *node);
+
+/**
+ * \<\<public\>\> Tester method for slotvec emptyness
+ *
+ * @param *self - pointer to this vector instance
+ * @return 1 if the slotvector is empty
+ */
+static inline int tcmi_slotvec_empty(struct tcmi_slotvec *self)
+{
+	return list_empty(&self->used_slots);
+}
+
+/**
+ * \<\<public\>\> Locks the instance data. Spin lock used - no
+ * sleeping allowed!
+ *
+ * @param *self - pointer to this vector instance
+ */
+static inline void tcmi_slotvec_lock(struct tcmi_slotvec *self)
+{
+	// Have to be irqsave to avoid possible safe->unsafe conflict in forks
+	spin_lock_irqsave(&self->s_lock, self->lock_flags);
+}
+
+/**
+ * \<\<public\>\> Unlocks the instance data.
+ *
+ * @param *self - pointer to this vector instance
+ */
+static inline void tcmi_slotvec_unlock(struct tcmi_slotvec *self)
+{
+ 	spin_unlock_irqrestore(&self->s_lock, self->lock_flags);
+}
+
+/** 
+ * \<\<public\>\> Hashmask accessor. This method is to be used only if
+ * the slot vector has been created by tcmi_slotvec_hnew() and is
+ * intented to be used as a hashtable. Otherwise the hashmask is not
+ * valid and defaults to 0.
+ *
+ * @return hashmask of the slot vector
+ */
+static inline u_int tcmi_slotvec_hashmask(struct tcmi_slotvec *self)
+{
+	return self->hashmsk;
+}
+
+
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_SLOTVEC_PRIVATE
+
+#endif /* TCMI_SLOTVEC_PRIVATE */
+
+
+/**
+ * @}
+ */
+#endif /* _TCMI_SLOTVEC_H */
--- linux-3.7.1_original/clondike/src/tcmi/lib/tcmi_slotvec.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/lib/tcmi_slotvec.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,224 @@
+/**
+ * @file tcmi_slotvec.c - slot vector container used through out TCMI 
+ *                      - implementation
+ * 
+ *
+ *
+ * Date: 04/05/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_slotvec.c,v 1.3 2007/09/02 10:54:43 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include <linux/slab.h>
+
+#include "tcmi_slotvec.h"
+
+#include <dbg.h>
+
+/** 
+ * \<\<public\>\> Creates new instance.
+ * - Vector of slots is allocated and all slots are initialized.
+ * Since we want the slot to do the management of unused/used lists
+ * on their own, we pass the vector lock as well as both list heads
+ * to the init method.
+ * - reference counter is initialized to 1 - the instantiator
+ * owns this slot vector now
+ * 
+ * @param size - number of slots to be allocated in the vector.
+ * @return a new slot vector or NULL
+ */
+struct tcmi_slotvec* tcmi_slotvec_new(u_int size)
+{
+	struct tcmi_slotvec *vec;
+	struct tcmi_slot *slots;
+	int i;
+	if (!(vec = kmalloc(sizeof(struct tcmi_slotvec), GFP_ATOMIC))) {
+		mdbg(ERR3, "Failed to allocate a slotvector");
+		goto exit0;
+	}
+	if (!(slots = kmalloc(sizeof(struct tcmi_slot) * size, GFP_ATOMIC))) {
+		mdbg(ERR3, "Failed to allocate a %d slots", size);
+		goto exit1;
+	}
+	vec->slots = slots;
+	vec->slot_count = size;
+	INIT_LIST_HEAD(&vec->unused_slots);
+	INIT_LIST_HEAD(&vec->used_slots);
+	atomic_set(&vec->ref_count, 1);
+	spin_lock_init(&vec->s_lock);
+	/* initialize all slots */
+	for (i = 0; i < size; i++) {
+		tcmi_slot_init(slots, i, &vec->unused_slots, 
+			       &vec->used_slots, &vec->s_lock);
+		slots++;
+	}
+	mdbg(INFO4, "Allocated %d slots (%lu bytes), memory=%p", size, 
+	     (unsigned long)(sizeof(struct tcmi_slot) * size), vec);
+	return vec;
+
+	/* error handling */
+ exit1:
+	kfree(vec);
+ exit0:
+	return NULL;
+}
+
+/**
+ * \<\<public\>\> This method creates a slot vector of the size
+ * \$2^{order}\$.  It is intended when using the slot vector as a
+ * hashtable with \$2^{order}\$ buckets. A hashmask is calculated as
+ * the vector size - 1.
+ *
+ * @param order - \$log_2(buckets)\$ 
+ * @return a new slot vector or NULL
+ */
+struct tcmi_slotvec* tcmi_slotvec_hnew(u_int order)
+{
+	struct tcmi_slotvec *vec;
+	if (!(vec = tcmi_slotvec_new(1 << order))) {
+		mdbg(ERR3, "Error creating a slot vector hashtable with 2^%d buckets", order);
+		goto exit0;
+	}
+	/* precompute the hashmask */
+	vec->hashmsk = vec->slot_count - 1;
+	return vec;
+	/* error handling */
+ exit0:
+	return NULL;
+}
+
+/**
+ * \<\<public\>\> Decrements the reference counter, when the count
+ * reaches 0, the instance is destroyed. This requires releasing all
+ * slots and eventually releasing the instance itself.
+ *
+ * @param *self - pointer to this vector instance
+ */
+void tcmi_slotvec_put(struct tcmi_slotvec *self)
+{
+	struct tcmi_slot *slots;
+	int i;
+	if (!self)
+		return;
+	mdbg(INFO3, "Putting ref. count=%d (%p)", 
+	     atomic_read(&self->ref_count), self);
+	if (atomic_dec_and_test(&self->ref_count)) {
+		slots = self->slots;
+		for (i = 0; i < self->slot_count; i++, slots++) {
+			if (!(tcmi_slot_empty(slots)))
+			    mdbg(WARN3, "Warning - non empty slot %d", i);
+		}
+		mdbg(INFO4, "Released %d slots (%lu bytes), memory=%p", 
+		     self->slot_count, 
+		     (unsigned long)(sizeof(struct tcmi_slot) * self->slot_count), self);
+		kfree(self->slots);
+		kfree(self);
+	}
+
+}
+
+/** 
+ * \<\<public\>\> Accesses a slot at a given index. If the index is
+ * not valid (exceeds the vector length), NULL is returned.
+ *
+ * @param *self - pointer to this vector instance
+ * @param index - index of a slot to be accessed.
+ * @return pointer to a slot at a given index or NULL
+ */
+struct tcmi_slot* tcmi_slotvec_at(struct tcmi_slotvec *self, u_int index)
+{
+	struct tcmi_slot *slot = NULL;
+	if (index < self->slot_count)
+		slot = &self->slots[index];
+
+	return slot;
+}
+
+/** 
+ * \<\<public\>\> Finds the first empty slot and reserves it.  The
+ * slot is removed from the unused list, so that other threads won't
+ * consider it when searching for empty slots. The user of this method
+ * is responsible for either filling the slot with some data or
+ * releasing the slot back to unused list by means of
+ * tcmi_slot.h::tcmi_slot_move_unused()
+ *
+ * @param *self - pointer to this vector instance
+ * @return pointer to an empty slot or NULL
+ */
+struct tcmi_slot* tcmi_slotvec_reserve_empty(struct tcmi_slotvec *self)
+{
+	struct tcmi_slot *slot = NULL;
+	struct list_head *list;
+
+	tcmi_slotvec_lock(self);
+	if (!list_empty(&self->unused_slots)) {
+		/* get the first slot */
+		list_for_each(list, &self->unused_slots)
+			break;
+		slot = list_entry(list, struct tcmi_slot, slot_list);
+		/* remove the slot, from the unused list */
+		list_del_init(list);
+		mdbg(INFO4, "Found empty slot index = %d", slot->index);
+	}
+	tcmi_slotvec_unlock(self);
+
+	return slot;
+}
+
+
+/** 
+ * \<\<public\>\> The index where the insertion takes place has to be
+ * a valid slot.  The work is then delegated to the slot.
+ *
+ * @param *self - pointer to this vector instance
+ * @param index - index of a slot to be accessed.
+ * @param *node - item to be inserted into an empty slot
+ * @return pointer to a slot at a given index where the node has been
+ * inserted or NULL
+ */
+struct tcmi_slot* tcmi_slotvec_insert_at(struct tcmi_slotvec *self, u_int index,
+					 struct hlist_node *node)
+{
+	struct tcmi_slot *slot = tcmi_slotvec_at(self, index);
+	if (slot)
+		tcmi_slot_insert(slot, node);
+	return slot;
+}
+/**
+ * \<\<public\>\> Takes the first slot from unused slot list and
+ * removes it from the list. The slot is then asked to insert the new
+ * node.
+ *
+ * @param *self - pointer to this vector instance
+ * @param *node - item to be inserted into an empty slot
+ * @return a pointer to the slot where the insertion took place
+ * or NULL
+ */
+struct tcmi_slot* tcmi_slotvec_insert_at_empty(struct tcmi_slotvec *self,
+					       struct hlist_node *node)
+{
+	struct tcmi_slot *slot = tcmi_slotvec_reserve_empty(self);
+	if (slot)
+		tcmi_slot_insert(slot, node);
+	return slot;
+}
--- linux-3.7.1_original/clondike/src/tcmi/manager/tcmi_ccnmigman.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/manager/tcmi_ccnmigman.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,117 @@
+/**
+ * @file tcmi_ccnmigman.h - TCMI cluster core node manager - a class that
+ *                       controls the cluster core node.
+ *                      
+ * 
+ *
+ *
+ * Date: 04/19/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_ccnmigman.h,v 1.3 2007/10/20 14:24:20 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_CCNMIGMAN_H
+#define _TCMI_CCNMIGMAN_H
+
+#include <linux/wait.h>
+
+#include "tcmi_migman.h"
+
+/** @defgroup tcmi_ccnmigman_class tcmi_ccnmigman class 
+ *
+ * @ingroup tcmi_migman_class
+ *
+ * TCMI CCN migration manager controls migrating tasks for a
+ * particular CCN-PEN pair and resides as the name describes - on a
+ * CCN.  Basic message handling capabilities are used from the \link
+ * tcmi_migman_class generic migration manager \endlink.
+ * 
+ * There are specific tasks that needs to be accomplished:
+ * - authenticate a connecting PEN
+ *
+ * It provides an additional entry in the TCMI ctlfs. This file reports
+ * an average load of a PEN that is connected to this migration manager.
+ * 
+ * @{
+ */
+
+
+/**
+ * A compound structure that holds all current shadow processes and
+ * other migration related data.
+ */
+struct tcmi_ccnmigman {
+	/** parent class instance. */
+	struct tcmi_migman super;
+
+	/** TCMI ctlfs - reports current load of the remote PEN. */
+	struct tcmi_ctlfs_entry *f_load;
+
+	/** General purpose wait queue, e.g. used when syncing the
+	 * context performing authentication with authentication
+	 * processing method */
+	wait_queue_head_t wq;
+};
+/** Casts to the CCN migration manager. */
+#define TCMI_CCNMIGMAN(migman) ((struct tcmi_ccnmigman *)migman)
+
+
+/** \<\<public\>\> TCMI CCN migration manager constructor. */
+extern struct tcmi_migman* tcmi_ccnmigman_new(struct kkc_sock *sock, u_int32_t ccn_id, struct tcmi_slot* manager_slot,
+					      struct tcmi_ctlfs_entry *root,
+					      struct tcmi_ctlfs_entry *migproc,
+					      const char namefmt[], ...);
+
+/** \<\<public\>\> Tries authenticating a PEN. */
+extern int tcmi_ccnmigman_auth_pen(struct tcmi_ccnmigman *self);
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_CCNMIGMAN_PRIVATE
+
+
+/** Initializes TCMI ctlfs files. */
+static int tcmi_ccnmigman_init_ctlfs_files(struct tcmi_migman *self);
+/** Destroys all TCMI ctlfs files. */
+static void tcmi_ccnmigman_stop_ctlfs_files(struct tcmi_migman *self);
+
+
+/** Read method for the TCMI ctlfs - reports current PEN load. */
+static int tcmi_ccnmigman_load(void *obj, void *data);
+
+/** Frees CCN mig. manager specific resources. */
+static void tcmi_ccnmigman_free(struct tcmi_migman *self);
+
+/** Processes a TCMI message m. */
+static void tcmi_ccnmigman_process_msg(struct tcmi_migman *self, struct tcmi_msg *m);
+
+/** CCN Migration manager operations that support polymorphism */
+static struct tcmi_migman_ops ccnmigman_ops;
+
+#endif /* TCMI_CCNMIGMAN_PRIVATE */
+
+
+/**
+ * @}
+ */
+
+
+#endif /* _TCMI_CCNMIGMAN_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/manager/tcmi_migman.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/manager/tcmi_migman.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,431 @@
+/**
+ * @file tcmi_migman.h - TCMI cluster core node manager - a class that
+ *                       controls the cluster core node.
+ *                      
+ * 
+ *
+ *
+ * Date: 04/19/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_migman.h,v 1.6 2009-01-20 14:23:03 andrep1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_MIGMAN_H
+#define _TCMI_MIGMAN_H
+
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/list.h>
+
+#include <kkc/kkc.h>
+#include <tcmi/comm/tcmi_messages_dsc.h>
+#include <tcmi/comm/tcmi_comm.h>
+#include <tcmi/ctlfs/tcmi_ctlfs.h>
+#include <tcmi/ctlfs/tcmi_ctlfs_dir.h>
+#include <tcmi/ctlfs/tcmi_ctlfs_file.h>
+#include <tcmi/lib/tcmi_sock.h>
+#include <tcmi/lib/tcmi_slotvec.h>
+#include <arch/arch_ids.h>
+
+struct tcmi_task;
+
+/** @defgroup tcmi_migman_class tcmi_migman class 
+ *
+ * @ingroup tcmi_managers_group
+ *
+ * TCMI migration manager controls migrating tasks for a particular
+ * CCN-PEN pair. This is abstract class that gathers all common
+ * functionality required for CCN and PEN resp. Node specific
+ * implementation is carried out in \link tcmi_ccnmigman_class CCN
+ * migration manager \endlink and \link tcmi_penmigman_class PEN
+ * migration manager \endlink
+ * 
+ * Node specific migration manager supplies only methods to:
+ * - release all its resources
+ * - initialize and destroy TCMI ctlfs directories
+ * - initialize and destroy TCMI ctlfs files
+ * - process an incoming message from the message queue
+ * - deliver a message to the message queue.
+ * 
+ * @{
+ */
+
+/** Describes the current state of the TCMI migration manager.
+ * The states have following meaning:
+ * - INIT - the system is being brought up
+ * - CONNECTED - PEN has been succesfully authenticated and is now connected
+ * - SHUTTING_DOWN - no more migration requests will be accepted, 
+ *   migrated should be moved back or to other PEN 
+ * - SHUT_DOWN - all connections are closed, component is ready
+ *   for destruction.
+ */
+typedef enum {
+	TCMI_MIGMAN_INIT,
+	TCMI_MIGMAN_CONNECTED,
+	TCMI_MIGMAN_SHUTTING_DOWN,
+	TCMI_MIGMAN_SHUT_DOWN,
+	/* number of states, not a special state */
+	TCMI_MIGMAN_STATE_COUNT 
+} tcmi_migman_state_t;
+
+
+/**
+ * A compound structure that holds all current shadow processes and
+ * other migration related data.
+ */
+struct tcmi_migman {
+	/** A slot node, used for insertion of the manager into a slot */
+	tcmi_slot_node_t node;
+
+	/** slot container for TCMI tasks(shadows on CCN /guests on
+	 * PEN) that it controls.*/
+	struct tcmi_slotvec *tasks;
+
+	/** CCN ID - supplied by the instantiator(for CCN mig manager)
+	 * or sent by the CCN(for PEN mig manager) */
+	u_int32_t ccn_id;
+	/** PEN ID - vica versa to how CCN ID is setup*/
+	u_int32_t pen_id;
+	/** Reference to slot in an associated manager migmans vector. Required when performing dequeueing. */
+	struct tcmi_slot* manager_slot;
+	/** Architecture of corresponding migration manager peer (communicated on registration) */	
+	enum arch_ids peer_arch_type;
+
+	/** Instance reference counter. */
+	atomic_t ref_count;
+	
+	/** Message queue for transaction-less messages. */
+	struct tcmi_queue msg_queue;
+	/** Message transactions. */
+	struct tcmi_slotvec *transactions;
+
+	/** Communication component used for message receiving and
+	 * delivery. */
+	struct tcmi_comm *comm;
+	/** TCMI socket that represents an active connection to the PEN. */
+	struct tcmi_sock *sock;
+
+	/** Message processing thread */
+	struct task_struct *msg_thread;
+
+	/** Denotes the current state of the manager. */
+	atomic_t state;
+
+	/** TCMI ctlfs - directory where all migration control
+	 * files/directories reside. */
+	struct tcmi_ctlfs_entry *d_migman;
+	/** TCMI ctlfs - directory for active connections */
+	struct tcmi_ctlfs_entry *d_conns;
+	/** TCMI ctlfs - reports current state of the manager. */
+	struct tcmi_ctlfs_entry *f_state;
+	/** TCMI ctlfs - request shutdown of this migration manager. */
+	struct tcmi_ctlfs_entry *f_stop;
+	/** TCMI ctlfs - request kill of this migration manager. */
+	struct tcmi_ctlfs_entry *f_kill;
+
+	/** TCMI ctlfs - reference to the migproc directory - needed
+	 * when immigrating a process. */
+	struct tcmi_ctlfs_entry *d_migproc;
+
+	struct tcmi_ctlfs_entry *s_migman;
+
+	/** Unique, randomly generated ID. */
+	u_int32_t id;
+	
+	/** Operations specific to CCN/PEN migration manager resp. */
+	struct tcmi_migman_ops *ops;
+};
+
+/** Migration manager operations that support polymorphism */
+struct tcmi_migman_ops {
+	/** Initializes TCMI ctlfs directories. */
+	int (*init_ctlfs_dirs)(struct tcmi_migman*);
+	/** Initializes TCMI ctlfs files. */
+	int (*init_ctlfs_files)(struct tcmi_migman*);
+	/** Destroys all TCMI ctlfs directories. */
+	void (*stop_ctlfs_dirs)(struct tcmi_migman*);
+	/** Destroys all TCMI ctlfs files. */
+	void (*stop_ctlfs_files)(struct tcmi_migman*);
+	/** Releases the instance specific resources. */
+	void (*free)(struct tcmi_migman*);
+	/** Processes a TCMI message m. */
+	void (*process_msg)(struct tcmi_migman*, struct tcmi_msg*);
+	
+	/** Request to stop this migration manager and terminate its connection with peer. */
+	void (*stop)(struct tcmi_migman*, int);
+
+};
+
+/** Message processing method type for the message processing thread. */
+typedef void process_msg_t (struct tcmi_migman*, struct tcmi_msg*);
+/** Casts to the migration manager. */
+#define TCMI_MIGMAN(migman) ((struct tcmi_migman*)migman)
+
+
+/** \<\<public\>\> TCMI migration manager initializer. 
+ *
+ * */
+extern int tcmi_migman_init(struct tcmi_migman *self, struct kkc_sock *sock, 
+			    u_int32_t ccn_id, u_int32_t pen_id, 
+			    enum arch_ids peer_arch_type, struct tcmi_slot* manager_slot,
+			    struct tcmi_ctlfs_entry *root,
+			    struct tcmi_ctlfs_entry *migproc,
+			    struct tcmi_migman_ops *ops,
+			    const char namefmt[], va_list args);
+
+
+/** 
+ * \<\<public\>\> Instance accessor, increments the reference counter.
+ *
+ * @param *self - pointer to this instance
+ * @return tcmi_migman instance
+ */
+static inline struct tcmi_migman* tcmi_migman_get(struct tcmi_migman *self)
+{
+	if (self) {
+		atomic_inc(&self->ref_count);
+	}
+	return self;
+}
+
+
+/** Releases the instance. */
+extern int tcmi_migman_put(struct tcmi_migman *self);
+
+
+/** 
+ * \<\<public\>\> Set atomically a new state of the migration manager. 
+ *
+ * @param *self - pointer to this instance
+ * @param state - new state to be set
+ * @return Last state, i.e. state before the state change was performed
+ */
+static inline tcmi_migman_state_t tcmi_migman_set_state(struct tcmi_migman *self, 
+					 tcmi_migman_state_t state)
+{
+	return (tcmi_migman_state_t)atomic_xchg(&self->state, (int)state);
+}
+
+/** 
+ * \<\<public\>\> Set atomically a new state of the migration manager, assuming current state == old_state
+ *
+ * @param *self - pointer to this instance
+ * @param old_state - old state, that must hold in order to succeed in change
+ * @param state - new state to be set
+ * @return Non zero, in case change was performed
+ */
+static inline int tcmi_migman_change_state(struct tcmi_migman *self, 
+					 tcmi_migman_state_t old_state, tcmi_migman_state_t state)
+{
+	tcmi_migman_state_t current_state = (tcmi_migman_state_t)atomic_cmpxchg(&self->state, (int)old_state, (int)state);
+	return current_state == old_state;
+}
+
+/** 
+ * \<\<public\>\> Migration manager state accessor.
+ *
+ * @param *self - pointer to this instance
+ * @return current state of the manager
+ */
+static inline tcmi_migman_state_t tcmi_migman_state(struct tcmi_migman *self)
+{
+	return (tcmi_migman_state_t)atomic_read(&self->state);
+}
+
+/** 
+ * \<\<public\>\> Migration manager slot index getter
+ *
+ * @param *self - pointer to this instance
+ * @return Index of slot in manager migmans vector
+ */
+static inline u_int tcmi_migman_slot_index(struct tcmi_migman *self)
+{
+	return tcmi_slot_index(self->manager_slot);
+}
+
+
+/** 
+ * \<\<public\>\> Migration manager root directory accessor.
+ *
+ * @param *self - pointer to this instance
+ * @return current state of the manager
+ */
+static inline struct tcmi_ctlfs_entry* tcmi_migman_root(struct tcmi_migman *self)
+{
+	return self->d_migman;
+}
+
+/** 
+ * \<\<public\>\> Transactions accessor.
+ *
+ * @param *self - pointer to this instance
+ * @return transactions slot vector
+ */
+static inline struct tcmi_slotvec* tcmi_migman_transactions(struct tcmi_migman *self)
+{
+	return self->transactions;
+}
+
+/** 
+ * \<\<public\>\> Message queue accesor.
+ *
+ * @param *self - pointer to this instance
+ * @return message queue reference 
+ */
+static inline struct tcmi_queue* tcmi_migman_msg_queue(struct tcmi_migman *self)
+{
+	return &self->msg_queue;
+}
+
+/** 
+ * \<\<public\>\> Communication socket accesor.  Reference counter is
+ * not adjusted as the socket is part of the tcmi_sock instance. The
+ * caller is expected to have a valid reference to the tcmi_migman
+ * which in turn guarantees a reference to tcmi_sock.
+ *
+ * @param *self - pointer to this instance
+ * @return pointer to KKC socket.
+ */
+static inline struct kkc_sock* tcmi_migman_sock(struct tcmi_migman *self)
+{
+	return tcmi_sock_kkc_sock_get(self->sock);
+}
+
+
+/** 
+ * \<\<public\>\> Slot node accessor.
+ *
+ * @param *self - pointer to this instance
+ * @return tcmi_slot_node
+ */
+static inline tcmi_slot_node_t* tcmi_migman_node(struct tcmi_migman *self)
+{
+	if (!self)
+		return NULL;
+	return &self->node;
+}
+
+/** 
+ * \<\<public\>\> Migration manager ID accessor.
+ *
+ * @param *self - pointer to this instance
+ * @return tcmi_slot_node
+ */
+static inline u_int32_t tcmi_migman_id(struct tcmi_migman *self)
+{
+	return self->id;
+}
+
+/** 
+ * \<\<public\>\> Migproc directory accessor.
+ *
+ * @param *self - pointer to this instance
+ * @return migproc directory where the migrated process publishes its
+ * info
+ */
+static inline struct tcmi_ctlfs_entry* tcmi_migman_migproc_dir(struct tcmi_migman *self)
+{
+	return self->d_migproc;
+}
+
+/** 
+ * \<\<public\>\> Getter of peer architecture type
+ *
+ * @param *self - pointer to this instance
+ * @return architecture of peer computer
+ */
+static inline enum arch_ids tcmi_migman_peer_arch(struct tcmi_migman* self)
+{
+	return self->peer_arch_type;
+}
+
+/** Asynchronous request to stop migration manager, migrate all process back to hom and terminate connection with peer. */
+void tcmi_migman_stop(struct tcmi_migman *self);
+
+/**
+ * Kills all tasks associated with this migman and drops reference to the migman (in case it was not already shutting down).
+ * The method is useful in case peer died without cleaning up its own tasks, because we need to clean them up before we can release reference to peer.
+ * 
+ * @return 1, if the migman instance was destroyed in context of this method
+ */
+int tcmi_migman_kill(struct tcmi_migman *self);
+
+/** \<\<public\>\> Registers tcmi task into the migration manager tasks slotvec */
+extern int tcmi_migman_add_task(struct tcmi_migman *self, struct tcmi_task* task);
+/** \<\<public\>\> Removes tcmi task from the migration manager tasks slotvec */
+extern int tcmi_migman_remove_task(struct tcmi_migman *self, struct tcmi_task* task);
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_MIGMAN_PRIVATE
+
+/** Removes migman from a list of migration managers of the associated manager. */
+static void tcmi_migman_unhash(struct tcmi_migman *self);
+
+/** Frees all migration manager resources. */
+static void tcmi_migman_free(struct tcmi_migman *self);
+
+/** Actual implementation of stop method */
+static int tcmi_migman_stop_perform(struct tcmi_migman *self, int remote_requested);
+
+/** Initializes TCMI ctlfs directories. */
+static int tcmi_migman_init_ctlfs_dirs(struct tcmi_migman *self,
+				       struct tcmi_ctlfs_entry *root,
+				       struct tcmi_ctlfs_entry *migproc,
+				       const char namefmt[], va_list args);
+/** Initializes TCMI ctlfs files. */
+static int tcmi_migman_init_ctlfs_files(struct tcmi_migman *self);
+
+/** Destroys all TCMI ctlfs directories. */
+static void tcmi_migman_stop_ctlfs_dirs(struct tcmi_migman *self);
+/** Destroys all TCMI ctlfs files. */
+static void tcmi_migman_stop_ctlfs_files(struct tcmi_migman *self);
+
+/** Read method for the TCMI ctlfs - reports migration manager state. */
+static int tcmi_migman_show_state(void *obj, void *data);
+/** Requests async shutdown */
+static int tcmi_migman_stop_request(void *obj, void *data);
+/** Requests async kill */
+static int tcmi_migman_kill_request(void *obj, void *data);
+
+/** Starts the TCMI migration manager message processing thread. */
+static int tcmi_migman_start_thread(struct tcmi_migman *self);
+/** Stops the TCMI migration manager message processing thread. */
+static void tcmi_migman_stop_thread(struct tcmi_migman *self);
+/** Delivers a TCMI message to the mig. manager or to a task */
+static int tcmi_migman_deliver_msg(void *obj, struct tcmi_msg *m);
+/** TCMI manager message processing thread. */
+static int tcmi_migman_msg_thread(void *data);
+
+/** */
+int tcmi_migman_create_symlink(struct tcmi_migman *self, struct tcmi_ctlfs_entry * root, struct kkc_sock *sock);
+
+/** String descriptor for the states of migration manager - forware declaration. */
+static char *tcmi_migman_states[];
+
+#endif /* TCMI_MIGMAN_PRIVATE */
+
+/**
+ * @}
+ */
+
+
+#endif /* _TCMI_MIGMAN_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/manager/tcmi_ccnmigman.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/manager/tcmi_ccnmigman.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,289 @@
+/**
+ * @file tcmi_ccnmigman.c - Implementation of TCMI cluster core node migration
+ *                          manager - a class that controls task migration on CCN
+ *                      
+ * 
+ *
+ *
+ * Date: 04/19/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_ccnmigman.c,v 1.5 2009-04-06 21:48:46 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <tcmi/migration/tcmi_migcom.h>
+
+#define TCMI_CCNMIGMAN_PRIVATE
+#include "tcmi_ccnmigman.h"
+#include "tcmi_ccnman.h"
+
+#include <tcmi/comm/tcmi_authenticate_msg.h>
+#include <tcmi/comm/tcmi_authenticate_resp_msg.h>
+#include <arch/current/regs.h>
+
+#include <director/director.h>
+
+#include <dbg.h>
+
+/** 2^8 elements in the shadow process hash */
+#define SHADOW_ORDER 8
+
+/**
+ * \<\<public\>\> TCMI CCN manager constructor.
+ * The initialization is accomplished exactly in this order:
+ * - create new instance
+ * - allocate new slot vector for shadow processes.
+ * - delegates all remaining intialization work to the generic manager.
+ * - authenticate the connecting PEN
+ *
+ * @param *sock - socket where the new PEN is registering
+ * @param ccn_id - CCN identifier
+ * @param *root - directory where the migration manager should create its
+ * files and directories
+ * @param *migproc - directory where the migrated process will have their info
+ * @param namefmt - nameformat string for the main manager directory name (printf style)
+ * @param ... - variable arguments
+ * @return new TCMI CCN manager instance or NULL
+ */
+struct tcmi_migman* tcmi_ccnmigman_new(struct kkc_sock *sock, u_int32_t ccn_id, struct tcmi_slot* manager_slot,
+					  struct tcmi_ctlfs_entry *root,
+				       struct tcmi_ctlfs_entry *migproc,
+					  const char namefmt[], ...)
+{
+	struct tcmi_ccnmigman *migman;
+	va_list args;
+
+	minfo(INFO2, "Creating new TCMI CCN migration manager");
+	if (!(migman = TCMI_CCNMIGMAN(kmalloc(sizeof(struct tcmi_ccnmigman), 
+					      GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate memory for CCM migration manager");
+		goto exit0;
+	}
+	init_waitqueue_head(&migman->wq);
+	va_start(args, namefmt);
+	if (tcmi_migman_init(TCMI_MIGMAN(migman), sock, ccn_id, 0, UNKNOWN, manager_slot, root, migproc,
+			     &ccnmigman_ops, namefmt, args) < 0) {
+		mdbg(ERR3, "TCMI CCN migman initialization failed!");
+		va_end(args);
+		goto exit1;
+	}
+	va_end(args);
+	
+	return TCMI_MIGMAN(migman);
+
+	/* error handling */
+ exit1:
+	kfree(migman);
+ exit0:
+	return NULL;
+}
+
+/**
+ * \<\<public\>\> Authenticates the connecting PEN expecting a
+ * registration message and processing it. Authentication is
+ * considered successful if after processing the message the new
+ * manager state is 'CONNECTED'.  The check is fully left upto the
+ * message processing framework. All that needs to be done is wait
+ * for a given time if the state changes. Of course, the connection
+ * message processing wakes us up earlier when needed.
+ *
+ * @param *self - pointer to this migration manager instance
+ * @return 0 if successfully, -EINVAL otherwise
+ */
+int tcmi_ccnmigman_auth_pen(struct tcmi_ccnmigman *self)
+{
+	int ret;
+	mdbg(INFO3, "Waiting for connection authentication.. %p", self);
+	ret = wait_event_interruptible_timeout(self->wq,
+					       (tcmi_migman_state(TCMI_MIGMAN(self)) == 
+						TCMI_MIGMAN_CONNECTED), 5*HZ); 
+	mdbg(INFO3, "woke up after %d, checking authentication result", ret);
+	return (tcmi_migman_state(TCMI_MIGMAN(self)) == TCMI_MIGMAN_CONNECTED ? 
+		0 : -EINVAL); 
+}
+
+/** @addtogroup tcmi_ccnmigman_class
+ *
+ * @{
+ */
+
+
+
+/** 
+ * \<\<private\>\> Creates the static files 
+ * described \link tcmi_ccnmigman_class here \endlink. 
+ *
+ * @param *self - pointer to this migration manager instance
+ * @return 0 upon success
+ */
+static int tcmi_ccnmigman_init_ctlfs_files(struct tcmi_migman *self)
+{
+	struct tcmi_ccnmigman *self_ccn = TCMI_CCNMIGMAN(self);
+	mdbg(INFO4, "Creating files");
+	if (!(self_ccn->f_load = 
+	      tcmi_ctlfs_intfile_new(tcmi_migman_root(self), TCMI_PERMS_FILE_R,
+				     self, NULL, tcmi_ccnmigman_load,
+				     sizeof(int), "load")))
+		goto exit0; 
+
+	return 0;
+
+	/* error handling */
+ exit0:
+	return -EINVAL;
+
+}
+
+
+/** 
+ *\<\<private\>\>  Unregisters and releases all control files.
+ *
+ * @param *self - pointer to this migration manager instance
+ */
+static void tcmi_ccnmigman_stop_ctlfs_files(struct tcmi_migman *self)
+{
+	struct tcmi_ccnmigman *self_ccn = TCMI_CCNMIGMAN(self);
+	mdbg(INFO3, "Destroying  TCMI ctlfs files - CCN migman");
+	tcmi_ctlfs_file_unregister(self_ccn->f_load);
+	tcmi_ctlfs_entry_put(self_ccn->f_load);
+}
+
+/**
+ * \<\<private\>\> Called on stop request
+ * 
+ * @param *self - pointer to this migration manager instance
+ */
+static void tcmi_ccnmigman_stop(struct tcmi_migman *self, int remote_requested) {
+    director_node_disconnected(tcmi_migman_slot_index(self), 1, remote_requested);
+}
+
+
+/** 
+ * \<\<private\>\> Read method for the TCMI ctlfs - reports current
+ * PEN load. Load is reported based on the last sent info from PEN
+ *
+ *
+ * @param *obj - this CCN manager instance
+ * @param *data - pointer to this migration manager instance
+ * @return 0 upon success
+ */
+static int tcmi_ccnmigman_load(void *obj, void *data)
+{
+	return 0;
+}
+
+
+
+/** 
+ * \<\<private\>\> Called upon migman destruction.
+ *  *
+ * @param *self - pointer to this migration manager instance
+ */
+static void tcmi_ccnmigman_free(struct tcmi_migman *self)
+{
+	/* struct tcmi_ccnmigman *self_ccn  = TCMI_CCNMIGMAN(self); */
+	/* nothing to do */
+}
+
+
+/**
+ * \<\<private\>\> Processes a TCMI message m. 
+ * The message is desposed afterwords.
+ *
+ * @param *self - pointer to this migration manager instance
+ * @param *m - pointer to a message to be processed
+ */
+static void tcmi_ccnmigman_process_msg(struct tcmi_migman *self, struct tcmi_msg *m)
+{
+	struct tcmi_msg *resp;
+	int result_code = 0;
+	int accepted;
+	struct tcmi_authenticate_msg *auth_msg;
+	struct tcmi_generic_user_msg *user_msg;
+
+	/* struct tcmi_ccnmigman *self_ccn = TCMI_CCNMIGMAN(self); */
+	int err;
+	mdbg(INFO4, "Processing message ID");
+
+	switch(tcmi_msg_id(m)) {
+	case TCMI_AUTHENTICATE_MSG_ID:
+		auth_msg = TCMI_AUTHENTICATE_MSG(m);
+		minfo(INFO1, "Authentication message arrived.");
+		
+		// Inform director that the node was connected 
+		err = director_node_connected(kkc_sock_getpeername2(tcmi_migman_sock(self)), tcmi_migman_slot_index(self), tcmi_authenticate_msg_auth_data_size(auth_msg), tcmi_authenticate_msg_auth_data(auth_msg), &accepted);
+		// The check for accept is performed only if the director responded, otherwise the call is ignored
+		if ( !err && !accepted ) {
+			minfo(ERR1, "Director rejected peer connection");
+			break;
+		}
+
+		self->pen_id = tcmi_authenticate_msg_pen_id(auth_msg);
+		self->peer_arch_type = tcmi_authenticate_msg_arch(auth_msg);
+
+		if ( !( resp = tcmi_authenticate_resp_msg_new_tx(tcmi_msg_req_id(m), self->ccn_id, ARCH_CURRENT, result_code, tcmi_ccnman_get_mount_params()) ) ) { 
+			mdbg(ERR3, "Error creating response message");
+			break;
+		}
+		if ((err = tcmi_msg_send_anonymous(resp, tcmi_migman_sock(self)))) {
+			mdbg(ERR3, "Error sending response message %d", err);
+		}
+		tcmi_msg_put(resp);
+		tcmi_migman_set_state(self, TCMI_MIGMAN_CONNECTED);
+		wake_up(&(TCMI_CCNMIGMAN(self)->wq));
+		break;
+	case TCMI_GENERIC_USER_MSG_ID:
+		user_msg = TCMI_GENERIC_USER_MSG(m);
+		minfo(INFO1, "User message arrived.");
+
+		err = director_generic_user_message_recv(tcmi_generic_user_msg_node_id(user_msg), 1, tcmi_migman_slot_index(self), tcmi_generic_user_msg_user_data_size(user_msg), tcmi_generic_user_msg_user_data(user_msg));
+		if ( err ) {
+			mdbg(ERR3, "Error in processing user message %d", err);
+		}
+		break;
+	default:
+		minfo(INFO1, "Unexpected message ID %x, no handler available.", 
+		      tcmi_msg_id(m));
+		break;
+	}
+
+	/* release the message */
+	tcmi_msg_put(m);
+
+}
+
+
+
+
+/** Migration manager operations that support polymorphism */
+static struct tcmi_migman_ops ccnmigman_ops = {
+	.init_ctlfs_files = tcmi_ccnmigman_init_ctlfs_files, 
+	.stop_ctlfs_files = tcmi_ccnmigman_stop_ctlfs_files,
+	.stop = tcmi_ccnmigman_stop,
+	.free = tcmi_ccnmigman_free,
+	.process_msg = tcmi_ccnmigman_process_msg,
+};
+
+/**
+ * @}
+ */
+
+
--- linux-3.7.1_original/clondike/src/tcmi/manager/tcmi_ccnman.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/manager/tcmi_ccnman.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,273 @@
+/**
+ * @file tcmi_ccnman.h - TCMI cluster core node manager - a class that
+ *                       controls the cluster core node.
+ *                      
+ * 
+ *
+ *
+ * Date: 04/06/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_ccnman.h,v 1.4 2007/09/15 14:46:09 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_CCNMAN_H
+#define _TCMI_CCNMAN_H
+
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/list.h>
+
+#include <tcmi/lib/tcmi_slotvec.h>
+#include <tcmi/ctlfs/tcmi_ctlfs_dir.h>
+#include <tcmi/ctlfs/tcmi_ctlfs_file.h>
+#include <tcmi/migration/fs/fs_mount_params.h>
+
+#include "tcmi_man.h"
+
+/* TCMI CCN manager is controlled by compile time config option in Kbuild */
+#ifdef CONFIG_TCMI_CCN
+/** @defgroup tcmi_ccnman_class tcmi_ccnman class 
+ *
+ * @ingroup tcmi_man_class
+ *
+ * This \<\<singleton\>\> class implements the CCN TCMI manager
+ * component. It is responsible for registration of new PEN's.  Each
+ * migration manager is associated with one registered PEN. The user
+ * controls the cluster core node by manipulating \link tcmi_ctlfs.c
+ * TCMI control file system \endlink. The directory/file layout can be
+ * divided into three groups of files/directories based on their
+ * maintainers, which can be:
+ *
+ * - TCMI CCN manager
+ * - TCMI CCN migration manager
+ * - TCMI CCN preemptive migration component
+ * - TCMI CCN non-preemtive migration component
+ * - TCMI shadow process
+ *
+ * 
+ \verbatim
+  ------------ T C M I  m a n a g e r --------------
+  ccn/listen -> allows adding new interfaces where the CCN manager 
+               will be listening on.
+      listening-on/1/  -> each listening interface has one associated directory
+                   2/
+                   .
+                   .
+                   5/iface -> file that contains the interface address
+
+      stop-listen-all -> writing into it terminates listening on all interfaces
+ 
+      stop-listen-one -> writing into it terminates specified listening
+
+      stop -> writing into this stops all listenings, migrates all processes back 
+             and terminates all migration managers.
+ 
+  ----------- T C M I  m i g r a t i o n   m a n a g e r s --------------
+      nodes/1/ -> each registered PEN has a separate directory, maintained
+                  by its migration manager that is in charge of it.
+            2/
+            .
+            .
+            9/connections/ -> all connections of a migration manager
+	                  ctrlconn/ -> control connection
+                                   arch -> contains architecture of the connection
+				   localname -> local socket name (address)
+				   peername -> remote socket name (address)
+	      state - current state of the migration manager
+              load -> average load of the PEN, used for migration decisions
+ 
+  ------------ T C M I  s h a d o w  p r o c e s s e s --------------
+      mig/migproc/1300/ -> similar to /proc, but contains PID's of migrated processes
+                           one directory per process
+                  2001/
+                     .
+                     .    
+                  6547/migman->../../nodes/7 -> a  symbolic link pointing to
+                                                its current  PEN 
+		       remote-pid -> process PID at its current PEN
+  ------------ T C M I  p p m  c o m p o n e n t --------------
+                emigrate-ppm-p -> writing a PID + PEN id pair into this file starts process 
+                            migration to the specified PEN.
+                migrate-home -> allows migrating a specified process back CCN
+  ------------ T C M I  n p m  c o m p o n e n t (not implemented) --------------
+                policy -> interface for the migration policy, the npm component
+                          uses this interface to ask the migration policy for migration
+                          decision.
+ 
+ \endverbatim
+ *
+ * As has been mentioned, the TCMI CCN manager is responsible for PEN registration.
+ * Handling incoming connections and instantiation of new migration managers requires
+ * a separate execution thread. 
+ *
+ * Generally, we assume a limited number of interfaces that the CCN
+ * will be listening on. The core datastructure for keeping track of
+ * listenings is \link tcmi_slotvec_class a slot vector \endlink.
+ *
+ * 
+ *
+ * @{
+ */
+
+/**
+ * A compound structure that holds all current listenings.
+ * This is for internal use only.
+ */
+struct tcmi_ccnman {
+	/** parent class instance. */
+	struct tcmi_man super;
+
+	/** slot container for listings, 1 listening per slot */
+	struct tcmi_slotvec *listenings;
+
+	/** TCMI ctlfs - listen control file */
+	struct tcmi_ctlfs_entry *f_listen;
+	/** TCMI ctlfs - directory for active listenings */
+	struct tcmi_ctlfs_entry *d_listening_on;
+	/** TCMI ctlfs - stop - listen - all control file */
+	struct tcmi_ctlfs_entry *f_stop_listen_all;
+	/** TCMI ctlfs - stop - listen - one control file */
+	struct tcmi_ctlfs_entry *f_stop_listen_one;
+
+	/** TCMI ctlfs - directory for moutner options */
+	struct tcmi_ctlfs_entry *d_mounter;
+	/** TCMI ctlfs - remote mount method. */
+	struct tcmi_ctlfs_entry *f_mount;
+	/** TCMI ctlfs - remote mount device. */
+	struct tcmi_ctlfs_entry *f_mount_device;
+	/** TCMI ctlfs - remote mount options. */
+	struct tcmi_ctlfs_entry *f_mount_options;
+	/** Remote moutn params */
+	struct fs_mount_params mount_params;
+
+	/** Listening thread reference */
+	struct task_struct *thread;
+
+	/** list of sleeper elements for each socket */
+	struct list_head sleepers;
+	/** protects the list from concurrent access */
+	spinlock_t sleepers_lock;
+};
+/** Casts to the CCN manager. */
+#define TCMI_CCNMAN(man) ((struct tcmi_ccnman *)man)
+
+/** \<\<public\>\> Initializes the TCMI CCN manager. */
+extern int tcmi_ccnman_init(struct tcmi_ctlfs_entry *root);
+
+/** \<\<public\>\> Shuts down TCMI CCN manager. */
+extern void tcmi_ccnman_shutdown(void);
+
+/** \<\<public\>\> Getter of mount params structure. */
+extern struct fs_mount_params* tcmi_ccnman_get_mount_params(void);
+
+extern struct tcmi_ccnman* tcmi_ccnman_get_instance(void);
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_CCNMAN_PRIVATE
+
+/** TCMI CCN manager \<\<singleton\>\> instance. */
+static struct tcmi_ccnman self;
+
+/** Initializes TCMI ctlfs directories. */
+static int tcmi_ccnman_init_ctlfs_dirs(void);
+/** Initializes TCMI ctlfs files. */
+static int tcmi_ccnman_init_ctlfs_files(void);
+/** Destroys all TCMI ctlfs directories. */
+static void tcmi_ccnman_stop_ctlfs_dirs(void);
+/** Destroys all TCMI ctlfs files. */
+static void tcmi_ccnman_stop_ctlfs_files(void);
+/** Stops the TCMI CCN manager. */
+static void tcmi_ccnman_stop(void);
+
+
+/** Write method for the TCMI ctlfs - adds new listening. */
+static int tcmi_ccnman_listen(void *obj, void *data);
+
+/** Write method for the TCMI ctlfs - stops all listenings. */
+static int tcmi_ccnman_stop_listen_all(void *obj, void *data);
+
+/** Write method for the TCMI ctlfs - stops a selected listening. */
+static int tcmi_ccnman_stop_listen_one(void *obj, void *data);
+
+
+/** Write method for the TCMI ctlfs - set mount types. */
+static int tcmi_man_set_mount(void *obj, void *data);
+/** Write method for the TCMI ctlfs - set mount device. */
+static int tcmi_man_set_mount_device(void *obj, void *data);
+/** Write method for the TCMI ctlfs - set mount options. */
+static int tcmi_man_set_mount_options(void *obj, void *data);
+
+/** Starts the TCMI CCN manager listening thread. */
+static int tcmi_ccnman_start_thread(void);
+
+/** Stops the TCMI CCN manager listening thread. */
+static void tcmi_ccnman_stop_thread(void);
+
+/** TCMI CCN manager listening thread. */
+static int tcmi_ccnman_thread(void *data);
+
+/** Processes a selected socket, checking for incoming connection. */
+static void tcmi_ccnman_process_sock(struct kkc_sock *);
+
+/** Adds a sleeper to the list. */
+static inline void tcmi_ccnman_add_sleeper(struct kkc_sock_sleeper *);
+
+
+/** Removes sleepers that sleep on the socket. */ 
+static inline void tcmi_ccnman_remove_sleepers(struct tcmi_sock *);
+
+
+/** CCN manager operations that support polymorphism */
+static struct tcmi_man_ops ccnman_ops;
+
+struct tcmi_ccnman* tcmi_ccnman_get_instance(void) {
+	return &self;
+};
+
+#endif /* TCMI_CCNMAN_PRIVATE */
+
+
+/**
+ * @}
+ */
+
+#else
+/** 
+ * Initializes the TCMI PEN manager, stub method when CCN not configured 
+ *
+ * @param *root - root directory of the filesystem, where all entries
+ * are to be created
+ * @return always 0;
+ */
+static inline int tcmi_ccnman_init(struct tcmi_ctlfs_entry *root)
+{
+	return 0;
+}
+
+/** Shuts down TCMI CCN manager, stub method when CCN not configured */
+static inline void tcmi_ccnman_shutdown(void) 
+{
+}
+
+#endif /* CONFIG_TCMI_CCN */
+
+#endif /* _TCMI_CCNMAN_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/manager/tcmi_man.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/manager/tcmi_man.c	2013-03-12 00:26:05.000000000 +0100
@@ -0,0 +1,634 @@
+/**
+ * @file tcmi_man.c - TCMI cluster node manager - a template class
+ *                    that is further implemented by CCN/PEN
+ *                      
+ * 
+ *
+ *
+ * Date: 05/05/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_man.c,v 1.6 2007/10/20 14:24:20 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <linux/types.h>
+#include <linux/random.h>
+#include <linux/kthread.h>
+
+#include <tcmi/ctlfs/tcmi_ctlfs.h>
+#include <tcmi/lib/tcmi_sock.h>
+#include <tcmi/task/tcmi_task.h>
+#include "tcmi_ccnmigman.h"
+
+#include <kkc/kkc.h>
+
+#define TCMI_MAN_PRIVATE
+#include "tcmi_man.h"
+
+#include <dbg.h>
+
+/** maximum number of connected nodes */
+#define MAX_NODES 40
+
+/** 
+ * \<\<public\>\> Initializes the TCMI manager.
+ * This generic init method, initializes basic singleton instance items
+ * common for both TCMI managers (CCN and PEN). The initialization is
+ * done in this order:
+ * - create a slot vector for migration managers
+ * - create TCMI ctlfs directories 
+ * - create TCMI ctlfs control files
+ *
+ *
+ * @param *self - a particular singleton instance to be initialized
+ * @param *root - root directory of the filesystem, where all entries
+ * are to be created
+ * @param *ops - instance specific operations
+ * @param *man_dirname - name for the main directory of the manager (e.g. ccn or pen)
+ * also represent connected nodes (e.g. all PEN's from  CCN prospective)
+ * @return 0 upon success
+ */
+int tcmi_man_init(struct tcmi_man *self,  
+		  struct tcmi_ctlfs_entry *root,
+		  struct tcmi_man_ops *ops,
+		  const char *man_dirname)
+{
+	if (!ops) {
+		mdbg(ERR3, "Missing migration manager operations!");
+		goto exit0;
+	}
+	atomic_set(&self->ready, 0);
+	
+	self->ops = ops;
+
+	if (!(self->mig_mans = tcmi_slotvec_new(MAX_NODES)))
+		goto exit0;
+	if (tcmi_man_init_ctlfs_dirs(self, root, man_dirname) < 0)
+		goto exit1;
+	if (tcmi_man_init_migration(self) < 0)
+		goto exit2;
+	if (tcmi_man_init_ctlfs_files(self) < 0)
+		goto exit3;
+	atomic_set(&self->ready, 1);
+	get_random_bytes(&self->id, sizeof(u_int32_t));
+	return 0;
+		
+	/* error handling */
+ exit3:
+	tcmi_man_stop_migration(self);
+ exit2:
+	tcmi_man_stop_ctlfs_dirs(self);
+ exit1:
+	tcmi_slotvec_put(self->mig_mans);
+ exit0:
+	return -EINVAL;
+}
+
+/**
+ * Waits for all migration managers to terminate.
+ *
+ * Note: We perform wait by active polling of count of remaining migmas (100ms) interval. 
+ * 	 In case there were no remote processes running, there would be no wait as all migmans were terminated synchronously.
+ * 	 In case there were remote processes, the waiting time for their migration back would be likely in order of seconds, so 100ms does not add much latency
+ *	 In case somebody volunteers, the code could be migrated to notify/wait patter to get rid of polling
+ */
+static void tcmi_man_wait_for_migmans_termination(struct tcmi_man *self) {
+	int is_empty;
+	
+	tcmi_slotvec_lock(self->mig_mans);
+	is_empty = tcmi_slotvec_empty(self->mig_mans);
+	tcmi_slotvec_unlock(self->mig_mans);
+		
+	while (!is_empty) {
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(msecs_to_jiffies(100)); 		
+	  
+	  	tcmi_slotvec_lock(self->mig_mans);
+		is_empty = tcmi_slotvec_empty(self->mig_mans);
+		tcmi_slotvec_unlock(self->mig_mans);
+	}
+}
+
+/** 
+ * \<\<public\>\> The manager is shutdown exactly in this order:
+ * - unregister all ctlfs files as we don't want anymore requests 
+ * from users.
+ *
+ * - shutdown the migration framework. This requires terminating all
+ * migration managers(results in termination or migration back of all 
+ * processes)
+ * - unregister all ctlfs directories
+ *
+ * @param *self - a particular manager singleton instance to be shutdown
+ */
+void tcmi_man_shutdown(struct tcmi_man *self)
+{
+	if ( atomic_cmpxchg(&self->ready, 1, 0) == 1 ) {
+		tcmi_man_stop_ctlfs_files(self);
+		tcmi_man_stop_ctlfs_dirs(self);
+		/* Request async mig mans shutdown */
+		tcmi_man_stop_migration(self);
+		/* Wait for migmans to terminate */
+		tcmi_man_wait_for_migmans_termination(self);
+		tcmi_slotvec_put(self->mig_mans);
+	}
+}
+
+static inline int tcmi_man_do_send_generic_user_message(struct tcmi_man *self, int target_slot_index, int user_data_size, char* user_data, struct tcmi_migman *migman) {
+	int err = 0;
+	struct tcmi_msg* msg;
+
+	// TODO: Node id is passed incorrectly, but on the other hand this node id is complete bullshit and should be likely removed, right?
+	if ( !( msg = TCMI_MSG(tcmi_generic_user_msg_new_tx(self->id, user_data, user_data_size)) ) ) { 
+		mdbg(ERR3, "Error creating response message");
+		return - ENOMEM;		;
+	}
+	if ((err = tcmi_msg_send_anonymous(msg, tcmi_migman_sock(migman)))) {
+		mdbg(ERR3, "Error sending user message %d", err);
+		err = -EINVAL;
+	}
+	tcmi_msg_put(msg);
+
+	return err;
+}
+
+int tcmi_man_send_generic_user_message(struct tcmi_man *self, int target_slot_index, int user_data_size, char* user_data) {
+	int err;
+	struct tcmi_slot *slot;
+	struct tcmi_migman *migman = NULL;
+
+	/* lookup the migration manager first */
+	tcmi_slotvec_lock(self->mig_mans);
+	if (!(slot = tcmi_slotvec_at(self->mig_mans, target_slot_index))) {
+		mdbg(ERR3, "Invalid migration manager identifier %d", target_slot_index);
+		err = -ENOENT;
+		goto exit0;
+	}
+	/* there is always only one mig man per slot */
+	tcmi_slot_find_first(migman, slot, node);
+	/* Slot might exist, but it might still be empty*/
+	if (!tcmi_migman_get(migman)) {
+		mdbg(ERR3, "No migration manager in the slot(%d)", tcmi_slot_index(slot));
+		err = -ENOENT;
+		goto exit0;
+	}
+	tcmi_slotvec_unlock(self->mig_mans);
+
+	err = tcmi_man_do_send_generic_user_message(self, target_slot_index, user_data_size, user_data, migman);
+
+	/* release the migration manager */
+	tcmi_migman_put(migman);
+
+	return err;
+
+	/* error handling */
+ exit0:
+	tcmi_slotvec_unlock(self->mig_mans);
+	return err;
+}
+
+/** @addtogroup tcmi_man_class
+ *
+ * @{
+ */
+
+
+/** 
+ * \<\<private\>\> Creates the directories as described in \link
+ * tcmi_man_class here \endlink. It is necessary to get the current
+ * root directory of the TCMI ctlfs first. So that it won't get
+ * unlinked under us.
+ *
+ * @param *self - a particular manager singleton instance
+ * @param *root - root directory of the filesystem, where all entries
+ * are to be created
+ * @param *man_dirname - name for the main directory of the manager (e.g. ccn or pen)
+ * @return 0 upon success
+ */
+
+static int tcmi_man_init_ctlfs_dirs(struct tcmi_man *self,  
+				    struct tcmi_ctlfs_entry *root,
+				    const char *man_dirname)
+{
+	mdbg(INFO4, "Creating directories");
+	if (!root)
+		goto exit0;
+
+	if (!(self->d_man = tcmi_ctlfs_dir_new(root, TCMI_PERMS_DIR, man_dirname)))
+		goto exit0;
+
+	if (!(self->d_nodes = 
+	      tcmi_ctlfs_dir_new(self->d_man, TCMI_PERMS_DIR, "nodes")))
+		goto exit1;
+
+	if (!(self->d_mig = 
+	      tcmi_ctlfs_dir_new(self->d_man, TCMI_PERMS_DIR, "mig")))
+		goto exit2;
+
+	if (!(self->d_migproc = 
+	      tcmi_ctlfs_dir_new(self->d_mig, TCMI_PERMS_DIR, "migproc")))
+		goto exit3;
+
+	if (self->ops->init_ctlfs_dirs && self->ops->init_ctlfs_dirs()) {
+		mdbg(ERR3, "Failed to create specific ctlfs directories!");
+		goto exit4;
+	}
+	return 0;
+
+	/* error handling */
+ exit4:
+	tcmi_ctlfs_entry_put(self->d_migproc);
+ exit3:
+	tcmi_ctlfs_entry_put(self->d_mig);
+ exit2:
+	tcmi_ctlfs_entry_put(self->d_nodes);
+ exit1:
+	tcmi_ctlfs_entry_put(self->d_man);
+ exit0:
+	return -EINVAL;
+
+}
+/** 
+ * \<\<private\>\> Creates the static files 
+ * described \link tcmi_man_class here \endlink. 
+ *
+ * @param *self - a particular manager singleton instance
+ * @return 0 upon success
+ */
+static int tcmi_man_init_ctlfs_files(struct tcmi_man *self)
+{
+	mdbg(INFO4, "Creating files");
+
+	if (!(self->f_stop = 
+	      tcmi_ctlfs_intfile_new(self->d_man, TCMI_PERMS_FILE_W,
+				     self, NULL, tcmi_man_stop,
+				     sizeof(int), "stop")))
+		goto exit0;
+
+	if (!(self->f_emig_ppm_p = 
+	      tcmi_ctlfs_intfile_new(self->d_mig, TCMI_PERMS_FILE_W,
+				     self, NULL, tcmi_man_emig_ppm_p,
+				     sizeof(int) * 2, "emigrate-ppm-p")))
+		goto exit1;
+	if (!(self->f_mig_home_ppm_p = 
+	      tcmi_ctlfs_intfile_new(self->d_mig, TCMI_PERMS_FILE_W,
+				     self, NULL, tcmi_man_mig_home_ppm_p,
+				     sizeof(int), "migrate-home")))
+		goto exit2;
+	if (self->ops->init_ctlfs_files && self->ops->init_ctlfs_files()) {
+		mdbg(ERR3, "Failed to create specific ctlfs files!");
+		goto exit3;
+	}
+	return 0;
+
+
+	/* error handling */
+ exit3:
+	tcmi_ctlfs_file_unregister(self->f_mig_home_ppm_p);
+	tcmi_ctlfs_entry_put(self->f_mig_home_ppm_p);
+ exit2:
+	tcmi_ctlfs_file_unregister(self->f_emig_ppm_p);
+	tcmi_ctlfs_entry_put(self->f_emig_ppm_p);
+ exit1:
+	tcmi_ctlfs_file_unregister(self->f_stop);
+	tcmi_ctlfs_entry_put(self->f_stop);
+ exit0:
+	return -EINVAL;
+
+}
+
+/** 
+ * \<\<private\>\> Destroys all ctlfs directories, first
+ * the singleton instance specific directories are destroyed
+ *
+ * @param *self - a particular manager singleton instance
+ */
+static void tcmi_man_stop_ctlfs_dirs(struct tcmi_man *self)
+{
+	mdbg(INFO3, "Destroying  TCMI manager ctlfs directories");
+
+	if (self->ops->stop_ctlfs_dirs) 
+		self->ops->stop_ctlfs_dirs();
+	tcmi_ctlfs_entry_put(self->d_migproc);
+	tcmi_ctlfs_entry_put(self->d_mig);
+	tcmi_ctlfs_entry_put(self->d_nodes);
+	tcmi_ctlfs_entry_put(self->d_man);
+}
+
+/** 
+ *\<\<private\>\>  Unregisters and releases all control files.
+ *
+ * @param *self - a particular manager singleton instance
+ */
+static void tcmi_man_stop_ctlfs_files(struct tcmi_man *self)
+{
+	mdbg(INFO3, "Destroying  TCMI manager ctlfs files");
+
+	if (self->ops->stop_ctlfs_files) 
+		self->ops->stop_ctlfs_files();
+
+	tcmi_ctlfs_file_unregister(self->f_stop);
+	tcmi_ctlfs_entry_put(self->f_stop);
+
+	tcmi_ctlfs_file_unregister(self->f_emig_ppm_p);
+	tcmi_ctlfs_entry_put(self->f_emig_ppm_p);
+
+	tcmi_ctlfs_file_unregister(self->f_mig_home_ppm_p);
+	tcmi_ctlfs_entry_put(self->f_mig_home_ppm_p);
+}
+
+/** 
+ * <\<private\>\>.
+ *
+ * @param *self - a particular manager singleton instance
+ * @return 0 upon success
+ */
+static int tcmi_man_init_migration(struct tcmi_man *self)
+{
+	mdbg(INFO3, "Initializing migration components");
+	return 0;
+}
+
+
+/** Finds and returns arbitrary migration manager that is either in INIT or CONNECTED state. */
+static struct tcmi_migman * tcmi_man_get_non_shutdowning_migman(struct tcmi_man *self) {
+    struct tcmi_slot *slot;
+    tcmi_slot_node_t* node;
+    struct tcmi_migman *migman = NULL;
+    tcmi_migman_state_t migman_state;
+
+    tcmi_slotvec_lock(self->mig_mans);
+    
+    tcmi_slotvec_for_each_used_slot(slot, self->mig_mans) {
+	    tcmi_slot_for_each(node, slot) {		    
+		    migman = tcmi_slot_entry(node, struct tcmi_migman, node);
+		    migman_state = tcmi_migman_state(migman);
+		   
+		    if ( migman_state == TCMI_MIGMAN_INIT || migman_state == TCMI_MIGMAN_CONNECTED ) {
+			goto found;		    
+		    }		   
+		    migman = NULL;
+	    };
+    };
+    
+found:    
+    tcmi_slotvec_unlock(self->mig_mans);   
+    return migman;
+}
+
+/**
+ * \<\<private\>\> Stops all migration components.  Terminates all
+ * migration managers, they are responsible for migrating all
+ * processes to the home node or a another execution node.
+ *
+ * @param *self - a particular manager singleton instance
+ */
+static void tcmi_man_stop_migration(struct tcmi_man *self)
+{
+	struct tcmi_migman *migman = tcmi_man_get_non_shutdowning_migman(self);
+	while (migman) {	  
+		mdbg(INFO3, "Requesting migration manager shutdown.");
+		tcmi_migman_stop(migman);
+		
+		migman = tcmi_man_get_non_shutdowning_migman(self);
+	}
+}
+
+/**
+ * \<\<private\>\> If the user called this method with parameter > 0,
+ * the TCMI manager stops the migration
+ * framework.  This results in migrating all processes back to CCN and
+ * terminating all migration managers.
+ *
+ * @param *obj - pointer to a particular TCMI manager singleton instance
+ * @param *data - if the value that it points to is >0, the action is 
+ * taken
+ * @return always 0 (success)
+ *
+ * NOTE: What is a purpose of this method? There is no inverse operation to stop, so is that essentially different from shutdown? ms
+ */
+static int tcmi_man_stop(void *obj, void *data)
+{  
+	int stop = *((int *)data);
+	struct tcmi_man *self = TCMI_MAN(obj);
+
+	mdbg(INFO3, "TCMI manager stop request, action = %d", stop);
+	if (stop) {
+		/* TODO: Stop operations are called just here, but shouldn't we call them as well on shutdown? */
+		if (self->ops->stop) 
+			self->ops->stop();
+		tcmi_man_stop_migration(self);
+	}
+	return 0;
+}
+
+/** 
+ * \<\<private\>\> TCMI ctlfs write method - emigration PPM P 
+ * What needs to be done: 
+ * - find the requested migration manager
+ * - call instance specific emigration method.
+ *
+ * @param *obj - pointer to a particular TCMI manager singleton instance
+ * @param *data - an array of two integers first contains PID, second
+ * one contains the desired manager identifier as it appears in 
+ * ctlfs. It is the name of its directory.
+ * @return 0 upon success
+ */
+static int tcmi_man_emig_ppm_p(void *obj, void *data)
+{
+	int err = 0;
+	pid_t pid = *((int *)data);
+	u_int32_t migman_id = *(((int *)data) + 1);
+	struct tcmi_man *self = TCMI_MAN(obj);
+	struct tcmi_slot *slot;
+	struct tcmi_migman *migman = NULL;
+
+	
+	mdbg(INFO2, "Emigration request PID %d, migration manager %d", 
+	     pid, migman_id);
+	
+	/* lookup the migration manager first */
+	tcmi_slotvec_lock(self->mig_mans);
+	if (!(slot = tcmi_slotvec_at(self->mig_mans, migman_id))) {
+		mdbg(ERR3, "Invalid migration manager identifier %d", migman_id);
+		goto exit0;
+	}
+	/* there is always only one mig man per slot */
+	tcmi_slot_find_first(migman, slot, node);
+	/* Slot might exist, but it might still be empty*/
+	if (!tcmi_migman_get(migman)) {
+		mdbg(ERR3, "No migration manager in the slot(%d)", tcmi_slot_index(slot));
+		goto exit0;
+	}
+	tcmi_slotvec_unlock(self->mig_mans);
+
+	if (self->ops->emigrate_ppm_p)
+		err = self->ops->emigrate_ppm_p(pid, migman);
+
+	/* release the migration manager */
+	tcmi_migman_put(migman);
+
+	return err;
+
+	/* error handling */
+ exit0:
+	tcmi_slotvec_unlock(self->mig_mans);
+	return -EINVAL;
+}
+
+/** 
+ * \<\<public\>\> Method that performs non-preemtive migration  
+ *
+ * @param pid Pid of the process to be migrated
+ * @param migman_id Id of the migration manager to be used for the migration
+ * @param npm_params Params of the non-preemptive migration
+ */
+int tcmi_man_emig_npm(struct tcmi_man *self, pid_t pid, u_int32_t migman_id, struct pt_regs* regs, struct tcmi_npm_params* npm_params)
+{
+	int err = 0;
+	struct tcmi_slot *slot;
+	struct tcmi_migman *migman = NULL;
+	
+	mdbg(INFO2, "Non preemptive emigration request PID %d, migration manager %d", 
+	     pid, migman_id);
+	
+	/* lookup the migration manager first */
+	tcmi_slotvec_lock(self->mig_mans);
+	if (!(slot = tcmi_slotvec_at(self->mig_mans, migman_id))) {
+		mdbg(ERR3, "Invalid migration manager identifier %d", migman_id);
+		goto exit0;
+	}
+	/* there is always only one mig man per slot */
+	tcmi_slot_find_first(migman, slot, node);
+	/* Slot might exist, but it might still be empty*/
+	if (!tcmi_migman_get(migman)) {
+		mdbg(ERR3, "No migration manager in the slot(%d)", tcmi_slot_index(slot));
+		goto exit0;
+	}
+	tcmi_slotvec_unlock(self->mig_mans);
+
+	if (self->ops->emigrate_npm)
+		err = self->ops->emigrate_npm(pid, migman, regs, npm_params);
+
+	/* release the migration manager */
+	tcmi_migman_put(migman);
+
+	return err;
+
+	/* error handling */
+ exit0:
+	tcmi_slotvec_unlock(self->mig_mans);
+	return -EINVAL;
+}
+
+int tcmi_man_fork(struct tcmi_man *self, struct task_struct* parent, struct task_struct* child) {
+	int err = 0;
+	struct tcmi_slot *slot;
+	struct tcmi_migman *migman = NULL;
+	u_int migman_slot_index;
+	struct tcmi_task* tcmi_parent;
+	unsigned long flags = 0;         //Set flags to 0 for remove warning 
+
+	// We perform all manager fork operation with interrupts disabled to prevent possible lock inversion problems
+	// Not sure what the intention was, but it does not work well.. interfere with getinode on ccfs initialization 
+	// (there are actually more interferences and we ideally need to get rid of getinode in this call chain altoghether)
+//	raw_local_irq_save(flags);
+
+	tcmi_parent = TCMI_TASK(parent->tcmi.tcmi_task);
+	migman_slot_index = tcmi_task_migman_slot_index(tcmi_parent);
+
+	BUG_ON(parent->tcmi.task_type != shadow && parent->tcmi.task_type != guest);
+	BUG_ON(tcmi_parent->migman->ccn_id != self->id && tcmi_parent->migman->pen_id != self->id);
+
+	mdbg(INFO2, "Performing fork of task pid: %d to child: %d (mig manager %u)", parent->pid, child->pid, migman_slot_index);
+
+	if ( child->tcmi.tcmi_task != parent->tcmi.tcmi_task ) { // This should hold, since the task struts were simply copied		
+		mdbg(ERR3, "Assertion error! Tasks after fork should have same tcmi task");
+		return -EINVAL;
+	}
+
+	// We've verified the task is really copied and now we need to prepare it to be attached.. for that we need to reset its TCMI structures first
+	child->tcmi.tcmi_task = NULL;
+	child->tcmi.mig_mode_handler = NULL;
+	
+	/* lookup the migration manager first */
+	tcmi_slotvec_lock(self->mig_mans);
+	if (!(slot = tcmi_slotvec_at(self->mig_mans, migman_slot_index))) {
+		mdbg(ERR3, "Invalid migration manager identifier %lu", (unsigned long)migman_slot_index);
+		goto exit0;
+	}
+	/* there is always only one mig man per slot */
+	tcmi_slot_find_first(migman, slot, node);
+	/* Slot might exist, but it might still be empty*/
+	if (!tcmi_migman_get(migman)) {
+		mdbg(ERR3, "No migration manager in the slot(%d)", tcmi_slot_index(slot));
+		goto exit0;
+	}
+	tcmi_slotvec_unlock(self->mig_mans);
+
+	
+	if (self->ops->fork)
+		err = self->ops->fork(parent, child, migman);
+
+//	raw_local_irq_restore(flags);
+	/* release the migration manager, task has now its own reference to it */
+	tcmi_migman_put(migman);	
+
+	return err;
+
+	/* error handling */
+exit0:
+	raw_local_irq_restore(flags);
+	tcmi_slotvec_unlock(self->mig_mans);
+	return -EINVAL;
+}
+
+/** 
+ * \<\<private\>\> TCMI ctlfs write method - migration home.
+ *
+ * Migration home requires delegating work to the instance specific method
+ * once we extract the requested PID.
+
+ * @param *obj - pointer to a particular TCMI manager singleton instance
+ * @param *data - contains PID that is to be migrated home
+ * @return 0 upon success
+ */
+static int tcmi_man_mig_home_ppm_p(void *obj, void *data)
+{
+	int err = 0;
+	pid_t pid = *((int *)data);
+	struct tcmi_man *self = TCMI_MAN(obj);
+	
+	mdbg(INFO2, "Migration home request for PID %d", pid);
+	
+
+	if (self->ops->migrate_home_ppm_p)
+		err = self->ops->migrate_home_ppm_p(pid);
+
+	return err;
+}
+
+
+/**
+ * @}
+ */
+
+
--- linux-3.7.1_original/clondike/src/tcmi/manager/tcmi_penman.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/manager/tcmi_penman.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,286 @@
+/**
+ * @file tcmi_penman.c - Implementation of TCMI cluster process execution
+ *                       manager - a class that controls the process
+ *                       execution node
+ *                      
+ * 
+ *
+ *
+ * Date: 04/17/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_penman.c,v 1.5 2009-04-06 21:48:46 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include <linux/kthread.h>
+
+#include <tcmi/migration/tcmi_migcom.h>
+#include <tcmi/ctlfs/tcmi_ctlfs.h>
+#include "tcmi_penmigman.h"
+
+#include <tcmi/task/tcmi_task.h>
+#include <tcmi/task/tcmi_taskhelper.h>
+#include <tcmi/migration/tcmi_npm_params.h>
+#include <kkc/kkc.h>
+
+#define TCMI_PENMAN_PRIVATE
+#include "tcmi_penman.h"
+
+#include <dbg.h>
+
+/**
+ * \<\<public\>\> Singleton instance initializer.
+ * The initialization is accomplished exactly in this order:
+ * - delegate rest of initialization to TCMI generic manager
+ *
+ * @param *root - root directory of the filesystem, where all entries
+ * are to be created
+ * @return 0 upon success
+ */
+int tcmi_penman_init(struct tcmi_ctlfs_entry *root)
+{
+	minfo(INFO1, "Initializing TCMI PEN manager");
+
+	if (tcmi_man_init(TCMI_MAN(&self), root, &penman_ops, "pen") < 0) {
+		mdbg(ERR3, "TCMI PEN manager - generic init failed");
+		goto exit0;
+	}
+	return 0;
+		
+	/* error handling */
+ exit0:
+	return -EINVAL;
+}
+
+/** 
+ * \<\<public\>\> The manager is shutdown exactly in this order:
+ * - unregister all ctlfs files as we don't want anymore requests 
+ * from users.
+ * - shutdown the migration framework. This includes
+ * migrating all processes back and terminating all migration managers
+ * - unregister all ctlfs directories
+ *
+ */
+void tcmi_penman_shutdown(void)
+{
+	minfo(INFO1, "Shutting down the TCMI PEN manager");
+
+	tcmi_man_shutdown(TCMI_MAN(&self));
+}
+
+
+/** @addtogroup tcmi_penman_class
+ *
+ * @{
+ */
+
+
+/** 
+ * \<\<private\>\> Creates the static files 
+ * described \link tcmi_penman_class here \endlink. 
+ *
+ * @return 0 upon success
+ */
+static int tcmi_penman_init_ctlfs_files(void)
+{
+	mdbg(INFO4, "Creating files");
+	if (!(self.f_connect = 
+	      tcmi_ctlfs_strfile_new(tcmi_man_root(TCMI_MAN(&self)), TCMI_PERMS_FILE_W,
+				     NULL, NULL, tcmi_penman_connect,
+				     KKC_MAX_WHERE_LENGTH, "connect")))
+		goto exit0;
+	return 0;
+
+	/* error handling */
+ exit0:
+	return -EINVAL;
+
+}
+
+
+/** 
+ *\<\<private\>\> Unregisters all control files.
+ */
+static void tcmi_penman_stop_ctlfs_files(void)
+{
+	mdbg(INFO3, "Destroying  TCMI PEN manager ctlfs files");
+
+	tcmi_ctlfs_file_unregister(self.f_connect);
+	tcmi_ctlfs_entry_put(self.f_connect);
+}
+
+/**
+ * @return 1, if there is a duplicate address for some of the peers
+ */
+static int check_duplicates(const char* address, int address_len) {
+    int ret = 0;
+    struct tcmi_slot *slot;
+    tcmi_slot_node_t* node;
+    struct tcmi_migman *migman = NULL;    
+    tcmi_slotvec_lock(TCMI_MAN(&self)->mig_mans);
+    
+    tcmi_slotvec_for_each_used_slot(slot, TCMI_MAN(&self)->mig_mans) {
+	    tcmi_slot_for_each(node, slot) {		    
+		    migman = tcmi_slot_entry(node, struct tcmi_migman, node);		    		    		    		    
+		    
+		    if ( kkc_sock_is_address_equal_to(tcmi_migman_sock(migman),address,address_len, 1) ) {
+			ret = 1;
+			goto found;		    
+		    }		   
+	    };
+    };
+    
+found:    
+    tcmi_slotvec_unlock(TCMI_MAN(&self)->mig_mans);
+    return ret;
+}
+
+/**
+ * \<\<private\>\> Creates a new connection and instantiates a new
+ * migration manager that will be responsible for handling it.
+ *
+ * @param *obj - pointer to an object - NULL is expected as
+ * TCMI PEN manager is a singleton class.
+ * @param *str - connection string - It is architecture dependent
+ * and passed further on tcmi_listen class. "@" char is used to separate address of the remote node and optional authentication data
+ * @return 0 upon success
+ */
+static int tcmi_penman_connect(void *obj, void *str)
+{
+	int err, separation_index, auth_data_size = 0; 
+	char *connect_str = (char *) str;
+	char *auth_data = NULL;
+	char *separation_char = NULL;
+	struct tcmi_migman *migman;
+	struct tcmi_slot *slot;
+	struct kkc_sock *sock;
+
+	mdbg(INFO3, "Connection request with param: %s", connect_str);
+
+	// @ serves as a special separator of "node address" from "authentication data
+	if ( (separation_char=strchr(connect_str, '@')) != NULL ) {
+		separation_index = separation_char - connect_str;
+		// TODO: Here we use strlen on auth data length calculation, which means we loose a capability of passing pure binary data.. improve it if possible
+		auth_data_size = strlen(connect_str) - separation_index - 1;
+		// We separate the string by zero so that it is internally threated as a short string for kkc soct
+		connect_str[separation_index] = '\0';
+		auth_data = connect_str + separation_index + 1;
+	}			
+	
+	if ( check_duplicates(connect_str, strlen(connect_str)) ) {
+	    mdbg(ERR3, "Duplicate peer, already connected:'%s' ", connect_str);
+	    goto exit0;
+	}
+	  
+
+	/* check if there is incoming connection */
+	if (kkc_connect(&sock, connect_str)) {
+		mdbg(ERR3, "Failed connecting to '%s' ", connect_str);
+		goto exit0;
+	}
+	mdbg(INFO3, "Connected to local: '%s', remote: '%s', auth_data_size: %d", 
+	     kkc_sock_getsockname2(sock), kkc_sock_getpeername2(sock), auth_data_size);
+	/* Reserve an empty slot */
+	if (!(slot = tcmi_man_reserve_migmanslot(TCMI_MAN(&self)))) {
+		mdbg(ERR3, "Failed allocating an empty slot for PEN migman"); 
+		goto exit1;
+	}
+
+	/* Accept the first incoming connection */
+	if (!(migman = tcmi_penmigman_new(sock, 
+					  tcmi_man_id(TCMI_MAN(&self)),
+					  slot,
+					  tcmi_man_nodes_dir(TCMI_MAN(&self)), 					  
+					  tcmi_man_migproc_dir(TCMI_MAN(&self)),
+					  "%d", tcmi_slot_index(slot)))) {
+		minfo(ERR1, "Failed to instantiate the PEN migration manager"); 
+		goto exit2;
+	}
+	
+	if ((err = tcmi_penmigman_auth_ccn(TCMI_PENMIGMAN(migman), auth_data_size, auth_data)) < 0) {
+		minfo(ERR1, "Failed to authenticate the CCN! %d", err); 
+		goto exit3;
+	}
+	tcmi_slot_insert(slot, tcmi_migman_node(migman));
+
+	kkc_sock_put(sock);
+
+	return 0;
+/* error handling */
+ exit3:
+	tcmi_migman_put(migman);
+ exit2:
+	tcmi_man_release_migmanslot(TCMI_MAN(&self), slot); 
+ exit1:
+	kkc_sock_put(sock);
+ exit0:
+	return -EINVAL;
+}
+
+
+/**
+ * \<\<private\>\> Stops the PEN manager.
+ *
+ */
+static void tcmi_penman_stop(void)
+{
+	/* Nothing to be done for now.. */
+}
+
+/**
+ * Performs non-preemtive migration back from PEN.
+ * Operates on "current" task
+ */
+int tcmi_penman_migrateback_npm(struct tcmi_man *self, struct pt_regs* regs, struct tcmi_npm_params* npm_params) {
+	struct tcmi_task* task = current->tcmi.tcmi_task;
+
+	BUG_ON(current->tcmi.tcmi_task == NULL);
+	BUG_ON(current->tcmi.task_type != guest);
+
+	// Submits task specific method for performing npm migback
+	tcmi_task_submit_method(task, tcmi_task_migrateback_npm, npm_params, sizeof(*npm_params));
+	// And enter directly to migmide as we are already in the task context
+	tcmi_taskhelper_do_mig_mode(regs);
+
+	return 0;
+}
+
+/** Singleton instance pre-initialization */
+static struct tcmi_penman self = {
+	.f_connect = NULL,
+};
+
+
+/** Migration manager operations that support polymorphism */
+static struct tcmi_man_ops penman_ops = {
+	.init_ctlfs_files = tcmi_penman_init_ctlfs_files, 
+	.stop_ctlfs_files = tcmi_penman_stop_ctlfs_files,
+	.stop = tcmi_penman_stop,
+	.migrate_home_ppm_p = tcmi_migcom_migrate_home_ppm_p,
+	.fork = tcmi_migcom_guest_fork,
+};
+
+/**
+ * @}
+ */
+
+
--- linux-3.7.1_original/clondike/src/tcmi/manager/tcmi_man.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/manager/tcmi_man.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,283 @@
+/**
+ * @file tcmi_man.h - TCMI cluster node manager - a template class
+ *                    that is further implemented by CCN/PEN
+ *                      
+ * 
+ *
+ *
+ * Date: 05/05/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_man.h,v 1.6 2007/10/20 14:24:20 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_MAN_H
+#define _TCMI_MAN_H
+
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/list.h>
+#include <linux/types.h>
+
+#include <tcmi/manager/tcmi_migman.h>
+#include <tcmi/lib/tcmi_slotvec.h>
+#include <tcmi/ctlfs/tcmi_ctlfs_dir.h>
+#include <tcmi/ctlfs/tcmi_ctlfs_file.h>
+
+struct tcmi_npm_params;
+
+/** @defgroup tcmi_man_class tcmi_man class 
+ *
+ * @ingroup tcmi_managers_group
+ * 
+ * This template \<\<singleton\>\> class implements a generic cluster
+ * node manager - TCMI manager. It provides generic functionality to control
+ * migration managers. 
+ *
+ * Each migration manager is associated with one registered PEN. The
+ * user controls the cluster node(PEN,CCN or both) by manipulating
+ * \link tcmi_ctlfs.c TCMI control file system \endlink. The
+ * directory/file layout can be divided into three groups of
+ * files/directories based on their maintainers, which can be:
+ *
+ * - TCMI manager
+ * - TCMI migration manager
+ * - TCMI preemptive migration component
+ * - TCMI non-preemtive migration component
+ * - TCMI tasks
+ *
+ *
+ * Description of a particular layout is detailed at \link
+ * tcmi_ccnman_class TCMI CCN manager \endlink and \link
+ * tcmi_penman_class TCMI PEN manager \endlink
+ *
+ *
+ * There is an upper bound on the number of registered nodes. This is
+ * a very common approach in UNIX design as it prevents problems with
+ * overloading the CCN. This parameter is currently set at compile
+ * time.  but might be made configurable via ctlfs from user space.
+ *
+ * The core datastructure for keeping track of migration
+ * managers(=registered cluster nodes) is \link tcmi_slotvec_class a
+ * slot vector \endlink.
+ *
+ * The TCMI manager carries a unique identifier that is generated
+ * randomly upon initialization. This ID then identifies a node in
+ * cluster.
+ *
+ * @{
+ */
+
+/**
+ * A compound structure that holds all current listenings and migration managers.
+ * This is for internal use only.
+ */
+struct tcmi_man {
+	/** indicates the manager is ready - used for proper shutdown */
+	atomic_t ready;
+
+	/** slot container for migration managers, 1 manager per slot */
+	struct tcmi_slotvec *mig_mans;
+
+
+	/** root directory of CCN or PEN where all control
+	 * files/directories reside */
+	struct tcmi_ctlfs_entry *d_man;
+	/** directory where all registered nodes (CCN's or PEN's) reside */
+	struct tcmi_ctlfs_entry *d_nodes;
+
+	/** TCMI ctlfs - migration directory */
+	struct tcmi_ctlfs_entry *d_mig;
+
+	/** TCMI ctlfs - migproc directory for migrated processes */
+	struct tcmi_ctlfs_entry *d_migproc;
+
+	/** TCMI ctlfs - stop control file */
+	struct tcmi_ctlfs_entry *f_stop;
+
+	/** TCMI ctlfs - migration control file (PPM physical ckpt.) */
+	struct tcmi_ctlfs_entry *f_emig_ppm_p;
+
+	/** TCMI ctlfs - migration control file (PPM physical ckpt.) */
+	struct tcmi_ctlfs_entry *f_mig_home_ppm_p;
+
+	/** Unique manager ID. */
+	u_int32_t id;
+
+	/** Operations specific to a CCN/PEN manager resp. */
+	struct tcmi_man_ops *ops;
+};
+/** Migration manager operations that support polymorphism */
+struct tcmi_man_ops {
+	/** Initializes TCMI ctlfs directories. */
+	int (*init_ctlfs_dirs)(void);
+	/** Initializes TCMI ctlfs files. */
+	int (*init_ctlfs_files)(void);
+	/** Destroys all TCMI ctlfs directories. */
+	void (*stop_ctlfs_dirs)(void);
+	/** Destroys all TCMI ctlfs files. */
+	void (*stop_ctlfs_files)(void);
+	/** Preemptive emigration method. */
+	int (*emigrate_ppm_p)(pid_t, struct tcmi_migman*);
+	/** Non-preemptive emigration method. */
+	int (*emigrate_npm)(pid_t, struct tcmi_migman*, struct pt_regs* regs, struct tcmi_npm_params*);
+	/** Migrate home method. */
+	int (*migrate_home_ppm_p)(pid_t);	
+	/** Transforms forked process to a same type of task as parent and assigns it with a same manager. */
+	int (*fork)(struct task_struct* parent, struct task_struct* child, struct tcmi_migman*);
+
+	/** Instance specific stop method. */
+	void (*stop)(void);
+};
+
+/** Casts to the TCMI manager. */
+#define TCMI_MAN(man) ((struct tcmi_man *)man)
+
+
+/** \<\<public\>\> Initializes the TCMI manager */
+extern int tcmi_man_init(struct tcmi_man *self,  
+			 struct tcmi_ctlfs_entry *root,
+			 struct tcmi_man_ops *ops,
+			 const char *man_dirname);
+
+/** \<\<public\>\> Shuts down TCMI manager */
+extern void tcmi_man_shutdown(struct tcmi_man *self);
+
+/** \<\<public\>\> Send generic user message */
+extern int tcmi_man_send_generic_user_message(struct tcmi_man *self, int target_slot_index, int user_data_size, char* user_data);
+
+/**
+ * \<\<public\>\> Reserves an empty slot for a new migration manager.
+ *
+ * @param *self - a particular manager singleton instance
+ * @return an empty slot(if available) or NULL
+ */
+static inline struct tcmi_slot* tcmi_man_reserve_migmanslot(struct tcmi_man *self)
+{
+	return tcmi_slotvec_reserve_empty(self->mig_mans);
+}
+
+
+/**
+ * \<\<public\>\> Releases a migration slot that has been previously
+ * reserved.  It is needed when new migration manager fails and won't
+ * inserted into the slot. The user that returns the slot back to the
+ * vector.
+ *
+ * @param *self - a particular manager singleton instance
+ * @param *slot thatis to be release back to the vector
+ */
+static inline void tcmi_man_release_migmanslot(struct tcmi_man *self, 
+					       struct tcmi_slot *slot)
+{
+	tcmi_slot_move_unused(slot); 
+}
+
+/**
+ * \<\<public\>\> Accessor for a main(root) directory of a particular
+ * TCMI manager.
+ *
+ * @param *self - a particular manager singleton instance
+ * @return main manager directory
+ */
+static inline struct tcmi_ctlfs_entry* tcmi_man_root(struct tcmi_man *self)
+{
+	return self->d_man;
+}
+
+/**
+ * \<\<public\>\> Accessor for a cluster nodes directory of a
+ * particular TCMI manager.
+ *
+ * @param *self - a particular manager singleton instance
+ * @return nodesdirectory
+ */
+static inline struct tcmi_ctlfs_entry* tcmi_man_nodes_dir(struct tcmi_man *self)
+{
+	return self->d_nodes;
+}
+
+/**
+ * \<\<public\>\> Accessor for migproc directory.
+ *
+ * @param *self - a particular manager singleton instance
+ * @return migproc directory
+ */
+static inline struct tcmi_ctlfs_entry* tcmi_man_migproc_dir(struct tcmi_man *self)
+{
+	return self->d_migproc;
+}
+
+/**
+ * \<\<public\>\> TCMI manager ID accessor.
+ *
+ * @param *self - a particular manager singleton instance
+ * @return manager ID
+ */
+static inline u_int32_t tcmi_man_id(struct tcmi_man *self)
+{
+	return self->id;
+}
+
+/** \<\<public\>\> Method that performs non-preemtive migration  */
+extern int tcmi_man_emig_npm(struct tcmi_man *self, pid_t pid, u_int32_t migman_id, struct pt_regs* regs, struct tcmi_npm_params* npm_params);
+
+/** \<\<public\>\> Method that performs task fork */
+extern int tcmi_man_fork(struct tcmi_man *self, struct task_struct* parent, struct task_struct* child);
+
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_MAN_PRIVATE
+
+/** Initializes TCMI ctlfs directories. */
+static int tcmi_man_init_ctlfs_dirs(struct tcmi_man *self,
+				    struct tcmi_ctlfs_entry *root,
+				    const char *man_dirname);
+/** Initializes TCMI ctlfs files. */
+static int tcmi_man_init_ctlfs_files(struct tcmi_man *self);
+
+/** Destroys all TCMI ctlfs directories. */
+static void tcmi_man_stop_ctlfs_dirs(struct tcmi_man *self);
+/** Destroys all TCMI ctlfs files. */
+static void tcmi_man_stop_ctlfs_files(struct tcmi_man *self);
+
+/** Initializes the migration components. */
+static int tcmi_man_init_migration(struct tcmi_man *self);
+/** Stops the migration components. */
+static void tcmi_man_stop_migration(struct tcmi_man *self);
+
+/** TCMI ctlfs write method - stops the manager. */
+static int tcmi_man_stop(void *obj, void *data);
+
+/** TCMI ctlfs write method - emigration PPM P */
+static int tcmi_man_emig_ppm_p(void *obj, void *data);
+/** TCMI ctlfs write method - migration home */
+static int tcmi_man_mig_home_ppm_p(void *obj, void *data);
+
+#endif /* TCMI_MAN_PRIVATE */
+
+
+/**
+ * @}
+ */
+
+
+#endif /* _TCMI_MAN_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/manager/tcmi_penmigman.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/manager/tcmi_penmigman.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,117 @@
+/**
+ * @file tcmi_penmigman.h - TCMI cluster core node manager - a class that
+ *                       controls the cluster core node.
+ *                      
+ * 
+ *
+ *
+ * Date: 04/19/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_penmigman.h,v 1.6 2009-04-06 21:48:46 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_PENMIGMAN_H
+#define _TCMI_PENMIGMAN_H
+
+#include <linux/wait.h>
+
+#include "tcmi_migman.h"
+#include <tcmi/migration/fs/fs_mount_params.h>
+
+/** @defgroup tcmi_penmigman_class tcmi_penmigman class 
+ *
+ * @ingroup tcmi_migman_class
+ * 
+ * TCMI PEN migration manager controls migrating tasks for a
+ * particular CCN-PEN pair and resides as the name describes - on a
+ * PEN.  Basic message handling capabilities are used from the \link
+ * tcmi_migman_class generic migration manager \endlink.
+ * 
+ * There are specific tasks that it needs to accomplish:
+ * - authenticate at the CCN that it is connected to
+ * - accept migrating tasks
+ *
+ * 
+ * @{
+ */
+
+
+/**
+ * A compound structure that holds all current shadow processes and
+ * other migration related data.
+ */
+struct tcmi_penmigman {
+	/** parent class instance. */
+	struct tcmi_migman super;
+	/** TCMI ctlfs - migrate-home-all file */
+	struct tcmi_ctlfs_entry *f_mighome_all;
+
+	/** Mount params to be used when starting processes from associated CCN */
+	struct fs_mount_params mount_params;
+};
+/** Casts to the CCN migration manager. */
+#define TCMI_PENMIGMAN(migman) ((struct tcmi_penmigman *)migman)
+
+
+/** \<\<public\>\> TCMI PEN migration manager constructor. */
+extern struct tcmi_migman* tcmi_penmigman_new(struct kkc_sock *sock, u_int32_t pen_id, struct tcmi_slot* manager_slot,
+					      struct tcmi_ctlfs_entry *root,
+					      struct tcmi_ctlfs_entry *migproc,
+					      const char namefmt[], ...);
+
+/** \<\<public\>\> Tries authenticating itself at the CCN that it is connected to. */
+extern int tcmi_penmigman_auth_ccn(struct tcmi_penmigman *self,  int auth_data_length, char* auth_data);
+
+/** \<\<public\>\> Getter of mount params structure. */
+static inline struct fs_mount_params* tcmi_penmigman_get_mount_params(struct tcmi_penmigman *self) {
+	return &self->mount_params;
+};
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_PENMIGMAN_PRIVATE
+
+
+/** Initializes TCMI ctlfs files. */
+static int tcmi_penmigman_init_ctlfs_files(struct tcmi_migman *self);
+/** Destroys all TCMI ctlfs files. */
+static void tcmi_penmigman_stop_ctlfs_files(struct tcmi_migman *self);
+
+
+/** Frees CCN mig. manager specific resources. */
+static void tcmi_penmigman_free(struct tcmi_migman *self);
+
+/** Processes a TCMI message m. */
+static void tcmi_penmigman_process_msg(struct tcmi_migman *self, struct tcmi_msg *m);
+
+
+/** CCN Migration manager operations that support polymorphism */
+static struct tcmi_migman_ops penmigman_ops;
+
+#endif /* TCMI_PENMIGMAN_PRIVATE */
+
+
+/**
+ * @}
+ */
+
+
+#endif /* _TCMI_PENMIGMAN_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/manager/tcmi_penman.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/manager/tcmi_penman.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,193 @@
+/**
+ * @file tcmi_penman.h - TCMI cluster core node manager - a class that
+ *                       controls the cluster core node.
+ *                      
+ * 
+ *
+ *
+ * Date: 04/06/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_penman.h,v 1.4 2007/11/05 19:38:28 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TCMI_PENMAN_H
+#define _TCMI_PENMAN_H
+
+
+
+
+
+#include <linux/sched.h>
+
+#include <tcmi/lib/tcmi_slotvec.h>
+#include <tcmi/ctlfs/tcmi_ctlfs_dir.h>
+#include <tcmi/ctlfs/tcmi_ctlfs_file.h>
+
+#include "tcmi_man.h"
+
+/* TCMI PEN manager is controlled by compile time config option in Kbuild */
+#ifdef CONFIG_TCMI_PEN
+/** @defgroup tcmi_penman_class tcmi_penman class 
+ * 
+ * @ingroup tcmi_man_class
+ *  
+ * This \<\<singleton\>\> class implements the PEN TCMI manager
+ * component. It is responsible for registering the cluster node to
+ * CCN's specified by the user. Each migration manager communicates with one
+ * CCN. User controls the process execution node by manipulating \link
+ * tcmi_ctlfs.c TCMI control file system \endlink. The directory/file
+ * layout can be divided into three groups of files/directories based
+ * on their maintainers, which can be:
+ *
+ * - TCMI PEN manager
+ * - TCMI PEN migration manager
+ * - TCMI PEN preemptive migration component
+ * - TCMI PEN non-preemtive migration component
+ * - TCMI migrated process
+ *
+ * As we can see these are exact counterparts to the components on CCN.
+ *
+ \verbatim
+  ------------ T C M I  P E N  m a n a g e r --------------
+  pen/connect -> allows connecting to a CCN
+  
+      stop -> writing into this stops the whole framework, migrates all processes back 
+             to their CCN's and terminates all migration managers.
+ 
+  ----------- T C M I  P E N  m i g r a t i o n   m a n a g e r s --------------
+      nodes/1/ -> each CCN where this PEN is registered has a separate directory, maintained
+                  by its migration manager that is in charge of it.
+            2/
+            .
+            .
+            9/connections/ -> all connections of a migration manager
+	                  ctrlconn/ -> control connection
+                                   arch -> contains architecture of the connection
+				   localname -> local socket name (address)
+				   peername -> remote socket name (address)
+	      state - current state of the migration manager
+ 
+  ------------ T C M I  P E N  s h a d o w  p r o c e s s e s --------------
+      mig/migproc/1300/ -> similar to /proc, but contains PID's of migrated processes
+                           one directory per process
+                  2001/
+                     .
+                     .    
+                  6547/migman->../../nodes/7 -> a  symbolic link pointing to
+                                                its current  CCN
+		       remote-pid -> process PID at its original CCN
+  ------------ T C M I  P E N  p p m  c o m p o n e n t --------------
+                emigrate-ppm-p -> writing a PID + PEN id pair into this file starts process 
+                            migration to the specified PEN.
+                migrate-home -> allows migrating a specified process back to CCN
+  ------------ T C M I  P E N  n p m  c o m p o n e n t (not implemented) --------------
+                policy -> interface for the migration policy, the npm component
+                          uses this interface to ask the migration policy for migration
+                          decision.
+ 
+ \endverbatim
+ * 
+ *
+ * @todo InterPEN migration is not implemented.
+ * @{
+ */
+
+
+struct npm_params;
+
+/**
+ * A compound structure that holds all current migration managers.
+ * This is for internal use only.
+ */
+struct tcmi_penman {
+	/** parent class instance. */
+	struct tcmi_man super;
+
+	/** TCMI ctlfs - connect control file */
+	struct tcmi_ctlfs_entry *f_connect;
+
+};
+/** Casts to the PEN manager. */
+#define TCMI_PENMAN(man) ((struct tcmi_penman *)man)
+
+/** \<\<public\>\> Initializes the TCMI PEN manager. */
+extern int tcmi_penman_init(struct tcmi_ctlfs_entry *root);
+
+/** \<\<public\>\> Shuts down TCMI PEN manager. */
+extern void tcmi_penman_shutdown(void);
+
+/** \<\<public\>\> Getter of a pen man signelton instance. */
+extern struct tcmi_penman* tcmi_penman_get_instance(void);
+
+/** \<\<public\>\> Performs non-preemptive migration back to CCN  */
+extern int tcmi_penman_migrateback_npm(struct tcmi_man *self, struct pt_regs* regs, struct tcmi_npm_params* npm_params);
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_PENMAN_PRIVATE
+
+/** TCMI PEN manager \<\<singleton\>\> instance. */
+static struct tcmi_penman self;
+
+/** Initializes TCMI ctlfs files. */
+static int tcmi_penman_init_ctlfs_files(void);
+/** Destroys all TCMI ctlfs files. */
+static void tcmi_penman_stop_ctlfs_files(void);
+/** Stops the TCMI PEN manager. */
+static void tcmi_penman_stop(void);
+
+/** Write method for the TCMI ctlfs - connects to a CCN. */
+static int tcmi_penman_connect(void *obj, void *data);
+
+/** CCN manager operations that support polymorphism */
+static struct tcmi_man_ops penman_ops;
+
+struct tcmi_penman* tcmi_penman_get_instance(void) {
+	return &self;
+};
+
+#endif /* TCMI_PENMAN_PRIVATE */
+
+
+/**
+ * @}
+ */
+#else
+/** 
+ * Initializes the TCMI PEN manager, stub method when PEN not configured.
+ *
+ * @param *root - root directory of the filesystem, where all entries
+ * are to be created
+ * @return always 0;
+ */
+static inline int tcmi_penman_init(struct tcmi_ctlfs_entry *root)
+{
+	return 0;
+}
+
+/** Shuts down TCMI PEN manager, stub method when PEN not configured */
+static inline void tcmi_penman_shutdown(void) 
+{
+}
+
+#endif /* CONFIG_TCMI_PEN */
+
+#endif /* _TCMI_PENMAN_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/manager/tcmi_ccnman.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/manager/tcmi_ccnman.c	2013-03-12 09:52:48.000000000 +0100
@@ -0,0 +1,703 @@
+/**
+ * @file tcmi_ccnman.c - Implementation of TCMI cluster core node
+ *                       manager - a class that controls the cluster 
+ *                       core node
+ *                      
+ * 
+ *
+ *
+ * Date: 04/06/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_ccnman.c,v 1.9 2009-04-06 21:48:46 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include <linux/spinlock_types.h>
+#include <linux/kthread.h>
+#include <tcmi/migration/tcmi_migcom.h>
+#include <tcmi/ctlfs/tcmi_ctlfs.h>
+#include <tcmi/lib/tcmi_sock.h>
+#include "tcmi_ccnmigman.h"
+
+#include <kkc/kkc.h>
+
+#define TCMI_CCNMAN_PRIVATE
+#include "tcmi_ccnman.h"
+//#include <tcmi/migration/fs/fs_mount_params.h>
+
+#include <dbg.h>
+
+#include <director/director.h>
+
+/** maximum number of listenings */
+#define MAX_LISTENINGS 2
+
+/**
+ * \<\<public\>\> Singleton instance initializer.
+ * The initialization is accomplished exactly in this order:
+ * - allocate new slot vector for listenings 
+ * - start listening thread
+ * - delegate rest of initialization to TCMI generic manager
+ *
+ * @param *root - root directory of the filesystem, where all entries
+ * are to be created
+ * @return 0 upon success
+ */
+int tcmi_ccnman_init(struct tcmi_ctlfs_entry *root)
+{
+	self.mount_params.mount_type[0] = '\0';
+	self.mount_params.mount_options[0] = '\0';
+	self.mount_params.mount_device[0] = '\0';
+	minfo(INFO1, "Initializing TCMI CCN manager");
+	if (!(self.listenings = tcmi_slotvec_new(MAX_LISTENINGS))) {
+		mdbg(ERR3, "Failed to create listenings slot vector");
+		goto exit0;
+	}
+	if (tcmi_ccnman_start_thread() < 0) {
+		mdbg(ERR3, "Failed to start listening thread");
+		goto exit1; 
+	}
+	if (tcmi_man_init(TCMI_MAN(&self), root, &ccnman_ops, "ccn") < 0) {
+		mdbg(ERR3, "TCMI CCN manager - generic init failed");
+		goto exit2;
+	}
+	return 0;
+		
+	/* error handling */
+
+ exit2:
+	tcmi_ccnman_stop_thread();
+ exit1:
+	tcmi_slotvec_put(self.listenings);
+ exit0:
+	return -EINVAL;
+}
+
+/** 
+ * \<\<public\>\> The manager is shutdown exactly in this order:
+ *
+ * - stop the listening thread, the thread doesn't need to worry about
+ * termination of any listenings-it will be done further
+ * - perform a generic shutdown (this destroys all
+ * files and stops migration etc.). This step preceeds stop listening
+ * as we need to be sure, that no control files are active (user
+ * might try adding a new listening interface)
+ * - stop listening on all interfaces
+ * - destroy the listenings slotvector (should be empty by now)
+ */
+void tcmi_ccnman_shutdown(void)
+{
+	int stop_listen = 1;
+	minfo(INFO1, "Shutting down the TCMI CCN manager");
+
+	tcmi_ccnman_stop_thread();
+	tcmi_man_shutdown(TCMI_MAN(&self));
+	tcmi_ccnman_stop_listen_all(NULL, &stop_listen);
+	tcmi_slotvec_put(self.listenings);
+}
+
+
+/** @addtogroup tcmi_ccnman_class
+ *
+ * @{
+ */
+
+
+/** 
+ * \<\<private\>\> Creates the additional directories as described in \link
+ * tcmi_ccnman_class here \endlink. This method is called back
+ * by the \link tcmi_man_class TCMI manager generic class\endlink.
+ *
+ * Currently, there is only one additional directory that stores listenings.
+ * @return 0 upon success
+ */
+static int tcmi_ccnman_init_ctlfs_dirs(void)
+{
+
+	if (!(self.d_listening_on = 
+	      tcmi_ctlfs_dir_new(tcmi_man_root(TCMI_MAN(&self)), TCMI_PERMS_DIR, "listening-on")))
+		goto exit0;
+
+	if (!(self.d_mounter = 
+	      tcmi_ctlfs_dir_new(tcmi_man_root(TCMI_MAN(&self)), TCMI_PERMS_DIR, "mounter")))
+		goto exit1;
+
+	return 0;
+
+	/* error handling */
+ exit1:
+	tcmi_ctlfs_entry_put(self.d_listening_on);
+ exit0:
+	return -EINVAL;
+
+}
+/** 
+ * \<\<private\>\> Creates the static files 
+ * described \link tcmi_ccnman_class here \endlink. 
+ *
+ * @return 0 upon success
+ */
+static int tcmi_ccnman_init_ctlfs_files(void)
+{
+	mdbg(INFO4, "Creating files");
+	if (!(self.f_stop_listen_all = 
+	      tcmi_ctlfs_intfile_new(tcmi_man_root(TCMI_MAN(&self)), TCMI_PERMS_FILE_W,
+				     NULL, NULL, tcmi_ccnman_stop_listen_all,
+				     sizeof(int), "stop-listen-all")))
+		goto exit0;
+
+	if (!(self.f_stop_listen_one = 
+	      tcmi_ctlfs_intfile_new(tcmi_man_root(TCMI_MAN(&self)), TCMI_PERMS_FILE_W,
+				     NULL, NULL, tcmi_ccnman_stop_listen_one,
+				     sizeof(int), "stop-listen-one")))
+		goto exit1;
+
+	if (!(self.f_listen = 
+	      tcmi_ctlfs_strfile_new(tcmi_man_root(TCMI_MAN(&self)), TCMI_PERMS_FILE_W,
+				     NULL, NULL, tcmi_ccnman_listen,
+				     KKC_MAX_WHERE_LENGTH, "listen")))
+		goto exit1;
+
+	if (!(self.f_mount = 
+	      tcmi_ctlfs_strfile_new(self.d_mounter, TCMI_PERMS_FILE_W,
+				     NULL, NULL, tcmi_man_set_mount,
+				     TCMI_FS_MOUNT_LENGTH, "fs-mount")))
+		goto exit1;
+
+	if (!(self.f_mount_device = 
+	      tcmi_ctlfs_strfile_new(self.d_mounter, TCMI_PERMS_FILE_W,
+				     NULL, NULL, tcmi_man_set_mount_device,
+				     TCMI_FS_MOUNT_LENGTH, "fs-mount-device")))
+		goto exit1;
+
+	if (!(self.f_mount_options = 
+	      tcmi_ctlfs_strfile_new(self.d_mounter, TCMI_PERMS_FILE_W,
+				     NULL, NULL, tcmi_man_set_mount_options,
+				     TCMI_FS_MOUNT_OPTIONS_LENGTH, "fs-mount-options")))
+		goto exit1;
+
+	return 0;
+
+	/* error handling */
+ exit1:
+	tcmi_ccnman_stop_ctlfs_files();
+ exit0:
+	return -EINVAL;
+
+}
+
+/**
+ * Adds a sleeper that represents a wait queue element for a newly
+ * created socket into the internal sleepers list.  The sleeper needs
+ * to be removed from the list prior to releasing the socket
+ * reference.
+ *
+ * @param *sleeper - element to be added to the sleepers list
+ */
+static inline void tcmi_ccnman_add_sleeper(struct kkc_sock_sleeper *sleeper)
+{
+	spin_lock(&self.sleepers_lock);
+	list_add(&sleeper->list, &self.sleepers);
+	spin_unlock(&self.sleepers_lock);
+}
+
+/**
+ * Searches the list of socket sleepers and removes all sleepers that
+ * match the socket. 
+ *
+ * @param *sock - socket that is to be cleaned from all sleepers
+ */
+static inline void tcmi_ccnman_remove_sleepers(struct tcmi_sock *sock)
+{
+	struct kkc_sock *k_sock = tcmi_sock_kkc_sock_get(sock);
+	/* backup element for traversing the list is needed since the
+	 * sleeper might get removed */
+	struct kkc_sock_sleeper *sleeper, *tmp;
+	spin_lock(&self.sleepers_lock);
+	/* Find all sleepers that match this socket */
+	list_for_each_entry_safe(sleeper, tmp, &self.sleepers, list) {
+		kkc_sock_sleeper_remove_match(sleeper, k_sock);
+	}
+	spin_unlock(&self.sleepers_lock);
+}
+
+/** 
+ * \<\<private\>\> Releases all directories - called back by generic
+ * TCMI manager
+ *
+ */
+static void tcmi_ccnman_stop_ctlfs_dirs(void)
+{
+	mdbg(INFO3, "Destroying  TCMI CCN manager ctlfs directories");
+	tcmi_ctlfs_entry_put(self.d_listening_on);
+	tcmi_ctlfs_entry_put(self.d_mounter);
+}
+
+/** 
+ *\<\<private\>\>  Unregisters and releases all control files.
+ */
+static void tcmi_ccnman_stop_ctlfs_files(void)
+{
+	mdbg(INFO3, "Destroying  TCMI CCN manager ctlfs files");
+
+	tcmi_ctlfs_file_unregister(self.f_listen);
+	tcmi_ctlfs_entry_put(self.f_listen);
+
+	tcmi_ctlfs_file_unregister(self.f_stop_listen_one);
+	tcmi_ctlfs_entry_put(self.f_stop_listen_one);
+
+	tcmi_ctlfs_file_unregister(self.f_stop_listen_all);
+	tcmi_ctlfs_entry_put(self.f_stop_listen_all);
+
+	tcmi_ctlfs_file_unregister(self.f_mount);
+	tcmi_ctlfs_entry_put(self.f_mount);	
+
+	tcmi_ctlfs_file_unregister(self.f_mount_device);
+	tcmi_ctlfs_entry_put(self.f_mount_device);	
+
+	tcmi_ctlfs_file_unregister(self.f_mount_options);
+	tcmi_ctlfs_entry_put(self.f_mount_options);	
+
+}
+
+/**
+ * \<\<private\>\> Instantiates a new listening.
+ * Following steps need to be done
+ * - reserve an empty slot in the slot vector
+ * - create a new KKC socket, that listens on specified interface
+ * - create a new KKC socket sleeper associated with the listening
+ * thread and add it to the sleepers list.
+ * - create a new TCMI socket that will present the KKC socket in
+ * TCMI ctlfs
+ * - insert the TCMI socket into that reserved slot
+ * - release the KKC socket - it is not needed anymore as the TCMI
+ * socket retains its own reference.
+ *
+ * @param *obj - pointer to an object - NULL is expected as
+ * TCMI CCN manager is a singleton class.
+ * @param *str - listening string - encodes the interface on which the
+ * new listening is to be started. It is architecture dependent
+ * and passed further on KKC to parse it.
+ * @return 0 upon success
+ */
+static int tcmi_ccnman_listen(void *obj, void *str)
+{
+	struct tcmi_slot *slot;
+	struct kkc_sock *k_sock;
+	struct tcmi_sock *t_sock;
+	/* storage for the new socket sleeper element */
+	struct kkc_sock_sleeper *sleeper;
+	char *listen_str = (char *) str;
+	int err = -EINVAL;
+
+	mdbg(INFO3, "Listen request on %s", listen_str);
+	/* Reserve an empty slot */
+	if (!(slot = tcmi_slotvec_reserve_empty(self.listenings))) {
+		mdbg(ERR3, "Failed allocating an empty slot for listening '%s'", 
+		     listen_str);
+		goto exit0;
+	}
+	/* create KKC socket */
+	if ((err = kkc_listen(&k_sock, listen_str))) {
+		mdbg(ERR3, "Failed creating KKC listening on '%s'", listen_str);
+		goto exit1;
+	}
+	if (!(sleeper = kkc_sock_sleeper_add(k_sock, self.thread))) {
+		mdbg(ERR3, "Failed to create a new socket sleeper");
+		goto exit2;
+	}
+
+	if (!(t_sock = tcmi_sock_new(self.d_listening_on, k_sock, "listen-%02d", 
+				     tcmi_slot_index(slot)))) {
+		mdbg(ERR3, "Failed creating TCMI socket on '%s'", listen_str);
+		goto exit3;
+	}
+	/* append the sleeper to the list */
+	tcmi_ccnman_add_sleeper(sleeper);
+	tcmi_slot_insert(slot, tcmi_sock_node(t_sock));
+	/* KKC socket not needed anymore as it is stored internally by
+	 * TCMI socket */
+	kkc_sock_put(k_sock);
+	
+	return 0;
+	/* error handling */
+ exit3:
+	kkc_sock_sleeper_remove(sleeper);
+ exit2:
+	kkc_sock_put(k_sock);
+ exit1:
+	tcmi_slot_move_unused(slot); 
+ exit0:
+	return err;
+}
+
+
+
+/**
+ * \<\<private\>\> Iterates through all active listenings and notifies
+ * each instance to quit. The slot vector needs to be locked while
+ * iterating through the listenings.
+ *
+ * @param *obj - pointer to an object - NULL is expected as
+ * TCMI CCN manager is a singleton class.
+ * @param *data - if the value that it points to is >0, the action is 
+ * taken
+ * @return 0 - when all listenings have been terminated
+ */
+static int tcmi_ccnman_stop_listen_all(void *obj, void *data)
+{
+	int stop = *((int *)data);
+	/* temporary storage for the slots while traversing the vector */
+	struct tcmi_sock *listening;
+	mdbg(INFO3, "Stop listening - all interfaces, action = %d", stop);
+	
+
+	if (stop) {
+		while (!tcmi_slotvec_empty(self.listenings)) {
+
+			tcmi_slotvec_lock(self.listenings);
+			tcmi_slotvec_remove_one_entry(self.listenings, listening, node);
+			tcmi_slotvec_unlock(self.listenings);
+
+			if (listening) {
+				tcmi_ccnman_remove_sleepers(listening);
+				tcmi_sock_put(listening);
+			}
+		}
+
+	}
+	return 0;
+}
+
+/**
+ * \<\<private\>\> Destroys a particular listening specified by the
+ * user.  The listening is first looked up in the slotvector and
+ * removed. After unlocking the slotvector we can destroy it.
+ *
+ * @param *obj - pointer to an object - NULL is expected as
+ * TCMI CCN manager is a singleton class.
+ * @param *data - slot number where the listening that is to 
+ * destroyed resides.
+ * @return 0 - when all listenings have been terminated
+ */
+static int tcmi_ccnman_stop_listen_one(void *obj, void *data)
+{
+	int slot_num = *((int *)data);
+	/* temporary storage for the slot where the listening resides */
+	struct tcmi_slot *slot;
+	/* temporary storage for the slots while traversing the vector */
+	struct tcmi_sock *listening = NULL;
+
+	
+
+	tcmi_slotvec_lock(self.listenings);
+	slot = tcmi_slotvec_at(self.listenings, slot_num);
+	if (!slot) {
+		mdbg(ERR3, "Can't stop listening - invalid number! %d", slot_num);
+		goto exit0;
+	}
+	/* there is always only one listening per slot */
+	tcmi_slot_remove_first(listening, slot, node);
+	/* Slot might exist, but it might still be empty*/
+	if (!listening) {
+		mdbg(ERR3, "Can't stop listening - no such listening (%d)", slot_num);
+		goto exit0;
+	}
+	tcmi_slotvec_unlock(self.listenings);
+	tcmi_ccnman_remove_sleepers(listening);
+	tcmi_sock_put(listening);
+
+	mdbg(INFO3, "Stopped listening - %d", slot_num);	
+	return 0;
+	/* error handling */
+ exit0:
+	tcmi_slotvec_unlock(self.listenings);
+	return -EINVAL;
+}
+
+/** 
+ * \<\<private\>\> Write method to set fs mount type
+ *
+ * @param *obj - this manager instance
+ * @param *data - string with name of the mount type
+ * @return 0 upon success
+ */
+static int tcmi_man_set_mount(void* obj, void* data)
+{
+	char *type_str = (char *)data;
+	strncpy(self.mount_params.mount_type, type_str, TCMI_FS_MOUNT_LENGTH);
+	return 0;
+}
+
+/** 
+ * \<\<private\>\> Write method to set fs mount device
+ *
+ * @param *obj - this manager instance
+ * @param *data - string with the mount device name
+ * @return 0 upon success
+ */
+static int tcmi_man_set_mount_device(void* obj, void* data)
+{
+	char *device_str = (char *)data;
+	strncpy(self.mount_params.mount_device, device_str, TCMI_FS_MOUNT_DEVICE_LENGTH);
+	return 0;
+}
+
+/** 
+ * \<\<private\>\> Write method to set fs mount options
+ *
+ * @param *obj - this manager instance
+ * @param *data - string with the mount options
+ * @return 0 upon success
+ */
+static int tcmi_man_set_mount_options(void* obj, void* data)
+{
+	char *options_str = (char *)data;
+	strncpy(self.mount_params.mount_options, options_str, TCMI_FS_MOUNT_OPTIONS_LENGTH);
+	return 0;
+}
+
+/**
+ * \<\<private\>\> This method is called back by the generic TCMI manager.
+ * It stops listening on all interfaces.
+ *
+ */
+static void tcmi_ccnman_stop(void)
+{
+	int stop_listen = 1;
+	tcmi_ccnman_stop_listen_all(NULL, &stop_listen);
+}
+
+/**
+ * \<\<private\>\> Starts the listening thread. The kernel thread is
+ * started by using kernel services. No additional actions are needed.
+ *
+ * @return 0 upon sucessful thread creation 
+ */
+static int tcmi_ccnman_start_thread(void)
+{
+	mdbg(INFO3, "Starting listening thread");
+
+	self.thread = kthread_run(tcmi_ccnman_thread, NULL, "tcmi_ccnmand");
+	
+	if (IS_ERR(self.thread)) {
+		mdbg(ERR2, "Failed to create a listening thread!");
+		goto exit0;
+	}
+	mdbg(INFO3, "Created listening thread %p", self.thread);
+	return 0;
+
+	/* error handling */
+ exit0:
+	return -EINVAL;
+}
+
+/**
+ * \<\<private\>\> The TCMI CCN manager listening thread is
+ * terminated. The thread state is changed to 'DONE', so that the
+ * thread notices, that the manager is about to be shutdown and
+ * terminates.
+ */
+static void tcmi_ccnman_stop_thread(void)
+{
+	if (self.thread) {
+		mdbg(INFO3, "Stopping listening thread");
+		kthread_stop(self.thread);
+	}
+}
+
+/**
+ * \<\<private\>\> This is the actual listening thread.  It performs
+ * an infinite loop which cycles through all listenings checking for
+ * an incoming connection. This task is not trivial as we are racing
+ * with other threads from user space, that add and remove
+ * listenings. Also it is highly desirable to process a listening and
+ * not hold the slot vector lock.
+ * 
+ * is equal to following pseudocode:
+ \verbatim
+ while(!signalled to quit) {
+   for each slot (s) {
+     take first listening (l) from (s)
+     if (s) is empty -> report serious error, break;
+     obtain the KKC socket and process it.
+     if (l) has been removed from (s) in the
+       meantime (unhashed) -> break;
+ }
+ \endverbatim
+ *
+ * @param *data - a mandatory parameter, not used by our thread as it
+ * can access all tcmi_ccnman related data from the singleton instance
+ * @return 0 upon successful thread termination.
+ */
+static int tcmi_ccnman_thread(void *data)
+{
+	struct tcmi_sock *listening = NULL;
+	struct tcmi_sock *tmp = NULL;
+	struct tcmi_slot *slot;
+	mdbg(INFO3, "Listening thread up and running %p", current);
+
+	while (!kthread_should_stop()) {
+		/* iterate safely through the slot vector */
+		tcmi_slotvec_lock(self.listenings);
+		tcmi_slotvec_for_each_used_slot(slot, self.listenings) {
+			/* release the socket from previous iteration */
+			tcmi_sock_put(tmp);
+			/* retrieve the first object in the slot */
+			tcmi_slot_find_first(listening, slot, node);
+			if (!tcmi_sock_get(listening)) {
+				mdbg(ERR3, "Slot vector inconsistency, empty slot in used list!!");
+				break;
+			}
+			tcmi_slotvec_unlock(self.listenings);
+			/* now the critical region is over, and we can
+			 * process the listening without any need to
+			 * lock the slot vector since we own */
+			tcmi_ccnman_process_sock(tcmi_sock_kkc_sock_get(listening));
+			tmp = listening; /* tmp is released in the next iteration */
+			/* set critical region for next iteration */
+			tcmi_slotvec_lock(self.listenings);
+			if (tcmi_slot_node_unhashed(tcmi_sock_node(tmp))) {
+				mdbg(INFO3, "Socket has been unhashed in the meantime local: '%s', remote: '%s'", 
+				     kkc_sock_getsockname2(tcmi_sock_kkc_sock_get(tmp)), 
+				     kkc_sock_getpeername2(tcmi_sock_kkc_sock_get(tmp)));
+				break;
+			}
+		}
+		tcmi_slotvec_unlock(self.listenings);
+		/* release the socket from the last iteration and
+		 * reset tmp to prevent another put in next main loop
+		 * iteration */
+		tcmi_sock_put(tmp);
+		tmp = NULL;
+
+		/* for each listening if incoming create mig man */
+		mdbg(INFO3, "Listening thread going to sleep");
+		schedule();
+		set_current_state(TASK_INTERRUPTIBLE);
+		mdbg(INFO3, "Listening thread woken up");
+	}
+	mdbg(INFO3, "Listening thread terminating");
+	return 0;
+}
+
+
+/** 
+ * \<\<private\>\> Processes a selected socket and checks for incoming
+ * connection. If an incoming connection is detected, spawns a new
+ * migration manager passing it the connected socket. A successfully
+ * created migration manager is added among other migration managers
+ * into the slot vector.
+ *
+ * @param *sock - kkc socket that is to be processed
+ */
+static void tcmi_ccnman_process_sock(struct kkc_sock *sock)
+{
+	int err;
+	struct kkc_sock *new_sock;
+	struct tcmi_migman *migman;
+	struct tcmi_slot *slot;	
+
+	/* check if there is incoming connection */
+	if ((err = kkc_sock_accept(sock, &new_sock, 
+				   KKC_SOCK_NONBLOCK)) < 0) {
+		mdbg(INFO3, "No connection, accept would block %d", err);
+		goto exit0;
+	}
+	mdbg(INFO3, "Accepted incoming connection local: '%s', remote: '%s'", 
+	     kkc_sock_getsockname2(new_sock), kkc_sock_getpeername2(new_sock));
+	/* Reserve an empty slot */
+	if (!(slot = tcmi_man_reserve_migmanslot(TCMI_MAN(&self)))) {
+		mdbg(ERR3, "Failed allocating an empty slot for CCN migman"); 
+		goto exit1;
+	}
+
+	/* Accept the first incoming connection */
+	if (!(migman = tcmi_ccnmigman_new(new_sock, 
+					  tcmi_man_id(TCMI_MAN(&self)), 
+					  slot,
+					  tcmi_man_nodes_dir(TCMI_MAN(&self)),
+					  tcmi_man_migproc_dir(TCMI_MAN(&self)),
+					  "%d", tcmi_slot_index(slot)))) {
+		minfo(ERR1, "Failed to instantiate the CCN migration manager"); 
+		goto exit2;
+	}
+	if ((err = tcmi_ccnmigman_auth_pen(TCMI_CCNMIGMAN(migman))) < 0) {
+		minfo(ERR1, "Failed to authenticate the PEN! %d", err); 
+		goto exit3;
+	}
+
+	tcmi_slot_insert(slot, tcmi_migman_node(migman));
+
+	kkc_sock_put(new_sock);
+
+	return;
+/* error handling */
+ exit3:
+	tcmi_migman_put(migman);
+ exit2:
+	tcmi_man_release_migmanslot(TCMI_MAN(&self), slot); 
+ exit1:
+	kkc_sock_put(new_sock);
+ exit0:
+	return;
+}
+
+/** \<\<public\>\> Getter of mount params structure. */
+struct fs_mount_params* tcmi_ccnman_get_mount_params(void) {
+	return &self.mount_params;
+}
+
+/** Singleton instance pre-initialization */
+static struct tcmi_ccnman self = {
+	.listenings = NULL,
+	.f_listen = NULL,
+	.d_listening_on = NULL,	
+	.f_stop_listen_all = NULL,
+	.d_mounter = NULL,
+	.f_mount = NULL,
+	.f_mount_device = NULL,
+	.f_mount_options = NULL,
+	.thread = NULL,
+	.sleepers = LIST_HEAD_INIT(self.sleepers),
+	.sleepers_lock = __SPIN_LOCK_UNLOCKED(old_style_spin_init)
+};
+
+
+/** Migration manager operations that support polymorphism */
+static struct tcmi_man_ops ccnman_ops = {
+	.init_ctlfs_dirs = tcmi_ccnman_init_ctlfs_dirs,
+	.stop_ctlfs_dirs = tcmi_ccnman_stop_ctlfs_dirs,
+	.init_ctlfs_files = tcmi_ccnman_init_ctlfs_files, 
+	.stop_ctlfs_files = tcmi_ccnman_stop_ctlfs_files,
+	.stop = tcmi_ccnman_stop,
+	.emigrate_ppm_p = tcmi_migcom_emigrate_ccn_ppm_p,
+	.emigrate_npm = tcmi_migcom_emigrate_ccn_npm,
+	.migrate_home_ppm_p = tcmi_migcom_migrate_home_ppm_p,
+	.fork = tcmi_migcom_shadow_fork,
+};
+
+/**
+ * @}
+ */
+
+
--- linux-3.7.1_original/clondike/src/tcmi/manager/tcmi_penmigman.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/manager/tcmi_penmigman.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,354 @@
+/**
+ * @file tcmi_penmigman.c - Implementation of TCMI cluster core node migration
+ *                          manager - a class that controls task migration on PEN
+ *                      
+ * 
+ *
+ *
+ * Date: 04/20/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_penmigman.c,v 1.9 2009-04-06 21:48:46 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <tcmi/migration/tcmi_migcom.h>
+#include <tcmi/lib/tcmi_slotvec.h>
+#include <tcmi/task/tcmi_task.h>
+#include <linux/sched.h>
+
+#define TCMI_PENMIGMAN_PRIVATE
+#include "tcmi_penmigman.h"
+
+#include <tcmi/comm/tcmi_authenticate_msg.h>
+#include <tcmi/comm/tcmi_authenticate_resp_msg.h>
+#include <arch/current/regs.h>
+#include <tcmi/lib/util.h>
+
+#include <director/director.h>
+
+#include <dbg.h>
+
+/** Forward declaration */
+static int tcmi_penmigman_migrate_all_home(void *obj, void *data);
+
+/**
+ * \<\<public\>\> TCMI PEN migration manager constructor.
+ * The initialization is accomplished exactly in this order:
+ * - create new instance
+ * - delegates all remaining intialization work to the generic manager.
+ *
+ * @param *sock - socket where the new PEN is registering
+ * @param pen_id - PEN identifier
+ * @param *root - directory where the migration manager should create its
+ * files and directories
+ * @param *migproc - directory where the migrated process will have their info
+ * @param namefmt - nameformat string for the main manager directory name (printf style)
+ * @param ... - variable arguments
+ * @return new TCMI PEN manager instance or NULL
+ */
+struct tcmi_migman* tcmi_penmigman_new(struct kkc_sock *sock, u_int32_t pen_id, struct tcmi_slot* manager_slot,
+				       struct tcmi_ctlfs_entry *root,
+				       struct tcmi_ctlfs_entry *migproc,
+				       const char namefmt[], ...)
+{
+	struct tcmi_penmigman *migman;
+	va_list args;
+
+	minfo(INFO2, "Creating new TCMI PEN migration manager");
+	if (!(migman = TCMI_PENMIGMAN(kmalloc(sizeof(struct tcmi_penmigman), 
+					      GFP_KERNEL)))) {
+		mdbg(ERR3, "Can't allocate memory for CCM migration manager");
+		goto exit0;
+	}
+	va_start(args, namefmt);
+	if (tcmi_migman_init(TCMI_MIGMAN(migman), sock, 0, pen_id, UNKNOWN, manager_slot, root, migproc,
+			     &penmigman_ops, namefmt, args) < 0) {
+		mdbg(ERR3, "TCMI PEN migman initializtion failed!");
+		va_end(args);
+		goto exit1;
+	}
+	va_end(args);
+	
+	return TCMI_MIGMAN(migman);
+
+	/* error handling */
+ exit1:
+	kfree(migman);
+ exit0:
+	return NULL;
+}
+
+/**
+ * \<\<public\>\> Authenticates at the CCN, expecting either a response
+ *(accept/refused)
+ *
+ * @param *self - pointer to this migration manager instance
+ * @param auth_data_size - optional authentication data string length
+ * @param auth_data - optional authentication data string, or NULL
+ * @return 0 if successfully, -EINVAL otherwise
+ */
+int tcmi_penmigman_auth_ccn(struct tcmi_penmigman *self, int auth_data_length, char *auth_data)
+{
+	/* authentication request and response*/
+	struct tcmi_msg *req, *resp;
+
+	/* Build the request */ 
+	if ( !(req = tcmi_authenticate_msg_new_tx(tcmi_migman_transactions(TCMI_MIGMAN(self)), TCMI_MIGMAN(self)->pen_id, ARCH_CURRENT, auth_data, auth_data_length)) ) { 
+		mdbg(ERR3, "Error creating the authentication request");
+		goto exit0;
+	}
+	if (tcmi_msg_send_and_receive(req, tcmi_migman_sock(TCMI_MIGMAN(self)), 
+				      &resp) < 0) {
+		minfo(ERR3, "Failed to send the authentication request!!");
+		goto exit1;
+	}
+	if (!resp) {
+		minfo(ERR3, "No authentication response from CCN - nothing arrived");
+		goto exit1;
+	}
+	mdbg(INFO3, "Authentication response  is now to be handled");
+	tcmi_penmigman_process_msg(TCMI_MIGMAN(self), resp);
+
+	/* fall through is ok, the response message has been discarded
+	 * by process_msg */
+ exit1:
+	/* release the message */
+	tcmi_msg_put(req);
+ exit0:
+	return (tcmi_migman_state(TCMI_MIGMAN(self)) == TCMI_MIGMAN_CONNECTED ? 
+		0 : -EINVAL); 
+}
+
+/** @addtogroup tcmi_penmigman_class
+ *
+ * @{
+ */
+
+
+
+/** 
+ * \<\<private\>\> Creates the static files 
+ * described \link tcmi_penmigman_class here \endlink. 
+ *
+ * @param *self - pointer to this migration manager instance
+ * @return 0 upon success
+ */
+static int tcmi_penmigman_init_ctlfs_files(struct tcmi_migman *self)
+{
+	struct tcmi_penmigman *self_pen = TCMI_PENMIGMAN(self);
+	mdbg(INFO4, "Creating TCMI ctlfs files - PEN migman");
+
+	if (!(self_pen->f_mighome_all = 
+	      tcmi_ctlfs_intfile_new(self->d_migman, TCMI_PERMS_FILE_W,
+				     self, NULL, tcmi_penmigman_migrate_all_home,
+				    sizeof(int),"migrate-home-all")))
+		goto exit0;
+
+	return 0;
+
+exit0:
+	return -EINVAL;
+}
+
+
+/** 
+ *\<\<private\>\>  Unregisters and releases all control files.
+ *
+ * @param *self - pointer to this migration manager instance
+ */
+static void tcmi_penmigman_stop_ctlfs_files(struct tcmi_migman *self)
+{
+	struct tcmi_penmigman *self_pen = TCMI_PENMIGMAN(self);
+	mdbg(INFO3, "Destroying  TCMI ctlfs files - PEN migman");
+
+	tcmi_ctlfs_file_unregister(self_pen->f_mighome_all);
+	tcmi_ctlfs_entry_put(self_pen->f_mighome_all);
+
+}
+
+/** 
+ * \<\<private\>\> Emigrates all contained tasks back to home node
+ * The method is asynchrounous. Migrate home requests are issued to all contained tasks,
+ * but we do not wait till the migration back is performed.
+ *
+ * @param *obj - pointer to this migration manager instance
+ * @param *data - not used
+ */
+static int tcmi_penmigman_migrate_all_home(void *obj, void *data) {
+	struct tcmi_task* task;
+	struct tcmi_slot *slot;
+	tcmi_slot_node_t* node;
+	
+	struct tcmi_migman *self  = TCMI_MIGMAN(obj);
+
+	mdbg(INFO3, "Penmigman migrate all home requested");
+	/* we protect the iteration so that migration backs do not interfere with the iteration */
+	tcmi_slotvec_lock(self->tasks);
+	/* Iterate over all managed tasks */
+	tcmi_slotvec_for_each_used_slot(slot, self->tasks) {
+		tcmi_slot_for_each(node, slot) {
+			task = tcmi_slot_entry(node, struct tcmi_task, node);
+			mdbg(INFO3, "Sending migrate home request to task: local_pid=%d", tcmi_task_local_pid(task));
+			tcmi_migcom_migrate_home_ppm_p(tcmi_task_local_pid(task));
+		};
+	};
+	tcmi_slotvec_unlock(self->tasks);
+	mdbg(INFO3, "Penmigman migrate all home done");
+
+	return 0;
+}
+
+static inline void tcmi_penmigman_free(struct tcmi_migman *self) {
+	/* struct tcmi_penmigman *self_ppn  = TCMI_PENMIGMAN(self); */
+	
+	/** 
+		TODO: We cannot do it so simply as this method won't get called if there are tasks pointing to the migman.. either tasks should not keep reference to migman
+		or we better we have to introduce some 'stop' method, that is invoked before the free is performed. This stop will migrate everything back and so we wouldn't need
+		to migrate back here, but we'd do that in the stop method
+	 */
+	//tcmi_penmigman_migrate_all_home(self, NULL);
+	/* TODO: Wait till all migrations are finished? */
+}
+
+/** 
+ * \<\<private\>\> Called on stop request
+ * 
+ * Emigrates all contained tasks back to home node (asynchronously - only emigration requests are issued in context of this method)
+ *
+ * @param *self - pointer to this migration manager instance
+ */
+static void tcmi_penmigman_stop(struct tcmi_migman *self, int remote_requested) {
+    tcmi_penmigman_migrate_all_home(self, NULL);
+    
+    director_node_disconnected(tcmi_migman_slot_index(self), 0, remote_requested);
+}
+
+/** \<\<public\>\> Send dignal to process
+ * @param *self - pointer to this penmigman instance 
+ * @param pid - signal target pid
+ * @param *info - info for signal to be send
+ */
+static void tcmi_penmigman_send_signal(struct tcmi_migman *self, int pid, siginfo_t *info)
+{
+	int sig;
+	struct task_struct *task;
+
+	rcu_read_lock();
+	task = task_find_by_pid(pid);
+	rcu_read_unlock();
+	sig = info->si_signo;
+	mdbg(INFO2, "Sending signal %d to task %p (PID %d)", sig, task, pid);
+	if(task)
+		send_sig_info(sig, info, task);
+}
+
+
+/**
+ * \<\<private\>\> Processes a TCMI message m. 
+ * The message is disposed afterwords.
+ *
+ * @param *self - pointer to this migration manager instance
+ * @param *m - pointer to a message to be processed
+ */
+static void tcmi_penmigman_process_msg(struct tcmi_migman *self, struct tcmi_msg *m)
+{
+	struct tcmi_authenticate_resp_msg *auth_msg;
+	struct tcmi_generic_user_msg *user_msg;
+	struct tcmi_msg *resp;
+	struct tcmi_penmigman *self_pen  = TCMI_PENMIGMAN(self);
+	int err;
+
+	mdbg(INFO4, "Processing message (%p)", m);
+	
+	if ( !m )
+	    return;
+
+	switch(tcmi_msg_id(m)) {
+		case TCMI_AUTHENTICATE_RESP_MSG_ID:
+			auth_msg = TCMI_AUTHENTICATE_RESP_MSG(m);
+	
+			if ( auth_msg->result_code == 0) {
+				minfo(INFO1, "Authentication at CCN successful..");
+				self->peer_arch_type = tcmi_authenticate_resp_msg_arch(auth_msg);
+				self->ccn_id = tcmi_authenticate_resp_msg_ccn_id(auth_msg);
+				self_pen->mount_params = *tcmi_authenticate_resp_msg_mount_params(auth_msg);
+				minfo(INFO1, "received mount_params - type: %s device: %s options: %s", 
+						self_pen->mount_params.mount_type, self_pen->mount_params.mount_device,
+						self_pen->mount_params.mount_options);
+				tcmi_migman_set_state(self, TCMI_MIGMAN_CONNECTED);
+			} else {
+				minfo(INFO1, "Authentication at CCN failed with error=%d..", auth_msg->result_code);			
+			}
+			break;
+		case TCMI_MSG_FLG_SET_ERR(TCMI_AUTHENTICATE_RESP_MSG_ID):
+			minfo(INFO1, "Authentication at CCN failed, error received..");
+			break;
+		case TCMI_SIGNAL_MSG_ID:
+			tcmi_penmigman_send_signal(self, TCMI_SIGNAL_MSG(m)->pid,
+					&TCMI_SIGNAL_MSG(m)->info);
+			break;
+		case TCMI_P_EMIGRATE_MSG_ID:
+			minfo(INFO1, "Physical emigrate message has arrived..");
+			if (tcmi_migcom_immigrate(m, self) < 0) {
+				minfo(ERR3, "Error immigrating process");
+												
+				if (!(resp = tcmi_err_procmsg_new_tx(TCMI_GUEST_STARTED_PROCMSG_ID, tcmi_msg_req_id(m), -EINVAL, tcmi_p_emigrate_msg_reply_pid(TCMI_P_EMIGRATE_MSG(m))))) {
+				      minfo(ERR3, "Failed to send error response");
+				} else {
+				      tcmi_msg_send_anonymous(resp, tcmi_migman_sock(self));				      
+				}
+			}
+			break;
+		case TCMI_GENERIC_USER_MSG_ID:
+			user_msg = TCMI_GENERIC_USER_MSG(m);
+			minfo(INFO1, "User message arrived in pen.");
+	
+			err = director_generic_user_message_recv(tcmi_generic_user_msg_node_id(user_msg), 0, tcmi_migman_slot_index(self), tcmi_generic_user_msg_user_data_size(user_msg), tcmi_generic_user_msg_user_data(user_msg));
+			if ( err ) {
+				mdbg(ERR3, "Error in processing user message %d", err);
+			}
+			break;
+		default:
+			minfo(INFO1, "Unexpected message ID %x, no handler available.", 
+			tcmi_msg_id(m));
+			break;
+	}
+
+	/* release the message */
+	tcmi_msg_put(m);
+
+}
+
+
+/** Migration manager operations that support polymorphism */
+static struct tcmi_migman_ops penmigman_ops = {
+	.init_ctlfs_files = tcmi_penmigman_init_ctlfs_files, 
+	.stop_ctlfs_files = tcmi_penmigman_stop_ctlfs_files,
+//	.free = tcmi_penmigman_free,
+	.stop = tcmi_penmigman_stop,
+	.process_msg = tcmi_penmigman_process_msg,
+};
+
+/**
+ * @}
+ */
+
+
--- linux-3.7.1_original/clondike/src/tcmi/manager/tcmi_migman.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/manager/tcmi_migman.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,780 @@
+/**
+ * @file tcmi_migman.c - Implementation of TCMI cluster core node migration
+ *                          manager - a class that controls task migration on CCN
+ *                      
+ * 
+ *
+ *
+ * Date: 04/19/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_migman.c,v 1.8 2009-01-20 14:23:03 andrep1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <linux/types.h>
+#include <linux/random.h>
+#include <linux/kthread.h>
+#include <linux/string.h>
+#include <linux/sched.h>
+
+#include <tcmi/task/tcmi_taskhelper.h>
+#include <tcmi/task/tcmi_task.h>
+
+#define TCMI_MIGMAN_PRIVATE
+#include "tcmi_migman.h"
+
+#include <dbg.h>
+
+/** 2^8 elements in the transaction process hash*/
+#define TRANSACTION_ORDER 8
+/** 2^9 elements in the process hash*/
+#define TASK_ORDER 9
+/** Max length of the state description */
+#define TCMI_MIGMAN_STATE_LENGTH 40
+
+/** TCMI migration manager initializer. */
+/**
+ * \<\<public\>\> TCMI migration manager initializer.
+ * The initialization is accomplished exactly in this order:
+ * - set ID's and initial state
+ * - initialize message queue and the transaction vector
+ * - choose a unique ID for the manager.
+ * - store a reference to a mig proc directory - it's required when
+ * immigrating a process.
+ * - start TCMI communication component
+ * - create TCMI ctlfs directories 
+ * - create TCMI ctlfs control files 
+ * - create a TCMI socket to represent the connection in filesystem
+ * - run the message processing thread.
+ *
+ * @param *self - this migration manager instance
+ * @param *sock - socket where the control connection between CCN/PEN is running
+ * @param ccn_id - CCN identifier - valid when initializing a CCN mig. manager
+ * @param pen_id - PEN identifier - valid when initializing a PEN mig. manager
+ * @param peer_arch_type - Architecture of the peer node
+ * @param *root - directory where the migration manager should create its
+ * files and directories
+ * @param *migproc - directory where the migrated process will have their info
+ * @param *ops - instance specific operations
+ * @param namefmt - nameformat string for the main manager directory name (printf style)
+ * @param args - variable arguments list
+ * @return 0 upon success
+ */
+int tcmi_migman_init(struct tcmi_migman *self, struct kkc_sock *sock, 
+		     u_int32_t ccn_id, u_int32_t pen_id, 
+		     enum arch_ids peer_arch_type, struct tcmi_slot* manager_slot,
+		     struct tcmi_ctlfs_entry *root,
+		     struct tcmi_ctlfs_entry *migproc,
+		     struct tcmi_migman_ops *ops,
+		     const char namefmt[], va_list args)
+{
+	int err = -EINVAL;
+
+	minfo(INFO2, "Creating new TCMI migration manager");
+	atomic_set(&self->state, TCMI_MIGMAN_INIT);
+	self->ccn_id = ccn_id;
+	self->pen_id = pen_id;
+	self->manager_slot = manager_slot;
+	self->peer_arch_type = peer_arch_type;
+	atomic_set(&self->ref_count, 1);
+	tcmi_queue_init(&self->msg_queue);
+
+	get_random_bytes(&self->id, sizeof(u_int32_t));
+	self->ops = ops;
+	if (!ops) {
+		mdbg(ERR3, "Missing migration manager operations!");
+		goto exit0;
+	}
+	
+	if (!ops->process_msg) {
+		mdbg(ERR3, "Missing process message operation!");
+		goto exit0;
+	}
+
+	if (!(self->transactions = tcmi_slotvec_hnew(TRANSACTION_ORDER))) {
+		mdbg(ERR3, "Can't create transactions slotvector!");
+		goto exit0;
+	}
+	
+	if (!(self->tasks = tcmi_slotvec_hnew(TASK_ORDER))) {
+		mdbg(ERR3, "Can't create tasks slotvector!");
+		goto exit1;
+	} 
+
+	/* TCMI comm that accepts all types of messages */
+	if (!(self->comm = tcmi_comm_new(sock, tcmi_migman_deliver_msg, self, 
+					 TCMI_MSG_GROUP_ANY))) {
+		mdbg(ERR3, "Failed to create TCMI comm component!");
+		goto exit2;
+	}
+
+	if (tcmi_migman_init_ctlfs_dirs(self, root, migproc, namefmt, args) < 0) {
+		mdbg(ERR3, "Failed to create ctlfs directories!");
+		goto exit3;
+	}
+
+	mdbg(INFO4, "Creating symlink: self: %p root: %p sock %p",self, root, sock);
+        if (tcmi_migman_create_symlink(self, root, sock) < 0){
+                mdbg(ERR3, "Failed to create ctlfs symlink!");
+                goto exit4;
+        }
+
+	if (tcmi_migman_init_ctlfs_files(self) < 0) {
+		mdbg(ERR3, "Failed to create ctlfs files!");
+		goto exit4;
+	}
+	if (!(self->sock = tcmi_sock_new(self->d_conns, sock, "ctrlconn"))) {
+		mdbg(ERR3, "Failed to create a TCMI socket!");
+		goto exit5;
+	}
+
+	if (tcmi_migman_start_thread(self) < 0) {
+		mdbg(ERR3, "Failed to create message processing thread!");
+		goto exit6;
+	}
+	
+	return 0;
+
+	/* error handling */
+ exit6:
+	tcmi_sock_put(self->sock);
+ exit5:
+	tcmi_migman_stop_ctlfs_files(self);
+ exit4:
+	tcmi_migman_stop_ctlfs_dirs(self);
+ exit3:
+	tcmi_comm_put(self->comm);
+ exit2:
+	tcmi_slotvec_put(self->tasks);
+ exit1:
+	tcmi_slotvec_put(self->transactions);
+ exit0:
+	return err;
+}
+
+
+/** 
+ * \<\<public\>\> The manager is shutdown exactly in this order:
+ * - calls the free method specific to a particular migration manager
+ * - stop message receiving thread
+ * - destroy TCMI socket
+ * - unregister all ctlfs files as we don't want anymore requests 
+ * from users.
+ * - unregister all ctlfs directories
+ * - release the communication component
+ * - release the transaction slot vector - check for stale transactions
+ * - release the shadows slot vector
+ *
+ * @param *self - pointer to this migration manager instance
+ * @return Returns 1, if the instance was destroyed as a result of this call
+ */
+int tcmi_migman_put(struct tcmi_migman *self)
+{
+	if (self && atomic_dec_and_test(&self->ref_count)) {
+		mdbg(INFO3, "Shutting down the TCMI migration manager %p", self);
+		tcmi_migman_free(self);
+		kfree(self);
+		
+		return 1;
+	}
+	
+	return 0;
+}
+
+/** @addtogroup tcmi_migman_class
+ *
+ * @{
+ */
+
+/** Removes migman from a list of migration managers of the associated manager. */
+static void tcmi_migman_unhash(struct tcmi_migman *self) {
+      /** Check if we were not already unhashed */
+      if ( !tcmi_slot_node_unhashed(&self->node) ) {
+	  tcmi_slot_lock(self->manager_slot);
+	  tcmi_slot_remove_first(self, self->manager_slot, node);
+	  tcmi_slot_unlock(self->manager_slot);
+      }
+}
+
+
+/** 
+ * \<\<private\>\> Free method is has two purposes:
+ * -# when the last reference is released, it will free all
+ *    instance resources, except for the instance itself.
+ * -# calls the child class free method if defined
+ *
+ * Note: It is important to free communication channels first, i.e. communication socket, processing thread and files. This ensures,
+ * that no new messages that may require reference to migman for processing will arrive. File operations are synchronized with releasing
+ * so it may be possible that some file works with the migman during the free method, but only until the file is ''synchronously'' released.
+ */
+static void tcmi_migman_free(struct tcmi_migman *self)
+{ 
+	/* terminate the processing thread first to prevent any
+	 * message processing */
+	tcmi_migman_stop_thread(self);
+	/* also stop receiving all messages */
+	tcmi_comm_put(self->comm);
+
+	tcmi_migman_stop_ctlfs_files(self);
+	tcmi_migman_stop_ctlfs_dirs(self);
+	tcmi_sock_put(self->sock);
+	tcmi_migman_unhash(self);
+	
+
+	/* now we are safe and we can start cleaning the rest */
+	if (self->ops->free)
+		self->ops->free(self);
+				
+	/* TODO: check for stale transactions.. */
+	tcmi_slotvec_put(self->transactions);
+	/* Note: Assumes, all tasks are already migrated back. */
+	tcmi_slotvec_put(self->tasks);
+}
+
+/**
+ * Requests asynchronous shutdown of connection with peer.
+ * First, it asynchronously requests emigration of tasks to their home node, in case we are on detached node.
+ * Then it notifies peer about current node being disconnected.
+ * Finally, a self reference is dropped so that the migman is free to be destroyed when all tasks are finished
+ */
+void tcmi_migman_stop(struct tcmi_migman *self) {
+    tcmi_migman_stop_perform(self, 0);
+}
+
+static void tcmi_migman_notify_peer_disconnect(struct tcmi_migman *self) {
+    struct tcmi_msg* msg;
+    int err;
+
+    if ( !( msg = TCMI_MSG(tcmi_disconnect_msg_new_tx()) ) ) { 
+	    minfo(ERR3, "Error creating disconnect message");
+    } else {
+	if ((err = tcmi_msg_send_anonymous(msg, tcmi_migman_sock(self)))) {
+		minfo(ERR3, "Error sending disconnect message %d", err);
+	}
+	tcmi_msg_put(msg);
+    }	    
+}
+  
+/**
+ * Actual implementation of stop, see tcmi_migman_stop
+ * 
+ * @param remote_requested True, if stop request was initiated as a response to received disconnect message
+ * @Return 1, if the migman instance was destroyed in context of this method
+ */
+static int tcmi_migman_stop_perform(struct tcmi_migman *self, int remote_requested) {
+     minfo(INFO3, "Requesting stop of migration manager: %d Remote requested: %d", tcmi_migman_slot_index(self), remote_requested);
+     
+     if ( tcmi_migman_change_state(self, TCMI_MIGMAN_CONNECTED, TCMI_MIGMAN_SHUTTING_DOWN) ) {
+	/* We are the first to request stop operation */
+	
+	if (self->ops->stop)
+	    self->ops->stop(self, remote_requested);
+
+	if ( !remote_requested ) {
+	    /* Sent notification to peer about disconnection being performed.. even if this fails (peer may be dead already), we proceed further */
+	    tcmi_migman_notify_peer_disconnect(self);
+	}		
+	
+	/* Finally drop the reference to "self". If this is the last reference, the instance is going to be unhased and deleted.
+	   At this phase it is possible some tasks are still running and so they have reference to this instance. Asynchronous emigration requests were already issued */
+	return tcmi_migman_put(self);
+     } else {
+	minfo(INFO3, "Migration manager stop was already requested -> Ignoring this call. Manager state is: %d", tcmi_migman_state(self));
+     }
+     
+     return 0;
+}
+
+/** Sends a kill signal to all tasks managed by this manager */
+static void kill_all_tasks(struct tcmi_migman *self) {	
+  	struct tcmi_task* task;
+	struct tcmi_slot *slot;
+	tcmi_slot_node_t* node;
+
+	tcmi_slotvec_lock(self->tasks);
+	/* Iterate over all managed tasks */
+	tcmi_slotvec_for_each_used_slot(slot, self->tasks) {
+		tcmi_slot_for_each(node, slot) {
+			task = tcmi_slot_entry(node, struct tcmi_task, node);
+			mdbg(INFO3, "Killing task: local_pid=%d", tcmi_task_local_pid(task));			
+			tcmi_task_signal_peer_lost(task);
+		};
+	};
+	tcmi_slotvec_unlock(self->tasks);  
+}
+
+/**
+ * Kills all tasks associated with this migman and drops reference to the migman (in case it was not already shutting down).
+ * The method is useful in case peer died without cleaning up its own tasks, because we need to clean them up before we can release reference to peer.
+ * 
+ * @return 1, if the migman instance was destroyed in context of this method
+ */
+int tcmi_migman_kill(struct tcmi_migman *self) {
+     minfo(INFO3, "Requesting kill of migration manager: %d", tcmi_migman_slot_index(self));
+         
+     kill_all_tasks(self);
+
+     if ( tcmi_migman_change_state(self, TCMI_MIGMAN_CONNECTED, TCMI_MIGMAN_SHUTTING_DOWN) ) {
+	/* Stop operation was not yet requested -> request it. */
+	return tcmi_migman_put(self);
+     } else {
+	minfo(INFO3, "Migration manager stop was already requested -> Do not perform release this call. Manager state is: %d", tcmi_migman_state(self));
+     }
+
+          
+     return 0;
+}
+
+
+/** 
+ * \<\<private\>\> Creates the directories as described in \link
+ * tcmi_migman_class here \endlink. 
+ *
+ * @param *self - pointer to this migration manager instance
+ * @param *root - root directory where to create TCMI ctlfs entries
+ * @param *migproc - directory where the migrated process will have their info
+ * @param namefmt - nameformat string for the main manager directory name (printf style)
+ * @param args - arguments to the format string
+ * @return 0 upon success
+ */
+static int tcmi_migman_init_ctlfs_dirs(struct tcmi_migman *self,
+				       struct tcmi_ctlfs_entry *root,
+				       struct tcmi_ctlfs_entry *migproc,
+				       const char namefmt[], va_list args)
+
+{
+	mdbg(INFO4, "Creating directories");
+
+	if (!(self->d_migman = tcmi_ctlfs_dir_vnew(root, TCMI_PERMS_DIR, namefmt, args)))
+		goto exit0;
+
+	if (!(self->d_conns = 
+	      tcmi_ctlfs_dir_new(self->d_migman, TCMI_PERMS_DIR, "connections")))
+		goto exit1;
+
+	if (!(self->d_migproc = tcmi_ctlfs_entry_get(migproc))) {
+		mdbg(ERR3, "Missing migproc directory for migration manager!");
+		goto exit2;
+	}
+	if (self->ops->init_ctlfs_dirs && self->ops->init_ctlfs_dirs(self)) {
+		mdbg(ERR3, "Failed to create specific ctlfs directories!");
+		goto exit3;
+	}
+
+	return 0;
+
+	/* error handling */
+ exit3:
+	tcmi_ctlfs_entry_put(self->d_migproc);
+ exit2:
+	tcmi_ctlfs_entry_put(self->d_conns);
+ exit1:
+	tcmi_ctlfs_entry_put(self->d_migman);
+ exit0:
+	return -EINVAL;
+
+}
+
+
+/** 
+ * \<\<private\>\> Creates the static files described \link
+ * tcmi_migman_class here \endlink.
+ *
+ * @param *self - pointer to this migration manager instance
+ * @return 0 upon success
+ */
+static int tcmi_migman_init_ctlfs_files(struct tcmi_migman *self)
+{
+	mdbg(INFO4, "Creating files");
+
+	if (!(self->f_state = 
+	      tcmi_ctlfs_strfile_new(self->d_migman, TCMI_PERMS_FILE_R,
+				     self, tcmi_migman_show_state, NULL,
+				     TCMI_MIGMAN_STATE_LENGTH, "state")))
+		goto exit0;
+
+	if (!(self->f_stop = 
+	      tcmi_ctlfs_intfile_new(self->d_migman, TCMI_PERMS_FILE_W,
+				     self, NULL, tcmi_migman_stop_request,
+				     sizeof(int), "stop")))
+		goto exit1;
+
+	if (!(self->f_kill = 
+	      tcmi_ctlfs_intfile_new(self->d_migman, TCMI_PERMS_FILE_W,
+				     self, NULL, tcmi_migman_kill_request,
+				     sizeof(int), "kill")))
+		goto exit2;
+
+	if (self->ops->init_ctlfs_files && self->ops->init_ctlfs_files(self)) {
+		mdbg(ERR3, "Failed to create specific ctlfs files!");
+		goto exit3;
+	}
+
+	return 0;
+
+	/* error handling */
+ exit3:
+ 	tcmi_ctlfs_file_unregister(self->f_kill);
+	tcmi_ctlfs_entry_put(self->f_kill); 	
+ exit2:
+ 	tcmi_ctlfs_file_unregister(self->f_stop);
+	tcmi_ctlfs_entry_put(self->f_stop); 
+ exit1:
+	tcmi_ctlfs_file_unregister(self->f_state);
+	tcmi_ctlfs_entry_put(self->f_state);
+ exit0:
+	return -EINVAL;
+
+}
+
+
+/** 
+ * \<\<private\>\> Destroys all TCMI ctlfs directories
+ *
+ * @param *self - pointer to this migration manager instance
+ */
+static void tcmi_migman_stop_ctlfs_dirs(struct tcmi_migman *self)
+{
+	mdbg(INFO3, "Destroying  TCMI migmanager ctlfs directories");
+
+	if (self->ops->stop_ctlfs_dirs) 
+		self->ops->stop_ctlfs_dirs(self);
+
+	tcmi_ctlfs_entry_put(self->d_migman);
+	tcmi_ctlfs_entry_put(self->s_migman);
+	tcmi_ctlfs_entry_put(self->d_conns);
+	tcmi_ctlfs_entry_put(self->d_migproc);
+}
+
+/** 
+ *\<\<private\>\>  Unregisters and releases all control files.
+ *
+ * @param *self - pointer to this migration manager instance
+ */
+static void tcmi_migman_stop_ctlfs_files(struct tcmi_migman *self)
+{
+	mdbg(INFO3, "Destroying  TCMI migmanager ctlfs files");
+
+	if (self->ops->stop_ctlfs_files) 
+		self->ops->stop_ctlfs_files(self);
+
+	/* We have to use non-locking unregister, because the unregister could be called from this file's write method */
+	tcmi_ctlfs_file_unregister2(self->f_stop, TCMI_CTLFS_FILE_FROM_METHOD);
+	tcmi_ctlfs_entry_put(self->f_stop);
+	/* We have to use non-locking unregister, because the unregister could be called from this file's write method */
+	tcmi_ctlfs_file_unregister2(self->f_kill, TCMI_CTLFS_FILE_FROM_METHOD);
+	tcmi_ctlfs_entry_put(self->f_kill);
+
+	tcmi_ctlfs_file_unregister(self->f_state);
+	tcmi_ctlfs_entry_put(self->f_state);
+}
+
+/** 
+ * \<\<private\>\> Requests asynchronous shutdown of this migration manager
+ *
+ * @param *obj - this migration manager instance
+ * @param *data - ignored
+ * @return 0 upon success
+ */
+static int tcmi_migman_stop_request(void *obj, void *data) {
+    struct tcmi_migman *self = TCMI_MIGMAN(obj);
+    tcmi_migman_stop(self);
+    
+    return 0;
+}
+
+/** 
+ * \<\<private\>\> Requests asynchronous kill of this migration manager
+ *
+ * @param *obj - this migration manager instance
+ * @param *data - ignored
+ * @return 0 upon success
+ */
+static int tcmi_migman_kill_request(void *obj, void *data) {
+    struct tcmi_migman *self = TCMI_MIGMAN(obj);
+    tcmi_migman_kill(self);
+    
+    return 0;
+}
+
+/** 
+ * \<\<private\>\> Read method for the TCMI ctlfs - reports migration
+ * manager state.
+ *
+ * @param *obj - this migration manager instance
+ * @param *data - pointer to this migration manager instance
+ * @return 0 upon success
+ */
+static int tcmi_migman_show_state(void *obj, void *data)
+{
+	struct tcmi_migman *self = TCMI_MIGMAN(obj);
+	
+	mdbg(INFO3, "state %d, maxcount %d", tcmi_migman_state(self), TCMI_MIGMAN_STATE_COUNT);
+	if (tcmi_migman_state(self) < TCMI_MIGMAN_STATE_COUNT) {
+		strncpy((char*)data, 
+			tcmi_migman_states[tcmi_migman_state(self)], 
+			TCMI_MIGMAN_STATE_LENGTH);
+		mdbg(INFO3, "Displaying state %s", tcmi_migman_states[tcmi_migman_state(self)]);
+	}
+	return 0;
+}
+
+/**
+ * \<\<private\>\> Starts the listening thread. The kernel thread is
+ * started by using kernel services. No additional actions are needed.
+ *
+ * @param *self - pointer to this migration manager instance
+ * @return 0 upon sucessful thread creation 
+ */
+static int tcmi_migman_start_thread(struct tcmi_migman *self)
+{
+	int err = 0;
+
+	self->msg_thread = kthread_run(tcmi_migman_msg_thread, self, 
+				       "tcmi_migmsgd");
+	
+	if (IS_ERR(self->msg_thread)) {
+		err = -EINVAL;
+		goto exit0;
+	}
+	mdbg(INFO3, "Created message processing thread %p", self->msg_thread);
+
+	/* error hanlding */
+ exit0:
+	return err;
+}
+
+/**
+ * \<\<private\>\> The TCMI manager listening thread is to be
+ * terminated by forcing a signal and waiting for it to terminate.
+ * The thread notices the request from the manager and terminates.
+ *
+ * @param *self - pointer to this migration manager instance
+ */
+static void tcmi_migman_stop_thread(struct tcmi_migman *self)
+{
+
+	if (self->msg_thread) {
+		mdbg(INFO3, "Stopping message processing thread");
+		force_sig(SIGTERM, self->msg_thread);
+		
+		if ( self->msg_thread != current ) {
+		  /* We can only call stop if we are not actually the thread being stopped! */
+		  kthread_stop(self->msg_thread);
+		}
+		
+	}
+}
+
+
+/** 
+ * \<\<private\>\> Message delivering method that is called back from
+ * the receiving thread of TCMI comm component instance. This method
+ * is reponsible for delivering the message reliably to its
+ * destination which can be:
+ *
+ * - local migration manager message queue 
+ * - local migration manager transaction slot vector
+ * - TCMI task message queue 
+ * - TCMI task transaction slot vector
+ *
+ * @param *obj - pointer to the migration manager instance.
+ * passed to the TCMI comm component upon creation
+ * @param *m - points to the message that is to be delivered.
+ * @return 0 upon successful delivery
+ */
+static int tcmi_migman_deliver_msg(void *obj, struct tcmi_msg *m)
+{
+	int err = 0;
+	struct tcmi_migman *self = TCMI_MIGMAN(obj);
+	struct tcmi_task *task;
+
+	if (TCMI_MSG_GROUP(tcmi_msg_id(m)) == TCMI_MSG_GROUP_PROC) {
+		/* try finding the task based on PID  in the message */
+		pid_t pid = tcmi_procmsg_dst_pid(TCMI_PROCMSG(m));
+		mdbg(INFO3, "Process message %08x arrived as expected for PID=%d", 
+		     tcmi_msg_id(m), pid);
+		/* find task by PID */
+		if (!(task = tcmi_taskhelper_find_by_pid(pid))) {
+			mdbg(ERR2, "Can't find dest. task for msg ID=%08x", 
+			     tcmi_msg_id(m));
+			goto exit0;
+		}
+		/* Verify it belongs to us */
+		if (tcmi_task_migman_id(task) != tcmi_migman_id(self)) {
+			mdbg(ERR2, "Task(PID=%d, migman ID=%08x) doesn't belong"
+			     "to migration manager ID=%08x", tcmi_task_local_pid(task),
+			     tcmi_task_migman_id(task), tcmi_migman_id(self));
+			goto exit1;
+		}
+		err = tcmi_task_deliver_msg(task, m);
+		tcmi_task_put(task);
+	}
+	else {
+		mdbg(INFO3, "Delivering regular migration message %08x",
+		     tcmi_msg_id(m));
+		err = tcmi_msg_deliver(m, &self->msg_queue, self->transactions);
+	}
+
+	return err;
+
+	/* error handling */
+ exit1:
+	tcmi_task_put(task);
+ exit0:
+	return -EINVAL;
+}
+
+/**
+ * \<\<private\>\> Message processing thread.
+ * Sleeps on the message queue and notifies the migration manager
+ * instance to process each incoming message.
+ *
+ * @param *data - migration manager instance
+ * @return 0 upon successful thread termination.
+ */
+static int tcmi_migman_msg_thread(void *data)
+{
+	int err = 0;
+	int migman_freed = 0;
+	struct tcmi_msg *m;
+	struct tcmi_migman *self = TCMI_MIGMAN(data);
+	/* saves 2 derefences when calling the process msg method */
+	process_msg_t *process_msg = self->ops->process_msg;
+
+	if (!process_msg) {
+		mdbg(ERR3, "Missing method to process messages!");
+		goto exit0;
+	}
+
+
+	mdbg(INFO3, "Message processing thread up and running %p", current);
+	while (!(kthread_should_stop() || signal_pending(current))) {
+		if ((err = tcmi_queue_wait_on_empty_interruptible(&self->msg_queue)) < 0) {
+			minfo(INFO1, "Signal arrived %d", err);
+			break;
+		}
+		tcmi_queue_remove_entry(&self->msg_queue, m, node);
+		if (m) {
+			mdbg(INFO3, "Processing message..");
+			switch(tcmi_msg_id(m)) {
+  			    default:
+				process_msg(self, m);
+				break;
+
+			    case TCMI_DISCONNECT_MSG_ID:
+			        minfo(INFO3, "Received disconnect message");
+				/* 
+				  Initiate shutdown upon reception of disconnect message 
+				  Note: It is important not to touch self after this call and before should_stop is checked again, because self reference may be already invalid!
+				*/
+				migman_freed = tcmi_migman_stop_perform(self, 1);
+				break;
+			}
+		}
+		else {
+			mdbg(ERR3, "Processing thread woken up, queue is still empty..");
+		}
+	}
+ exit0:
+	/* In case the migman was freed by this thread, no should_stop sync is performed */
+	if ( !migman_freed ) {
+	    /* We have to wait for thread terminating us as it is going to call stop at some tim */
+	    wait_on_should_stop();
+	}
+	
+	mdbg(INFO3, "Message processing thread terminating");
+	return 0;
+}
+
+/** \<\<public\>\> Registers tcmi task into the migration manager tasks slotvec */
+int tcmi_migman_add_task(struct tcmi_migman *self, struct tcmi_task* task) {
+	u_int hash;
+
+	hash = tcmi_task_hash(tcmi_task_local_pid(task), tcmi_slotvec_hashmask(self->tasks));
+
+	//tcmi_slotvec_lock(self->tasks);
+	if ( !tcmi_slotvec_insert_at(self->tasks, hash, &task->node) ) {
+		//tcmi_slotvec_unlock(self->tasks);
+		minfo(ERR3, "Can't insert task into a migration manager slot vector!");
+		return -EINVAL;
+	}
+	//tcmi_slotvec_unlock(self->tasks);
+
+	mdbg(INFO3, "Inserted task PID=%d into slot with hash %d", tcmi_task_local_pid(task), hash);
+
+	return 0;
+}
+
+/** \<\<public\>\> Removes tcmi task from the migration manager tasks slotvec */
+int tcmi_migman_remove_task(struct tcmi_migman *self, struct tcmi_task* task) {
+	u_int hash;
+	struct tcmi_slot* slot;
+
+	hash = tcmi_task_hash(tcmi_task_local_pid(task), tcmi_slotvec_hashmask(self->tasks));
+	
+	//tcmi_slotvec_lock(self->tasks);
+	slot = tcmi_slotvec_at(self->tasks, hash);
+
+	if ( !slot ) {
+		//tcmi_slotvec_unlock(self->tasks);
+		minfo(ERR3, "Failed to remove task slotvec in migman tasks");
+		return -EINVAL;
+	}
+
+	tcmi_slot_remove(slot, &task->node);
+	//tcmi_slotvec_unlock(self->tasks);
+
+	mdbg(INFO3, "Removed task PID=%d from slot with hash %d", tcmi_task_local_pid(task), hash);
+
+	return 0;
+}
+
+int tcmi_migman_create_symlink(struct tcmi_migman *self, struct tcmi_ctlfs_entry * root, struct kkc_sock *sock)
+{
+        char n[KKC_SOCK_MAX_ADDR_LENGTH];
+        //char * n = kmalloc(KKC_SOCK_MAX_ADDR_LENGTH,GFP_KERNEL);
+        int i = KKC_SOCK_MAX_ADDR_LENGTH;
+        mdbg(INFO4,"tcmi_migman_create_symlink");
+        kkc_sock_getpeername(sock,n,KKC_SOCK_MAX_ADDR_LENGTH);
+        while(i>-1 && n[i]!=':')i--;
+        if(i>-1 && n[i] == ':')n[i]=0;
+        if(!(self->s_migman=tcmi_ctlfs_symlink_new(root,self->d_migman,n))){
+                return -EINVAL;
+        }
+        return 0;
+}
+
+
+/** String descriptor for the states of migration manager */
+static char *tcmi_migman_states[] = {
+	"Init",
+	"Connected",
+	"Shutting down",
+	"Shutdown"
+};
+
+
+/**
+ * @}
+ */
+
+
--- linux-3.7.1_original/clondike/src/tcmi/ctlfs/tcmi_ctlfs_dir.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/ctlfs/tcmi_ctlfs_dir.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,80 @@
+/**
+ * @file tcmi_ctlfs_dir.h - Declaration of a class that represents directory
+ *                          class in tcmifs. This class extends tcmi_ctlfs_entry
+ * 
+ * 
+ * 
+ * 
+ * 
+ * 
+ *
+ * Date: 03/26/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_ctlfs_dir.h,v 1.2 2007/07/02 02:26:17 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef TCMI_CTLFS_DIR_H
+#define TCMI_CTLFS_DIR_H
+
+#include "tcmi_ctlfs_entry.h"
+
+/** @defgroup tcmi_ctlfs_dir_class tcmi_ctlfs_dir class 
+ * 
+ * @ingroup tcmi_ctlfs_entry_class
+ * 
+ * This class represents a directory in the tcmi control file system.
+ * It provides a functionality to instantiate a root directory and
+ * regular directories. The root directory is special as it doesn't
+ * have a parent entry.
+ *
+ *@{
+ */
+
+/**
+ * A directory compound structure, extends the parent entry class.
+ */
+struct tcmi_ctlfs_dir {
+	/** parent class instance */
+	struct tcmi_ctlfs_entry super;
+};
+
+
+/** \<\<public\>\> Creates a new directory instance. */
+extern struct tcmi_ctlfs_entry* tcmi_ctlfs_dir_new(struct tcmi_ctlfs_entry *parent,
+						   mode_t mode, const char namefmt[], ...);
+
+/** \<\<public\>\> Creates a new directory instance - va_list version. */
+struct tcmi_ctlfs_entry* tcmi_ctlfs_dir_vnew(struct tcmi_ctlfs_entry *parent,
+					     mode_t mode, const char namefmt[], 
+					     va_list args);
+
+/** \<\<public\>\> Creates a root directory instance. */
+extern struct tcmi_ctlfs_entry* tcmi_ctlfs_rootdir_new(struct super_block *sb);
+
+/** Casts an entry to directory */
+#define TCMI_CTLFS_DIR(e) ((struct tcmi_ctlfs_dir *)e)
+
+/**
+ * @}
+ */
+	
+
+#endif /* TCMI_CTLFS_DIR_H */
--- linux-3.7.1_original/clondike/src/tcmi/ctlfs/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/ctlfs/Makefile	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,25 @@
+##############################################################################
+# @file Makefile - Builds Control Filesystem
+#
+# Author: Petr Malat
+#
+# This file is part of Clondike.
+#
+# Clondike is free software: you can redistribute it and/or modify it under 
+# the terms of the GNU General Public License version 2 as published by 
+# the Free Software Foundation.
+#
+# Clondike is distributed in the hope that it will be useful, but WITHOUT ANY
+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
+# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more 
+# details.
+# 
+# You should have received a copy of the GNU General Public License along with 
+# Clondike. If not, see http://www.gnu.org/licenses/.
+##############################################################################
+
+ccflags-y = `dbgenv $<`
+
+obj-$(CONFIG_TCMI) := tcmictlfs.o
+tcmictlfs-objs     := tcmi_ctlfs.o tcmi_ctlfs_entry.o tcmi_ctlfs_dir.o \
+		      tcmi_ctlfs_file.o tcmi_ctlfs_symlink.o  
--- linux-3.7.1_original/clondike/src/tcmi/ctlfs/tcmi_ctlfs.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/ctlfs/tcmi_ctlfs.c	2013-03-12 15:24:25.000000000 +0100
@@ -0,0 +1,311 @@
+/**
+ * @file tcmi_ctlfs.c - TCMI control file system module provides basic super
+ *                      block handling and is responsible for root directory
+ *                      instantiation.
+ * 
+ *
+ *
+ * Date: 03/26/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_ctlfs.c,v 1.3 2007/10/07 15:54:00 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/pagemap.h>
+#include <linux/slab.h>
+
+#include "tcmi_ctlfs_dir.h"
+#define TCMI_CTLFS_PRIVATE
+#include "tcmi_ctlfs.h"
+
+
+#include <dbg.h>
+
+
+/** Magic number identifies the fs super block */
+#define TCMI_CTLFS_MAGIC 0x20050326
+
+
+
+
+/**
+ * \<\<public\>\> Root entry accessor. If the filesystem has not been
+ * activated yet, a kernel mount is performed. The kernel mount in
+ * turn ensures instantiation of the root directory. A user might have
+ * already mounted the filesystem from userspace. This is not a
+ * problem as we allow only one instance of the filesystem in
+ * memory(enforced by get_sb_single()), so only a reference counter of
+ * the root directory and the associated superblock is
+ * incremented. The last thread that releases the last reference to
+ * the super block and eventually to the root directory causes the
+ * whole filesystem to be released. See tcmi_ctlfs_kill_super() for
+ * details on this.
+ *
+ * If the filesystem is already active (the vfs_mnt is valid), the
+ * mount reference count is adjusted.
+ *
+ * It is necessary to protect the vfs_mnt variable as it can be
+ * manipulated by other threads that might issue tcmi_ctlfs_put_root()
+ * and release the vfs mount from under us.
+ *
+ * @return pointer to the root entry (reference counter adjusted by
+ * tcmi_ctlfs_entry_get()) or NULL
+ */
+struct tcmi_ctlfs_entry* tcmi_ctlfs_get_root(void)
+{
+	down(&self.vfs_mnt_sem);
+	/* when the VFS mount is currently inactive we have to create
+	 * a new one */
+	if (!self.vfs_mnt) {
+		mdbg(INFO3, "Mounting");
+		self.vfs_mnt = kern_mount(&self.fs_type);
+		if (IS_ERR(self.vfs_mnt)) {
+			minfo(ERR1, "Could not mount!");
+			self.vfs_mnt = NULL;
+			/* if the mount failed, the root directory
+			 * instance doesn't exist too, so we don't
+			 * need to explicitely delete it*/
+			self.root_dir = NULL;
+		}
+	} 
+	/* VFS mount still active, just increment its ref. counter */
+	else
+		mntget(self.vfs_mnt);
+	up(&self.vfs_mnt_sem);
+
+	mdbg(INFO3, "sb c_count=%d, s_active=%d", self.sb->s_count, 
+	     atomic_read(&self.sb->s_active));
+	//mdbg(INFO3, "mount mnt_count=%d", atomic_read(&self.vfs_mnt->mnt_count));
+	return tcmi_ctlfs_entry_get(self.root_dir);
+}
+
+/**
+ * \<\<public\>\> Releases the root directory and then the mount
+ * object.  VFS takes care of releasing the object in case their
+ * reference count reaches 0. We need to take care of setting the
+ * mnt to NULL.
+ * 
+ * The last 2 steps don't need to be semaphore protected as we are
+ * working on copies of both pointers and we wanted to protect the
+ * access to mnt only. If anybody tries to get a root from now on
+ * a new VFS mount will be created. If the root directory has been
+ * also destroyed, the read_super method takes care of instantiating a
+ * new super block along with the root directory.
+ */
+void tcmi_ctlfs_put_root(void)
+{
+	struct vfsmount *cur_vfs_mnt;
+	struct tcmi_ctlfs_entry *cur_root_dir;
+	mdbg(INFO3, "sb c_count=%d, s_active=%d", self.sb->s_count, 
+	     atomic_read(&self.sb->s_active));
+	//mdbg(INFO3, "mount mnt_count=%d", atomic_read(&self.vfs_mnt->mnt_count));
+
+	/* mdbg(INFO3, "root d_count=%d", atomic_read(&self.root_dir->super.dentry->d_count));*/
+
+	down(&self.vfs_mnt_sem);
+	cur_vfs_mnt = self.vfs_mnt;
+	cur_root_dir = self.root_dir;
+	/* If we are the last thread accesing the kernel mount */
+	//if (atomic_read(&self.vfs_mnt->mnt_count) == 1)     Commented by Jiri Rakosnik mnt_count doesn't exist in struct vfsmount
+		//self.vfs_mnt = NULL;
+
+	up(&self.vfs_mnt_sem);
+
+	/* no locking needed since working on copies of both
+	 * pointers */
+	tcmi_ctlfs_entry_put(cur_root_dir);
+	mntput(cur_vfs_mnt);
+}
+
+
+/** @addtogroup tcmi_ctlfs_class
+ *
+ * @{
+ */
+
+static struct kmem_cache *ctlfs_inode_cachep;
+
+static void init_once(void *foo) {
+         struct inode *inode = (struct inode *) foo;
+ 
+         inode_init_once(inode);
+ }
+
+/*
+ * Overriden in order to perform GFP_ATOMIC allocation
+ */
+#if 0
+static struct inode *tcmi_ctlfs_alloc_inode(struct super_block *sb)
+{
+	struct inode* res;
+	mdbg(INFO4, "TMPDBG: BEFORE ALLOC");
+	res = kmem_cache_alloc(ctlfs_inode_cachep, GFP_ATOMIC);
+	mdbg(INFO4, "TMPDBG: AFTER ALLOC: %p", res);
+
+	if (!res) {
+		return NULL;
+	}
+
+	return res;
+}
+
+/** Must also override corresponding destroy method */
+static void tcmi_ctlfs_destroy_inode(struct inode *inode) {
+	mdbg(INFO4, "TMPDBG: BEFORE FREE %p", inode);
+	kmem_cache_free(ctlfs_inode_cachep, inode);
+	mdbg(INFO4, "TMPDBG: AFTER FREE");
+}
+#endif
+
+static int init_inodecache(void)
+{
+	ctlfs_inode_cachep = kmem_cache_create("ctlfs_inode_cache", sizeof(struct inode), 0, (SLAB_RECLAIM_ACCOUNT| SLAB_MEM_SPREAD), init_once);
+	if (ctlfs_inode_cachep == NULL)
+		return -ENOMEM;
+
+	return 0;
+}
+
+static void destroy_inodecache(void)
+{
+	kmem_cache_destroy(ctlfs_inode_cachep);
+}
+
+
+static struct super_operations s_ops = {
+	.statfs = simple_statfs,
+//	.alloc_inode = tcmi_ctlfs_alloc_inode,
+	//.destroy_inode = tcmi_ctlfs_destroy_inode,
+};
+
+/**
+ * \<\<private\>\> Sets up super block and instantiates the root
+ * directory. This method is called only once through out the super
+ * block life.
+ *
+ * @param sb - pointer to the super block
+ * @param *data - custom data supplied when reading the superblock(not used)
+ * @param silent - required by VFS, no idea what it means.
+ * 
+ * @return 0 upon success
+ */
+static int tcmi_ctlfs_fill_super(struct super_block *sb, void *data, int silent)
+{
+	sb->s_blocksize = PAGE_CACHE_SIZE;
+	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
+	sb->s_magic = TCMI_CTLFS_MAGIC;
+	sb->s_op = &s_ops;
+	self.sb = sb;
+mdbg(INFO4, "TMPDBG: GOING TO REQUEST ROOT");
+	self.root_dir = tcmi_ctlfs_rootdir_new(sb);
+mdbg(INFO4, "TMPDBG: ROOT SUCCEEDED");
+	return 0;
+}
+
+/**
+ * \<\<private\>\> Super block as assigned a nonexistent device and
+ * the super block is obtained via mount_single(). The kernel
+ * function mount_single() ensures that only 1 instance of the
+ * filesystem can be mounted at a time.  Custom method to fill the
+ * super block is passed as parameter.
+ *
+ * @param *fst - points to the file system type, that is being mounted
+ * @param flags - 
+ * @param *devname - device name, on which the file system resides (it has no meaning here)
+ * @param *data - pointer to private filesystem data - not used
+ *
+ * @return - pointer to the dentry object that has been created
+ */
+ //Replaced function get_sb_single to mount_single and small fix remove vfsmount parameter, return value is pointer to struct dentry | by Jiri Rakosnik  
+static struct dentry* tcmi_ctlfs_get_super(struct file_system_type *fst,
+						int flags, const char *devname, void *data)
+{
+	return mount_single(fst, flags, data, tcmi_ctlfs_fill_super);
+}
+
+/**
+ * Module initialization
+ *
+ * @return - status of the register_filesystem() call
+ */
+static int __init tcmi_ctlfs_init(void)
+{
+	int error;
+	minfo(INFO3, "Registering TCMI control filesystem");
+	error = init_inodecache();
+	if (error)
+		return error;
+
+	error = register_filesystem(&self.fs_type);
+
+	return error;
+}
+
+/**
+ * module cleanup
+ */
+static void __exit tcmi_ctlfs_exit(void)
+{
+	minfo(INFO3, "Unregistering TCMI control filesystem");
+	destroy_inodecache();
+	unregister_filesystem(&self.fs_type);
+}
+
+
+
+/** \<\<singleton\>\> instance initialization */
+static struct tcmi_ctlfs self = {
+	/** Root directory of the TCMI control filesystem. */
+	.root_dir = NULL,
+	/** This semaphore protects the vfs_mount value */
+	.vfs_mnt_sem = __SEMAPHORE_INITIALIZER( self.vfs_mnt_sem, 1 ),
+	/** Filesystem mount object */
+	.vfs_mnt = NULL,
+	/** Filesystem super block object */
+	.sb = NULL,
+	/** File system type descriptor, only get_sb method is needed
+	 * to be customized
+	 */
+	.fs_type = {
+		.owner          = THIS_MODULE,
+		.name           = "tcmi_ctlfs",
+		.mount          = tcmi_ctlfs_get_super,
+		.kill_sb        = kill_litter_super, 
+	},
+};
+
+/**
+ * @}
+ */
+
+module_init(tcmi_ctlfs_init);
+module_exit(tcmi_ctlfs_exit);
+
+EXPORT_SYMBOL_GPL(tcmi_ctlfs_get_root);
+EXPORT_SYMBOL_GPL(tcmi_ctlfs_put_root);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Jan Capek");
+
--- linux-3.7.1_original/clondike/src/tcmi/ctlfs/tcmi_ctlfs_file.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/ctlfs/tcmi_ctlfs_file.c	2013-03-11 20:24:36.000000000 +0100
@@ -0,0 +1,484 @@
+/**
+ * @file tcmi_ctlfs_file.c - Definition of a class that represents file
+ *                          class in tcmifs. This class extends tcmi_ctlfs_entry
+ * 
+ * 
+ * 
+ * 
+ * 
+ * 
+ *
+ * Date: 03/28/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_ctlfs_file.c,v 1.3 2007/09/02 13:23:43 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+
+#define TCMI_CTLFS_FILE_PRIVATE
+#include "tcmi_ctlfs_file.h"
+
+#include <dbg.h>
+
+
+/** 
+ * \<\<public\>\> Creates a new instance of a file. The file will be
+ * used as an interface of the registered object to the user space. It
+ * allows calling object methods and pass integer numbers as arguments
+ * in ascii form.
+ * 
+ * For conversion ascii<->integer, the proc_dointvec() function is used from
+ * kernel/sysctl.c
+ *
+ * @param *parent - pointer to the parent entry - has to be a directory
+ * @param *mode - access rights for the inode
+ * @param *object - points to the object that creates the file
+ * @param *read_method - method of the file creator that will be called upon file read
+ * @param *write_method - method of the file creator that will be called upon file write
+ * @param maxlen - maximum length of the data in bytes
+ * @param namefmt - nameformat string (printf style)
+ * @return pointer to the new file or NULL
+ */
+struct tcmi_ctlfs_entry* tcmi_ctlfs_intfile_new(struct tcmi_ctlfs_entry *parent,
+						mode_t mode,
+						void *object,
+						object_method *read_method,
+						object_method *write_method,
+						int maxlen,
+						const char namefmt[], ...)
+
+{
+	struct tcmi_ctlfs_entry *file;
+	va_list args;
+	va_start(args, namefmt);
+	file = tcmi_ctlfs_genericfile_new(parent, mode, object,
+					  read_method, write_method,
+					  maxlen, proc_dointvec, namefmt, args);
+	va_end(args);
+	return file;
+}
+
+/** 
+ * \<\<public\>\> Creates a new instance of a file. The file will be
+ * used as an interface of the registered object to the user space. It
+ * allows calling object methods and pass strings as an argument.
+ * 
+ * For conversion overflow checking and newlines conversions are
+ * handled by proc_dostring(). The function is used from
+ * kernel/sysctl.c
+ *
+ * @param *parent - pointer to the parent entry - has to be a directory
+ * @param *mode - access rights for the inode
+ * @param *object - points to the object that creates the file
+ * @param *read_method - method of the file creator that will be called upon file read
+ * @param *write_method - method of the file creator that will be called upon file write
+ * @param maxlen - maximum length of the data in bytes
+ * @param namefmt - nameformat string (printf style)
+ * @return pointer to the new file or NULL
+ */
+struct tcmi_ctlfs_entry* tcmi_ctlfs_strfile_new(struct tcmi_ctlfs_entry *parent,
+					       mode_t mode,
+					       void *object,
+					       object_method *read_method,
+					       object_method *write_method,
+					       int maxlen,
+					       const char namefmt[], ...)
+{
+	struct tcmi_ctlfs_entry *file;
+	va_list args;
+	va_start(args, namefmt);
+	file = tcmi_ctlfs_genericfile_new(parent, mode, object,
+					  read_method, write_method,
+					  maxlen, proc_dostring, namefmt, args);
+	va_end(args);
+	return file;
+}
+
+/** 
+ * \<\<public\>\> Creates a raw file instance.  The file will be used
+ * as an interface of the registered object to the user space. It
+ * allows calling object methods and passing raw unprocessed data as
+ * an argument.
+ * 
+ * @param *parent - pointer to the parent entry - has to be a directory
+ * @param *mode - access rights for the inode
+ * @param *object - points to the object that creates the file
+ * @param *read_method - method of the file creator that will be called upon file read
+ * @param *write_method - method of the file creator that will be called upon file write
+ * @param maxlen - maximum length of the data in bytes
+ * @param namefmt - nameformat string (printf style)
+ * @return pointer to the new file or NULL
+ * @note Currently not implemented
+ */
+struct tcmi_ctlfs_entry* tcmi_ctlfs_rawfile_new(struct tcmi_ctlfs_entry *parent,
+						mode_t mode,
+						void *object,
+						object_method *read_method,
+						object_method *write_method,
+						int maxlen,
+						const char namefmt[], ...)
+{
+	return NULL;
+}
+
+
+/** 
+ * \<\<public\>\> This method unregisters the file uses the semaphore
+ * lock as protection from races. This is the prefered way of
+ * detaching the file from an object. If the file is to unregister
+ * itself (e.g. from inside the registered object's methods), the
+ * previous version is recommended to prevent deadlocks.
+ *
+ * @param *self - pointer to this file instance
+ */
+void tcmi_ctlfs_file_unregister(struct tcmi_ctlfs_entry *self) 
+{
+	struct tcmi_ctlfs_file *self_f = TCMI_CTLFS_FILE(self);
+	if (self_f) {
+		tcmi_ctlfs_file_lock(self_f);
+		__tcmi_ctlfs_file_unregister(self);
+		tcmi_ctlfs_file_unlock(self_f);
+
+	}
+}
+
+
+/** 
+ * \<\<public\>\> This method unregisters the file and allows the user
+ * to specify the preferred way of unregistration (w/ or w/o the
+ * lock). It is typically used if owning object uses this file is for
+ * unregistering other files including this file.  All work is
+ * delegate to either __tcmi_ctlfs_file_unregister() or
+ * tcmi_ctlfs_file_unregister()
+ *
+ * @param *self - pointer to this file instance
+ * @param unreg - describes a unregistration type, if a regular shutdown
+ * is requested, the file is unregistered using the lock version. A file
+ * unregistrationn from inside the registered object's method requires using
+ * a lock free version. The access to the file is already serialized.
+ */
+void tcmi_ctlfs_file_unregister2(struct tcmi_ctlfs_entry *self, 
+				 tcmi_ctlfs_file_unreg_t unreg) 
+{
+	/* unregistration issued from owning object's method, no locking */
+	if (unreg == TCMI_CTLFS_FILE_FROM_METHOD)
+		__tcmi_ctlfs_file_unregister(self);
+	/* default case - explicit unregistration , requires locking*/
+	else
+		tcmi_ctlfs_file_unregister(self);
+}
+
+/** @addtogroup tcmi_ctlfs_file_class
+ *
+ * @{
+ */
+
+/** 
+ * \<\<private\>\> This is a generic method, that creates a new
+ * instance of a file as follows:
+ *
+ * - allocates a new instance and delegates the entry initialization to
+ * the parent class. There is a custom tcmi_ctlfs_ops vector as file
+ * destruction needs special handling. There are also file and inode
+ * specific operations.
+ * - allocates file associated data
+ * - registers the object and its 2 methods with the file. None of
+ * the methods are mandatory
+ * - there is a custom entry_free operation that releases the 
+ * above allocated file data upon file destruction
+ * - proc_handler is associated with the data, so that ascii data
+ * can be parsed when passing from/to the object's read/write method
+ * 
+ *
+ * @param *parent - pointer to the parent entry - has to be a directory
+ * @param *mode - access rights for the inode
+ * @param *object - points to the object that creates the file
+ * @param *read_method - method of the file creator that will be called upon file read
+ * @param *write_method - method of the file creator that will be called upon file write
+ * @param maxlen - maximum length of the data in bytes
+ * @param *proc_handler - data parsing handler that does the conversion from/to ascii
+ * @param namefmt - nameformat string (printf style)
+ * @param args - arguments to the format string
+ * @return pointer to the new file or NULL
+ */
+static struct tcmi_ctlfs_entry* tcmi_ctlfs_genericfile_new(struct tcmi_ctlfs_entry *parent,
+							  mode_t mode,
+							  void *object,
+							  object_method *read_method,
+							  object_method *write_method,
+							  int maxlen,
+							  proc_handler *proc_handler,
+							  const char namefmt[], va_list args)
+{
+	struct tcmi_ctlfs_file *file;
+	mdbg(INFO4, "Creating new file");
+
+	if (!(file = kmalloc(sizeof(struct tcmi_ctlfs_file), GFP_ATOMIC))) {
+		mdbg(ERR3, "Failed to allocate memory for file");
+		goto exit0;
+	}
+	if (tcmi_ctlfs_entry_init(TCMI_CTLFS_ENTRY(file), 
+				  TCMI_CTLFS_ENTRY(parent), 
+				  S_IFREG | mode, 
+				  &tcmi_ctlfs_file_ops, 
+				  &tcmi_ctlfs_file_inode_operations,
+				  &tcmi_ctlfs_file_operations, namefmt, args)) {
+		mdbg(ERR3, "Failed to create the file");
+		goto exit1;
+	}
+	if (!(file->data = kmalloc(maxlen, GFP_ATOMIC))) {
+		mdbg(ERR3, "Failed to allocate %d bytes of file data", maxlen);
+		goto exit2;
+	}
+	file->maxlen = maxlen;
+	sema_init(&file->f_sem, 1); //Replaced macro init_MUTEX to sema_init for kernel 3.7.x | by Jiri Rakosnik
+	/* object associated with the file */
+	file->object = object;
+	file->read_method = read_method; /*TESTING */
+	file->write_method = write_method; /*TESTING */
+	file->proc_handler = proc_handler; /* TESTING */
+	/* indicates a valid object has registered with the file */
+	file->unregistered = 0; 
+	return TCMI_CTLFS_ENTRY(file);
+
+	/* error handling */
+ exit2:
+	kfree(file->data);   
+ exit1:
+	kfree(file);
+ exit0:
+	return NULL;
+}
+
+/** 
+ * \<\<private\>\> This method is used to free the data associated with
+ * the file. No explicit locking is needed since:
+ * - the semaphore is already held by the unregister function or
+ * - the method of the registered object is currently executing and the file
+ * protects itself and this is an attempt to destroy the file from inside the
+ * object method.
+ * 
+ * @param *entry - points to the file that is to be freed
+ * @return 0 upon succes.
+ */
+static void tcmi_ctlfs_file_release(struct tcmi_ctlfs_entry *entry)
+{
+	struct tcmi_ctlfs_file *file = TCMI_CTLFS_FILE(entry);
+	
+	mdbg(INFO4, "Freeing file associated data(%p)", file->data);
+	kfree(file->data);
+	file->data = NULL;
+
+}
+
+
+/** 
+ * \<\<private\>\> The read file operation, called by the read system call. 
+ * The access to the file associated data is serialized, so that the
+ * object method always receives consistent data.
+ * - Read requests are possible only from offset (ppos) 0.
+ * - Initial check whether an object is already unregistered with the file is 
+ *   performed. This is to prevent calling the method when the the object is
+ *   currently detaching from the file. The associated object might have already 
+ *   taken steps that don't allow calling the read method - E.g. has already
+ *   woken up the sleeping process and doesn't want another process to call
+ *   the method again.
+ * - The registered object is first sent a read request and data 
+ *   is returned
+ * - The data is then processed by the proc_handler. It is necessary 
+ *   to setup the ctl_table, so that the we can reuse the sysctl.c
+ *   data parsing code for integers and strings.
+ *
+ * @param *filp - pointer to the kernel file object that is being read
+ * @param *buf - user buffer where to store the result
+ * @param count - number of bytes to be read
+ * @param *ppos - pointer to the current position in the file
+ * @return - when >= 0 - number of bytes written, the result from the proc_handler
+ * is usually 0, just to denote success converting from binary to ascii
+ *           when <  0 - error
+ */
+static ssize_t tcmi_ctlfs_file_read(struct file *filp, char __user *buf,
+				    size_t count, loff_t *ppos)
+{
+	struct tcmi_ctlfs_file *file = 
+		TCMI_CTLFS_FILE(TCMI_CTLFS_DENTRY_TO_ENTRY(filp->f_dentry));
+	size_t res;
+	ssize_t error = 0;
+	
+	struct ctl_table tbl = {
+		.data = file->data,
+		.maxlen = file->maxlen,
+	};
+	mdbg(INFO4, "file read in progress count=%lu, ppos=%Ld", (unsigned long)count, *ppos);
+	if (tcmi_ctlfs_file_lock_interruptible(file)) {
+		error = -ERESTARTSYS;
+		goto exit0;
+	}
+	/* when object unregistering is in progress don't start any operation */
+	if (file->unregistered)
+		goto exit1;
+	/* when trying from other position than 0, reset the file position and quit */
+	if (*ppos) {
+		*ppos = 0;
+		goto exit1;
+	}
+	if (file->read_method)
+		if ((error = file->read_method(file->object, file->data)))
+			goto exit1;
+	if (file->proc_handler) {
+		/* res is in/out parameter, initially stores the number of requested bytes.
+		 The handler then returns the number of bytes really processed */
+		res = count;
+		if ((error = file->proc_handler(&tbl, 0, buf, &res, ppos)))
+			goto exit1;
+		error = (ssize_t)res;
+	}
+
+ exit1:
+	tcmi_ctlfs_file_unlock(file);
+	/* signal arrived, semaphore still busy */
+ exit0: 
+	return error;
+}
+
+/**
+ * \<\<private\>\> The write file operation, called by the write system call. 
+ * The access to the file associated data is serialized, so that the
+ * object method always receives consistent data.
+ * - Initial check whether an object is already unregistered with the file is 
+ *   performed. This is to prevent calling the method when the the object is
+ *   currently detaching from the file. The associated object might have already 
+ *   taken steps that don't allow calling the write method - E.g. has already
+ *   woken up the sleeping process and doesn't want another process to call
+ *   the method again.
+ * - The requested file offset can be arbitrary, but must not exceed
+ *   the size of the data assoicated with the file - handled by the 
+ *   proc_handler
+ * - The data is first processed by the proc_handler. It is necessary
+ *   to setup the ctl_table, so that the we can reuse the sysctl.c
+ *   data parsing code for integers and strings.
+ * - Finally, the registered object is notified about the write event
+ *   and the data is passed to it.
+ *
+ * @param *filp - pointer to the kernel file object that is being written
+ * @param *buf - user buffer where to take the source data
+ * @param count - number of bytes to be written
+ * @param *ppos - pointer to the current position in the file
+ * @return - when >= 0 - number of bytes written, the result from the proc_handler
+ * is usually 0, just to denote success converting the ascii data to binary
+ *           when <  0 - error
+ */
+static ssize_t tcmi_ctlfs_file_write(struct file *filp, const char __user *buf,
+				    size_t count, loff_t *ppos)
+{
+	struct tcmi_ctlfs_file *file = 
+		TCMI_CTLFS_FILE(TCMI_CTLFS_DENTRY_TO_ENTRY(filp->f_dentry));
+	size_t res;
+	ssize_t error = 0;
+
+	struct ctl_table tbl = {
+		.data = file->data,
+		.maxlen = file->maxlen,
+	};
+	mdbg(INFO4, "file write in progress count=%lu, ppos=%Ld", (unsigned long)count, *ppos);
+	if (tcmi_ctlfs_file_lock_interruptible(file)) {
+		error = -ERESTARTSYS;
+		goto exit0;
+	}
+	/* when object unregistering is in progress don't start any operation */
+	if (file->unregistered)
+		goto exit1;
+	if (file->proc_handler) {
+		res = count;
+		if ((error = file->proc_handler(&tbl, 1, (char __user *)buf, &res, ppos)))
+			goto exit1;
+	}
+	if (file->write_method) {
+		if ((error = file->write_method(file->object, file->data)))
+			goto exit1;
+		error = (ssize_t)res;
+	}
+ exit1:
+	tcmi_ctlfs_file_unlock(file);
+	/* signal arrived, semaphore still busy */
+ exit0: 
+	return error;
+}
+
+/** 
+ * This method is used when object associated with the file wants to
+ * unregister with the file.  The calling object is responsible for waking 
+ * up a user process currently using this file (e.g. that have it open
+ * and might be sleeping in the read/write methods of the object). 
+ *
+ * This method assumes, that the file lock is already held by the
+ * caller. A typical use can be when the file is supposed to destroy
+ * itself upon user reading from or writing into the file (from inside
+ * the registered object's methods).
+ *
+ * The unregistration requires resetting read/write methods and
+ * associated proc_handler and object pointer. The unregistered flag
+ * ensures that the methods will be ignored on the next read/write issued
+ * by any user process. 
+ *
+ * @param *self - pointer to this file instance
+ */
+static void __tcmi_ctlfs_file_unregister(struct tcmi_ctlfs_entry *self) 
+{
+	struct tcmi_ctlfs_file *self_f = TCMI_CTLFS_FILE(self);
+	if (self_f) {
+		/* in case the object hasn't set the unregistered flag in advance */
+		tcmi_ctlfs_file_unregister_prepare(self);
+		self_f->object = NULL;
+		self_f->read_method = NULL;
+		self_f->write_method = NULL;
+		self_f->proc_handler = NULL;
+	}
+}
+
+/** A file requires special entry operations to free all resources. */
+static struct tcmi_ctlfs_ops tcmi_ctlfs_file_ops = {
+	.entry_release = tcmi_ctlfs_file_release,
+}; 
+/** File operations for VFS. */
+static struct file_operations tcmi_ctlfs_file_operations = {
+	.read		= tcmi_ctlfs_file_read,
+	.write		= tcmi_ctlfs_file_write,
+};
+
+/** Inode operations for VFS, the only method getattr is taken from fs/libfs\.c. */
+static struct inode_operations tcmi_ctlfs_file_inode_operations = {
+	.getattr	= simple_getattr,
+};
+
+/**
+ * @}
+ */
+
+
+EXPORT_SYMBOL_GPL(tcmi_ctlfs_intfile_new);
+EXPORT_SYMBOL_GPL(tcmi_ctlfs_strfile_new);
+EXPORT_SYMBOL_GPL(tcmi_ctlfs_rawfile_new);
+EXPORT_SYMBOL_GPL(tcmi_ctlfs_file_unregister);
+EXPORT_SYMBOL_GPL(tcmi_ctlfs_file_unregister2);
--- linux-3.7.1_original/clondike/src/tcmi/ctlfs/tcmi_ctlfs_entry.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/ctlfs/tcmi_ctlfs_entry.c	2013-03-11 20:20:20.000000000 +0100
@@ -0,0 +1,505 @@
+/**
+ * @file tcmi_ctlfs_entry.c - Implementation of an entry class in tcmifs 
+ * 
+ * 
+ * 
+ * 
+ * 
+ * 
+ *
+ * Date: 03/26/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_ctlfs_entry.c,v 1.2 2007/07/02 02:26:17 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include <linux/module.h>
+#include <linux/pagemap.h>
+#include <linux/slab.h> 
+
+#define TCMI_CTLFS_ENTRY_PRIVATE
+#include "tcmi_ctlfs_entry.h"
+
+#include <dbg.h>
+
+/** 
+ * \<\<public\>\> This method is used when initializing a new entry.
+ * It follows these steps:
+ *
+ * - converts the nameformat string and the args into a regular string
+ * This will be the name assigned to the dentry
+ * - checks whether we have a valid parent directory
+ * - check whether an entry with the same name already exists
+ * in the parent directory entry(if so, an error is returned)
+ * - creates a new inode with the specified super block and operations
+ * - creates a new dentry associated with the inode.
+ * - sets a entry_operations specific to this particular entry type 
+ * This supports polymorphism.
+ *
+ * @param *self - pointer to this instance
+ * @param *parent - pointer to the parent entry - has to be a directory
+ * @param *mode - file type and access rights for the inode
+ * @param *entry_ops - custom operations of the child class
+ * @param *i_ops - inode operations
+ * @param *f_ops - file operations(also stored in the new inode)
+ * @param namefmt - nameformat string (printf style)
+ * @param args - arguments to the format string
+ * @return 0 upon success
+ */
+int tcmi_ctlfs_entry_init(struct tcmi_ctlfs_entry *self,
+			  struct tcmi_ctlfs_entry *parent,
+			  mode_t mode,
+			  struct tcmi_ctlfs_ops *entry_ops,
+			  const struct inode_operations *i_ops,
+			  const struct file_operations *f_ops,
+			  const char namefmt[], va_list args)
+{
+	struct inode *dir;
+	struct inode *inode;
+
+	vsnprintf(self->name, sizeof(self->name), namefmt, args);
+	mdbg(INFO4, "Initializing a new tcmi_ctlfs_entry, '%s'(%p)", self->name, self);
+	if (!parent) {
+		mdbg(ERR4, "Can't initialized new entry '%s', no parent specified! ", self->name);
+		goto exit0;
+	}
+	mdbg(INFO4, "Parent entry='%s'", tcmi_ctlfs_entry_name(parent));
+	/* */
+	dir = parent->dentry->d_inode;
+	if (!S_ISDIR(dir->i_mode)) {
+		mdbg(ERR3, "Can't initialize new entry '%s', parent entry is not a directory!", self->name);
+		goto exit0;
+	}
+
+
+	/* check parent for an entry with 'name' */
+	if (tcmi_ctlfs_entry_exists(parent, self->name)) {
+		mdbg(ERR3,"Can't initialize new entry '%s', parent entry contains an entry of the same name!", 
+		     self->name);
+		goto exit0;
+	}
+
+	/* allocate a new inode */
+	if (!(inode = tcmi_ctlfs_get_inode(dir, dir->i_sb, mode, i_ops, f_ops))) {
+		mdbg(ERR3, "Failed to allocate an inode for '%s'", self->name);
+		goto exit0;
+	}
+	/* allocate a new dentry, associated with the inode */
+	if (tcmi_ctlfs_entry_alloc_dentry(self, parent, inode)) {
+		mdbg(ERR3, "Failed to allocate a new dentry for %s", self->name);
+		goto exit1;
+	}
+	/* Custom operations of the child class */
+	self->entry_ops = entry_ops;
+	return 0;
+	/* error handling */
+ exit1:
+	iput(inode);
+ exit0:
+	return -ENOSPC;
+}
+
+/** 
+ * \<\<public\>\> Initializes a root entry instance.
+ *
+ * @param *self - pointer to this instance
+ * @param *sb - pointer to the super block of the filesystem
+ * @param *mode - file type and access rights for the inode
+ * @param *entry_ops - custom operations of the child class
+ * @param *i_ops - inode operations
+ * @param *f_ops - file operations(also stored in the new inode)
+ * @return 0 upon success
+ */
+int tcmi_ctlfs_rootentry_init(struct tcmi_ctlfs_entry *self,
+			      struct super_block *sb,
+			      mode_t mode,
+			      struct tcmi_ctlfs_ops *entry_ops,
+			      const struct inode_operations *i_ops,
+			      const struct file_operations *f_ops)
+{
+	struct dentry *root;
+	struct inode *inode;
+
+	mdbg(INFO3, "Initializing a root entry");
+	if (!(inode = tcmi_ctlfs_get_inode(NULL, sb, mode, i_ops, f_ops))) {
+		mdbg(ERR1, "Failed to allocate inode for root dentry!");
+		goto exit0;
+	}
+	/* try allocating the dentry */
+  //Replaced function d_alloc_root to d_make_root for kernel 3.x | by Jiri Rakosnik
+	if (!(root = d_make_root(inode))) {
+		mdbg(ERR1, "Failed to allocate a root dentry!");
+		goto exit1;
+	}
+	/* Initialize the dentry */
+	root->d_fsdata = (void *)self; 
+	root->d_op = &tcmi_ctlfs_dentry_ops; 
+	self->dentry = root;
+	sb->s_root = root;
+	/* Custom operations of the child class */
+	self->entry_ops = entry_ops;
+	return 0;
+	/* error handling*/
+ exit1:
+	iput(inode);
+ exit0:
+	return -ENOSPC;
+}
+
+
+
+/** 
+ * \<\<public\>\> Iterates through all entry predecessors and calls
+ * the specified method for each entry (including self). The root
+ * entry is omitted. The callback function is supplied with the
+ * pointer to data that the users specified as parameter.  This
+ * provides a safe way of iterating through all predecessors. The
+ * reference counters are used to control the access from multiple
+ * threads.
+ *
+ * @param *self - pointer to this instance
+ * @param *func - pointer to the callback function
+ * @param *data - pointer to the data that is passed the callback.
+ */
+void tcmi_ctlfs_entry_traverse_pred(struct tcmi_ctlfs_entry *self, callback *func, void *data)
+{
+	struct tcmi_ctlfs_entry *parent;
+	struct tcmi_ctlfs_entry *entry = self;
+	/* increment the ref counter and get the instance */
+	parent = tcmi_ctlfs_entry_get(entry);
+
+	/* mdbg(INFO4, "getting %s", tcmi_ctlfs_entry_name(entry)); */
+	while (!tcmi_ctlfs_entry_isroot(parent)) {
+		entry = parent;
+		parent = tcmi_ctlfs_entry_get_parent(entry);
+		/* mdbg(INFO4, "getting %s", tcmi_ctlfs_entry_name(parent)); */
+		(*func)(entry, data); /* notify the next entry */
+		tcmi_ctlfs_entry_put(entry);
+		/* mdbg(INFO4, "putting %s", tcmi_ctlfs_entry_name(entry)); */
+	} 
+	/* decrement the root's reference counter too */
+	tcmi_ctlfs_entry_put(parent);
+	/* mdbg(INFO4, "putting %s", tcmi_ctlfs_entry_name(parent)); */
+}
+
+
+/** 
+ * \<\<public\>\> Calculates the depth of the entry in the tree.
+ *
+ * @param *self - pointer to this instance
+ * @return - depth (0 denotes root entry)
+ */
+int tcmi_ctlfs_entry_depth(struct tcmi_ctlfs_entry *self)
+{
+	int depth = 0;
+
+	tcmi_ctlfs_entry_traverse_pred(self, tcmi_ctlfs_add_depth, &depth);
+	return depth;
+}
+
+/**
+ * \<\<public\>\> Calculates the length of the pathname string
+ * (including '/' for every path element).
+ *
+ * @param *self - pointer to this instance
+ * @return pathname length
+ */
+int tcmi_ctlfs_entry_path_length(struct tcmi_ctlfs_entry *self)
+{
+	int length = 1;
+	tcmi_ctlfs_entry_traverse_pred(self, tcmi_ctlfs_add_length, &length);
+	return length;
+}
+
+/**
+ * \<\<public\>\> Fills in the entry's pathname into the specified
+ * buffer.  The pathname is being filled in reverse order starting
+ * from the end of the buffer.
+ * 
+ * @param *self - pointer to this symlink instance
+ * @param *buffer - buffer where store the pathname
+ * @param length - size of the buffer allocated for the pathname - this
+ *                 is can be > pathname length, as the user might want to add
+ *                 some prefix to the pathname (e.g. ../'s)
+ */
+void tcmi_ctlfs_entry_fill_path(struct tcmi_ctlfs_entry *self, char *buffer, int length)
+{
+	struct {
+		char *buffer;
+		int length;
+	} buf_data;
+
+	buf_data.buffer = buffer;
+	/* account for terminating \0 */
+	buf_data.length = --length; 
+
+	tcmi_ctlfs_entry_traverse_pred(self, tcmi_ctlfs_add_path, &buf_data);	
+}
+
+/** @addtogroup tcmi_ctlfs_entry_class
+ *
+ * @{
+ */
+
+/** 
+ *  \<\<private\>\> Helper callback function when calculating entry
+ *  depth.
+ *
+ * @param *self - pointer to this instance
+ * @param *curr_depth - pointer to the current depth
+ */
+static void tcmi_ctlfs_add_depth(struct tcmi_ctlfs_entry *self, void *curr_depth)
+{
+	(*((int *)curr_depth))++;
+}
+
+
+/** 
+ *  \<\<private\>\> Helper callback function when calculating entry
+ *  pathname length.
+ *
+ * @param *self - pointer to this instance
+ * @param *curr_length - pointer to the current length
+ */
+static void tcmi_ctlfs_add_length(struct tcmi_ctlfs_entry *self, void *curr_length)
+{
+	/* + 1 accounts for '/' */
+	(*((int *)curr_length)) += strlen(tcmi_ctlfs_entry_name(self)) + 1;
+}
+
+
+/** 
+ *  \<\<private\>\> Helper callback method when filling the entry's
+ * pathname The entry fills in its name and the '/' as prefix to the
+ * current end of the buffer.
+ *
+ * @param *self - pointer to this instance
+ * @param *buf_data - buffer data that contain pointer to the buffer and
+ *                    its current length.
+ */
+static void tcmi_ctlfs_add_path(struct tcmi_ctlfs_entry *self, void *buf_data)
+{
+	struct {
+		char *buffer;
+		int length;
+	} *buf = buf_data;
+
+	int cur = strlen(tcmi_ctlfs_entry_name(self));
+	mdbg(INFO4, "Adding.. %s, buffer length=%d", tcmi_ctlfs_entry_name(self), buf->length);
+		
+	/* back up enough to print entry name with '/' prefix */
+	buf->length -= cur;
+	strncpy(buf->buffer + buf->length, tcmi_ctlfs_entry_name(self), cur);
+	*(buf->buffer + --(buf->length)) = '/';
+
+	mdbg(INFO4, "New buffer length=%d", buf->length);
+}
+
+
+/** 
+ *  \<\<private\>\> This private method is responsible for freeing any
+ * resources the entry is currently using(currently nothing). When
+ * possible the child class is also notified.  The instance is
+ * eventually destroyed.
+ *
+ * @param *self - pointer to this instance 
+ * @return 0
+ */
+static inline void tcmi_ctlfs_entry_release(struct tcmi_ctlfs_entry *self)
+{
+	mdbg(INFO4, "entry '%s' is being freed(%p)", 
+	     tcmi_ctlfs_entry_name(self), self);
+	/* free child class instance data? */
+	if (self->entry_ops && self->entry_ops->entry_release) {
+		self->entry_ops->entry_release(self);	
+	}
+
+	kfree(self);
+}
+
+
+/** 
+ *  \<\<private\>\> A method for inode allocation.  Currently the uid
+ * and gid is assigned based on the current's fsuid and fsgid. Block
+ * size is not relevant, set to page size.  If the user doesn't
+ * specify any inode or file operations, the default(empty operations,
+ * but not NULL) assigned by the VFS will be kept.
+ *
+ * If the user specified a parent directory inode, it's access rights
+ * are investigated and inherited by the new inode as follows:
+ * - if the parent has the SGID bit set, parent's gid is assigned to
+ * the new inode.
+ * - a parent SGID bit is set on the new inode, if the new inode is a 
+ * directory
+ * 
+ *
+ * @param *dir - inode of the parent directory for the new inode
+ * @param *sb - super block of the filesystem where the inode is
+ * to be allocated
+ * @param *mode - file type and access rights for the inode
+ * @param *i_ops - inode operations
+ * @param *f_ops - file operations (also stored in the new inode)
+ * @return a pointer to the new inode or NULL
+ */
+static struct inode* tcmi_ctlfs_get_inode(struct inode *dir, 
+					  struct super_block *sb, 
+					  mode_t mode,
+					  const struct inode_operations *i_ops,
+					  const struct file_operations *f_ops)
+{
+	struct inode *inode = new_inode(sb);
+
+	if (inode) {
+		inode->i_mode = mode;
+		inode->i_uid = current_fsuid();
+		inode->i_gid = current_fsgid();
+		inode->i_blocks = 0;
+		inode->i_op  = (i_ops ? i_ops : inode->i_op);
+		inode->i_fop = (f_ops ? f_ops : inode->i_fop);
+		inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
+		mdbg(INFO4, "New inode allocated, inode number = %ld", inode->i_ino);
+		/* check parent inode's(if any) access rights */
+		if (dir && (dir->i_mode & S_ISGID)) {
+			inode->i_gid = dir->i_gid;
+			if (S_ISDIR(mode))
+				inode->i_mode |= S_ISGID;
+		}
+
+	}
+	else
+		minfo(ERR3, "Failed to allocate a new inode");
+
+	return inode;
+}
+
+/** 
+ *  \<\<private\>\>   The new dentry is
+ * allocated based on the parent's dentry and the current name of the
+ * ctlfs entry. The dentry is associated with the specified inode. The
+ * dentry is assigned our custom operations vector, so that we are
+ * informed about dentry destruction.
+ *
+ * @param *self - pointer to this instance
+ * @param *parent - pointer to the parent entry - has to be a directory
+ * @param *inode - pointer to the inode, that is to be associated with
+ * the new dentry.
+ * @return 0 upon success.
+ */
+static int tcmi_ctlfs_entry_alloc_dentry(struct tcmi_ctlfs_entry *self, 
+					 struct tcmi_ctlfs_entry *parent, 
+					 struct inode *inode)
+{
+	struct dentry *dentry;
+	int error = 1;
+	/* try allocating the dentry */
+	if ((dentry = d_alloc_name(parent->dentry, self->name))) {
+		d_add(dentry, inode); /* enters the dentry into hash queues */
+		dentry->d_fsdata = (void *)self; 
+		dentry->d_op = &tcmi_ctlfs_dentry_ops; 
+		self->dentry = dentry;
+		/* dget(dentry); Extra count - pin the dentry in core - not needed */
+		error = 0;
+	}
+	else 
+		mdbg(ERR3, "Failed to allocate a new dentry for %s", self->name);
+	return error;
+}
+
+/**
+ * \<\<private\>\> Checks whether a directory entry contains entry of
+ * the specified name
+ * 
+ * @param *self - pointer to this instance
+ * @param *name - pointer to the name to be checked
+ * @return 1 - if the entry of the specified name exists
+ */
+static int tcmi_ctlfs_entry_exists(struct tcmi_ctlfs_entry *self, const char *name)
+{
+	struct dentry *dentry;
+	struct qstr q;
+	int exists = 0;
+
+	q.name = name;
+	q.len = strlen(name);
+	q.hash = full_name_hash(q.name, q.len);
+	dentry = d_lookup(self->dentry, &q);
+	/* dentry already exists, decrement its reference counter since lookup 
+	 incremented it */
+	if (dentry) {
+		dput(dentry);
+	        exists = 1;
+	}
+	return exists;
+}
+/**
+ *  \<\<private\>\> This class method is a custom implementation of a
+ * VFS delete_dentry operation.  The delete_dentry is called by VFS
+ * when destroying the dentry associated with a particular
+ * tcmi_ctlfs_entry object. This happens when the dentry's reference
+ * counter reaches 0.
+ *
+ * @param *dentry - pointer to the dentry that is to be deleted
+ * @return - always 1 since we don't want the VFS to put the dentry
+ * into the dentry_unused. This way the dentry will be unhashed and
+ * removed right away
+ */
+static int tcmi_ctlfs_dentry_delete(const struct dentry *dentry)
+{
+	return 1;
+}
+
+/**
+ *  \<\<private\>\> This class method is a custom implementation of a
+ * VFS release_dentry operation.  The release_dentry is called by VFS
+ * when releasing the dentry associated with a particular
+ * tcmi_ctlfs_entry object. This happens when the dentry's reference
+ * counter reaches 0.
+ *
+ * Unlike previous VFS method, we are allowed to sleep as the dcache
+ * lock and dentry lock are not held anymore (see fs/dcache.c)
+ *
+ * @param *dentry - pointer to the dentry that is to be deleted
+ * @return - always 1 since we don't want the VFS to put the dentry
+ * into the dentry_unused. This way the dentry will be unhashed and
+ * removed right away
+ */
+static void tcmi_ctlfs_dentry_release(struct dentry *dentry)
+{
+	/* get the instance first */
+	struct tcmi_ctlfs_entry *self = TCMI_CTLFS_DENTRY_TO_ENTRY(dentry);
+	if (self)
+		tcmi_ctlfs_entry_release(self);
+	else
+		minfo(ERR2, "VFS issued dentry_release on a dentry without tcmi_ctlfs_instance!!");
+}
+
+/** Custom dentry delete operation for VFS. */
+static struct dentry_operations tcmi_ctlfs_dentry_ops =
+{
+	.d_delete	= tcmi_ctlfs_dentry_delete,
+	.d_release = tcmi_ctlfs_dentry_release,
+};
+
+/**
+ * @}
+ */
+
+EXPORT_SYMBOL_GPL(tcmi_ctlfs_entry_depth);
+EXPORT_SYMBOL_GPL(tcmi_ctlfs_entry_traverse_pred);
--- linux-3.7.1_original/clondike/src/tcmi/ctlfs/tcmi_ctlfs_symlink.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/ctlfs/tcmi_ctlfs_symlink.c	2013-03-11 20:25:55.000000000 +0100
@@ -0,0 +1,230 @@
+/**
+ * @file tcmi_ctlfs_symlink.c - Definition of a class that represents
+ * symbolic link in TCMI control file system.  This class extends
+ * tcmi_ctlfs_entry.
+ *
+ * Date: 03/30/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_ctlfs_symlink.c,v 1.2 2007/07/02 02:26:17 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/dcache.h>
+#include <linux/namei.h>
+#include <linux/fs.h>
+#include <asm/page.h>
+#include <linux/slab.h>
+
+#define TCMI_CTLFS_SYMLINK_PRIVATE
+#include "tcmi_ctlfs_symlink.h"
+
+#include <dbg.h>
+
+
+/**
+ * \<\<public\>\> Symbolic link is created as a regular ctlfs
+ * entry. In addition, it retains an extra reference to the target
+ * object. 
+ *
+ * @param *parent - pointer to the parent entry - has to be a directory
+ * @param *target - target entry to which link should point to
+ * @param namefmt - nameformat string (printf style)
+ * @return new symlink instance or NULL
+ */
+struct tcmi_ctlfs_entry* tcmi_ctlfs_symlink_new(struct tcmi_ctlfs_entry *parent,
+						struct tcmi_ctlfs_entry *target,
+						const char namefmt[], ...)
+{
+	struct tcmi_ctlfs_symlink *symlink;
+	va_list args;
+	va_start(args, namefmt);
+	mdbg(INFO4, "Creating new symlink");
+
+	if (!(symlink = kmalloc(sizeof(struct tcmi_ctlfs_symlink), GFP_ATOMIC))) {
+		mdbg(ERR3, "Failed to allocate memory for symlink");
+		goto exit0;
+	}
+	if (tcmi_ctlfs_entry_init(TCMI_CTLFS_ENTRY(symlink), 
+				  TCMI_CTLFS_ENTRY(parent), 
+				  S_IFLNK|S_IRWXUGO,
+				  &tcmi_ctlfs_symlink_ops,
+				  &tcmi_ctlfs_symlink_inode_operations,
+				  NULL, namefmt, args)) {
+		mdbg(ERR3, "Failed to initialize the symlink");
+		goto exit1;
+	}
+	symlink->target_entry = tcmi_ctlfs_entry_get(target);
+	va_end(args);
+
+	return TCMI_CTLFS_ENTRY(symlink);
+
+	/* error handling */
+ exit1:
+	kfree(symlink);
+ exit0:
+	va_end(args);
+	return NULL;
+}
+
+/** @addtogroup tcmi_ctlfs_symlink_class
+ *
+ * @{
+ */
+
+/** 
+ * \<\<private\>\> This method is used to free the data associated with the
+ * symlink. The target entry's reference is decremented as
+ * the symlink doesn't need the target entry anymore.
+ * 
+ * @param *entry - points to the symlink that is to be freed
+ * @return 0 upon success
+ */
+static void tcmi_ctlfs_symlink_release(struct tcmi_ctlfs_entry *entry)
+{
+	struct tcmi_ctlfs_symlink *symlink = TCMI_CTLFS_SYMLINK(entry);
+	mdbg(INFO3, "Target entry '%s' released", tcmi_ctlfs_entry_name(symlink->target_entry));
+	tcmi_ctlfs_entry_put(symlink->target_entry);
+}
+
+
+
+/**
+ * \<\<private\>\> The path is built as follows:
+ * - The path needs to be traversed to the root directory first '../', the number
+ * of these elements is determined by the depth of the symlink in the tree.
+ * - the minimum required buffer length is calculated based on:
+ *        - symlink depth (see above)
+ *        - pathname length of the target entry
+ * - the buffer is then filled with ../'s
+ * - the path of the target entry is then filled in
+ * 
+ * Should the target entry be invalid, the function terminates with an error
+ * access to the target entry is serialized by the lock. 
+ *
+ * @param *self - pointer to this instance
+ * @param *path - storage buffer for the path
+ * @param length - maximum path length (storage buffer size)
+ * @return 0 upon success
+ */
+static int tcmi_ctlfs_symlink_get_link(struct tcmi_ctlfs_symlink *self, 
+				       char *path, int length)
+{
+	char * s;
+	int depth, size;
+	int err = -EINVAL;
+
+	depth = tcmi_ctlfs_entry_depth(TCMI_CTLFS_ENTRY(self));
+	/* we are interested in the depth of the parent entry, this is safe since
+	 a minimum symlink depth is 1 (when it resides in the root directory) */
+	depth--;
+	size = tcmi_ctlfs_entry_path_length(self->target_entry) + depth * 3 - 1;
+	if (size > length) {
+		err = -ENAMETOOLONG;
+		goto exit0;
+	}
+	mdbg(INFO4,"depth = %d, size = %d", depth, size);
+
+	for (s = path; depth--; s += 3)
+		strcpy(s,"../");
+
+	if (self->target_entry)
+		tcmi_ctlfs_entry_fill_path(self->target_entry, path, size);
+
+	mdbg(INFO3, "path = '%s'\n", path);
+
+	return 0;
+
+	/* error handling */
+ exit0:
+/*   tcmi_ctlfs_symlink_unlock(self); */
+	return err;
+}
+
+/**
+ * \<\<private\>\> Provides symlink resolution. 
+ * Supplies the pathname of the target entry that the symlink refers to.
+ * This code is adapted from sysfs/symlink.c.
+ * - allocates a whole page for the pathname (faster than kmalloc)
+ * - extracts the symlink from the dentry
+ * - asks the symlink for path resolution
+ *
+ * @param *dentry - points to the dentry of the symlink that is to be
+ * resolved
+ * @param *nd - where the pathname is to be stored
+ * @return NULL upon success
+ */
+static void* tcmi_ctlfs_symlink_follow_link(struct dentry *dentry, struct nameidata *nd)
+{
+	int error = -ENOMEM;
+	unsigned long page = get_zeroed_page(GFP_ATOMIC);
+	struct tcmi_ctlfs_symlink *symlink;
+	if (page) {
+		symlink = TCMI_CTLFS_SYMLINK(TCMI_CTLFS_DENTRY_TO_ENTRY(dentry));
+		error = tcmi_ctlfs_symlink_get_link(symlink, (char *) page, PAGE_SIZE); 
+	}
+	nd_set_link(nd, error ? ERR_PTR(error) : (char *)page);
+	return NULL;
+}
+
+/**
+ * \<\<private\>\> This VFS operation is called when the symlink pathname is not needed anymore by
+ * VFS. It allows us to release the memory needed for the pathname.
+ *
+ * @param *dentry - points to the dentry of the symlink
+ * @param *nd - where the pathname resides
+ */
+static void tcmi_ctlfs_symlink_put_link(struct dentry *dentry, struct nameidata *nd, void * vd)
+{
+	char *page = nd_get_link(nd);
+	mdbg(INFO4, "Destroying pathname related data");
+	if (!IS_ERR(page)) {
+		mdbg(INFO4, "Freeing pathname buffer");
+		free_page((unsigned long)page);
+	}
+}
+
+/** 
+ * A symlink requires special entry operations to free all
+ * resources. 
+ */
+static struct tcmi_ctlfs_ops tcmi_ctlfs_symlink_ops = {
+	.entry_release = tcmi_ctlfs_symlink_release
+}; 
+
+/** 
+ * Custom VFS operations. Readlink operation is reused from VFS
+ * (generic_readlink). The generic version in turn uses the
+ * follow_symlink() to get the link pathname.
+ */
+static struct inode_operations tcmi_ctlfs_symlink_inode_operations = {
+	.readlink = generic_readlink,
+	.follow_link = tcmi_ctlfs_symlink_follow_link,
+	.put_link = tcmi_ctlfs_symlink_put_link,
+};
+
+/**
+ * @}
+ */
+
+
+EXPORT_SYMBOL_GPL(tcmi_ctlfs_symlink_new);
--- linux-3.7.1_original/clondike/src/tcmi/ctlfs/tcmi_ctlfs_file.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/ctlfs/tcmi_ctlfs_file.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,267 @@
+/**
+ * @file tcmi_ctlfs_file.h - Declaration of a class that represents file
+ *                          class in tcmifs. This class extends tcmi_ctlfs_entry
+ * 
+ * 
+ * 
+ * 
+ * 
+ * 
+ *
+ * Date: 03/26/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_ctlfs_file.h,v 1.2 2007/07/02 02:26:17 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef TCMI_CTLFS_FILE_H
+#define TCMI_CTLFS_FILE_H
+
+/* ctl_table and proc_do{int,string} are reused */
+#include <linux/sysctl.h> 
+#include <linux/semaphore.h>
+
+#include "tcmi_ctlfs_dir.h"
+
+
+/** describes the signature of a method that an object registers with a file */
+typedef int object_method (void *object, void *data);
+
+/** @defgroup tcmi_ctlfs_file_class tcmi_ctlfs_file class 
+ * 
+ * @ingroup tcmi_ctlfs_entry_class
+ *
+ * A file in the TCMI control file system is used to export object
+ * interfaces.  An object or a component creates a new control file
+ * for each method it wants to made available to the user space. The
+ * design idea is an extension of how linux sysctl works.  
+ *
+ * - When a user space application reads from a file, the associated
+ * object is notified by calling its registered method. The result is
+ * communicated back to user space. Similarly to sysctl, there are
+ * various data types that can be passed to the objects method. Their
+ * conversion from/to ascii is handled by special handlers.
+ *
+ * - When a user space program writes data to the file, the data is
+ * parsed by the TCMI file object and the binary form is passed on to
+ * the registered object's method.
+ *
+ * As in sysctl, following functions for parsing ascii input data are provided:
+ * - string
+ * - an array of integers
+ * - in addition, a raw data can be passed into the method of the registered object.
+ *
+ * Based on this we can create three types of files:
+ * - integer files - methods of file instantiators accept/return integer data.
+ *                   Conversion from/to ascii is handled internally by this class
+ * - string files  - methods of file instantiators accept/return string data.
+ *                   String parsing (overflow checks, new lines conversion) is 
+ *                   handled internally by this class.
+ * - raw files     - methods of file instantiators accept raw data.
+ *                   No conversion is performed.
+ *
+ * The object that creates the control file, specifies maximum allowed
+ * data length as it is in sysctl.
+ * 
+ * To prevent code duplication, this class reuses the procfs
+ * functions(sysctl.c) - proc_dostring(), proc_dointvec() for ascii/binary
+ * conversions.
+ *
+ * When the data is being passed to registered object's method, a
+ * mutual access guarantees integrity (implemented using mutex)
+ *
+ * 
+ * @{
+ */
+
+/** Describes the type of the file unregistration that is taking
+ * place.
+ *
+ * - regular way - is explicit file unregistration without using the
+ * file. This is requires locking the actual file, before
+ * unregistering its object.
+ * - from a method of the registered object - this is a special
+ * situation when the file is already locked (access is serialized by
+ * read/write file operations). Therefore, no locking is needed.
+ */
+typedef enum {
+	TCMI_CTLFS_FILE_REGULAR,
+	TCMI_CTLFS_FILE_FROM_METHOD
+} tcmi_ctlfs_file_unreg_t;
+
+/**
+ * A file compound structure, extends the parent entry class.
+ * Contains a reference to the object whose read/write methods
+ * are to be called.
+ */
+struct tcmi_ctlfs_file {
+	/** parent class instance. */
+	struct tcmi_ctlfs_entry super;
+
+	/** mutex semaphore to serialized the file access via
+	 * read/write methods. */
+	struct semaphore f_sem;
+
+	/** object that instantiated this file. */
+	void *object;
+	/** read method that the file instantiator registers. */
+	object_method *read_method;
+	/** write method that the file instantiator registers. */
+	object_method *write_method;
+	/** data parsing handler (reused from sysctl). */
+	proc_handler *proc_handler;
+
+	/** storage for the data associated with the file. */
+	void *data;
+	/** maximal data length. */
+	int maxlen;
+	/** flag that indicates when the object unregisters with the file */
+	int unregistered;
+};
+
+/** Casts an entry to file */
+#define TCMI_CTLFS_FILE(e) ((struct tcmi_ctlfs_file *)e)
+
+/** \<\<public\>\> Creates a new integer file instance. */
+extern struct tcmi_ctlfs_entry* tcmi_ctlfs_intfile_new(struct tcmi_ctlfs_entry *parent,
+						      mode_t mode,
+						      void *object,
+						      object_method *read_method,
+						      object_method *write_method,
+						      int maxlen,
+						      const char namefmt[], ...);
+
+/** \<\<public\>\> Creates a new string file instance. */
+extern struct tcmi_ctlfs_entry* tcmi_ctlfs_strfile_new(struct tcmi_ctlfs_entry *parent,
+						      mode_t mode,
+						      void *object,
+						      object_method *read_method,
+						      object_method *write_method,
+						      int maxlen,
+						      const char namefmt[], ...);
+
+/** \<\<public\>\> Creates a raw file instance. */
+extern struct tcmi_ctlfs_entry* tcmi_ctlfs_rawfile_new(struct tcmi_ctlfs_entry *parent,
+						       mode_t mode,
+						       void *object,
+						       object_method *read_method,
+						       object_method *write_method,
+						       int maxlen,
+						       const char namefmt[], ...);
+
+/**
+ * \<\<public\>\> Sets the unregistered flag of the file. This is used when the
+ * associated object is about to unregister from the file. However,
+ * the object needs to be guaranteed that from now on, no new process
+ * will send him a read/write message. This is exactly what the
+ * unregistered flag does.
+ *
+ * @param *self - pointer to this file instance
+ * \sa tcmi_ctlfs_file_unregister()
+ */
+static inline void tcmi_ctlfs_file_unregister_prepare(struct tcmi_ctlfs_entry *self) 
+{
+	if (self)
+		TCMI_CTLFS_FILE(self)->unregistered = 1;
+}
+
+
+/** \<\<public\>\> Unregisters the file. */
+extern void tcmi_ctlfs_file_unregister(struct tcmi_ctlfs_entry *self);
+
+/** \<\<public\>\> Unregisters the file, advanced version */
+extern void tcmi_ctlfs_file_unregister2(struct tcmi_ctlfs_entry *self, 
+					tcmi_ctlfs_file_unreg_t unreg);
+
+/**
+ * \<\<public\>\> Locks this file instance, interruptible version, the
+ * process can be woken up by a signal.
+ *
+ * @param *self - pointer to this file instance
+ */
+static inline int tcmi_ctlfs_file_lock_interruptible(struct tcmi_ctlfs_file *self)
+{
+	return (down_interruptible(&self->f_sem));
+}
+
+/**
+ * \<\<public\>\> Locks this file instance.
+ *
+ * @param *self - pointer to this file instance
+ */
+static inline void tcmi_ctlfs_file_lock(struct tcmi_ctlfs_file *self)
+{
+		down(&self->f_sem);
+}
+
+/**
+ * \<\<public\>\> Unlocks this file instance.
+ *
+ * @param *self - pointer to this file instance
+ */
+static inline void tcmi_ctlfs_file_unlock(struct tcmi_ctlfs_file *self)
+{
+		up(&self->f_sem);
+}
+
+
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_CTLFS_FILE_PRIVATE
+/** A forward declaration, generic file constructor. */
+static struct tcmi_ctlfs_entry* tcmi_ctlfs_genericfile_new(struct tcmi_ctlfs_entry *parent,
+							   mode_t mode,
+							   void *object,
+							   object_method *read_method,
+							   object_method *write_method,
+							   int maxlen,
+							   proc_handler *proc_handler,
+							   const char namefmt[], va_list args);
+/** A forward declaration, frees all file resources. */
+static void tcmi_ctlfs_file_release(struct tcmi_ctlfs_entry *entry);
+
+
+
+/** A forward declaration, read operation for VFS. */
+static ssize_t tcmi_ctlfs_file_read(struct file *filp, char __user *buf,
+				    size_t count, loff_t *ppos);
+/** A forward declaration, write operation for VFS. */
+static ssize_t tcmi_ctlfs_file_write(struct file *filp, const char __user *buf,
+				     size_t count, loff_t *ppos);
+
+/** Unregisters the associated object - lock free version */
+static void __tcmi_ctlfs_file_unregister(struct tcmi_ctlfs_entry *self);
+
+/** A forward declaration, special operations for tcmi_ctlfs entries. */
+static struct tcmi_ctlfs_ops tcmi_ctlfs_file_ops;
+/** A forward declaration, file operations for VFS. */
+static struct file_operations tcmi_ctlfs_file_operations;
+/** A forward declaration, inode operations for VFS. */
+static struct inode_operations tcmi_ctlfs_file_inode_operations;
+
+#endif /* TCMI_CTLFS_FILE_PRIVATE */
+
+/**
+ * @}
+ */
+
+
+#endif /* TCMI_CTLFS_FILE_H */
+
--- linux-3.7.1_original/clondike/src/tcmi/ctlfs/tcmi_ctlfs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/ctlfs/tcmi_ctlfs.h	2013-03-11 18:43:30.000000000 +0100
@@ -0,0 +1,106 @@
+/**
+ * @file tcmi_ctlfs.h - TCMI control file system module declaration
+ *                      exports the root directory entry
+ * 
+ *
+ *
+ * Date: 03/26/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_ctlfs.h,v 1.3 2008/05/02 19:59:20 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef TCMI_CTLFS_H
+#define TCMI_CTLFS_H
+
+#include <linux/mount.h>
+#include <linux/semaphore.h>
+
+#include "tcmi_ctlfs_dir.h"
+
+
+/** @defgroup tcmi_ctlfs_class control filesystem
+ * 
+ * @ingroup tcmi_module_class
+ *
+ * This \<\<singleton\>\> class represents TCMI control filesystem.
+ * The idea behind the filesystem is very similar to what we have in
+ * sysfs. The reason why a separate filesystem has been created is
+ * that TCMI doesn't fit among regular device drivers which is the
+ * primary use of sysfs.
+ *
+ * Similarly to sysfs, we provide a mechanism that allows any object
+ * in TCMI to create an interface presented to user space. The user
+ * is able to notify the object via reading/writing a file. 
+ *
+ * An entity in TCMI ctlfs is called an 'entry'. Currently there are
+ * entries that represent \link tcmi_ctlfs_file a file \endlink, \link
+ * tcmi_ctlfs_dir a directory \endlink and \link tcmi_ctlfs_symlink a
+ * symbolic link \endlink.
+ *
+ *@{
+ */
+
+/**
+ * A compound structure that contains all internal data of TCMI ctlfs.
+ * This is for internal use only.
+ */
+struct tcmi_ctlfs {
+	/** forward declaration of the root directory of the TCMI control filesystem */
+	struct tcmi_ctlfs_entry *root_dir;
+	/** a semaphore that protects the vfs_mount variable against
+	 * concurrent accesses. This is important when issuing
+	 * tcmi_ctlfs_get_root/tcmi_ctlfs_put_root
+	 */
+	struct semaphore vfs_mnt_sem;
+	/** forward declaration of the mount object of TCMI control filesystem */
+	struct vfsmount *vfs_mnt;     
+	/** Filesystem super block object */
+	struct super_block *sb;
+	/** A forward declaration describing this filesystem type */
+	struct file_system_type fs_type;
+};
+
+/** \<\<public\>\> Root entry accessor. */
+extern struct tcmi_ctlfs_entry* tcmi_ctlfs_get_root(void);
+/** \<\<public\>\> Releases the root directory. */
+extern void tcmi_ctlfs_put_root(void);
+
+/** Preferred directory rights */
+#define TCMI_PERMS_DIR    (S_IRWXU | S_IRGRP | S_IXGRP)
+/** Preferred write file rights */
+#define TCMI_PERMS_FILE_W (S_IWUSR)
+/** Preferred read file rights */
+#define TCMI_PERMS_FILE_R (S_IRUSR | S_IRGRP)
+/** Preferred read/write file rights */
+#define TCMI_PERMS_FILE_RW (TCMI_PERMS_FILE_R | TCMI_PERMS_FILE_W)
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_CTLFS_PRIVATE
+/** TCMI ctlfs \<\<singleton\>\> instance. */
+static struct tcmi_ctlfs self;
+#endif
+
+/**
+ * @}
+ */
+
+
+#endif /* TCMI_CTLFS_H */
--- linux-3.7.1_original/clondike/src/tcmi/ctlfs/tcmi_ctlfs_dir.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/ctlfs/tcmi_ctlfs_dir.c	2013-03-11 20:22:36.000000000 +0100
@@ -0,0 +1,145 @@
+/**
+ * @file tcmi_ctlfs_dir.c - Implementation of a class that represents directory
+ *                          class in tcmifs. This class extends tcmi_ctlfs_entry
+ * 
+ *
+ *
+ * Date: 03/26/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_ctlfs_dir.c,v 1.2 2007/07/02 02:26:17 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/dcache.h>
+#include <linux/slab.h>
+
+#include "tcmi_ctlfs_dir.h"
+
+#include <dbg.h>
+
+/** 
+ * \<\<public\>\> Creates a new directory entry in the tcmi_ctlfs
+ * tree.  Handles variable number of arguments and delegates work to
+ * tcmi_ctlfs_dir_vnew()
+ *
+ * @param *parent - pointer to the parent entry - has to be a directory
+ * @param *mode - access rights for the inode
+ * @param namefmt - nameformat string (printf style)
+ * @return pointer to the new directory or NULL
+ */
+struct tcmi_ctlfs_entry* tcmi_ctlfs_dir_new(struct tcmi_ctlfs_entry *parent,
+					    mode_t mode, const char namefmt[], ...)
+{
+	struct tcmi_ctlfs_entry *dir;
+	va_list args;
+	va_start(args, namefmt);
+	dir = tcmi_ctlfs_dir_vnew(parent, mode, namefmt, args);
+	va_end(args);
+	return dir;
+}
+
+/** 
+ * \<\<public\>\> Creates a new directory entry in the tcmi_ctlfs tree.
+ * The instance is:
+ * - created
+ * - initialized (delegated to the parent class)
+ * - link counts of parent and new directory need to be adjusted
+ *
+ * @param *parent - pointer to the parent entry - has to be a directory
+ * @param *mode - access rights for the inode
+ * @param namefmt - nameformat string (printf style)
+ * @param args - arguments to the format string
+ * @return pointer to the new directory or NULL
+ */
+struct tcmi_ctlfs_entry* tcmi_ctlfs_dir_vnew(struct tcmi_ctlfs_entry *parent,
+					     mode_t mode, const char namefmt[], 
+					     va_list args)
+{
+	struct tcmi_ctlfs_dir *dir;
+
+	mdbg(INFO4, "Creating new directory");
+	if (!(dir = kmalloc(sizeof(struct tcmi_ctlfs_dir), GFP_ATOMIC))) {
+		mdbg(ERR3, "Failed to allocate memory for directory");
+		goto exit0;
+	}
+        /* directory file operations are taken from fs/libfs.c */
+	if (tcmi_ctlfs_entry_init(TCMI_CTLFS_ENTRY(dir), 
+				  TCMI_CTLFS_ENTRY(parent), 
+				  S_IFDIR | mode, 
+				  NULL, 
+				  &simple_dir_inode_operations, 
+				  &simple_dir_operations, namefmt, args)) {
+		mdbg(ERR3, "Failed to create the directory"); 
+		goto exit1;
+	}
+	/* success, append the directory to its parent (account for '..') and 
+	   increment the link count for '.' */
+	tcmi_ctlfs_entry_inc_links(TCMI_CTLFS_ENTRY(parent));
+	tcmi_ctlfs_entry_inc_links(TCMI_CTLFS_ENTRY(dir));
+	return TCMI_CTLFS_ENTRY(dir);
+
+	/* error handling */
+ exit1:
+	kfree(dir);
+ exit0:
+	return NULL;
+}
+
+/** 
+ * \<\<public\>\> Root directory is instantiated by delegating all
+ * work to the parent class.
+ *
+ * @param *sb - super block of the file system
+ * @return pointer to the new root directory or NULL
+ */
+struct tcmi_ctlfs_entry* tcmi_ctlfs_rootdir_new(struct super_block *sb)
+{
+	struct tcmi_ctlfs_dir *root;
+		
+	mdbg(INFO4, "Creating root directory");
+	if (!(root = kmalloc(sizeof(struct tcmi_ctlfs_dir), GFP_ATOMIC))) {
+		mdbg(ERR3, "Failed to allocate memory for root directory");
+		goto exit0;
+	}
+	/* directory file operations are taken from fs/libfs.c */
+	if (tcmi_ctlfs_rootentry_init(TCMI_CTLFS_ENTRY(root), sb, 
+				      S_IFDIR | 0755, 
+				      NULL, 
+				      &simple_dir_inode_operations, 
+				      &simple_dir_operations)) {
+		mdbg(ERR3, "Failed to create root directory");
+		goto exit1;
+	}
+
+	/* account for '.' */
+	tcmi_ctlfs_entry_inc_links(TCMI_CTLFS_ENTRY(root));
+	return TCMI_CTLFS_ENTRY(root);
+
+	/* error handling */
+ exit1:
+	kfree(root);
+ exit0:
+	return NULL;
+}
+	
+EXPORT_SYMBOL_GPL(tcmi_ctlfs_dir_new);
+EXPORT_SYMBOL_GPL(tcmi_ctlfs_dir_vnew);
--- linux-3.7.1_original/clondike/src/tcmi/ctlfs/tcmi_ctlfs_entry.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/ctlfs/tcmi_ctlfs_entry.h	2013-03-12 19:10:28.000000000 +0100
@@ -0,0 +1,263 @@
+/**
+ * @file tcmi_ctlfs_entry.h - Declaration of a generic entry class in tcmifs 
+ * 
+ * 
+ * 
+ * 
+ * 
+ * 
+ *
+ * Date: 03/26/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_ctlfs_entry.h,v 1.3 2007/10/07 15:54:00 stavam2 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef _TCMI_CTLFS_ENTRY_H
+#define _TCMI_CTLFS_ENTRY_H
+
+#include <linux/dcache.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+
+#include <dbg.h>
+
+/** @defgroup tcmi_ctlfs_entry_class tcmi_ctlfs_entry class 
+ * 
+ * @ingroup tcmi_ctlfs_class
+ *
+ * This class represents a generic entry in the tcmi control file system.
+ * No instances of this class can be made. The goal is to provide generic
+ * functionality that can be used by specific file system entries:
+ * - Initialization/deletion/freeing of instances.
+ * - Instance reference counting - this is needed as we expect
+ * multiple threads of execution to access one entry at a time. This
+ * ensures no memory leaks will occur. The reference counting is not
+ * implemented from scratch. Each entry is associated with a VFS
+ * dentry. These are VFS objects that already have a reference
+ * counter. Each instance registers with VFS and receives a
+ * notification when the reference counter reaches 0
+ * (tcmi_ctlfs_dentry_release()) and the associated dentry is to be
+ * freed. This approach provides a safe access to the entry instances
+ * from multiple threads of execution without writing an extra
+ * reference couting code.  
+ * - entry location methods - a generic method that iterates through
+ * all predecessors of an entry is provided. This is used when
+ * determining the depth of the entry in the filesystem tree.
+ *
+ *@{
+ */
+
+/** Maximum entry name length. */
+#define MAX_ENTRY_NAME_LEN 256
+
+/**
+ * An entry compound structure. Contains the associated dentry.
+ */
+struct tcmi_ctlfs_entry {
+	/** VFS directory entry(dentry) that is associated with an instance. */
+	struct dentry *dentry;
+	/** custom operations */
+	struct tcmi_ctlfs_ops *entry_ops;
+	/** current entry name */
+	char name[MAX_ENTRY_NAME_LEN];
+};
+
+
+/** entry operations that support polymorphism */
+struct tcmi_ctlfs_ops {
+	/** child class method, that frees all instance resources
+	 * (but keeps the instance).
+	 */
+	void (*entry_release)(struct tcmi_ctlfs_entry *);
+};
+
+/** \<\<public\>\> Initializes an instance. */
+extern int tcmi_ctlfs_entry_init(struct tcmi_ctlfs_entry *self,
+				 struct tcmi_ctlfs_entry *parent,
+				 mode_t mode,
+				 struct tcmi_ctlfs_ops *entry_ops,
+				 const struct inode_operations *i_ops,
+				 const struct file_operations *f_ops,
+				 const char namefmt[], va_list args);
+	
+/** \<\<public\>\> Initializes a root entry instance. */
+extern int tcmi_ctlfs_rootentry_init(struct tcmi_ctlfs_entry *self,
+				     struct super_block *sb,
+				     mode_t mode,
+				     struct tcmi_ctlfs_ops *entry_ops,
+				     const struct inode_operations *i_ops,
+				     const struct file_operations *f_ops);
+
+/** Callback method of an object when traversing through predecessors */
+typedef void callback (struct tcmi_ctlfs_entry *, void *);
+/** \<\<public\>\> Iterator through entry predecessors. */
+void tcmi_ctlfs_entry_traverse_pred(struct tcmi_ctlfs_entry *self, callback *func, void *data);
+
+/** \<\<public\>\> Calculates the current depth of the entry in the tree. */
+int tcmi_ctlfs_entry_depth(struct tcmi_ctlfs_entry *entry);
+/** \<\<public\>\> Calculates the length of the pathname string. */
+int tcmi_ctlfs_entry_path_length(struct tcmi_ctlfs_entry *self);
+/** \<\<public\>\> Fills in the entry's pathname. */
+void tcmi_ctlfs_entry_fill_path(struct tcmi_ctlfs_entry *self, char *buffer, int length);
+
+
+/** Extracts the entry object from the dentry */
+#define TCMI_CTLFS_DENTRY_TO_ENTRY(dentry) TCMI_CTLFS_ENTRY(dentry->d_fsdata)
+/** Casts a child entry to the super class*/
+#define TCMI_CTLFS_ENTRY(e) ((struct tcmi_ctlfs_entry *)e)
+
+
+/** 
+ * \<\<public\>\> Increments the number of links referencing this
+ * entry's inode.  This method is used by directory entries. When a
+ * new child entry is added to the directory, the number of links in
+ * the inode->i_nlink needs to be adjusted as well as its parent's
+ * inode->i_nlink also needs to be incremented @param *self - pointer
+ * to this instance
+ *    
+ */
+static inline void tcmi_ctlfs_entry_inc_links(struct tcmi_ctlfs_entry *self)
+{
+	inc_nlink(self->dentry->d_inode); //Changed direct increment to inc_nlink function which it does atomic. | by Jiri Rakosnik
+}
+
+/** 
+ * \<\<public\>\> Entry name accessor.
+ *
+ * @param *self - pointer to this instance
+ * @return - entry name
+ */
+static inline const char* tcmi_ctlfs_entry_name(struct tcmi_ctlfs_entry *self)
+{
+	return self->dentry->d_name.name;
+}
+
+
+/** 
+ * \<\<public\>\> Checks whether a given entry is the root of the TCMI
+ * ctlfs tree.  This is when the d_parent of the dentry of this
+ * tcmi_ctlfs_entry points back to the dentry
+ *
+ * @param *self - pointer to this instance
+ * @return - 1 if it is root
+ */
+static inline int tcmi_ctlfs_entry_isroot(struct tcmi_ctlfs_entry *self)
+{
+	struct dentry *dentry = self->dentry;
+	return (dentry == dentry->d_parent);
+}
+
+
+/** 
+ * \<\<public\>\> Instance accessor, Calls instance custom get method
+ * and increments the reference counter.  The user is now guaranteed,
+ * that the instance stays in memory while he is using it.
+ *
+ * @param *self - pointer to this instance
+ * @return tcmi_ctlfs_entry instance
+ */
+static inline struct tcmi_ctlfs_entry* tcmi_ctlfs_entry_get(struct tcmi_ctlfs_entry *self)
+{
+	if (self) {
+		mdbg(INFO4, "Incrementing ref. count of '%s'(%p)", 
+		     tcmi_ctlfs_entry_name(self), self);
+		dget(self->dentry);
+	}
+	return self;
+}
+
+/** 
+ * \<\<public\>\> Returns parent entry, reference counter is
+ * incremented.
+ *
+ * @param *self - pointer to this instance
+ * @return - parent entry.
+ */
+static inline struct tcmi_ctlfs_entry* tcmi_ctlfs_entry_get_parent(struct tcmi_ctlfs_entry *self)
+{
+	return tcmi_ctlfs_entry_get(TCMI_CTLFS_DENTRY_TO_ENTRY(self->dentry->d_parent));
+}
+
+/** 
+ * \<\<public\>\> Calls the instance custom put method(if any) and
+ * Decrements the reference counter of the dentry that the instance
+ * uses to carry it through out the file system. If the reference
+ * count reaches 0, the dentry will be released from the dentry cache
+ * and the instance of tcmi_ctlfs_entry will be freed. (VFS calls the
+ * d_delete() method of the dentry that we have customized @see
+ * tcmi_ctlfs_dentry_delete and d_release() that is also customized in
+ * tcmi_ctlfs_dentry_release())
+ *
+ *@param *self - pointer to this instance
+ */
+static inline void tcmi_ctlfs_entry_put(struct tcmi_ctlfs_entry *self)
+{
+	if (self) {
+		mdbg(INFO4, "Decrementing ref. count of '%s'(%p) (dentry: %p). Count before dec: %d", 
+		     tcmi_ctlfs_entry_name(self), self, self->dentry, self->dentry->d_count); //Removed function atomic_read for bad usage | by Jiri Rakosnik
+		dput(self->dentry);
+	}
+}
+
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_CTLFS_ENTRY_PRIVATE
+
+/** A callback method for calculation of entry depth. */
+static void tcmi_ctlfs_add_depth(struct tcmi_ctlfs_entry *self, void *curr_depth);
+/** A callback method for calculation of entry pathname length. */
+static void tcmi_ctlfs_add_length(struct tcmi_ctlfs_entry *self, void *curr_length);
+/** A callback method when building a pathname of an entry. */
+static void tcmi_ctlfs_add_path(struct tcmi_ctlfs_entry *self, void *buf_data);
+
+/** Frees all entry resources. */
+/*static int tcmi_ctlfs_entry_free(struct tcmi_ctlfs_entry *self);*/
+
+/** Checks for existing directory entry. */
+static int tcmi_ctlfs_entry_exists(struct tcmi_ctlfs_entry *self, const char *name);
+
+/** Creates a new inode. */
+static struct inode* tcmi_ctlfs_get_inode(struct inode *dir, struct super_block *sb, 
+					  mode_t mode,
+					  const struct inode_operations *i_ops,
+					  const struct file_operations *f_ops);
+/** A method for dentry allocation. */
+static int tcmi_ctlfs_entry_alloc_dentry(struct tcmi_ctlfs_entry *self, 
+					 struct tcmi_ctlfs_entry *parent, 
+					 struct inode *inode);
+
+/** VFS dentry_delete operation. */
+static int tcmi_ctlfs_dentry_delete(const struct dentry *dentry);
+
+/** VFS dentry_delete operation. */
+static void tcmi_ctlfs_dentry_release(struct dentry *dentry);
+
+/** Custom dentry delete operation for VFS. */
+static struct dentry_operations tcmi_ctlfs_dentry_ops;
+
+#endif /* TCMI_CTLFS_ENTRY_PRIVATE */
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_CTLFS_ENTRY_H */
--- linux-3.7.1_original/clondike/src/tcmi/ctlfs/tcmi_ctlfs_symlink.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/tcmi/ctlfs/tcmi_ctlfs_symlink.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,120 @@
+/**
+ * @file tcmi_ctlfs_symlink.h - Declaration of a class that represents
+ * symbolic link in TCMI control file system.  This class extends
+ * tcmi_ctlfs_entry.
+ *
+ * Date: 03/30/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: tcmi_ctlfs_symlink.h,v 1.2 2007/07/02 02:26:17 malatp1 Exp $
+ *
+ * This file is part of Task Checkpointing and Migration Infrastructure(TCMI)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * TCMI is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * TCMI is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef TCMI_CTLFS_SYMLINK_H
+#define TCMI_CTLFS_SYMLINK_H
+
+
+
+#include "tcmi_ctlfs_dir.h"
+
+
+/** @defgroup tcmi_ctlfs_symlink_class tcmi_ctlfs_symlink class 
+ * 
+ * @ingroup tcmi_ctlfs_entry_class
+ *
+ * This class provides a robust solution for symbolic link creation.
+ * A symbolic link can be made to any entry within the TCMI control
+ * file system. The link instantiator provides only the target entry
+ * object that the link should point to. The class itself then takes
+ * care of creating the pathname to the target on fly as follow link
+ * requests come. There are three VFS inode operations that the link
+ * must provide:
+ *
+ * - follow_link - supplies the target object pathname to the VFS
+ * - put_link - a notification form VFS that the target pathname is not
+ * needed anymore after follow_link operation. 
+ * - readlink - copies the target pathname to the buffer supplied by VFS
+ *
+ * This class implements only the first 2 operations
+ * (tcmi_ctlfs_symlink_follow_link() and
+ * tcmi_ctlfs_symlink_put_link()). The third one uses VFS generic_readlink()
+ * that in turn invokes the custom tcmi_ctlfs_symlink_follow_link()).
+ *
+ * Each symbolic link instance retains a reference to the target entry.
+ * This reference is released upon symlink destruction.
+ * 
+ * @{
+ */
+
+/**
+ * A symbolic link compound structure, extends the parent entry class.
+ * Contains a reference to the target entry.
+ */
+struct tcmi_ctlfs_symlink {
+	/** parent class instance. */
+	struct tcmi_ctlfs_entry super;
+
+	/** target entry, that the symbolic link is pointing to. */
+	struct tcmi_ctlfs_entry *target_entry;
+
+};
+
+
+/** \<\<public\>\> Creates a new symbolic link instance. */
+extern struct tcmi_ctlfs_entry* tcmi_ctlfs_symlink_new(struct tcmi_ctlfs_entry *parent,
+						       struct tcmi_ctlfs_entry *target,
+						       const char namefmt[], ...);
+
+
+
+/** Casts an entry to a symlink */
+#define TCMI_CTLFS_SYMLINK(e) ((struct tcmi_ctlfs_symlink *)e)
+
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef TCMI_CTLFS_SYMLINK_PRIVATE
+
+/** A forward declaration, frees all file resources. */
+static void tcmi_ctlfs_symlink_release(struct tcmi_ctlfs_entry *entry);
+
+
+/** Builds the path that points from a symlink entry to the target entry. */
+static int tcmi_ctlfs_symlink_get_link(struct tcmi_ctlfs_symlink *self, 
+				       char *path, int length);
+
+/** VFS operation to follow the symlink. */
+static void* tcmi_ctlfs_symlink_follow_link(struct dentry *dentry, struct nameidata *nd);
+
+/** VFS operation to release symlink's pathname. */
+static void tcmi_ctlfs_symlink_put_link(struct dentry *dentry, struct nameidata *nd, void * vd);
+
+/** A forward declaration, special operations for tcmi_ctlfs entries. */
+static struct tcmi_ctlfs_ops tcmi_ctlfs_symlink_ops;
+
+/** A forward declaration, inode operations for VFS. */
+static struct inode_operations tcmi_ctlfs_symlink_inode_operations;
+
+#endif /* TCMI_CTLFS_SYMLINK_PRIVATE */
+
+/**
+ * @}
+ */
+
+#endif /* TCMI_CTLFS_SYMLINK_H */
+
--- linux-3.7.1_original/clondike/src/kkc/kkc_sock_tcp.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/kkc/kkc_sock_tcp.c	2013-03-01 12:02:15.000000000 +0100
@@ -0,0 +1,645 @@
+/** @file kkc_sock_tcp.c - Generic Kernel to Kernelin Communcation abstraction - socket
+ *
+ * Date: 04/13/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: kkc_sock_tcp.c,v 1.4 2008/05/02 19:59:20 stavam2 Exp $
+ *
+ * This file is part of Kernel-to-Kernel Communication Library(KKC)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * KKC is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * KKC is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/socket.h>
+#include <net/sock.h>
+#include <net/tcp.h>
+#include <linux/in.h>
+
+
+#include "kkc_arch.h"
+
+#define KKC_SOCK_TCP_PRIVATE
+#include "kkc_sock_tcp.h"
+
+#include <dbg.h>
+
+
+/** Declare the TCP architecture */
+KKC_ARCH_DECLARE(tcp, &tcp_arch_ops, NULL);
+
+/** @addtogroup kkc_sock_tcp_class
+ *
+ * @{
+ */
+
+/** 
+ * \<\<private\>\> Creates an empty TCP socket.  The BSD socket is
+ * created for a stream connection using TCP protocol. In addition,
+ * socket reuse option is set.  Eventhough a regular TCP socket
+ * instance is created it is casted to kkc_arch_obj_t, which is a
+ * generic object supported by kkc_arch.  The user of the architecture
+ * class instance always knows, what instance to expect, so he/she can
+ * cast it to kkc_sock without problems. The reason, why we cannot
+ * return directly kkc_sock, is that it would create a circular
+ * dependency between \link kkc_arch_class kkc_arch \endlink and \link
+ * kkc_sock_class kkc_sock \endlink.
+ *
+ *
+ * @return architecture object instance or NULL
+ */
+static kkc_arch_obj_t kkc_sock_tcp_new(void)
+{
+	
+	struct kkc_sock_tcp *sock;
+	mdbg(INFO4, "Creating a new TCP socket..");
+
+	/* Allocate the instance */
+	if (!(sock = KKC_SOCK_TCP(kmalloc(sizeof(struct kkc_sock_tcp), GFP_KERNEL)))) {
+		mdbg(ERR4, "Can't allocate memory for TCP socket");
+		goto exit0;
+	}
+	/* Initialize the generic socket */
+	if (kkc_sock_init(KKC_SOCK(sock), kkc_arch_get(&KKC_ARCH(tcp)), &tcp_sock_ops)) {
+		mdbg(ERR4, "Error initializing TCP socket");
+		goto exit1;
+	}
+
+	mdbg(INFO4, "Creating BSD socket");
+	if (sock_create_kern(PF_INET, SOCK_STREAM, IPPROTO_TCP, &sock->sock)) {
+		mdbg(ERR4, "Cannot create socket");
+		goto exit1;
+	}
+
+	// TODO: At the moment, we set this on all TCP connections, but in a future we may want to use this selectively
+	kkc_sock_tcp_disable_nagle(KKC_SOCK(sock));
+	kkc_sock_tcp_enable_quickack(KKC_SOCK(sock));
+	kkc_sock_enable_keepalive(KKC_SOCK(sock));
+
+	/* setup reuse option - this is how it was in original KKC, why? */
+	sock->sock->sk->sk_reuse = 1;
+	sock->read_callback = NULL;
+	sock->sock->sk->sk_user_data = sock; // Back reference to kkc socket
+	return KKC_ARCH_OBJ(sock);
+
+	/* error handling */
+ exit1:
+	kfree(sock);
+ exit0:
+	return NULL;
+
+}
+
+/** 
+ * \<\<private\>\> Connects to the given address. 
+ * Stores the address inside the socket and delegates all work
+ * to the architecture specific socket.
+ *
+ * @param *self - pointer to this socket instance
+ * @param *addr - address where to connect to.
+ * @return 0 upon successful connection
+ */
+static int kkc_sock_tcp_connect(struct kkc_sock *self, char *addr)
+{
+	int err = 0;
+	struct socket *sock = KKC_SOCK_TCP(self)->sock;
+	struct sockaddr_in sin;
+	
+	/* Extract ip address and port number from addr argument */
+	if ((err = kkc_sock_tcp_extract_addr(addr, &sin))) {
+		mdbg(ERR4, "Cannot extract ip address from argument '%s'", addr);
+		goto exit0;
+	}
+	mdbg(INFO4, "Connecting to '%s' ..", addr);
+	if ((err = sock->ops->connect(sock, (struct sockaddr*)&sin, sizeof(sin), O_RDWR)) < 0) {
+		mdbg(ERR4, "Cannot connect to '%s', error=%d", addr, err);
+		goto exit0;
+	}
+	mdbg(INFO4, "Connected to '%s' ..", addr);	
+	return 0;
+	/* error handling */
+ exit0:
+	return err;
+}
+
+
+/** 
+ * \<\<private\>\> Starts listening on a specified address.
+ * Extracts the address from the string, binds the socket
+ * to this address and starts listening.
+ *
+ * @param *self - pointer to this socket instance
+ * @param *addr - address where to connect to.
+ * @return 0 upon successfully establishing the listening
+ */
+static int kkc_sock_tcp_listen(struct kkc_sock *self, char *addr)
+{
+	int err = 0;
+	struct socket *sock = KKC_SOCK_TCP(self)->sock;
+	struct sockaddr_in sin;
+
+
+
+	/* Extract ip address and port number from addr argument */
+	if ((err = kkc_sock_tcp_extract_addr(addr, &sin))) {
+		mdbg(ERR4, "Cannot extract ip address from argument '%s'", addr);
+		goto exit0;
+	}
+	if ((err = sock->ops->bind(sock, (struct sockaddr*)&sin, sizeof(sin))) < 0) {
+		mdbg(ERR4, "Cannot bind to '%s'", addr);
+		goto exit0;
+	}
+	if ((err = sock->ops->listen(sock, 32)) < 0) {
+		mdbg(ERR4, "Cannot start listening on '%s'", addr);
+		goto exit0;
+	}
+	mdbg(INFO4, "TCP Listening on '%s' ..", addr);
+	return 0;
+	/* error handling */
+ exit0:
+	return err;
+}
+
+/** 
+ * \<\<private\>\> Creates a new socket by accepting the incoming connection.
+ * After instantiating a new socket, a TCP socket specific method is
+ * called to accept a connection. This will setup the rest of the newly
+ * created TCP socket. 
+ *
+ * @param *self - pointer to this socket instance
+ * @param **new_kkc_sock - storage for the new socket created for the incoming 
+ * connection.
+ * @param flags - specify blocking/nonblocking mode
+ * @return 0 upon successful connection
+ * @todo - this needs an optimization, so that a full socket doesn't get 
+ * manufactured everytime. This is a performance problem when using nonblock mode
+ */
+static int kkc_sock_tcp_accept(struct kkc_sock *self, struct kkc_sock **new_kkc_sock, 
+			       kkc_sock_flags_t flags)
+{
+	int err = 0;
+	int tmp_flags;
+	struct socket *sock, *new_sock;
+	/* Create a new TCP socket that will handle the incoming connection */
+	if (!(*new_kkc_sock = KKC_SOCK(kkc_sock_tcp_new()))) {
+		mdbg(ERR4, "Failed to create a new KKC TCP socket");
+		err = -ENOMEM;
+		goto exit0;
+	}
+	/* BSD socket where we check for incoming connections */
+	sock = KKC_SOCK_TCP(self)->sock;
+	/* newly created BSD socket that handles the incoming connection */
+	new_sock = KKC_SOCK_TCP(*new_kkc_sock)->sock;
+
+	/* compose flags for accepting */
+	tmp_flags = O_RDWR | ((flags & KKC_SOCK_NONBLOCK) != 0 ? O_NONBLOCK : 0);
+
+	mdbg(INFO4, "Accepting incoming connection");
+	if ((err = sock->ops->accept(sock, new_sock, tmp_flags)) < 0) {
+		if ( err != -EAGAIN ) {
+			mdbg(ERR4, "Cannot accept new connection %d", err);
+		} else {
+			mdbg(INFO4, "Accept timeouted.");
+		}
+		goto exit1;
+	}
+
+	mdbg(INFO4, "Accepted a TCP connection..");
+
+	return 0;
+	/* error handling */
+ exit1:
+	kkc_sock_put(*new_kkc_sock);
+	new_kkc_sock = NULL; /* user will get back NULL */
+ exit0:
+	return err;
+}
+
+/** 
+ * \<\<private\>\> Sends out specified data. 
+ * What needs to be done:
+ * - setup a message header
+ * - setup iovec and store the buffer base address and length into it
+ * - asks the kernel to receive the message
+ *
+ * @param *self - pointer to this socket instance
+ * @param *buf - buffer with the data to be sent
+ * @param buflen - length of the buffer to be sent
+ * @param flags - specify blocking or non-blocking mode.
+ * @return number of bytes actually sent or error when < 0
+ */
+static int kkc_sock_tcp_send(struct kkc_sock *self, void *buf, int buflen, 
+			     kkc_sock_flags_t flags)
+{
+	struct socket *sock;
+	struct msghdr msg;
+	struct iovec iov;
+	int result = 0;
+	
+	mdbg(INFO4, "TCP Sending buffer %p length: %d bytes", buf, buflen);
+	sock = KKC_SOCK_TCP(self)->sock;
+
+	/* Setup message header */
+	msg.msg_name = NULL;
+	msg.msg_namelen = 0;
+	msg.msg_control = NULL;
+	msg.msg_controllen = 0;
+	msg.msg_flags = 0;	/* blocking mode do we need to set
+				 * this, it should be default for
+				 * sending??*/
+
+	iov.iov_base = buf;
+	iov.iov_len = buflen;
+
+	result = kernel_sendmsg(sock, &msg,(struct kvec*)&iov, 1, buflen);
+
+	mdbg(INFO4, "TCP sending buffer %p length: %d bytes, sent %d", buf, buflen, result);	
+
+
+	return result;
+}
+
+
+/** 
+ * \<\<private\>\> Receives requested number of bytes of data. 
+ * What needs to be done:
+ * - setup a message header
+ * - setup iovec and store the buffer base address and length into it
+ * - asks the kernel to receive the message
+ *
+ * @param *self - pointer to this socket instance
+ * @param *buf - buffer where to store received data.
+ * @param buflen - length of the buffer to be sent
+ * @param flags - specify blocking or non-blocking mode.
+ * @return number of bytes actually received or error when < 0
+ */
+static int kkc_sock_tcp_recv(struct kkc_sock *self, void *buf, int buflen,
+			     kkc_sock_flags_t flags)
+{
+	struct socket *sock = KKC_SOCK_TCP(self)->sock;
+	struct msghdr msg;
+	struct iovec iov;
+	int tmp_flags;
+	int result = 0;
+
+	/* Setup message header */
+	msg.msg_name = NULL;
+	msg.msg_namelen = 0;
+	msg.msg_control = NULL;
+	msg.msg_controllen = 0;
+	tmp_flags = (flags & KKC_SOCK_NONBLOCK ? MSG_DONTWAIT : 0);
+
+	iov.iov_base = buf;
+	iov.iov_len = buflen;
+
+	result = kernel_recvmsg(sock, &msg, (struct kvec*)&iov, 1, buflen, tmp_flags);
+
+	mdbg(INFO4, "TCP receiving buffer %p length: %d bytes, received %d", buf, buflen, result);	
+
+
+	/* connection reset is marked as 0, so if the user requested
+	 * more than 0bytes to be sent, we have to check for this and
+	 * convert the error */
+	return ((result == 0) && (buflen > 0)) ? -ECONNRESET : result;
+}
+
+
+/** 
+ * \<\<private\>\> Disconnects the socket.  Connection is shutdown in
+ * both directions, it might be a good idea, to add the option for the
+ * user to specify which part of the connection is to be closed.
+ *
+ * @param *self - pointer to this socket instance
+ * @return 0 upon success
+ */
+static int kkc_sock_tcp_shutdown(struct kkc_sock *self)
+{
+	int err = 0;
+
+	struct socket *sock = KKC_SOCK_TCP(self)->sock;
+
+	mdbg(INFO4, "TCP disconnecting..");
+	err = sock->ops->shutdown(sock, SEND_SHUTDOWN | RCV_SHUTDOWN);
+
+	return err;
+}
+
+/** 
+ * \<\<private\>\> Adds a task to the queue of processes sleeping on
+ * this socket. We use the sk_sleep wait queue, no locking needed
+ * waitqueues handle serialization on their own.
+ *
+ * @param *self - pointer to this socket instance
+ * @param *wait - pointer to the waitqueue element with the task that
+ * wants to sleep on this socket.
+ * @return 0 upon success
+ */
+static int kkc_sock_tcp_add_wait_queue(struct kkc_sock *self, wait_queue_t *wait)
+{
+	int err = 0;
+
+	mdbg(INFO4, "TCP adding to wait queue..");
+	/* add to socket wait queue */
+	add_wait_queue(sk_sleep(KKC_SOCK_TCP(self)->sock->sk), wait);
+	// Fix for kernel 3.7.1 call inline function sk_sleep instead of original record sk_sleep in structure sk | by Jiri Rakosnik
+
+	return err;
+}
+
+/** 
+ * \<\<private\>\> Removes a task from the queue of processes sleeping
+ * on this socket.
+ *
+ * @param *self - pointer to this socket instance
+ * @param *wait - pointer to the waitqueue element with the task that
+ * wants to sleep on this socket.
+ * @return 0 upon success
+ */
+static int kkc_sock_tcp_remove_wait_queue(struct kkc_sock *self, wait_queue_t *wait)
+{
+	int err = 0;
+
+	mdbg(INFO4, "TCP removing from wait queue..");
+	/* remove from socket wait queue */
+	remove_wait_queue(sk_sleep(KKC_SOCK_TCP(self)->sock->sk), wait);
+	// Fix for kernel 3.7.1 call inline function sk_sleep instead of original record sk_sleep in structure sk | by Jiri Rakosnik
+	return err;
+}
+
+/** 
+ * \<\<private\>\> Method that will be registered to standard sock as a callback function and will dispatch the request
+ * to our registered callback
+ */
+static void kkc_sock_tcp_callback(struct sock *sk, int count) {
+	if ( sk->sk_user_data ) {
+		struct kkc_sock* self = sk->sk_user_data;
+		if ( KKC_SOCK_TCP(self)->read_callback ) {
+			KKC_SOCK_TCP(self)->read_callback(KKC_SOCK_TCP(self)->callback_data, count);
+		}
+	}
+}
+
+/** 
+ * \<\<private\>\> Registeres callback function that will be called when there are
+ * some data to be read in the socket
+ *
+ * @param *self - pointer to this socket instance
+ * @param *wait - pointer to the callback function
+ * @return 0 upon success
+ */
+static int kkc_sock_tcp_register_read_callback(struct kkc_sock *self, kkc_data_ready callback, void* callback_data)
+{
+	int err = 0;
+
+	mdbg(INFO4, "TCP registering read callback..");
+	KKC_SOCK_TCP(self)->read_callback = callback;
+	KKC_SOCK_TCP(self)->callback_data = callback_data;
+	KKC_SOCK_TCP(self)->sock->sk->sk_data_ready = kkc_sock_tcp_callback;
+
+	return err;
+}
+
+/** 
+ * \<\<private\>\> Free TCP socket related resources.  Essentially, it
+ * terminates the connection and releases the socket.
+ * This method is called by the super class when the last reference
+ * to the socket is dropped.
+ *
+ * @param *self - pointer to this socket instance
+ */
+static void kkc_sock_tcp_free(struct kkc_sock *self)
+{
+
+	mdbg(INFO4, "TCP freeing socket resources..");
+	kkc_sock_tcp_shutdown(self);
+	sock_release(KKC_SOCK_TCP(self)->sock);
+}
+
+/**
+ * \<\<private\>\> Socket name accessor.  The socket name is returned in format
+ * 'a.b.c.d:p' We use a socket operation to retrieve the desired part
+ * of the address(local or peer). The address is then formated as
+ * mentioned above and stored in the buffer.
+ *
+ * @param *self - pointer to this socket instance
+ * @param *name - pointer to the buffer where the sockname is to be stored
+ * @param size - maximum string length that fits into the sockname buffer
+ * @param local - if set to 0, retrieves the local name, otherwise retreives
+ * the remote(peer) name
+ * @return 0 upon success
+ */
+static int kkc_sock_tcp_getname(struct kkc_sock *self, char *name, int size, int local)
+{
+	int err = 0;
+	int len = sizeof(struct sockaddr_in);
+	struct socket *sock = KKC_SOCK_TCP(self)->sock;
+	struct sockaddr_in address;
+
+	/* used to remap the s_addr for byte access */
+	unsigned char *paddr;
+	if ((err = sock->ops->getname(sock, (struct sockaddr *)&address, 
+				      &len, local)) < 0) {
+		goto exit0;
+	}
+	paddr = (char *) &address.sin_addr.s_addr;
+	
+	snprintf(name, size, "%u.%u.%u.%u:%u", paddr[0], paddr[1], paddr[2], paddr[3],
+		 ntohs(address.sin_port));
+	
+	return 0;
+	/* error handling */
+ exit0:
+	memset(name, 0, size);
+	return err;
+}
+
+/**
+ * \<\<private\>\> IP Comparator
+ *
+ * @param *address - string with the address in the form a.b.c.d:p
+ * @param *addr_length
+ * @param *local - 1 to compare with local IP, 0 if to compare with peer IP
+ * @return 1, if address equals to local or peer addres (depending on local flag)
+ */
+static int kkc_sock_tcp_is_address_equal_to(struct kkc_sock *self, const char* addr, int addr_length, int local) {
+	int err = 0;
+	int len = sizeof(struct sockaddr_in);
+	struct socket *sock = KKC_SOCK_TCP(self)->sock;
+	struct sockaddr_in address;
+	unsigned char *paddr;
+	char name[KKC_SOCK_MAX_ADDR_LENGTH];
+	
+	if ( !addr )
+	    return 0;	
+
+	/* used to remap the s_addr for byte access */	
+	if ((err = sock->ops->getname(sock, (struct sockaddr *)&address, 
+				      &len, local)) < 0) {
+		goto exit0;
+	}
+	paddr = (char *) &address.sin_addr.s_addr;	
+	snprintf(name, KKC_SOCK_MAX_ADDR_LENGTH, "tcp:%u.%u.%u.%u:%u", paddr[0], paddr[1], paddr[2], paddr[3],
+		 ntohs(address.sin_port));
+	
+//	printk("Comparing: %s with %s local %d, %d, %d\n", name, addr, local, strncmp(addr, name, min((size_t)addr_length, strlen(name))), strcmp(addr, name));
+			
+	return strncmp(addr, name, min((size_t)addr_length, strlen(name))) == 0;
+	/* error handling */
+ exit0:
+	return 0;  
+}
+
+/**
+ * \<\<private\>\> Helper class method for extracting ip address and port
+ * number from string argument.
+ *
+ * @param *addr - string with the address in the form a.b.c.d:p
+ * @param *sin - output parameter that will have ip address and 
+ * port filled out upon success
+ * @return 0 if a valid IP address and port have been extracted
+ */
+static int kkc_sock_tcp_extract_addr(char *addr, struct sockaddr_in *sin)
+{
+	char *colon_ptr;
+	int colon_pos;
+	char tmp_ip[16];
+	unsigned long int tmp_port;	
+	char *dummy;
+	int err = 0;
+
+	/* find colon in address */
+	if ((colon_ptr = strchr(addr, ':')) == NULL) {
+		mdbg(ERR4, "Invalid IP address syntax");
+		err = -EINVAL;
+		goto leave;
+	}
+		
+	/*
+	 * Extract ip address 
+	 */
+	colon_pos = colon_ptr - addr;
+	if (colon_pos > 15) {
+		mdbg(ERR4, "Invalid IP address syntax");
+		err = -EINVAL;
+		goto leave;
+	}
+	strncpy(tmp_ip, addr, colon_pos);
+	tmp_ip[colon_pos] = '\0';
+	mdbg(INFO4, "Extracted ip address is '%s'", tmp_ip);
+
+	/* extract port */
+	tmp_port = simple_strtoul(colon_ptr + 1, &dummy, 10);
+	mdbg(INFO4, "Extracted port number is '%lu'", tmp_port);
+
+	/* fill results */
+	
+	sin->sin_addr.s_addr = in_aton(tmp_ip);
+	
+	sin->sin_port = htons((unsigned short int)tmp_port);
+	sin->sin_family = AF_INET;
+
+leave:
+	return err;
+}
+
+/** TCP architecture specific operations. */
+static struct kkc_arch_ops tcp_arch_ops = {
+	.kkc_arch_obj_new = kkc_sock_tcp_new
+};
+
+/** Socket operations that support polymorphism. */
+static struct kkc_sock_ops tcp_sock_ops = {
+	.connect = kkc_sock_tcp_connect,
+	.listen  = kkc_sock_tcp_listen,
+	.accept  = kkc_sock_tcp_accept,
+	.send    = kkc_sock_tcp_send,
+	.recv    = kkc_sock_tcp_recv,
+	.shutdown = kkc_sock_tcp_shutdown,
+	.add_wait_queue = kkc_sock_tcp_add_wait_queue,
+	.remove_wait_queue = kkc_sock_tcp_remove_wait_queue,
+	.register_read_callback = kkc_sock_tcp_register_read_callback,
+	.free = kkc_sock_tcp_free,
+	.getname = kkc_sock_tcp_getname,
+	.is_address_equal_to = kkc_sock_tcp_is_address_equal_to
+};
+
+
+/** Method used for enabling of keep alive on socket and setting of aggressive timing of timeout detection */
+int kkc_sock_enable_keepalive(struct kkc_sock* self) {
+	struct kkc_sock_tcp* kkc_tcp = KKC_SOCK_TCP(self);
+	struct socket* socket = kkc_tcp->sock;
+	int val = 1;
+	int ret;
+
+	// Note: must be done via those calls, direct setting does not update timer values!
+
+	val = 10; // Start tracking timeout after 10 seconds
+	ret = kernel_setsockopt(socket, SOL_TCP, TCP_KEEPIDLE, (char __user *) &val, sizeof(val));
+	if ( ret ) minfo(ERR4, "Failed to set keep idle flag");
+
+	val = 1; // Check tracking message every second after first timeout
+	ret = kernel_setsockopt(socket, SOL_TCP, TCP_KEEPINTVL, (char __user *) &val, sizeof(val));
+	if ( ret ) minfo(ERR4, "Failed to set keep intl flag");
+
+	val = 10; // After 10 missed packets, mark the connection as dead
+	ret = kernel_setsockopt(socket, SOL_TCP, TCP_KEEPCNT, (char __user *) &val, sizeof(val));
+	if ( ret ) minfo(ERR4, "Failed to set keep cnt flag");	 
+
+	ret = kernel_setsockopt(socket, SOL_SOCKET, SO_KEEPALIVE,
+			(char *)&val, sizeof(val));
+	if (ret < 0) minfo(ERR4, "Failed to set keep-alive");
+
+
+	return ret;
+}
+
+
+
+/** Method used for disabling of nagels algorithm on a tcp connection */
+int kkc_sock_tcp_disable_nagle(struct kkc_sock* self) {
+	// COPIED FORM tcp.c
+	struct kkc_sock_tcp* kkc_tcp = KKC_SOCK_TCP(self);
+	struct socket* tcp_socket = kkc_tcp->sock;
+	struct sock* sock = tcp_socket->sk;
+ 	struct tcp_sock *tp = tcp_sk(sock);
+        //struct inet_connection_sock *icsk = inet_csk(sock);
+
+	tp->nonagle |= TCP_NAGLE_OFF|TCP_NAGLE_PUSH;
+	// TODO: This is not exported... but we likely do not need that as long as we disable nagle before any transmissions, right?
+        //tcp_push_pending_frames(sock);	
+
+	return 0;
+}
+
+/** Method used for enabling quick-ack on a tcp connection */
+int kkc_sock_tcp_enable_quickack(struct kkc_sock* self) {
+	// COPIED FORM tcp.c
+	struct kkc_sock_tcp* kkc_tcp = KKC_SOCK_TCP(self);
+	struct socket* tcp_socket = kkc_tcp->sock;
+	struct sock* sock = tcp_socket->sk;
+        struct inet_connection_sock *icsk = inet_csk(sock);
+
+	// TODO: Can be called safely only before the connection is established
+	// Otherwise we shall copy other bits from tcp.c
+	icsk->icsk_ack.pingpong = 0;
+	return 0;
+}
+
+/**
+ * @}
+ */
--- linux-3.7.1_original/clondike/src/kkc/kkc_sock.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/kkc/kkc_sock.c	2013-03-01 11:30:21.000000000 +0100
@@ -0,0 +1,294 @@
+/** @file kkc_sock.c - Generic Kernel to Kernelin Communcation abstraction - socket
+ *
+ * Date: 04/13/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: kkc_sock.c,v 1.3 2007/10/07 15:53:59 stavam2 Exp $
+ *
+ * This file is part of Kernel-to-Kernel Communication Library(KKC)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * KKC is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * KKC is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <linux/errno.h>
+
+#define KKC_SOCK_PRIVATE
+#include "kkc_sock.h"
+
+#include <dbg.h>
+
+
+/** 
+ * \<\<public\>\> Initializes generic socket.  This method should be
+ * called back from the architecture specific constructor to
+ * initialize common socket fields.  Architecture is set.
+ *
+ * @param *self - pointer to this socket instance
+ * @param *sock_ops - operations vector of the architecture specific socket
+ * @param *arch - socket specific architecture. This allows the user
+ * to read architecture name.
+ * 
+ * @return 0 upon successful connection
+ */
+int kkc_sock_init(struct kkc_sock *self, struct kkc_arch *arch, 
+		  struct kkc_sock_ops *sock_ops)
+{
+	if (!arch) {
+		mdbg(ERR4, "No architecture specified, can't init socket");
+		return -EINVAL;
+	}
+	self->arch = arch;
+	self->sock_ops = sock_ops;
+	atomic_set(&self->ref_count, 1);
+	sema_init(&self->sock_send_sem, 1);		// Change macro init_MUTEX to contain of original macro sema_init(sem,1) for kernel 3.7.1 by Jiri Rakosnik
+	sema_init(&self->sock_recv_sem, 1);
+	INIT_LIST_HEAD(&self->pub_list);
+
+	mdbg(INFO4, "Initialized KKC socket: %p", self); 
+
+	return 0;
+}
+
+/** 
+ * \<\<public\>\> Connects to the given address.  Delegates all work
+ * to the architecture specific socket operation.
+ *
+ * @param *self - pointer to this socket instance
+ * @param *addr - address where to connect to.
+ * @return 0 upon successful connection
+ */
+int kkc_sock_connect(struct kkc_sock *self, char *addr)
+{
+	int error = 0;
+	mdbg(INFO4, "Connecting to '%s' ..", addr);
+	if (self->sock_ops && self->sock_ops->connect)
+		error = self->sock_ops->connect(self, addr);
+
+	return error;
+}
+
+
+/** 
+ * \<\<public\>\> Starts listening on a specified address. Delegates
+ * all work to the architecture specific socket operation.
+ *
+ * @param *self - pointer to this socket instance
+ * @param *addr - address where to connect to.
+ * @return 0 upon successfully establishing the listening
+ */
+int kkc_sock_listen(struct kkc_sock *self, char *addr)
+{
+	int error = 0;
+	mdbg(INFO4, "Listening on '%s' ..", addr);
+	if (self->sock_ops && self->sock_ops->listen)
+		error = self->sock_ops->listen(self, addr);
+
+	return error;
+}
+
+/** 
+ * \<\<public\>\> Creates a new socket by accepting the incoming
+ * connection.  Delegates work to the architecture specific class.
+ *
+ * @param *self - pointer to this socket instance
+ * @param **new_kkc_sock - storage for the new socket created for the incoming 
+ * connection.
+ * @param flags - specify blocking/nonblocking mode
+ * @return 0 upon successful connection
+ */
+int kkc_sock_accept(struct kkc_sock *self, struct kkc_sock **new_kkc_sock, 
+		    kkc_sock_flags_t flags)
+{
+	int error = 0;
+	mdbg(INFO4, "Accepting connection..");
+	if (self->sock_ops && self->sock_ops->accept)
+		error = self->sock_ops->accept(self, new_kkc_sock, flags);
+	return error;
+}
+
+/** 
+ * \<\<public\>\> Sends out specified data.  Sends the entire content
+ * of the specified buffer. This might require multiple iterations -
+ * the method will try until all data is sent or an error occurs.
+ *
+ * @param *self - pointer to this socket instance
+ * @param *buf - buffer with the data to be sent
+ * @param buflen - length of the buffer to be sent
+ * @param *buflen - number of bytes actually sent
+ * @param flags - specify blocking or non-blocking mode. 
+ * @return number of bytes actually sent or error when < 0
+ */
+int kkc_sock_send(struct kkc_sock *self, void *buf, int buflen,
+		  kkc_sock_flags_t flags)
+{
+	int result = 0;
+	mdbg(INFO4, "Sending buffer %p length: %d bytes", buf, buflen);
+	if (self->sock_ops && self->sock_ops->send) {
+		result = kkc_sock_send_recv(self, buf, buflen, flags, 
+					    self->sock_ops->send);
+	}
+
+	return result;
+}
+
+
+/** 
+ * \<\<public\>\> Receives requested number of bytes of data.  The
+ * behavior of the function depends on the mode. In blocking mode, it
+ * will try to receive all buflen bytes via kkc_sock_send_recv(). In
+ * non-blocking mode it will perform only 1 attempt to receive data,
+ * using the receive operation of the socket instance directly.
+ *
+ * @param *self - pointer to this socket instance
+ * @param *buf - buffer where to store received data.
+ * @param buflen - length of the buffer to be sent
+ * @param flags - specify blocking or non-blocking mode.
+ * @return number of bytes actually received or error when < 0
+ */
+int kkc_sock_recv(struct kkc_sock *self, void *buf, int buflen,
+		  kkc_sock_flags_t flags)
+{
+	int result = 0;
+	mdbg(INFO4, "Receiving into buffer %p length: %d bytes", buf, buflen);
+	if (self->sock_ops && self->sock_ops->recv) {
+		if (flags == KKC_SOCK_BLOCK)
+			result = kkc_sock_send_recv(self, buf, buflen, flags,
+						    self->sock_ops->recv); 
+		else
+			result = self->sock_ops->recv(self, buf, buflen, flags);
+			
+	}
+
+	return result;
+}
+
+
+/** 
+ * \<\<public\>\> Disconnects the socket.  Delegates work to the
+ * specific socket class.
+ *
+ * @param *self - pointer to this socket instance
+ * @return 0 upon success
+ */
+int kkc_sock_shutdown(struct kkc_sock *self)
+{
+	int error = 0;
+	if (self->sock_ops && self->sock_ops->shutdown) {
+		error = self->sock_ops->shutdown(self);
+
+	}
+
+	return error;
+}
+
+/** 
+ * \<\<public\>\> Adds a task to the queue of processes sleeping on
+ * the socket.  Delegates work to the specific socket class.
+ *
+ * @param *self - pointer to this socket instance
+ * @param *wait - pointer to the waitqueue element with the task that
+ * wants to sleep on this socket.
+ * @return 0 upon success
+ */
+int kkc_sock_add_wait_queue(struct kkc_sock *self, wait_queue_t *wait)
+{
+	int error = 0;
+	if (self->sock_ops && self->sock_ops->add_wait_queue)
+		error = self->sock_ops->add_wait_queue(self, wait);
+
+	return error;
+}
+
+/** 
+ * \<\<public\>\> Removes a task from the queue of processes sleeping
+ * on the socket.  Delegates work to the specific socket class.
+ *
+ * @param *self - pointer to this socket instance
+ * @param *wait - pointer to the waitqueue element with the task that
+ * wants to sleep on this socket.
+ * @return 0 upon success
+ */
+int kkc_sock_remove_wait_queue(struct kkc_sock *self, wait_queue_t *wait)
+{
+	int error = 0;
+	if (self->sock_ops && self->sock_ops->remove_wait_queue)
+		error = self->sock_ops->remove_wait_queue(self, wait);
+
+	return error;
+}
+
+/** \<\<public\>\> Registers data_ready callback function, that should be called when there are some data 
+ * read to be read on the socket
+ */
+int kkc_sock_register_read_callback(struct kkc_sock* self, kkc_data_ready callback, void* callback_data) {
+	int error = 0;
+	if (self->sock_ops && self->sock_ops->register_read_callback)
+		error = self->sock_ops->register_read_callback(self, callback, callback_data);
+
+	return error;
+};
+
+
+/** @addtogroup kkc_sock_class
+ *
+ * @{
+ */
+
+/**
+ * \<\<private\>\> Transfers a required number of bytes. This method
+ * is intended for receiving and sending in blocking mode.  The caller
+ * specifies only which method should be used. The method tries to
+ * transfer all the requested bytes until an error occurs.
+ *
+ * @param *self - pointer to this socket instance
+ * @param *buf - buffer for transferred data (received or sent)
+ * @param buflen - length of the buffer to be sent/received
+ * @param flags - specify blocking or non-blocking mode.
+ * @param *kkc_sock_method - send or receive method to be executed
+ * @return number of bytes actually sent or received or error when < 0
+ */
+static int kkc_sock_send_recv(struct kkc_sock *self, void *buf, int buflen, 
+			      kkc_sock_flags_t flags,
+			      int (*kkc_sock_method)(struct kkc_sock *, void *, 
+						     int, kkc_sock_flags_t))
+{
+	int error = 0;
+	int total = 0;
+	while ((buflen > 0) && (error >= 0)) {
+		error = kkc_sock_method(self, buf, buflen, flags);
+		mdbg(INFO4, "Buffer starting at %p, xferred %d bytes", buf, error);
+		buf += error;
+		buflen -= error;
+		total += error;
+	}
+	/* When error occured, return error code, otherwise the total */
+	return  ((error >= 0) ? total : error);
+}
+
+/**
+ * @}
+ */
+/* connect and listen are not exported as sockets should be created via
+ * kkc_connect/kkc_listen that allow specifying a proper architecture
+ * in the address string */
+EXPORT_SYMBOL_GPL(kkc_sock_accept);
+EXPORT_SYMBOL_GPL(kkc_sock_send);
+EXPORT_SYMBOL_GPL(kkc_sock_recv);
+EXPORT_SYMBOL_GPL(kkc_sock_shutdown);
+EXPORT_SYMBOL_GPL(kkc_sock_add_wait_queue);
+EXPORT_SYMBOL_GPL(kkc_sock_remove_wait_queue);
+EXPORT_SYMBOL_GPL(kkc_sock_register_read_callback);
--- linux-3.7.1_original/clondike/src/kkc/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/kkc/Makefile	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,24 @@
+##############################################################################
+# @file Makefile - Builds Kernel to Kernel Communication library
+#
+# Author: Petr Malat
+#
+# This file is part of Clondike.
+#
+# Clondike is free software: you can redistribute it and/or modify it under 
+# the terms of the GNU General Public License version 2 as published by 
+# the Free Software Foundation.
+#
+# Clondike is distributed in the hope that it will be useful, but WITHOUT ANY
+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
+# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more 
+# details.
+# 
+# You should have received a copy of the GNU General Public License along with 
+# Clondike. If not, see http://www.gnu.org/licenses/.
+##############################################################################
+
+ccflags-y = `dbgenv $<`
+
+obj-$(CONFIG_TCMI) := kkc_lib.o
+kkc_lib-objs += kkc.o kkc_sock.o kkc_sock_tcp.o
--- linux-3.7.1_original/clondike/src/kkc/kkc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/kkc/kkc.h	2013-03-01 11:10:02.000000000 +0100
@@ -0,0 +1,91 @@
+/** @file kkc.h - Kernel to Kernel Communication Library for
+ *                communication between two Linux Kernels
+ *
+ * Date: 04/13/2005
+ *
+ * Author: Jan Capek, Daniel Langr (original version for 2.4 kernel)
+ *
+ * $Id: kkc.h,v 1.3 2007/08/15 20:30:23 malatp1 Exp $
+ *
+ * This file is part of Kernel-to-Kernel Communication Library(KKC)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * KKC is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * KKC is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef _KKC_H
+#define _KKC_H
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/slab.h>		//Added include slab for kernel 3.7.1 by Jiri Rakosnik
+
+#include "kkc_sock.h"
+#include "kkc_sock_sleeper.h"
+#include "kkc_arch.h"
+
+
+/** @defgroup kkc_class KKC
+ *
+ * KKC is a \<\<singleton\>\> class that provides interkernel
+ * communication facility. KKC sockets are used as an abstraction of
+ * a connection. This component ensures loading architecture specific
+ * modules via \link kkc_arch_class kkc_arch \endlink. 
+ *
+ * The communication features can be divided into two groups: 
+ *
+ * -# Socket creation and connecting to the destination or listening
+ * on a specified interface. This is handled by connect/listen
+ * operations as follows: Based on the string specified by the user
+ * (e.g. tcp:192.168.0.1:2000), it gets the instance of the particular
+ * architecture (tcp in this case) and delegates the work to the
+ * particular architecture to instantiate the socket. Then, the new socket
+ * is asked to setup a connection or listening.
+ * -# Regular socket operations - to send/receive data, disconnect,
+ * append/remove a process to the socket waitqueue. These operations
+ * are KKC socket methods and this class provides only aliases.
+ *
+ * @{
+ */
+
+
+/** Maximum where string length*/
+#define KKC_MAX_WHERE_LENGTH (KKC_MAX_ARCH_LENGTH + KKC_SOCK_MAX_ADDR_LENGTH)
+
+
+/** \<\<public\>\> Creates an architecture specific socket and
+ * performs a connection to the destination. */
+extern int kkc_connect(struct kkc_sock **sock, const char *addr);
+/** \<\<public\>\> Creates an architecture specific socket and starts
+ * listening for incoming connnections. */
+extern int kkc_listen(struct kkc_sock **sock, const char *addr);
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef KKC_PRIVATE
+
+/** Creates a new socket and Establishes a new connection or
+ * listening */
+static int kkc_establish(struct kkc_sock **sock, const char *addr,
+			 int (*kkc_sock_method)(struct kkc_sock *, char *));
+/** Gets the architecture based on the where string. */
+static int kkc_get_architecture(const char *where, struct kkc_arch **arch, char *addr);
+
+#endif /* KKC_PRIVATE */
+
+/**
+ * @}
+ */
+
+#endif	/* _KKC_H */
--- linux-3.7.1_original/clondike/src/kkc/kkc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/kkc/kkc.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,230 @@
+/** @file kkc.c - Kernel to Kernel Communication Library for
+ *                communication between two Linux Kernels
+ *
+ * Date: 04/13/2005
+ *
+ * Author: Jan Capek, Daniel Langr (original version for 2.4 kernel)
+ *
+ * $Id: kkc.c,v 1.3 2007/08/15 20:30:23 malatp1 Exp $
+ *
+ * This file is part of Kernel-to-Kernel Communication Library(KKC)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * KKC is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * KKC is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#define KKC_PRIVATE
+#include "kkc.h"
+
+#include <dbg.h>
+
+
+
+
+
+/** 
+ * \<\<public\>\> Creates a connection the destination specified by
+ * the user.  The work is delegated to the kkc_establish() method
+ * along with the socket method that kkc_establish() should call on
+ * the newly created socket. To create new connection -
+ * kkc_sock.c::kkc_sock_connect() is used.
+ *
+ * @param **sock - ouput parameter - upon successful connection
+ * contains a valid socket
+ * @param *where - address string with architecture prefix -
+ * e.g. tcp:192.168.0.1.2:2000
+ * @return 0 upon success
+ */
+int kkc_connect(struct kkc_sock **sock, const char *where)
+{
+	return kkc_establish(sock, where, kkc_sock_connect);
+}
+
+
+/** 
+ * \<\<public\>\> Starts listening on a specified interface.  The work
+ * is delegated to the kkc_establish() method along with the socket
+ * method that kkc_establish() should call on the newly created
+ * socket. To create new listening - kkc_sock.c::kkc_sock_connect() is
+ * used.
+ *
+ * @param **sock - ouput parameter - upon successful creation of 
+ * listening contains a valid socket
+ * @param *where - address string with architecture prefix -
+ * e.g. tcp:192.168.0.1.2:2000
+ * @return 0 upon success
+ */
+int kkc_listen(struct kkc_sock **sock, const char *where)
+{
+	return kkc_establish(sock, where, kkc_sock_listen);
+}
+
+/** @addtogroup kkc_class
+ *
+ * @{
+ */
+
+/** 
+ * \<\<private\>\> Creates an architecture specific socket and starts
+ * listening or connects to the destination.  First an architecture,
+ * based on the prefix in the address, has to be retrieved.  The
+ * creation of the socket is delegated to the archictecture. If
+ * everything goes fine, the socket is asked to perform an operation
+ * specified by the user - kkc_sock_method().
+ *
+ * @param **sock - ouput parameter - upon successful creation of 
+ * a connection or listening contains a valid socket
+ * @param *where - address string with architecture prefix -
+ * e.g. tcp:192.168.0.1.2:2000
+ * @param *kkc_sock_method - method called on the created socket. 
+ * This would yield a new connection or a listening, depending
+ * on what method the user specified 
+ * @return 0 upon success
+ */
+static int kkc_establish(struct kkc_sock **sock, const char *where,
+			 int (*kkc_sock_method)(struct kkc_sock *, char *))
+{
+
+	struct kkc_arch *arch;
+	int err = 0;
+	char addr[KKC_SOCK_MAX_ADDR_LENGTH];
+	*sock = NULL;
+
+	mdbg(INFO4, "Requesting architecture structure and network address");
+	if ((err = kkc_get_architecture(where, &arch, addr)) < 0) {
+		mdbg(ERR4, "Cannot get architecture structure");
+		err = -ENOMEM;
+		goto exit0;
+	}
+
+	/* instantiate the socket */
+	if (!((*sock) = KKC_SOCK(kkc_arch_obj_new(arch)))) {
+		mdbg(ERR4, "Failed to create a new socket");
+		err = -ENOMEM;
+		goto exit1;
+	}
+	if (kkc_sock_method(*sock, addr)) {
+		mdbg(ERR4, "KKC socket method failed");
+		err = -ENOMEM;
+		goto exit2;
+	}
+	/* release the architecture as the socket has created its own
+	 * reference */
+	kkc_arch_put(arch);
+	return 0;
+	/* error handling */
+ exit2:
+	kkc_sock_put(*sock);
+	*sock = NULL; /* return no socket to the user */
+ exit1:
+	kkc_arch_put(arch);
+ exit0:
+	return err;
+}
+
+/**
+ * \<\<private\>\> Helper function for parsing 'where' string and
+ * requesting for particular architecture structure. As side effect
+ * fills 'addr' string with address part of 'where'.
+ *
+ * @param *where - pointer to the where request string
+ * @param **arch - output parameter - stores the architecture if one found
+ * @param *addr - storage for the address string, that gets extracted from 
+ * the where string
+ * @return 0 upon success.
+ */
+static int kkc_get_architecture(const char *where, struct kkc_arch **arch, char *addr)
+{
+	char arch_name[KKC_MAX_ARCH_LENGTH];
+	char *colon_ptr;
+	int colon_pos;
+
+	int err = 0;
+
+	/* find colon */
+	if ((colon_ptr = strchr(where, ':')) == NULL) {
+		mdbg(ERR4, "Invalid syntax - could not find colon");
+		err = -EINVAL;
+		goto exit0;
+	}
+
+	/* check position */
+	colon_pos = colon_ptr - where;
+	if (colon_pos > (KKC_MAX_ARCH_LENGTH - 1)) {
+		mdbg(ERR4, "Invalid syntax - too long architecture name length");
+		err = -EINVAL;
+		goto exit0;
+	}
+
+	/* get architecture name */
+	strncpy(arch_name, where, colon_pos);
+	arch_name[colon_pos] = '\0';
+	mdbg(INFO4, "Extracted architecture name: ""%s""", arch_name);
+
+	/* get address */
+	strncpy(addr, colon_ptr + 1, KKC_SOCK_MAX_ADDR_LENGTH - 1);
+	addr[KKC_SOCK_MAX_ADDR_LENGTH - 1] = '\0';
+	mdbg(INFO4, "Extracted address: ""%s""", addr); 
+	
+
+	if (!(*arch = kkc_arch_get_by_name(arch_name))) {
+		mdbg(ERR4, "Could not get architecture for '%s'", arch_name);
+		err = -EINVAL;
+	}
+		
+	/* error handling */
+exit0:
+	return err;
+}
+
+/**
+ * @}
+ */
+
+
+/**
+ * KKC module loading
+ *
+ * @return always 0
+ */
+int __init kkc_init_module(void)
+{
+
+	minfo(INFO1, "Loading KKC");
+	return 0;
+}
+
+/**
+ * KKC module unloading
+ */
+void __exit kkc_exit_module(void)
+{
+	minfo(INFO1, "Unloading KKC");
+}
+
+module_init(kkc_init_module);
+module_exit(kkc_exit_module);
+
+
+EXPORT_SYMBOL_GPL(kkc_connect);
+EXPORT_SYMBOL_GPL(kkc_listen);
+
+/*
+ * Module properties
+ */
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Jan Capek");
+MODULE_AUTHOR("Daniel Langr");
+MODULE_DESCRIPTION("Kernel to Kernel Communication Library");
--- linux-3.7.1_original/clondike/src/kkc/kkc_arch.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/kkc/kkc_arch.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,203 @@
+/** @file kkc_arch.h - KKC architecture descriptor class.
+ *
+ * Date: 04/13/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: kkc_arch.h,v 1.2 2007/07/02 02:26:17 malatp1 Exp $
+ *
+ * This file is part of Kernel-to-Kernel Communication Library(KKC)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * KKC is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * KKC is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef _KKC_ARCH_H
+#define _KKC_ARCH_H
+
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/stringify.h>
+
+#include <dbg.h>
+
+/** @defgroup kkc_arch_class kkc_arch class
+ *
+ * @ingroup kkc_class
+ *
+ * This class describes a particular network architecture. Each
+ * architecture has its unique name. Based on this name, the main KKC
+ * module will lookup a particular architecture to create a user
+ * specified object. 
+ *
+ * The instances of kkc_arch are to be created at compile time by the
+ * corresponding architecture socket class(e.g. \link
+ * kkc_sock_tcp_class kkc_sock_tcp \endlink). The socket class then
+ * provides architecture specific operations. Currently, there is only
+ * one operation needed - the socket constructor.
+ * 
+ * Also each particular architecture instance retains a reference to a
+ * module where it has been declared. Each object created via the
+ * architecture owns a reference to the architecture. That way, the
+ * module can't get unloaded when instance of its sockets still exist.
+ *
+ * @{
+ */
+/** Maximum architecture string length. */
+#define KKC_MAX_ARCH_LENGTH 20
+
+/** Describes a generic KKC architecture object */
+typedef void* kkc_arch_obj_t;
+
+/** Architecture specific operations */
+struct kkc_arch_ops {
+	/** instantiates a KKC object. */
+	kkc_arch_obj_t (*kkc_arch_obj_new)(void);
+};
+
+
+/** Compound structure, describes one particular architecture. */
+struct kkc_arch {
+	/** Name of network architecture (e.g. 'tcp'). */
+	char name[KKC_MAX_ARCH_LENGTH];
+	
+	/** Architecture specific operations. */
+	struct kkc_arch_ops *arch_ops;
+
+	/** Module owning this architecture. */
+	struct module *owner;
+
+	/** Any data needed by particular network architecture. */
+	void *data;
+};
+
+
+/** KKC architecture prefix. */
+#define KKC_ARCH_PREFIX kkc_arch_
+/** KKC architecture prefix in string form - used when looking up
+ * particular architecture. */
+#define KKC_ARCH_PREFIX_STR __stringify(KKC_ARCH_PREFIX)
+
+/** Constructs the architecture symbol name. */
+#define KKC_ARCH(a_name) kkc_arch_##a_name
+
+
+/** Casts to the architecture object. */
+#define KKC_ARCH_OBJ(o) ((kkc_arch_obj_t)o)
+
+/** 
+ * Declares a KKC architecture.  This is the preferred way of declaring
+ * of a new architecture by specific architecture modules.
+ * 
+ *
+ * @param a_name - name of the kkc architecture identifier (not quoted)
+ * @param a_ops - pointer to the architecture specific operations
+ * @param a_data - pointer to the architecture specific data
+ */
+#define KKC_ARCH_DECLARE(a_name, a_ops, a_data)	\
+struct kkc_arch KKC_ARCH(a_name) = {		\
+	.name = #a_name,			\
+	.arch_ops = a_ops,			\
+	.owner = THIS_MODULE,			\
+	.data = a_data				\
+};						\
+EXPORT_SYMBOL_GPL(KKC_ARCH(a_name))
+
+
+/** 
+ * \<\<public\>\> Architecture name accessor.
+ *
+ * @param *self - pointer to this architecture instance
+ * @return pointer to the architecture describing string
+ */
+static inline char* kkc_arch_name(struct kkc_arch *self)
+{
+	return self->name;
+}
+
+/** 
+ * \<\<public\>\> Increments the reference counter on the module
+ * owning the architecture. So that he module can't get unloaded when
+ * being used.
+ *
+ * @param *self - pointer to this architecture instance
+ * @return pointer to the architecture if succeeded in getting the module or NULL
+ */
+static inline struct kkc_arch* kkc_arch_get(struct kkc_arch *self)
+{
+       if (try_module_get(self->owner))
+	       return self;
+       return NULL;
+}
+
+/** 
+ * \<\<public\>\> Retrieves an architecture by name.  This requires
+ * merging the architecture name with the architecture prefix and
+ * asking the kernel to retrieve the symbol specified by this string.
+ *
+ * This is a class method
+ * @param arch_name - name of the architecture requested (e.g. 'tcp')
+ * @return - instance of the kkc_arch that handles the specified type
+ */
+static inline struct kkc_arch* kkc_arch_get_by_name(char *arch_name)
+{
+
+	char sym[sizeof(KKC_ARCH_PREFIX_STR) + KKC_MAX_ARCH_LENGTH];
+	strlcpy(sym, KKC_ARCH_PREFIX_STR, sizeof(KKC_ARCH_PREFIX_STR) + KKC_MAX_ARCH_LENGTH);
+	strlcat(sym, arch_name, sizeof(KKC_ARCH_PREFIX_STR) + KKC_MAX_ARCH_LENGTH);
+	mdbg(INFO3, "Getting architecture '%s', prefix: '%s'", sym, MODULE_SYMBOL_PREFIX);
+
+	return (struct kkc_arch*) __symbol_get((const char*)sym);
+}
+
+/** 
+ * \<\<public\>\> Decrements the reference counter on the module
+ * owning the architecture.
+ *
+ * @param *self - pointer to this architecture instance
+ */
+static inline void kkc_arch_put(struct kkc_arch *self)
+{
+	return module_put(self->owner);
+}
+
+/** 
+ * \<\<public\>\> Calls the constructor to build the architecture
+ * specific object.
+ *
+ * @param *self - pointer to this architecture instance
+ * @return architecture object instance or NULL
+ */
+static inline kkc_arch_obj_t kkc_arch_obj_new(struct kkc_arch *self)
+{
+	kkc_arch_obj_t obj = NULL;
+	if (self->arch_ops && self->arch_ops->kkc_arch_obj_new)
+		obj = self->arch_ops->kkc_arch_obj_new();
+	return obj;
+}
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef KKC_ARCH_PRIVATE
+
+#endif /* KKC_ARCH_PRIVATE */
+
+
+/**
+ * @}
+ */
+
+
+#endif /* _KKC_ARCH_H */
+
+
--- linux-3.7.1_original/clondike/src/kkc/kkc_sock_tcp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/kkc/kkc_sock_tcp.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,123 @@
+/** @file kkc_sock_tcp.h - Generic Kernel to Kernelin Communcation abstraction - socket
+ *
+ * Date: 04/13/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: kkc_sock_tcp.h,v 1.4 2008/05/02 19:59:20 stavam2 Exp $
+ *
+ * This file is part of Kernel-to-Kernel Communication Library(KKC)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * KKC is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * KKC is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef _KKC_SOCK_TCP_H
+#define _KKC_SOCK_TCP_H
+
+#include <linux/inet.h>
+
+#include "kkc_sock.h"
+
+/** @defgroup kkc_sock_tcp_class kkc_sock_tcp class
+ *
+ * @ingroup kkc_sock_class
+ *
+ * This class is a TCP socket. The functionality is implemented via
+ * BSD socket abstraction.
+ * 
+ * @{
+ */
+
+/** A coumpound structure that contains TCP socket specific information. */
+struct kkc_sock_tcp {
+	/** parent class instance */
+	struct kkc_sock super;
+	/** BSD socket abstraction. */
+	struct socket *sock;
+	/** Read callback function.. TODO: Perhaps move this to sock directly? */
+	kkc_data_ready read_callback;
+	/** Data provided to the callback function. The socket is NOT owner of these data! */
+	void* callback_data;
+};
+
+/** Casts to the kkc_sock instance. */
+#define KKC_SOCK_TCP(s) ((struct kkc_sock_tcp*)s)
+
+/** Method used for disabling of nagels algorithm on a tcp connection */
+int kkc_sock_tcp_disable_nagle(struct kkc_sock* self);
+/** Method used for enabling quick-ack on a tcp connection */
+int kkc_sock_tcp_enable_quickack(struct kkc_sock* self);
+/** Method used for enabling of keep alive on socket */
+int kkc_sock_enable_keepalive(struct kkc_sock* self);
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef KKC_SOCK_TCP_PRIVATE
+
+/** Architecture specific constructor. */
+static kkc_arch_obj_t kkc_sock_tcp_new(void);
+/** Connects to the given address */
+static int kkc_sock_tcp_connect(struct kkc_sock *self, char *addr);
+/** Starts listening on a specified address */
+static int kkc_sock_tcp_listen(struct kkc_sock *self, char *addr);
+/** Creates a new socket by accepting the incoming socket. */
+static int kkc_sock_tcp_accept(struct kkc_sock *self, struct kkc_sock **new_kkc_sock, 
+			       kkc_sock_flags_t flags);
+/** Sends out specified data. */
+static int kkc_sock_tcp_send(struct kkc_sock *self, void *buf, int buflen,
+			     kkc_sock_flags_t flags);
+/** Receives requested number of bytes of data. */
+static int kkc_sock_tcp_recv(struct kkc_sock *self, void *buf, int buflen,
+			     kkc_sock_flags_t flags);
+/** Disconnects the socket. */
+static int kkc_sock_tcp_shutdown(struct kkc_sock *self);
+/** Adds a task to the queue of processes waiting sleeping on the socket. */
+static int kkc_sock_tcp_add_wait_queue(struct kkc_sock *self, wait_queue_t *wait);
+/** Removes a task from the queue of processes waiting sleeping on the socket. */
+static int kkc_sock_tcp_remove_wait_queue(struct kkc_sock *self, wait_queue_t *wait);
+/** Free socket related resources */
+static void kkc_sock_tcp_free(struct kkc_sock *self);
+/** Socket name accessor. */
+static int kkc_sock_tcp_getname(struct kkc_sock *self, char *name, int size, int local);
+/** Address comparator */
+static int kkc_sock_tcp_is_address_equal_to(struct kkc_sock *self, const char* address, int addr_length, int local);
+
+/** Transfers a buffer using the specified method. */
+/*static int kkc_sock_tcp_send_recv(struct kkc_sock *self, void *buf, int buflen, 
+				  int (*kkc_sock_tcp_method)(struct kkc_sock_tcp *, void *, 
+							     int, kkc_tcp_flags_t));
+*/
+
+/** Helper class method for extracting ip address and port number from
+ * string argument. */
+static int kkc_sock_tcp_extract_addr(char *addr, struct sockaddr_in *sin);
+
+/** TCP architecture specific operations. */
+static struct kkc_arch_ops tcp_arch_ops; 
+
+/** TCP Socket specific operations. */
+static struct kkc_sock_ops tcp_sock_ops; 
+
+#endif /* KKC_SOCK_TCP_PRIVATE */
+
+
+/**
+ * @}
+ */
+
+
+#endif /* _KKC_SOCK_TCP_H */
+
+
--- linux-3.7.1_original/clondike/src/kkc/kkc_sock_sleeper.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/kkc/kkc_sock_sleeper.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,140 @@
+/** @file kkc_sock_sleeper.h - Artificial object, that simplifies
+ *                             sleeping on sockets
+ *
+ * Date: 04/18/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: kkc_sock_sleeper.h,v 1.2 2007/07/02 02:26:17 malatp1 Exp $
+ *
+ * This file is part of Kernel-to-Kernel Communication Library(KKC)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * KKC is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * KKC is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef _KKC_SOCK_SLEEPER_H
+#define _KKC_SOCK_SLEEPER_H
+
+#include <linux/list.h>
+
+#include "kkc_sock.h"
+
+
+/** @defgroup kkc_sock_sleeper kkc_sock_sleeper class
+ *
+ * @ingroup kkc_class
+ *
+ * The main purpose of this class is to make it easier to create
+ * and manage sleeping on KKC sockets. Usually when a thread 
+ * is watching multiple sockets, it needs to create a separate
+ * wait_queue_t element for it. The problem is where to store
+ * all these queue elements as all its internal linking items
+ * are fully used by the kernel wait queue. This class provides
+ * a simple solution - a wrapper object.
+ *
+ * The object is intentionally designed for single threaded access(no
+ * reference counting) as this should be sufficient.
+ * 
+ * @{
+ */
+/** Compound structure allowing external linking socket sleepers. */
+struct kkc_sock_sleeper {
+	/** linking element for public use. */
+	struct list_head list;
+	/** wait queue element passed to the socket. */
+	wait_queue_t wait;
+	/** socket associated with the sleeper */
+	struct kkc_sock *sock;
+};
+
+/** 
+ * \<\<public\>\> Creates a new sleeper element associated with a
+ * particular socket and task. The specified task is added to the
+ * socket wait queue
+ *
+ * @param *sock - target socket where to add new waiting process
+ * @param *tsk - task that wants to sleep on socket's wait queue
+ * @return new sleeper or NULL
+ */
+static inline struct kkc_sock_sleeper* kkc_sock_sleeper_add(struct kkc_sock *sock, 
+							    struct task_struct *tsk)
+{
+	struct kkc_sock_sleeper *sleeper;
+
+	if (!(sleeper = (struct kkc_sock_sleeper*)
+	      kmalloc(sizeof(struct kkc_sock_sleeper), GFP_KERNEL))) {
+		mdbg(ERR3, "Failed to allocate KKC sock sleeper");
+		goto exit0;
+	}
+	/* initialize internal data */
+	INIT_LIST_HEAD(&sleeper->list);
+	init_waitqueue_entry(&sleeper->wait, tsk);
+	sleeper->sock = sock;
+
+	/* append the task to socket's wait queue */
+	kkc_sock_add_wait_queue(sock, &sleeper->wait);
+
+	mdbg(INFO3, "Added sleeper for socket local: '%s', remote: '%s'", 
+	     kkc_sock_getsockname2(sock), kkc_sock_getpeername2(sock));
+
+	return sleeper;
+	/* error handling */
+ exit0:
+	return NULL;
+}
+
+/** 
+ * \<\<public\>\> Removes a sleeper from its socket, from the list and
+ * disposes it.
+ *
+ * @param *self - this socket sleeper instance
+ */
+static inline void kkc_sock_sleeper_remove(struct kkc_sock_sleeper *self)
+{
+	list_del_init(&self->list);
+	kkc_sock_remove_wait_queue(self->sock, &self->wait);
+	mdbg(INFO3, "Removed sleeper from socket local: '%s', remote: '%s'", 
+	     kkc_sock_getsockname2(self->sock), kkc_sock_getpeername2(self->sock));
+	kfree(self);
+}
+
+
+/** 
+ * \<\<public\>\> Checks if the specified socket matches the socket
+ * stored in the sleeper. If so, the sleeper removes itself from the
+ * wait queue.
+ *
+ * @param *self - this socket sleeper instance
+ * @param *sock - socket that is to be removed from a sleeper
+ * @return true if successfully removed
+ */
+static inline int kkc_sock_sleeper_remove_match(struct kkc_sock_sleeper *self,
+						struct kkc_sock *sock)
+{
+	int ret = 0;
+	if (self->sock == sock) {
+		mdbg(INFO4, "Socket matches, removing..");
+		kkc_sock_sleeper_remove(self);
+		ret = 1;
+	}
+	return ret;
+}
+/**
+ * @}
+ */
+
+
+#endif /* _KKC_SOCK_SLEEPER_H */
--- linux-3.7.1_original/clondike/src/kkc/kkc_sock.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/kkc/kkc_sock.h	2013-03-01 11:09:44.000000000 +0100
@@ -0,0 +1,373 @@
+/** @file kkc_sock.h - Generic Kernel to Kernelin Communcation abstraction - socket
+ *
+ * Date: 04/13/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: kkc_sock.h,v 1.3 2007/10/07 15:53:59 stavam2 Exp $
+ *
+ * This file is part of Kernel-to-Kernel Communication Library(KKC)
+ * Copyleft (C) 2005  Jan Capek
+ * 
+ * KKC is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * KKC is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef _KKC_SOCK_H
+#define _KKC_SOCK_H
+
+#include <linux/list.h>
+#include <asm/atomic.h>
+#include <linux/semaphore.h>
+#include <linux/mutex.h>		//Added two includes mutex and slab for kernel 3.7.1 by Jiri Rakosnik
+#include <linux/slab.h>
+
+#include "kkc_arch.h"
+
+/** @defgroup kkc_sock_class kkc_sock class
+ *
+ * @ingroup kkc_class
+ *
+ * This is a generic KKC socket. It handles basic administration of
+ * the generic socket, initialization of common socket parameters, and
+ * releasing the socket instance. It is questionable if a regular BSD
+ * socket should be included into the compound structure or
+ * not. Currently, there is no other communication abstraction in Linux
+ * other than sockets. For now, the BSD socket handling functionality
+ * will be in child classes (e.g. kkc_sock_tcp). For the common part
+ * for all network architectures, we will keep only the address in
+ * string form in the kkc_socket super class.
+ *
+ * KKC socket is meant for full duplex communication. In addition, it
+ * provides locking mechanism that allows separate serialization of
+ * send and receive requests.
+ * 
+ * @{
+ */
+
+/** Maximum address length */
+#define KKC_SOCK_MAX_ADDR_LENGTH 100
+
+
+/** Flags for receive and accept operations */
+typedef enum {
+	/* blocking mode operation */
+	KKC_SOCK_BLOCK,
+	/* non-blocking mode operation */
+	KKC_SOCK_NONBLOCK
+} kkc_sock_flags_t;
+
+/** A coumpound structure that contains generic information about a KKC
+ * socket. */
+struct kkc_sock {
+	/** architecture for this socket - the reason why we keep the
+	 * reference is the release the reference to the architecture,
+	 * if the socket has been created based on user string. */
+	struct kkc_arch *arch;
+
+	/** local address ('name') of the socket object - temporary
+	 * storage.*/
+	char sockname[KKC_SOCK_MAX_ADDR_LENGTH];
+
+	/** remote address ('name') of the socket object - temporary
+	 * storage. */
+	char peername[KKC_SOCK_MAX_ADDR_LENGTH];
+
+	/** message operations */
+	struct kkc_sock_ops *sock_ops;
+
+	/** reference counter */
+	atomic_t ref_count;
+
+	/** mutex semaphore to serialize receiving from the socket. */
+	struct semaphore sock_recv_sem;
+	/** mutex semaphore to serialize sending via the socket. */
+	struct semaphore sock_send_sem;
+
+	/** general purpose list entry for storing sockets */
+	struct list_head pub_list;
+};
+
+/** Callback function prototype, that can be registered to be notified about in case there are some data ready to be read on a socket */
+typedef void (*kkc_data_ready)(void* data, int bytes);
+
+/** Socket operations that support polymorphism. */
+struct kkc_sock_ops {
+	/** Connects to the given address. */
+	int (*connect)(struct kkc_sock*, char*);
+	/** Connects to the given address. */
+	int (*listen)(struct kkc_sock*, char*);
+	/** Accepts an incoming socket. */
+	int (*accept)(struct kkc_sock*, struct kkc_sock**, kkc_sock_flags_t);
+	/** Sends out specified data. */
+	int (*send)(struct kkc_sock*, void*, int, kkc_sock_flags_t);
+	/** Receives requested number of bytes of data. */
+	int (*recv)(struct kkc_sock*, void*, int, kkc_sock_flags_t);
+	/** Adds a task to the queue of processes waiting on incoming data. */
+	int (*add_wait_queue)(struct kkc_sock*, wait_queue_t*);
+	/** Removes a task from the queue of processes waiting on incoming data. */
+	int (*remove_wait_queue)(struct kkc_sock*, wait_queue_t*);
+	/** Registers read callback. */
+	int (*register_read_callback)(struct kkc_sock*, kkc_data_ready callback, void* callback_data);
+	/** Disconnects the socket. */
+	int (*shutdown)(struct kkc_sock*);
+	/** Frees socket architecture specific resources. */
+	void (*free)(struct kkc_sock*);
+	/** Socket name/peer name accessor. */
+	int (*getname)(struct kkc_sock *, char *, int, int);
+	/** Compare addresses */
+	int (*is_address_equal_to)(struct kkc_sock *, const char *, int, int);
+};
+
+/** \<\<public\>\> Initializes generic socket. */
+extern int kkc_sock_init(struct kkc_sock *self, struct kkc_arch *arch, 
+			 struct kkc_sock_ops *sock_ops);
+/** \<\<public\>\>  Connects to the given address */
+extern int kkc_sock_connect(struct kkc_sock *self, char *addr);
+/** \<\<public\>\> Starts listening on a specified address */
+extern int kkc_sock_listen(struct kkc_sock *self, char *addr);
+/** \<\<public\>\> Creates a new socket by accepting the incoming socket. */
+extern int kkc_sock_accept(struct kkc_sock *self, struct kkc_sock **new_kkc_sock, 
+			   kkc_sock_flags_t flags);
+/** \<\<public\>\> Sends out specified data. */
+extern int kkc_sock_send(struct kkc_sock *self, void *buf, int buflen,
+			 kkc_sock_flags_t flags);
+/** \<\<public\>\> Receives requested number of bytes of data. */
+extern int kkc_sock_recv(struct kkc_sock *self, void *buf, int buflen,
+			 kkc_sock_flags_t flags);
+/** \<\<public\>\> Disconnects the socket. */
+extern int kkc_sock_shutdown(struct kkc_sock *self);
+/** \<\<public\>\> Adds a task to the queue of processes sleeping on the socket. */
+extern int kkc_sock_add_wait_queue(struct kkc_sock *self, wait_queue_t *wait);
+/** \<\<public\>\> Removes a task from the queue of processes sleeping on the socket. */
+extern int kkc_sock_remove_wait_queue(struct kkc_sock *self, wait_queue_t *wait);
+
+/** \<\<public\>\> Registers data_ready callback function, that should be called when there are some data read to be read on the socket*/
+extern int kkc_sock_register_read_callback(struct kkc_sock*, kkc_data_ready callback, void* callback_data);
+
+/** \<\<public\>\> Checks, whether an address passed as string is equal to this socket local/peer port. Can return true only if current socket is connected. */
+static inline int kkc_sock_is_address_equal_to(struct kkc_sock *self, const char *addr, int addr_length, int local) {
+	int err = 0;
+	if (self->sock_ops && self->sock_ops->is_address_equal_to)
+		err = self->sock_ops->is_address_equal_to(self, addr, addr_length, local);
+	return err;  
+}
+
+
+/**
+ * \<\<public\>\> Local socket name accessor.  Asks the architecture specific socket to
+ * fill in its local name (address).  The generic socket operation
+ * getname() is used, passing 0 selects the local name.
+ *
+ * @param *self - pointer to this socket instance
+ * @param *sockname - pointer to the buffer where the sockname is to be stored
+ * @param size - maximum string length that fits into the sockname buffer
+ * @return 0 upon success
+ */
+static inline int kkc_sock_getsockname(struct kkc_sock *self, char *sockname, int size)
+{
+	int err = 0;
+	if (self->sock_ops && self->sock_ops->getname)
+		err = self->sock_ops->getname(self, sockname, size, 0);
+	return err;
+}
+/**
+ * \<\<public\>\> Peer socket name accessor.  Asks the architecture
+ * specific socket to fill in its remote name (destination address).
+ * The generic socket operation getname() is used, passing 1 selects
+ * the peer name.
+ *
+ * @param *self - pointer to this socket instance
+ * @param *sockname - pointer to the buffer where the sockname is to be stored
+ * @param size - maximum string length that fits into the sockname buffer
+ * @return 0 upon success
+ */
+static inline int kkc_sock_getpeername(struct kkc_sock *self, char *sockname, int size)
+{
+	int err = 0;
+	if (self->sock_ops && self->sock_ops->getname)
+		err = self->sock_ops->getname(self, sockname, size, 1);
+	return err;
+}
+
+/**
+ * \<\<public\>\> Architecture name accessor.  Asks the architecture
+ * to fill in its name.
+ *
+ * @param *self - pointer to this socket instance
+ * @param *archname - pointer to the buffer where the architecture name is to be stored
+ * @param size - maximum string length that fits into the sockname buffer
+ */
+static inline void kkc_sock_getarchname(struct kkc_sock *self, char *archname, int size)
+{
+	strncpy(archname, kkc_arch_name(self->arch), size);
+}
+
+/**
+ * \<\<public\>\> Socket name accessor.  Unlike the previous version,
+ * returns pointer to the socket local name. The socket local name is
+ * stored inside the instance. Having this method makes it easier to
+ * use it inside print statements.
+ * 
+ * @param *self - pointer to this socket instance
+ * @return to the local socket name
+ */
+static inline const char* kkc_sock_getsockname2(struct kkc_sock *self)
+{
+	memset(self->sockname, 0, KKC_SOCK_MAX_ADDR_LENGTH);
+	kkc_sock_getsockname(self, self->sockname, KKC_SOCK_MAX_ADDR_LENGTH);
+	return self->sockname;
+}
+/**
+ * \<\<public\>\> Socket name accessor.  Unlike the previous version,
+ * returns pointer to the socket local name. The socket local name is
+ * stored inside the instance. Having this method makes it easier to
+ * use it inside print statements.
+ * 
+ * @param *self - pointer to this socket instance
+ * @return to the local socket name
+ */
+static inline const char* kkc_sock_getpeername2(struct kkc_sock *self)
+{
+	memset(self->peername, 0, KKC_SOCK_MAX_ADDR_LENGTH);
+	kkc_sock_getpeername(self, self->peername, KKC_SOCK_MAX_ADDR_LENGTH);
+	return self->peername;
+}
+
+/** 
+ * \<\<public\>\> Instance accessor, increments the reference count.
+ *
+ * @param *self - pointer to this message instance
+ */
+static inline struct kkc_sock* kkc_sock_get(struct kkc_sock *self)
+{
+	if (self) {
+		atomic_inc(&self->ref_count);
+	}
+	return self;
+}
+
+/** 
+ * \<\<public\>\> Decrements reference counter, if it reaches 0 the
+ * custom free method is called if defined.  Also the architecture is
+ * released.
+ *
+ * The user is responsible for taking the socket out of any lists
+ * where he had stored it.
+ *
+ * @param *self - pointer to this socket instance
+ */
+static inline void kkc_sock_put(struct kkc_sock *self)
+{
+	if (!self)
+		return;
+	if (atomic_dec_and_test(&self->ref_count)) {
+		mdbg(INFO4, "Destroying KKC socket local: '%s', remote: '%s', %p", 
+		     kkc_sock_getsockname2(self), 
+		     kkc_sock_getpeername2(self), self); 
+		if (self->sock_ops && self->sock_ops->free) 
+			self->sock_ops->free(self);
+		/* release the architecture */
+		kkc_arch_put(self->arch);
+		
+		kfree(self);
+	}
+
+}
+
+
+/**
+ * \<\<public\>\> Locks this socket instance for sending,
+ * interruptible version, the process can be woken up by a signal.
+ *
+ * @param *self - pointer to this file instance
+ */
+static inline int kkc_sock_snd_lock_interruptible(struct kkc_sock *self)
+{
+	return (down_interruptible(&self->sock_send_sem));
+}
+
+/**
+ * \<\<public\>\> Locks this socket instance for sending.
+ *
+ * @param *self - pointer to this socket instance
+ */
+static inline void kkc_sock_snd_lock(struct kkc_sock *self)
+{
+		down(&self->sock_send_sem);
+}
+
+/**
+ * \<\<public\>\> Unlocks this socket instance for sending.
+ *
+ * @param *self - pointer to this socket instance
+ */
+static inline void kkc_sock_snd_unlock(struct kkc_sock *self)
+{
+		up(&self->sock_send_sem);
+}
+
+/**
+ * \<\<public\>\> Locks this socket instance for receiving,
+ * interruptible version, the process can be woken up by a signal.
+ *
+ * @param *self - pointer to this file instance
+ */
+static inline int kkc_sock_rcv_lock_interruptible(struct kkc_sock *self)
+{
+	return (down_interruptible(&self->sock_recv_sem));
+}
+
+/**
+ * \<\<public\>\> Locks this socket instance for receiving.
+ *
+ * @param *self - pointer to this socket instance
+ */
+static inline void kkc_sock_rcv_lock(struct kkc_sock *self)
+{
+		down(&self->sock_recv_sem);
+}
+
+/**
+ * \<\<public\>\> Unlocks this socket instance for receiving.
+ *
+ * @param *self - pointer to this socket instance
+ */
+static inline void kkc_sock_rcv_unlock(struct kkc_sock *self)
+{
+		up(&self->sock_recv_sem);
+}
+
+/** Casts to the kkc_sock instance. */
+#define KKC_SOCK(s) ((struct kkc_sock*)s)
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef KKC_SOCK_PRIVATE
+
+/** Transfers a buffer using the specified method. */
+static int kkc_sock_send_recv(struct kkc_sock *self, void *buf, int buflen, 
+			      kkc_sock_flags_t flags,
+			      int (*kkc_sock_method)(struct kkc_sock *, void *, 
+						     int, kkc_sock_flags_t));
+#endif /* KKC_SOCK_PRIVATE */
+
+
+/**
+ * @}
+ */
+
+
+#endif /* _KKC_SOCK_H */
+
+
--- linux-3.7.1_original/clondike/src/dbg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/dbg.h	2013-03-07 11:03:54.000000000 +0100
@@ -0,0 +1,224 @@
+/** @file dbg.h - a debugging and logging framework, based on mdbg
+ * library by Martin Kacer.  The standard message types are divided
+ * into four categories: 
+ * -# info messages (tracing only) 
+ * -# warnings (something strange happend) 
+ * -# errors (it is not possible to do something which should be possible to do)
+ * -# critical errors (serious program failures). 
+ *
+ * Other than that, there is a number from 1 (very important) to 4
+ * (least important) assigned to each of the messages - the severity.
+ * Whenever the logging macro mdbg() is called, the given type of the
+ * message is compared to the mask stored in MDBG_MASK. All the bits
+ * that are set in the message type must also be set in the defined
+ * mask. In other words, the condition "(~mask & type) == 0" must be
+ * satisfied.  The standard messages with higher severity have always
+ * less bits set than the ones with lower severity. That means
+ * enabling some type of message enables also all the other types in
+ * the same category which have higher severity. E.g. enabling
+ * 'MDBG_INFO2' enables also 'MDBG_INFO1' too.
+ *
+ * There are two macros provided:
+ * - mdbg()
+ * - minfo() - standard info output by the kernel application. The message 
+ * is stored into a corresponding log file set by kernel logging framework.
+ * The user still specifies a message level type. This is needed as the message
+ * is still passed onto mdbg().
+ *
+ * The user has to define selected levels for each
+ * category if he/she doesn't want to use the defaults (which is
+ * 4). For example in a Makefile, it can be done as follows:
+ * \verbatim
+ * EXTRA_CFLAGS += -DMDBG_CRIT=4 -DMDBG_ERR=4 -DMDBG_WARN=4 -DMDBG_INFO=4
+ * \endverbatim
+ * This ensures that levels 1-4 will be displayed in the debug log for 
+ * each category.
+ *
+ * Date: 05/05/2005
+ *
+ * Author: Jan Capek, Martin Kacer
+ *
+ * $Id: dbg.h,v 1.6 2008/05/02 19:59:20 stavam2 Exp $
+ *
+ * This file is part of Clondike project
+ * Copyleft (C) 2005  Jan Capek, Martin Kacer
+ * 
+ * Clondike is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * Clondike is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef DBG_H
+#define DBG_H
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <clondike/tcmi/tcmi_dbg.h>
+
+/*********************************************/
+/***  Message types  as used in the source ***/
+/*********************************************/
+#define MDBG_CRIT1   0x00001000
+#define MDBG_CRIT2   0x00003000
+#define MDBG_CRIT3   0x00007000
+#define MDBG_CRIT4   0x0000F000
+#define MDBG_ERR1    0x00000100
+#define MDBG_ERR2    0x00000300
+#define MDBG_ERR3    0x00000700
+#define MDBG_ERR4    0x00000F00
+#define MDBG_WARN1   0x00000010
+#define MDBG_WARN2   0x00000030
+#define MDBG_WARN3   0x00000070
+#define MDBG_WARN4   0x000000F0
+#define MDBG_INFO1   0x00000001
+#define MDBG_INFO2   0x00000003
+#define MDBG_INFO3   0x00000007
+#define MDBG_INFO4   0x0000000F
+
+//#define APP_NAME 0
+//#define MDBG_CRIT 1
+//#define MDBG_ERR 1
+//#define MDBG_WARN 1
+//#define MDBG_INFO 1
+
+/* Default levels for each category */
+#ifndef MDBG_CRIT 
+#error MDBG_CRIT not defined
+#endif
+#ifndef MDBG_ERR 
+#error MDBG_ERR not defined
+#endif
+#ifndef MDBG_WARN 
+#error MDBG_WARN not defined
+#endif
+#ifndef MDBG_INFO 
+#error MDBG_INFO not defined
+#endif
+
+/* Description of each message */
+#define MDBG_DESC_CRIT(level) "<crit"#level">"
+#define MDBG_DESC_ERR(level)  "<err"#level"> "
+#define MDBG_DESC_WARN(level) "<warn"#level">"
+#define MDBG_DESC_INFO(level) "<info"#level">"
+
+/* This assigns each message a description */
+#define MDBG_DESC_CRIT4  MDBG_DESC_CRIT(4)
+#define MDBG_DESC_CRIT3  MDBG_DESC_CRIT(3)
+#define MDBG_DESC_CRIT2  MDBG_DESC_CRIT(2)
+#define MDBG_DESC_CRIT1  MDBG_DESC_CRIT(1)
+#define MDBG_DESC_ERR4   MDBG_DESC_ERR(4) 
+#define MDBG_DESC_ERR3   MDBG_DESC_ERR(3)
+#define MDBG_DESC_ERR2   MDBG_DESC_ERR(2)
+#define MDBG_DESC_ERR1   MDBG_DESC_ERR(1)
+#define MDBG_DESC_WARN4  MDBG_DESC_WARN(4)
+#define MDBG_DESC_WARN3  MDBG_DESC_WARN(3)
+#define MDBG_DESC_WARN2  MDBG_DESC_WARN(2)
+#define MDBG_DESC_WARN1  MDBG_DESC_WARN(1)
+#define MDBG_DESC_INFO4  MDBG_DESC_INFO(4)
+#define MDBG_DESC_INFO3  MDBG_DESC_INFO(3)
+#define MDBG_DESC_INFO2  MDBG_DESC_INFO(2)
+#define MDBG_DESC_INFO1  MDBG_DESC_INFO(1)
+
+/* This assigns each message a valid kernel log level - used by
+ * minfo(). All debug messages are assigned the KERN_DEBUG level by
+ * default */
+#define MDBG_KERN_CRIT4  KERN_CRIT
+#define MDBG_KERN_CRIT3  KERN_CRIT
+#define MDBG_KERN_CRIT2  KERN_CRIT 
+#define MDBG_KERN_CRIT1  KERN_CRIT 
+#define MDBG_KERN_ERR4   KERN_ERR
+#define MDBG_KERN_ERR3   KERN_ERR
+#define MDBG_KERN_ERR2   KERN_ERR   
+#define MDBG_KERN_ERR1   KERN_ERR 
+#define MDBG_KERN_WARN4  KERN_WARNING
+#define MDBG_KERN_WARN3  KERN_WARNING
+#define MDBG_KERN_WARN2  KERN_WARNING
+#define MDBG_KERN_WARN1  KERN_WARNING
+#define MDBG_KERN_INFO4  KERN_INFO
+#define MDBG_KERN_INFO3  KERN_INFO
+#define MDBG_KERN_INFO2  KERN_INFO
+#define MDBG_KERN_INFO1  KERN_INFO
+
+/* creates a mask that has first b bits starting from LSb set and the
+ * whole mask is then shifted by s bits to the right */
+#define MDBG_SET_BITS(b, s) (((1 << b) - 1) << s)
+
+/* Creates the debug level mask from critical, error, warning, info
+ * levels */
+#define MDBG_MAKE_MASK(C, E, W, I)		\
+ (MDBG_SET_BITS(C, 12) | MDBG_SET_BITS(E, 8) |	\
+  MDBG_SET_BITS(W, 4)  | MDBG_SET_BITS(I, 0))
+
+/* Extend the define application name with : */
+#ifndef APP_NAME
+#error APP_NAME not defined
+#endif
+
+#define CLONDIKE_STR(s) #s
+#define MAKE_APP_NAME(name) CLONDIKE_STR(name)
+#define __APP_NAME MAKE_APP_NAME(APP_NAME)
+
+#ifndef MDBG_MASK
+#define MDBG_MASK \
+ MDBG_MAKE_MASK(MDBG_CRIT, MDBG_ERR, MDBG_WARN, MDBG_INFO)
+#endif
+
+#ifdef CONFIG_TCMI_DEBUG
+#define mdbg(type, fmt, args...)								\
+do {												\
+	if ( ((MDBG_##type & MDBG_MASK) == MDBG_##type) /*&&  tcmi_dbg */ )						\
+		printk(KERN_DEBUG __APP_NAME MDBG_DESC_##type " %s()[%d]:" fmt "\n", __FUNCTION__, current->pid, ## args);\
+} while(0)
+
+/* Generic information macro, in addition produces a debug log */
+/* 	printk(MDBG_KERN_##type __APP_NAME MDBG_DESC_##type ":" fmt "\n", ## args);	*/
+#define minfo(type, fmt, args...)							\
+do {											\
+	if ( ((MDBG_##type & MDBG_MASK) == MDBG_##type) )				\
+	  	printk(MDBG_KERN_##type __APP_NAME MDBG_DESC_##type ":" fmt "\n", ## args);\
+} while(0)
+#define debug_enabled (tcmi_dbg)
+
+/**
+ * This function just allocs and frees various size memory blocks. It is intended to collaborate with kernel memory access check functions
+ * that check for memory poisioning. This call should be added to code just temporarily when chasing broken allocations and trying to find out
+ * when the memory is already broken.
+ */
+#define memory_sanity_check(msg)								\
+do {													\
+	int i = 1;												\
+	int kmsize = 1;												\
+	int test_size = 99;												\
+	int res = 0;												\
+	void** memtest;												\
+	memtest = kmalloc(sizeof(void*)*test_size, GFP_KERNEL);												\
+	for ( i = 0; i < test_size; i++ ) {											\
+	  memtest[i] = kmalloc(kmsize, GFP_KERNEL);											  \
+	  kmsize = (kmsize * 2) % 8500;												\
+	  res = res + (int)memtest[i];												\
+	}										\
+	for ( i = 0; i < test_size; i++ ) {											\
+	  kfree(memtest[i]);												\
+	}													\
+	printk(KERN_DEBUG __APP_NAME " %s()[%d]: " msg " -> Memory check -> %p\n", __FUNCTION__, current->pid, memtest); \
+	kfree(memtest);												\
+} while(0)
+
+#else // CONFIG_TCMI_DEBUG
+#define mdbg(type, fmt, args...) do {} while (0)
+#define minfo(type, fmt, args...) do {} while (0)
+#define debug_enabled 0
+#define memory_sanity_check(msg) do {} while (0)
+#endif
+
+#endif /* DBG_H */
--- linux-3.7.1_original/clondike/src/director/director.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/director/director.c	2013-03-12 19:33:10.000000000 +0100
@@ -0,0 +1,134 @@
+#include "director.h"
+#include "netlink/comm.h"
+#include "netlink/npm_msg.h"
+#include "netlink/node_connected_msg.h"
+#include "netlink/node_disconnected_msg.h"
+#include "netlink/generic_user_message_recv_msg.h"
+#include "netlink/generic_user_message_send_handler.h"
+#include "netlink/task_exitted_msg.h"
+#include "netlink/task_forked_msg.h"
+#include "netlink/immigration_request_msg.h"
+#include "netlink/immigration_confirmed_msg.h"
+#include "netlink/emigration_failed_msg.h"
+#include "netlink/migrated_home_msg.h"
+
+#include <linux/module.h>
+#include <dbg.h>
+
+MODULE_LICENSE("GPL");
+
+int director_npm_check(pid_t pid, uid_t uid, int is_guest, const char* name, 
+		const char* __user const * __user argv, const char* __user const * __user envp, 
+		int* migman_to_use, int* migrate_home, struct rusage *rusage) {
+	int res, decision, decision_value;
+
+	// TODO: If full is not too expensive do full every time? Or perhaps some "learning" for which processes we should do full immediately and for which not?
+
+	res = npm_check(pid, uid, is_guest, name, &decision, &decision_value, rusage);
+	minfo(INFO4, "Npm check [%s]. Decision: %d, Res %d", name, decision, res);
+	if ( res )
+		return res;
+
+	if ( decision == REQUIRE_ARGS || decision == REQUIRE_ENVP || decision == REQUIRE_ARGS_AND_ENVP ) {
+		res = npm_check_full(pid, uid, is_guest, name, argv, envp, &decision, &decision_value);
+
+		minfo(INFO4, "Npm check full [%s]. Decision: %d, Res %d", name, decision, res);
+		
+		if ( res )
+			return res;
+	}
+
+	minfo(INFO4, "Npm result [%s]. Decision %d, migman %d", name, decision, decision_value);
+	if ( decision == MIGRATE_BACK ) {
+		*migrate_home = 1;
+		return 1;
+	} else if ( decision == MIGRATE ) {
+		*migman_to_use = decision_value;
+		return 1;
+	} else if ( decision == DO_NOT_MIGRATE ) {
+		return 0;
+	}
+
+	minfo(ERR1, "How did we get here %d?", decision);
+
+	return 0;
+};
+
+EXPORT_SYMBOL(director_npm_check);
+
+int director_immigration_request(int slot_index, uid_t uid, const char* name, int* accept) {
+	return immigration_request(slot_index, uid, name, accept);
+}
+
+EXPORT_SYMBOL(director_immigration_request);
+
+int director_immigration_confirmed(int slot_index, uid_t uid, const char* name, pid_t local_pid, pid_t remote_pid) {
+	return immigration_confirmed(slot_index, uid, name, local_pid, remote_pid);
+}
+EXPORT_SYMBOL(director_immigration_confirmed);
+
+int director_node_connected(const char* address, int slot_index, int auth_data_size, char* auth_data,  int* accept) {
+	return node_connected(address, slot_index, auth_data_size, auth_data, accept);
+}
+
+EXPORT_SYMBOL(director_node_connected);
+
+int director_node_disconnected(int slot_index, int detached, int reason) {
+	minfo(ERR1, "Node disconnected being called");
+	
+	return node_disconnected(slot_index, detached, reason);
+}
+
+EXPORT_SYMBOL(director_node_disconnected);
+
+int director_generic_user_message_recv(int node_id, int is_core_node, int slot_index, int user_data_size, char* user_data) {
+	return generic_user_message_recv(node_id, is_core_node, slot_index, user_data_size, user_data);
+}
+
+EXPORT_SYMBOL(director_generic_user_message_recv);
+
+void director_register_send_generic_user_message_handler(send_generic_user_message_handler_t handler) {
+	register_send_generic_user_message_handler(handler);
+}
+
+EXPORT_SYMBOL(director_register_send_generic_user_message_handler);
+
+int director_task_exit(pid_t pid, int exit_code, struct rusage *rusage) {
+	return task_exitted(pid, exit_code, rusage);	
+}
+
+EXPORT_SYMBOL(director_task_exit);
+
+int director_task_fork(pid_t pid, pid_t ppid) {
+	/** Do not notify directory about its own forks, as this would lead to a lock-out of netlink communications */
+	if ( is_director_pid(ppid) )
+	    return 0;
+	
+	return task_forked(pid, ppid);	
+}
+
+EXPORT_SYMBOL(director_task_fork);
+
+int director_emigration_failed(pid_t pid) {
+	return emigration_failed(pid);
+}
+
+EXPORT_SYMBOL(director_emigration_failed);
+
+int director_migrated_home(pid_t pid) {
+	return migrated_home(pid);
+}
+
+EXPORT_SYMBOL(director_migrated_home);
+
+static int __init init_director_module(void) {
+	init_director_comm();
+	return 0;
+}
+
+static void __exit exit_director_module(void) {	
+	destroy_director_comm();
+}
+
+module_init(init_director_module);
+module_exit(exit_director_module);
--- linux-3.7.1_original/clondike/src/director/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/director/Makefile	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,29 @@
+##############################################################################
+# @file Makefile - Builds director
+#
+# Author: Petr Malat
+#
+# This file is part of Clondike.
+#
+# Clondike is free software: you can redistribute it and/or modify it under 
+# the terms of the GNU General Public License version 2 as published by 
+# the Free Software Foundation.
+#
+# Clondike is distributed in the hope that it will be useful, but WITHOUT ANY
+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
+# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more 
+# details.
+# 
+# You should have received a copy of the GNU General Public License along with 
+# Clondike. If not, see http://www.gnu.org/licenses/.
+##############################################################################
+
+ccflags-y = `dbgenv $<`
+
+obj-$(CONFIG_TCMI) := director-mod.o
+director-mod-objs  := director.o netlink/genl_ext.o netlink/npm_msg.o \
+		      netlink/node_connected_msg.o netlink/node_disconnected_msg.o netlink/task_exitted_msg.o \
+		      netlink/immigration_request_msg.o netlink/generic_user_message_recv_msg.o \
+		      netlink/emigration_failed_msg.o netlink/migrated_home_msg.o netlink/immigration_confirmed_msg.o\
+		      netlink/task_forked_msg.o netlink/generic_user_message_send_handler.o netlink/comm.o
+
--- linux-3.7.1_original/clondike/src/director/handlers.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/director/handlers.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,17 @@
+#ifndef DIRECTOR_HANDLERS_H
+#define DIRECTOR_HANDLERS_H
+
+/**
+ * Handler of user message transmission requests. 
+ * 
+ * @param is_core_node 1 if we shall send to core node manager, 0 if we shall send to detached node manager
+ * @param target_slot_index Slot of a manager to sent message to
+ * @returns Can return (error return codes go back to user space in error field of ack):
+ *
+ * ENOENT - Invalid slot_index -> No such a peer
+ * ENOMEM - Run out of memory
+ * EFAULT - Failed to send message for whatever reason
+ */
+typedef int (*send_generic_user_message_handler_t)(int is_core_node, int target_slot_index, int user_data_size, char* user_data);
+
+#endif
--- linux-3.7.1_original/clondike/src/director/director.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/director/director.h	2013-03-12 19:32:37.000000000 +0100
@@ -0,0 +1,130 @@
+#ifndef DIRECTOR_H
+#define DIRECTOR_H
+
+#include <linux/types.h>
+#include <linux/resource.h>
+#include "handlers.h"
+
+/**
+ * This is the main entry point that can be used by TCMI when it needs to consult user space director.
+ */
+
+
+/**
+ * Checks, whether the process should be non-preemptively migrated to some other node.
+ *
+ * @param pid Pid of the process
+ * @param uid Effective user ID of the process being executed
+ * @param is_guest 1 if the process is guest
+ * @param name File name, that is being executed
+ * @param argv Args of execve
+ * @param envp Envp of execve
+ * @param migman_to_use Output parameter.. slot index of migration manager to be used
+ * @param migrate_home Output param .. should we migrate home?
+ * @param rusage Resource usage structure of process
+ *
+ * @return 0 on success, if no migration should be performed
+ *         1 on success, when a migration should be performed
+ *         error code otherwise. In case of error, output params are not valid!
+ */
+int director_npm_check(pid_t pid, uid_t uid, int is_guest, const char* name, const char* __user const * __user argv, const char* __user const * __user envp, int* migman_to_use, int* migrate_home, struct rusage *rusage);
+
+/**
+ * Request to immigrate process from core node specified by slot_index to this node.
+ *
+ * @param slot_index Index of the remote core node manager that requests immigration to this node
+ * @param uid Uid of user on the remote node that is requesting the migration
+ * @param name Name of the binary the process (executable) that should be immigrated
+ * @param accept Output param. 0 if immigration is rejected, everything else if it is accepted
+ * @return 0 on success, error code otherwise. In case of error, output params are not valid!
+ */
+int director_immigration_request(int slot_index, uid_t uid, const char* name, int* accept);
+
+/**
+ * Notification about successful imigration
+ *
+ * @param slot_index Index of the remote core node manager that requests immigration to this node
+ * @param uid Uid of user on the remote node that is requesting the migration
+ * @param name Name of the binary the process (executable) that should be immigrated
+ * @param local_pid Local pid of the task
+ * @param remote_pid Pid of the task on core node
+ * @return 0 on success, error code otherwise
+ */
+int director_immigration_confirmed(int slot_index, uid_t uid, const char* name, pid_t local_pid, pid_t remote_pid);
+
+/**
+ * Called, when a detached node connects to the core node.
+ *
+ * @param address Protocol specific address string of a detached node
+ * @param slot_index Index in manager that was assigned to this connection
+ * @param accept Output parameter. 0 if remote node connection should be rejected, otherwise it is accepted
+ * @param auth_data_size Size of authentication data, if any
+ * @param auth_data Authentication data, or NULL
+ * @return 0 on success, error code otherwise. In case of error, output params are not valid!
+ */
+int director_node_connected(const char* address, int slot_index, int auth_data_size, char* auth_data, int* accept);
+
+/**
+ * Called, when a peer node disconnets
+ *
+ * @param slot_index Index in manager that was assigned to this connection
+ * @param detached Was the disconnected remote peer node was playing role of detached node or of a core node (in the particular connection that was broken)
+ * @param reason Reason of disconnection - 0 - local request, 1 remote request
+ * @return 0 on success, error code otherwise. In case of error, output params are not valid!
+ */
+int director_node_disconnected(int slot_index, int detached, int reason);
+
+/**
+ * Called, when a generic user message arrives
+ *
+ * @param node_id Id of remote node
+ * @param is_core_node 1 if the slot_index is index of core node manager, 0 if it is indes of detached node manager
+ * @param slot_index Index in manager that was assigned to this connection
+ * @param user_data_size Size of user data
+ * @param user_data User data, or NULL
+ * @return 0 on success, error code otherwise. In case of error, output params are not valid!
+ */
+int director_generic_user_message_recv(int node_id, int is_core_node, int slot_index, int user_data_size, char* user_data);
+
+/**
+ * Called, when a task exits
+ *
+ * @param pid Pid of the task that exists
+ * @param exit_code Exit code of the task
+ * @param rusage Resource usage structure of process
+ * @return 0 on success, error code otherwise. In case of error, output params are not valid!
+ */
+int director_task_exit(pid_t pid, int exit_code, struct rusage *rusage);
+
+/**
+ * Called, when a task forks
+ *
+ * @param pid Pid of a new task that was forked
+ * @param ppid Pid of a parent task that was forked
+ * @return 0 on success, error code otherwise. In case of error, output params are not valid!
+ */
+int director_task_fork(pid_t pid, pid_t ppid);
+
+/**
+ * Called, when a task emigration has failed
+ *
+ * @param pid Pid of a new task that failed to emigrate
+ * @return 0 on success, error code otherwise.
+ */
+int director_emigration_failed(pid_t pid);
+
+/**
+ * Called, when a task migrates home
+ *
+ * @param pid Pid of a new task that returned home
+ * @return 0 on success, error code otherwise.
+ */
+int director_migrated_home(pid_t pid);
+
+/**
+ * Registers handler for send generic user message command..
+ */
+void director_register_send_generic_user_message_handler(send_generic_user_message_handler_t handler);
+
+
+#endif
--- linux-3.7.1_original/clondike/src/director/netlink/task_exitted_msg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/director/netlink/task_exitted_msg.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,69 @@
+#include "npm_msg.h"
+#include "msgs.h"
+#include "genl_ext.h"
+#include "comm.h"
+
+#include "task_exitted_msg.h"
+
+#include <dbg.h>
+
+#include <linux/skbuff.h>
+
+struct task_exitted_params {
+	/* In params */
+	u32 pid;
+	u32 exit_code;
+	struct rusage *rusage;
+
+	/* Out params -> NONE */
+
+};
+
+static int task_exitted_create_request(struct sk_buff *skb, void* params) {
+  	int ret = 0;
+  	struct task_exitted_params* task_exitted_params = params;
+
+	ret = nla_put_u32(skb, DIRECTOR_A_PID, task_exitted_params->pid);
+  	if (ret != 0)
+      		goto failure;
+
+	ret = nla_put_u32(skb, DIRECTOR_A_EXIT_CODE, task_exitted_params->exit_code);
+  	if (ret != 0)
+      		goto failure;
+
+	ret = nla_put(skb, DIRECTOR_A_RUSAGE, sizeof *task_exitted_params->rusage, task_exitted_params->rusage);
+  	if (ret != 0)
+      		goto failure;
+
+failure:
+	return ret;
+}
+
+
+static int task_exitted_read_response(struct genl_info* info, void* params) {
+	int ret = 0;
+//	struct task_exitted_params* task_exitted_params = params;
+
+	return ret;
+}
+
+static struct msg_transaction_ops task_exitted_msg_ops = {
+	.create_request = task_exitted_create_request,
+	.read_response = task_exitted_read_response
+};
+
+
+int task_exitted(pid_t pid, int exit_code, struct rusage *rusage) {
+	struct task_exitted_params params;
+	int ret;
+
+	params.pid = pid;
+	params.exit_code = exit_code;
+	params.rusage = rusage;
+
+	ret = msg_transaction_do(DIRECTOR_TASK_EXIT, &task_exitted_msg_ops, &params, 1);
+
+	minfo(INFO3, "Task exitted. Pid:  %u  Exit code: %d -> Res: %d", pid, exit_code, ret);
+
+	return ret;
+}
--- linux-3.7.1_original/clondike/src/director/netlink/generic_user_message_recv_msg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/director/netlink/generic_user_message_recv_msg.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,77 @@
+#include "generic_user_message_recv_msg.h"
+#include "msgs.h"
+#include "genl_ext.h"
+#include "comm.h"
+
+#include <dbg.h>
+
+#include <linux/skbuff.h>
+
+struct generic_user_message_params {
+	/* In params */
+	int node_id;
+	int is_core_node;
+	int slot_index;
+	int user_data_size;
+	const char* user_data;
+
+	/* Out params */
+
+};
+
+static int generic_user_message_create_request(struct sk_buff *skb, void* params) {
+  	int ret = 0;
+  	struct generic_user_message_params* generic_user_message_params = params;
+
+	ret = nla_put_u32(skb, DIRECTOR_A_INDEX, generic_user_message_params->node_id);
+  	if (ret != 0)
+      		goto failure;
+
+	ret = nla_put_u32(skb, DIRECTOR_A_SLOT_INDEX, generic_user_message_params->slot_index);
+  	if (ret != 0)
+      		goto failure;
+
+	ret = nla_put_u32(skb, DIRECTOR_A_SLOT_TYPE, generic_user_message_params->is_core_node);
+  	if (ret != 0)
+      		goto failure;
+
+	ret = nla_put_u32(skb, DIRECTOR_A_LENGTH, generic_user_message_params->user_data_size);
+  	if (ret != 0)
+      		goto failure;
+
+	if ( generic_user_message_params->user_data_size > 0 ) {
+		ret = nla_put(skb, DIRECTOR_A_USER_DATA, generic_user_message_params->user_data_size, generic_user_message_params->user_data);
+		if (ret != 0)
+			goto failure;	
+	}
+failure:
+	return ret;
+}
+
+static int generic_user_message_read_response(struct genl_info* info, void* params) {
+	int ret = 0;
+	return ret;
+}
+
+static struct msg_transaction_ops generic_user_message_msg_ops = {
+	.create_request = generic_user_message_create_request,
+	.read_response = generic_user_message_read_response
+};
+
+int generic_user_message_recv(int node_id, int is_core_node, int slot_index, int user_data_size, char* user_data) {
+	struct generic_user_message_params params;
+	int ret;
+
+	params.node_id = node_id;
+	params.is_core_node = is_core_node;
+	params.slot_index = slot_index;
+	params.user_data_size = user_data_size;
+	params.user_data = user_data;
+
+	ret = msg_transaction_do(DIRECTOR_GENERIC_USER_MESSAGE, &generic_user_message_msg_ops, &params, 0);
+
+	if ( ret )
+		return ret;
+	
+	return 0;
+}
--- linux-3.7.1_original/clondike/src/director/netlink/node_connected_msg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/director/netlink/node_connected_msg.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,18 @@
+#ifndef NODE_CONNECTED_MSG_H
+#define NODE_CONNECTED_MSG_H
+
+#include <linux/types.h>
+
+/**
+ * Called, when a detached node connects to the core node.
+ *
+ * @param address Protocol specific address string of a detached node
+ * @param slot_index Index in manager that was assigned to this connection
+ * @param auth_data_size Size of authentication data, if any
+ * @param auth_data Authentication data, or NULL
+ * @param accept Output parameter. 0 if remote node connection should be rejected, otherwise it is accepted
+ * @return 0 on success, error code otherwise. In case of error, output params are not valid!
+ */
+int node_connected(const char* address, int slot_index, int auth_data_size, char* auth_data, int* accept);
+
+#endif
--- linux-3.7.1_original/clondike/src/director/netlink/generic_user_message_recv_msg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/director/netlink/generic_user_message_recv_msg.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,18 @@
+#ifndef GENERIC_USER_MESSAGE_MSG_H
+#define GENERIC_USER_MESSAGE_MSG_H
+
+#include <linux/types.h>
+
+/**
+ * Called, when a generic user message arrives
+ *
+ * @param node_id Id of remote node
+ * @param is_core_node 1 if the slot_index is index of core node manager, 0 if it is indes of detached node manager
+ * @param slot_index Index in manager that was assigned to this connection
+ * @param user_data_size Size of user data
+ * @param user_data User data, or NULL
+ * @return 0 on success, error code otherwise. In case of error, output params are not valid!
+ */
+int generic_user_message_recv(int node_id, int is_core_node, int slot_index, int user_data_size, char* user_data);
+
+#endif
--- linux-3.7.1_original/clondike/src/director/netlink/immigration_request_msg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/director/netlink/immigration_request_msg.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,17 @@
+#ifndef IMMIGRATION_REQUEST_MSG_H
+#define IMMIGRATION_REQUEST_MSG_H
+
+#include <linux/types.h>
+
+/**
+ * Request to immigrate process from core node specified by slot_index to this node.
+ *
+ * @param slot_index Index of the remote core node manager that requests immigration to this node
+ * @param uid Uid of user on the remote node that is requesting the migration
+ * @param name Name of the binary the process (executable) that should be immigrated
+ * @param accept Output param. 0 if immigration is rejected, everything else if it is accepted
+ * @return 0 on success, error code otherwise. In case of error, output params are not valid!
+ */
+int immigration_request(int slot_index, uid_t uid, const char* name, int* accept);
+
+#endif
--- linux-3.7.1_original/clondike/src/director/netlink/emigration_failed_msg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/director/netlink/emigration_failed_msg.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,14 @@
+#ifndef EMIGRATION_FAILED_MSG_H
+#define EMIGRATION_FAILED_MSG_H
+
+#include <linux/types.h>
+
+/**
+ * Called, when an emigration request for task has failed
+ *
+ * @param pid Pid of the task that failed to emigrate
+ * @return 0 on success, error code otherwise
+ */
+int emigration_failed(pid_t pid);
+
+#endif
--- linux-3.7.1_original/clondike/src/director/netlink/npm_msg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/director/netlink/npm_msg.h	2013-03-12 19:37:56.000000000 +0100
@@ -0,0 +1,46 @@
+#ifndef NPM_MSG_H
+#define NPM_MSG_H
+
+#include <linux/types.h>
+#include <linux/resource.h>
+
+enum npm_msg_response {
+	DO_NOT_MIGRATE, 
+	MIGRATE, // In this case second return params is target migman id
+	MIGRATE_BACK,
+	// Following return codes indicate, that we need to provide more info to user mode director for decision
+	REQUIRE_ARGS,
+	REQUIRE_ENVP,
+	REQUIRE_ARGS_AND_ENVP,	
+};
+
+/**
+ * Checks, whether the process should be non-preemptively migrated to some other node.
+ *
+ * @param pid Pid of the process
+ * @param uid Effective user ID of the process being executed
+ * @param is_guest 1 if the process is guest
+ * @param name File name, that is being executed
+ * @param decision Output parameter.. element of "npm_msg_response" enum
+ * @param decision_value Output param .. if result is to perform migration, this will contain slot of the migration manager to be used
+ * @return 0 on success, error code otherwise. In case of error, output params are not valid!
+ */
+int npm_check(pid_t pid, uid_t uid, int is_guest, const char* name, int* decision, int* decision_value, struct rusage *rusage);
+
+/**
+ * Checks, whether the process should be non-preemptively migrated to some other node.
+ * This version in addition passes args & envp
+ *
+ * @param pid Pid of the process
+ * @param uid Effective user ID of the process being executed
+ * @param is_guest 1 if the process is guest
+ * @param name File name, that is being executed
+ * @param args Args, or NULL if no args are provided
+ * @param envp Envinromental properties, or NULL if no envs are provided
+ * @param decision Output parameter.. element of "npm_msg_response" enum
+ * @param decision_value Output param .. if result is to perform migration, this will contain slot of the migration manager to be used
+ * @return 0 on success, error code otherwise. In case of error, output params are not valid!
+ */
+int npm_check_full(pid_t pid, uid_t uid, int is_guest, const char* name, const char __user * const __user * args, const char __user * const __user* envp, int* decision, int* decision_value);
+
+#endif
--- linux-3.7.1_original/clondike/src/director/netlink/migrated_home_msg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/director/netlink/migrated_home_msg.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,14 @@
+#ifndef MIGRATED_HOME_MSG_H
+#define MIGRATED_HOME_MSG_H
+
+#include <linux/types.h>
+
+/**
+ * Called, when a task is migrated home (called on ccn)
+ *
+ * @param pid Pid of the task that has returned
+ * @return 0 on success, error code otherwise
+ */
+int migrated_home(pid_t pid);
+
+#endif
--- linux-3.7.1_original/clondike/src/director/netlink/comm.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/director/netlink/comm.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,46 @@
+#ifndef DIRECTOR_COMM_H
+#define DIRECTOR_COMM_H
+
+#include <linux/types.h>
+
+/** Initializes director generic netlink family */
+int init_director_comm(void);
+/** Finalizes director generic netlink family */
+void destroy_director_comm(void);
+
+
+/******** Message support **********/
+
+
+struct sk_buff;
+struct genl_info;
+
+/** Specific operations that are performed on the message */
+struct msg_transaction_ops {
+	/** Fills in request with params. Return 0 on success */
+	int (*create_request)(struct sk_buff *skb, void* params);
+	/** Reads response data. Return 0 on success */
+	int (*read_response)(struct genl_info* info, void* params);
+};
+
+/**
+ * Performs a netlink transaction.
+ *
+ * 1) Creates a message (with specified code)
+ * 2) Uses "create_resquest" method to fill params
+ * 3) Sends the request
+ * 4) Reads response
+ * 5) Uses "read_response" to parse output data
+ *
+ * @param msg_code Code of the message to be created
+ * @param ops Transaction specific operations to fill params and read response
+ * @param params Structure that will contain input params and hold output values
+ * @param interruptible if !=0, the waiting for response can be interrupted by a signal
+ * @return 0 on success, error code otherwise
+ */
+int msg_transaction_do(int msg_code, struct msg_transaction_ops* ops, void* params, int interruptible);
+
+/** Returns 1 if, ppid is equal to userspace director pid */
+int is_director_pid(pid_t ppid);
+
+#endif
--- linux-3.7.1_original/clondike/src/director/netlink/migrated_home_msg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/director/netlink/migrated_home_msg.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,55 @@
+#include "npm_msg.h"
+#include "msgs.h"
+#include "genl_ext.h"
+#include "comm.h"
+
+#include "migrated_home_msg.h"
+
+#include <dbg.h>
+
+#include <linux/skbuff.h>
+
+struct migrated_home_params {
+	/* In params */
+	u32 pid;
+
+	/* Out params -> NONE */
+
+};
+
+static int migrated_home_create_request(struct sk_buff *skb, void* params) {
+  	int ret = 0;
+  	struct migrated_home_params* migrated_home_params = params;
+
+	ret = nla_put_u32(skb, DIRECTOR_A_PID, migrated_home_params->pid);
+  	if (ret != 0)
+      		goto failure;
+failure:
+	return ret;
+}
+
+
+static int migrated_home_read_response(struct genl_info* info, void* params) {
+	int ret = 0;
+
+	return ret;
+}
+
+static struct msg_transaction_ops migrated_home_msg_ops = {
+	.create_request = migrated_home_create_request,
+	.read_response = migrated_home_read_response
+};
+
+
+int migrated_home(pid_t pid) {
+	struct migrated_home_params params;
+	int ret;
+
+	params.pid = pid;
+
+	ret = msg_transaction_do(DIRECTOR_MIGRATED_HOME, &migrated_home_msg_ops, &params, 1);
+
+	minfo(INFO3, "Migrated home. Pid:  %u -> Res: %d", pid, ret);
+
+	return ret;
+};
--- linux-3.7.1_original/clondike/src/director/netlink/task_exitted_msg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/director/netlink/task_exitted_msg.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,17 @@
+#ifndef TASK_EXITTED_MSG_H
+#define TASK_EXITTED_MSG_H
+
+#include <linux/types.h>
+#include <linux/resource.h>
+
+/**
+ * Called, when a task exits
+ *
+ * @param pid Pid of the task that exists
+ * @param exit_code Exit code of the task
+ * @param rusage Resource usage of process
+ * @return 0 on success, error code otherwise. In case of error, output params are not valid!
+ */
+int task_exitted(pid_t pid, int exit_code, struct rusage *rusage);
+
+#endif
--- linux-3.7.1_original/clondike/src/director/netlink/msgs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/director/netlink/msgs.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,68 @@
+#ifndef DIRECTOR_MSGS_H
+#define DIRECTOR_MSGS_H
+
+extern const char* DIRECTOR_CHANNEL_NAME;
+
+/* Message types */
+enum {
+  /* User space requests */
+  DIRECTOR_REGISTER_PID, /* User helper daemon initially registers itself and its PID to the kernel */
+  DIRECTOR_SEND_GENERIC_USER_MESSAGE, /* Informs requests transmission of a generic user message to peer */
+  /* Generic ack */
+  DIRECTOR_ACK,
+
+  /* Commands */
+  DIRECTOR_CHECK_NPM, /* Checks if a non-preemptive migration should be performed */
+  DIRECTOR_CHECK_FULL_NPM, /* Checks if a non-preemptive migration should be performed (pass in args&envp) */
+  DIRECTOR_NODE_CONNECTED, /* Informs director, that DN has successfuly connected to CN */
+  DIRECTOR_NODE_DISCONNECTED, /* Informs director that a peer node connection was closed */
+  DIRECTOR_IMMIGRATION_REQUEST, /* Informs director, some associated CN wants to immigrate task to this node */
+  DIRECTOR_IMMIGRATION_CONFIRMED, /* Informs director about successful immigration */
+  DIRECTOR_TASK_EXIT, /* Informs, that a task has finished */
+  DIRECTOR_TASK_FORK, /* Informs, that a task has forked */
+  DIRECTOR_GENERIC_USER_MESSAGE, /* Informs about newly arrived generic user message */
+  DIRECTOR_EMIGRATION_FAILED, /* Informs director about failed emigration request (could be npm or ppm, director should know which one based on provided pid) */
+  DIRECTOR_MIGRATED_HOME, /* Informs director that a task was migrated home */
+
+  /* Responses */
+  DIRECTOR_NPM_RESPONSE, /* Response on non-preemptive migration check */
+  DIRECTOR_NODE_CONNECT_RESPONSE, /* Informs director, that a DN connected to current CCN */
+  DIRECTOR_IMMIGRATION_REQUEST_RESPONSE, /* Accept/reject respons on immigration request */
+
+  __DIRECTOR_MSG_MAX
+};
+
+#define DIRECTOR_MSG_MAX (__DIRECTOR_MSG_MAX - 1)
+
+/* Message attributes */
+enum {
+  DIRECTOR_A_PID, /* process pid */
+  DIRECTOR_A_REMOTE_PID, /* remote pid */
+  DIRECTOR_A_PPID, /* process parent pid */
+  DIRECTOR_A_UID, /* user id */
+  DIRECTOR_A_TASK_TYPE, /* Task type (1=guest/0=shadow)*/
+  DIRECTOR_A_NAME, /* Name of anything */
+  DIRECTOR_A_LENGTH, /* 32 bit length */
+  DIRECTOR_A_INDEX, /* 32 bit index */
+  DIRECTOR_A_SLOT_INDEX, /* 32 bit index */
+  DIRECTOR_A_SLOT_TYPE, /* 32 bit (1=core, 0=detached) */
+  DIRECTOR_A_ADDRESS, /* Address of remote end point in a protocol specific format */
+  DIRECTOR_A_AUTH_DATA,
+  DIRECTOR_A_USER_DATA, /* Generic user data */
+  DIRECTOR_A_ARGS,
+  DIRECTOR_A_ARG,
+  DIRECTOR_A_ENVS,
+  DIRECTOR_A_ENV,
+  DIRECTOR_A_REASON, /* 32 bit length */  
+  DIRECTOR_A_DECISION, /* 32 bit length */  
+  DIRECTOR_A_DECISION_VALUE, /* 32 bit length */  
+  DIRECTOR_A_EXIT_CODE, /* 32 bit length */  
+  DIRECTOR_A_ERRNO, /* error code, in case some error occured */
+  DIRECTOR_A_RUSAGE,
+
+  __DIRECTOR_ATTR_MAX
+};
+
+#define DIRECTOR_ATTR_MAX __DIRECTOR_ATTR_MAX
+
+#endif
--- linux-3.7.1_original/clondike/src/director/netlink/npm_msg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/director/netlink/npm_msg.c	2013-03-12 19:47:52.000000000 +0100
@@ -0,0 +1,220 @@
+#include "npm_msg.h"
+#include "msgs.h"
+#include "genl_ext.h"
+#include "comm.h"
+
+#include <dbg.h>
+
+#include <linux/skbuff.h>
+#include <linux/resource.h>
+
+struct npm_check_params {
+	/* In params */
+	pid_t pid;
+	uid_t uid;
+	int is_guest;
+	const char* name;
+	int name_length;
+	struct rusage *rusage;
+	/* Params only in full mode */
+	const char __user * const __user * args;
+	const char __user * const __user * envp;
+
+	/* Out params */
+	/** User mode helper decision.. one of npm_msg_response enum */
+	int decision;
+	/** If the decision has some target value, this will hold it */
+	int decision_value; 
+};
+
+/** Creates npm check request */
+static int npm_check_create_request(struct sk_buff *skb, void* params) {
+  	int ret = 0;
+  	struct npm_check_params* check_params = params;
+
+  	ret = nla_put_u32(skb, DIRECTOR_A_PID, check_params->pid);
+  	if (ret != 0)
+      		goto failure;
+
+  	ret = nla_put_u32(skb, DIRECTOR_A_UID, check_params->uid);
+  	if (ret != 0)
+      		goto failure;
+
+  	ret = nla_put_u32(skb, DIRECTOR_A_TASK_TYPE, check_params->is_guest ? 1 : 0);
+  	if (ret != 0)
+      		goto failure;
+
+	ret = nla_put_string(skb, DIRECTOR_A_NAME, check_params->name);
+  	if (ret != 0)
+      		goto failure;
+
+  	ret = nla_put_u32(skb, DIRECTOR_A_LENGTH, check_params->name_length);
+	if (ret != 0)
+		goto failure;
+
+	if (check_params->rusage) {
+		ret = nla_put(skb, DIRECTOR_A_RUSAGE, sizeof *check_params->rusage, check_params->rusage);
+  		if (ret != 0)
+      			goto failure;
+	}
+
+failure:
+
+	return ret;
+}
+
+static int npm_check_read_response(struct genl_info* info, void* params) {
+	int ret = 0;
+	struct nlattr* attr;
+	struct npm_check_params* check_params = params;
+
+	attr = nlmsg_find_attr(info->nlhdr, sizeof(struct genlmsghdr), DIRECTOR_A_DECISION);
+	if ( attr == NULL ) {
+		ret = -EBADMSG;
+		goto done;
+	}
+
+	check_params->decision = nla_get_u32(attr);
+
+	attr = nlmsg_find_attr(info->nlhdr, sizeof(struct genlmsghdr), DIRECTOR_A_DECISION_VALUE);
+	if ( attr != NULL ) {
+		check_params->decision_value = nla_get_u32(attr);
+	} else {
+		check_params->decision_value = 0;
+	}
+done:
+	return ret;
+}
+
+static struct msg_transaction_ops npm_check_msg_ops = {
+	.create_request = npm_check_create_request,
+	.read_response = npm_check_read_response
+};
+
+int npm_check(pid_t pid, uid_t uid, int is_guest, const char* name, int* decision, int* decision_value, struct rusage *rusage) {
+	struct npm_check_params params;
+	int ret;
+
+	params.pid = pid;
+	params.uid = uid;
+	params.is_guest = is_guest;
+	params.name = name;
+	params.name_length = strlen(name);
+	params.args = NULL;
+	params.envp = NULL;
+	params.rusage = rusage;
+
+	ret = msg_transaction_do(DIRECTOR_CHECK_NPM, &npm_check_msg_ops, &params, 0);
+
+	if ( ret )
+		return ret;
+
+	*decision = params.decision;
+	*decision_value = params.decision_value;
+	
+	return 0;
+}
+
+static int put_char_array(struct sk_buff *skb, const char* const* chars, int type, int nested_type) {
+	struct nlattr* nest_attr;
+	int ret = 0;
+
+	if ( chars ) {
+		int i=0;		
+		nest_attr = nla_nest_start(skb, type);
+                if ( !nest_attr ) {
+			ret = -EMSGSIZE;
+			goto failure;
+		}
+
+		while ( chars[i] ) {
+//			printk("Putting arg\n");
+			ret = nla_put_string(skb, nested_type, chars[i]);
+			if (ret != 0)
+				goto failure;
+			
+			i++;
+		}
+
+//		printk("Putting length: %d\n", i);
+
+		ret = nla_put_u32(skb, DIRECTOR_A_LENGTH, i); // Count of elements
+		if (ret != 0)
+			goto failure;		
+
+		nla_nest_end(skb, nest_attr);
+	}
+
+	return ret;
+
+failure:
+	minfo(ERR1, "Putting of char array has failed: %d", ret);
+	return ret;
+}
+
+static int npm_check_full_create_request(struct sk_buff *skb, void* params) {
+  	int ret = 0;
+  	struct npm_check_params* check_params = params;
+	
+
+  	ret = nla_put_u32(skb, DIRECTOR_A_PID, check_params->pid);
+  	if (ret != 0)
+      		goto failure;
+
+  	ret = nla_put_u32(skb, DIRECTOR_A_UID, check_params->uid);
+  	if (ret != 0)
+      		goto failure;
+
+  	ret = nla_put_u32(skb, DIRECTOR_A_TASK_TYPE, check_params->is_guest ? 1 : 0);
+  	if (ret != 0)
+      		goto failure;
+
+	ret = nla_put_string(skb, DIRECTOR_A_NAME, check_params->name);
+  	if (ret != 0)
+      		goto failure;
+
+//  	ret = nla_put_u32(skb, DIRECTOR_A_LENGTH, check_params->name_length);
+//	if (ret != 0)
+//		goto failure;
+
+	ret = put_char_array(skb, check_params->args, DIRECTOR_A_ARGS, DIRECTOR_A_ARG);
+	if (ret != 0)
+		goto failure;
+
+	ret = put_char_array(skb, check_params->envp, DIRECTOR_A_ENVS, DIRECTOR_A_ENV);
+	if (ret != 0)
+		goto failure;
+
+failure:
+	return ret;
+}
+
+static struct msg_transaction_ops npm_check_full_msg_ops = {
+	.create_request = npm_check_full_create_request,
+	.read_response = npm_check_read_response
+};
+
+
+int npm_check_full(pid_t pid, uid_t uid, int is_guest, const char* name, const char __user * const __user * args, const char __user* const __user* envp, int* decision, int* decision_value) {
+	struct npm_check_params params;
+	int ret;
+
+	params.pid = pid;
+	params.uid = uid;
+	params.is_guest = is_guest;
+	params.name = name;
+	params.name_length = strlen(name);
+	params.args = args;
+	params.envp = envp;
+	params.rusage = NULL;
+
+	ret = msg_transaction_do(DIRECTOR_CHECK_FULL_NPM, &npm_check_full_msg_ops, &params, 0);
+
+	if ( ret )
+		return ret;
+
+	*decision = params.decision;
+	*decision_value = params.decision_value;
+	
+	return 0;
+}
--- linux-3.7.1_original/clondike/src/director/netlink/node_disconnected_msg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/director/netlink/node_disconnected_msg.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,16 @@
+#ifndef NODE_DISCONNECTED_MSG_H
+#define NODE_DISCONNECTED_MSG_H
+
+#include <linux/types.h>
+
+/**
+ * Called, when a peer node disconnets
+ *
+ * @param slot_index Index in manager that was assigned to this connection
+ * @param detached Was the disconnected remote peer node was playing role of detached node or of a core node (in the particular connection that was broken)
+ * @param reason Reason of disconnection - 0 - local request, 1 remote request
+ * @return 0 on success, error code otherwise. In case of error, output params are not valid!
+ */
+int node_disconnected(int slot_index, int detached, int reason);
+
+#endif
--- linux-3.7.1_original/clondike/src/director/netlink/immigration_request_msg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/director/netlink/immigration_request_msg.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,79 @@
+#include "immigration_request_msg.h"
+#include "msgs.h"
+#include "genl_ext.h"
+#include "comm.h"
+
+#include <dbg.h>
+
+#include <linux/skbuff.h>
+
+struct immigration_request_params {
+	/* In params */
+	const char* name;
+	int slot_index;
+	uid_t uid;
+
+	/* Out params */
+	/** User mode helper decision*/
+	int accepted;
+
+};
+
+static int immigration_request_create_request(struct sk_buff *skb, void* params) {
+  	int ret = 0;
+  	struct immigration_request_params* immigration_request_params = params;
+
+	ret = nla_put_u32(skb, DIRECTOR_A_UID, immigration_request_params->uid);
+  	if (ret != 0)
+      		goto failure;
+
+	ret = nla_put_u32(skb, DIRECTOR_A_INDEX, immigration_request_params->slot_index);
+  	if (ret != 0)
+      		goto failure;
+
+	ret = nla_put_string(skb, DIRECTOR_A_NAME, immigration_request_params->name);
+  	if (ret != 0)
+      		goto failure;
+
+failure:
+	return ret;
+}
+
+static int immigration_request_read_response(struct genl_info* info, void* params) {
+	int ret = 0;
+	struct nlattr* attr;
+	struct immigration_request_params* immigration_request_params = params;
+
+	attr = nlmsg_find_attr(info->nlhdr, sizeof(struct genlmsghdr), DIRECTOR_A_DECISION);
+	if ( attr == NULL ) {
+		ret = -EBADMSG;
+		goto done;
+	}
+
+	immigration_request_params->accepted = nla_get_u32(attr);
+done:
+	return ret;
+}
+
+static struct msg_transaction_ops immigration_request_msg_ops = {
+	.create_request = immigration_request_create_request,
+	.read_response = immigration_request_read_response
+};
+
+int immigration_request(int slot_index, uid_t uid, const char* name, int* accept) {
+	struct immigration_request_params params;
+	int ret;
+	
+	params.slot_index = slot_index;
+	params.uid = uid;
+	params.name = name;
+
+	ret = msg_transaction_do(DIRECTOR_IMMIGRATION_REQUEST, &immigration_request_msg_ops, &params, 0);
+
+	if ( ret )
+		return ret;
+
+	*accept = params.accepted;
+	
+	return 0;
+}
--- linux-3.7.1_original/clondike/src/director/netlink/immigration_confirmed_msg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/director/netlink/immigration_confirmed_msg.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,75 @@
+#include "immigration_confirmed_msg.h"
+#include "msgs.h"
+#include "genl_ext.h"
+#include "comm.h"
+
+#include <dbg.h>
+
+#include <linux/skbuff.h>
+
+struct immigration_confirmed_params {
+	/* In params */
+	const char* name;
+	int slot_index;
+	uid_t uid;
+	pid_t local_pid;
+	pid_t remote_pid;
+
+	/* Out params */
+};
+
+static int immigration_confirmed_create_request(struct sk_buff *skb, void* params) {
+  	int ret = 0;
+  	struct immigration_confirmed_params* immigration_confirmed_params = params;
+
+	ret = nla_put_u32(skb, DIRECTOR_A_UID, immigration_confirmed_params->uid);
+  	if (ret != 0)
+      		goto failure;
+
+	ret = nla_put_u32(skb, DIRECTOR_A_INDEX, immigration_confirmed_params->slot_index);
+  	if (ret != 0)
+      		goto failure;
+
+	ret = nla_put_string(skb, DIRECTOR_A_NAME, immigration_confirmed_params->name);
+  	if (ret != 0)
+      		goto failure;
+
+	ret = nla_put_u32(skb, DIRECTOR_A_PID, immigration_confirmed_params->local_pid);
+  	if (ret != 0)
+      		goto failure;
+
+	ret = nla_put_u32(skb, DIRECTOR_A_REMOTE_PID, immigration_confirmed_params->remote_pid);
+  	if (ret != 0)
+      		goto failure;
+
+failure:
+	return ret;
+}
+
+static int immigration_confirmed_read_response(struct genl_info* info, void* params) {
+	int ret = 0;
+	return ret;
+}
+
+static struct msg_transaction_ops immigration_confirmed_msg_ops = {
+	.create_request = immigration_confirmed_create_request,
+	.read_response = immigration_confirmed_read_response
+};
+
+int immigration_confirmed(int slot_index, uid_t uid, const char* name, pid_t local_pid, pid_t remote_pid) {
+	struct immigration_confirmed_params params;
+	int ret;
+	
+	params.slot_index = slot_index;
+	params.uid = uid;
+	params.name = name;
+	params.local_pid = local_pid;
+	params.remote_pid = remote_pid;
+
+	ret = msg_transaction_do(DIRECTOR_IMMIGRATION_CONFIRMED, &immigration_confirmed_msg_ops, &params, 0);
+
+	if ( ret )
+		return ret;
+
+	return 0;
+}
--- linux-3.7.1_original/clondike/src/director/netlink/node_connected_msg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/director/netlink/node_connected_msg.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,86 @@
+#include "node_connected_msg.h"
+#include "msgs.h"
+#include "genl_ext.h"
+#include "comm.h"
+
+#include <dbg.h>
+
+#include <linux/skbuff.h>
+
+struct node_connected_params {
+	/* In params */
+	const char* address;
+	int slot_index;
+	int auth_data_size;
+	const char* auth_data;
+
+	/* Out params */
+	/** User mode helper decision*/
+	int accepted;
+
+};
+
+static int node_connected_create_request(struct sk_buff *skb, void* params) {
+  	int ret = 0;
+  	struct node_connected_params* node_connected_params = params;
+
+	ret = nla_put_string(skb, DIRECTOR_A_ADDRESS, node_connected_params->address);
+  	if (ret != 0)
+      		goto failure;
+
+	ret = nla_put_u32(skb, DIRECTOR_A_INDEX, node_connected_params->slot_index);
+  	if (ret != 0)
+      		goto failure;
+
+	ret = nla_put_u32(skb, DIRECTOR_A_LENGTH, node_connected_params->auth_data_size);
+  	if (ret != 0)
+      		goto failure;
+
+	if ( node_connected_params->auth_data_size > 0 ) {
+		ret = nla_put(skb, DIRECTOR_A_AUTH_DATA, node_connected_params->auth_data_size, node_connected_params->auth_data);
+		if (ret != 0)
+			goto failure;	
+	}
+failure:
+	return ret;
+}
+
+static int node_connected_read_response(struct genl_info* info, void* params) {
+	int ret = 0;
+	struct nlattr* attr;
+	struct node_connected_params* node_connected_params = params;
+
+	attr = nlmsg_find_attr(info->nlhdr, sizeof(struct genlmsghdr), DIRECTOR_A_DECISION);
+	if ( attr == NULL ) {
+		ret = -EBADMSG;
+		goto done;
+	}
+
+	node_connected_params->accepted = nla_get_u32(attr);
+done:
+	return ret;
+}
+
+static struct msg_transaction_ops node_connected_msg_ops = {
+	.create_request = node_connected_create_request,
+	.read_response = node_connected_read_response
+};
+
+int node_connected(const char* address, int slot_index, int auth_data_size, char* auth_data, int* accept) {
+	struct node_connected_params params;
+	int ret;
+
+	params.address = address;
+	params.slot_index = slot_index;
+	params.auth_data_size = auth_data_size;
+	params.auth_data = auth_data;
+
+	ret = msg_transaction_do(DIRECTOR_NODE_CONNECTED, &node_connected_msg_ops, &params, 0);
+
+	if ( ret )
+		return ret;
+
+	*accept = params.accepted;
+	
+	return 0;
+}
--- linux-3.7.1_original/clondike/src/director/netlink/emigration_failed_msg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/director/netlink/emigration_failed_msg.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,55 @@
+#include "npm_msg.h"
+#include "msgs.h"
+#include "genl_ext.h"
+#include "comm.h"
+
+#include "emigration_failed_msg.h"
+
+#include <dbg.h>
+
+#include <linux/skbuff.h>
+
+struct emigration_failed_params {
+	/* In params */
+	u32 pid;
+
+	/* Out params -> NONE */
+
+};
+
+static int emigration_failed_create_request(struct sk_buff *skb, void* params) {
+  	int ret = 0;
+  	struct emigration_failed_params* emigration_failed_params = params;
+
+	ret = nla_put_u32(skb, DIRECTOR_A_PID, emigration_failed_params->pid);
+  	if (ret != 0)
+      		goto failure;
+failure:
+	return ret;
+}
+
+
+static int emigration_failed_read_response(struct genl_info* info, void* params) {
+	int ret = 0;
+
+	return ret;
+}
+
+static struct msg_transaction_ops emigration_failed_msg_ops = {
+	.create_request = emigration_failed_create_request,
+	.read_response = emigration_failed_read_response
+};
+
+
+int emigration_failed(pid_t pid) {
+	struct emigration_failed_params params;
+	int ret;
+
+	params.pid = pid;
+
+	ret = msg_transaction_do(DIRECTOR_EMIGRATION_FAILED, &emigration_failed_msg_ops, &params, 1);
+
+	minfo(INFO3, "Emigration failed. Pid:  %u -> Res: %d", pid, ret);
+
+	return ret;
+};
--- linux-3.7.1_original/clondike/src/director/netlink/genl_ext.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/director/netlink/genl_ext.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,186 @@
+#include "genl_ext.h"
+#include <linux/mutex.h>
+#include <linux/list.h>
+#include <linux/jiffies.h>
+#include <linux/sched.h>
+
+#include <dbg.h>
+
+struct genl_tx_internal {
+	struct list_head link; /* To be enlistable in linked lists */
+
+	struct genl_tx tx;
+
+	/* Response data */
+	struct sk_buff* skb;
+	struct genl_info info;
+	
+	u64 start_time;
+
+	int interuptible;
+	int done;
+};
+
+/* guards access to transactions */
+static DEFINE_MUTEX(genl_ext_mutex); 
+/* Processes waiting on their transactions to be finished */
+static DECLARE_WAIT_QUEUE_HEAD(tx_queue);
+
+/* All registered and not yet processed transactions */
+static LIST_HEAD(transactions);
+
+static void genl_ext_lock(void) {
+        mutex_lock(&genl_ext_mutex);
+}
+
+static void genl_ext_unlock(void) {
+        mutex_unlock(&genl_ext_mutex);
+}
+
+int genlmsg_unicast_tx(struct sk_buff *skb, u32 pid, struct genl_tx* tx, int interuptible) {
+	int res;
+	
+	/* If the transaction context if provided, we have to register it BEFORE we perform the unicast so that we do not miss the response */
+	if ( tx ) {
+		struct nlmsghdr *nlh;
+		struct genlmsghdr *hdr;
+		struct genl_tx_internal* itx =  kmalloc(sizeof(struct genl_tx_internal), GFP_KERNEL);
+		if ( !itx )
+			return -ENOMEM;
+		
+		itx->start_time = cpu_clock(smp_processor_id());
+		itx->interuptible = interuptible;
+
+		nlh = (struct nlmsghdr *) skb->data;
+		hdr = nlmsg_data(nlh);
+
+		/*tx->cmd = hdr->cmd;*/		
+		tx->seq = nlh->nlmsg_seq;
+		memcpy(&itx->tx,tx, sizeof(struct genl_tx));
+		itx->skb = NULL; /* Response buffer, not the request buffer */
+		itx->done = 0;
+
+		genl_ext_lock();
+		list_add(&itx->link, &transactions);
+		genl_ext_unlock();
+
+		mdbg(INFO3,"Generic Tx registered: %d Data len: %d\n",tx->seq, skb->len);
+	}
+	
+	res = genlmsg_unicast(&init_net, skb, pid);
+	
+	if ( res ) {
+	    minfo(ERR3, "Unicast error: %d\n", res);
+	}
+	
+	return res;
+}
+
+/* Must be called with transactions lock held */
+static struct genl_tx_internal* __find_itx(struct genl_tx* tx) {
+	struct genl_tx_internal* tmp_entry;
+	struct list_head* tmp;
+
+	list_for_each(tmp, &transactions) {
+		tmp_entry = list_entry(tmp, struct genl_tx_internal, link);
+		if ( memcmp(&tmp_entry->tx, tx, sizeof(*tx)) == 0 ) {
+			return tmp_entry;
+		};
+	};
+
+	return NULL;
+}
+
+int genlmsg_read_response(struct genl_tx* tx, struct sk_buff **skb, struct genl_info *info, int timeout) {
+	struct genl_tx_internal* itx;
+	int err;
+	u64 read_time;
+
+	genl_ext_lock();	
+	itx = __find_itx(tx);
+	genl_ext_unlock();
+
+	if ( !itx )
+		return -EINVAL;
+	
+	if ( itx->interuptible ) {
+	  err = wait_event_interruptible_timeout(tx_queue, itx->done == 1, msecs_to_jiffies(timeout*1000));
+	}else {
+	  /* If the request is not interruptible, we have to wait for reply even when signal arrives. This is, however, generally fast enough not to cause too much trouble (sub ms). */
+	  err = wait_event_timeout(tx_queue, itx->done == 1, msecs_to_jiffies(timeout*1000));	  
+	}
+	    	
+	read_time = cpu_clock(smp_processor_id());
+	
+	mdbg(INFO3,"Reading response done: %d err: %d. Read took: %llu ms", tx->seq, err, (read_time - itx->start_time)/1000000);
+
+	genl_ext_lock();	
+	if ( itx )
+		list_del(&itx->link);
+	genl_ext_unlock();
+	
+	if ( err == 0 )
+		err = -ETIME; /* Timeout */
+	
+	if ( err < 0 )
+		goto wait_err;	
+
+	*skb = itx->skb;
+	memcpy(info,&itx->info, sizeof(struct genl_info));
+	kfree(itx);
+	return 0;
+
+wait_err:
+	/*kfree_skb(*skb);*/
+	kfree(itx);
+	return err;
+}
+
+/* This handler will distribute the message to registered transactions */
+static int generic_message_handler(struct sk_buff *skb, struct genl_info *info) {
+	struct genl_tx_internal* itx;
+	struct genl_tx tx;
+
+	/*tx.cmd = info->genlhdr->cmd;*/
+	tx.seq = info->snd_seq;
+	mdbg(INFO4,"Generic message handler got: %d", tx.seq);
+
+	genl_ext_lock();	
+	itx = __find_itx(&tx);	
+	genl_ext_unlock();
+
+	if ( !itx ) {		
+		/* No tx registered for the message */
+		minfo(ERR1, "Sequence not registered: %d", tx.seq);
+		return -EINVAL;
+	}
+
+	skb = skb_get(skb); /* Get a reference of skb for further processing */
+	itx->skb = skb;
+	memcpy(&itx->info, info, sizeof(struct genl_info));
+	/* TODO: Do we need wmb here? Or does wake up all make a barrier? */
+	itx->done = 1;
+
+	wake_up_all(&tx_queue); /* TODO: Some more scalable waking strategy? Wake up only thread waiting for current itx? */
+
+	return 0;
+}
+
+struct genl_ops* genlmsg_register_tx_ops(struct genl_family *family, struct nla_policy* policy, u8 command) {
+	int err;
+	struct genl_ops* ops;
+
+	ops = kmalloc(sizeof(struct genl_ops), GFP_KERNEL);
+	ops->cmd = command;
+	ops->flags = 0;
+	ops->policy = policy;
+	ops->doit = generic_message_handler;
+	ops->dumpit = NULL;
+
+	if ( (err=genl_register_ops(family, ops)) )  {
+		kfree(ops);
+		return NULL;
+	}
+
+	return ops;
+}
--- linux-3.7.1_original/clondike/src/director/netlink/generic_user_message_send_handler.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/director/netlink/generic_user_message_send_handler.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,10 @@
+#ifndef GENERIC_USER_MESSAGE_SEND_HANDLER_H
+#define GENERIC_USER_MESSAGE_SEND_HANDLER_H
+
+#include "../handlers.h"
+
+void register_send_generic_user_message_handler(send_generic_user_message_handler_t handler);
+
+int handle_send_generic_user_message(struct sk_buff *skb, struct genl_info *info);
+
+#endif
--- linux-3.7.1_original/clondike/src/director/netlink/node_disconnected_msg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/director/netlink/node_disconnected_msg.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,59 @@
+#include "node_disconnected_msg.h"
+#include "msgs.h"
+#include "genl_ext.h"
+#include "comm.h"
+
+#include <dbg.h>
+
+#include <linux/skbuff.h>
+
+struct node_disconnected_params {
+	/* In params */
+	int slot_index;
+	int detached;
+	int reason;
+
+	/* Out params - NONE */
+};
+
+static int node_disconnected_create_request(struct sk_buff *skb, void* params) {
+  	int ret = 0;
+  	struct node_disconnected_params* node_disconnected_params = params;
+
+	ret = nla_put_u32(skb, DIRECTOR_A_INDEX, node_disconnected_params->slot_index);
+  	if (ret != 0)
+      		goto failure;
+
+	// If remote node is detached, then local slot is of type core node (because detached nodes are connected into core slots)
+	ret = nla_put_u32(skb, DIRECTOR_A_SLOT_TYPE, node_disconnected_params->detached != 0);
+  	if (ret != 0)
+      		goto failure;
+
+	ret = nla_put_u32(skb, DIRECTOR_A_REASON, node_disconnected_params->reason);
+  	if (ret != 0)
+      		goto failure;
+failure:
+	return ret;
+}
+
+static struct msg_transaction_ops node_disconnected_msg_ops = {
+	.create_request = node_disconnected_create_request,
+	.read_response = NULL
+};
+
+int node_disconnected(int slot_index, int detached, int reason) {
+	struct node_disconnected_params params;
+	int ret;
+
+	params.slot_index = slot_index;
+	params.detached = detached;
+	params.reason = reason;
+
+	ret = msg_transaction_do(DIRECTOR_NODE_DISCONNECTED, &node_disconnected_msg_ops, &params, 1);
+
+	if ( ret )
+		return ret;
+	
+	return 0;
+}
+
--- linux-3.7.1_original/clondike/src/director/netlink/genl_ext.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/director/netlink/genl_ext.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,47 @@
+#ifndef GENL_EXT_H
+#define GENL_EXT_H
+
+#include <net/genetlink.h>
+
+struct sk_buff;
+
+/* Helper functions that extend generic netlink functionality to better support kernel-as-client functionality */
+
+/* Structure representing one request-response transaction */
+struct genl_tx {
+/*	u8 cmd;  Command type */
+	u32 seq; /* Sequence number */
+};
+
+/**
+  * genlmsg_unicast_tx - wrapper around generic netlink unicast. 
+  * It addition to a standard version it has an option to register transaction for reading the response
+  * 
+  * @param skb: netlink message as socket buffer
+  * @param pid: netlink pid of the destination socket
+  * @param tx: the transaction context that can be later used for reading the response. If NULL then only standard unicast is performed
+  * @param interuptible: If !=0, the transaction can be terminated when signal arrives and does not need to wait for a reply
+  */
+int genlmsg_unicast_tx(struct sk_buff *skb, u32 pid, struct genl_tx* tx, int interuptible);
+
+/**
+  * Blocking read call that will read netlink response for the specified transaction
+  *
+  * @param tx: Transaction previously used in genlms_unicast_tx
+  * @param skb: will hold resulting buffer (and reference to it, that must be freed by the caller)
+  * @param info: will hold resulting genl_info.. it should be a pointer to already allocated structure, and its data will be just filled
+  * @param timeout: timeout in seconds
+  */
+int genlmsg_read_response(struct genl_tx* tx, struct sk_buff **skb, struct genl_info *info, int timeout);
+
+/**
+  * This method must be called to register response command for transaction handling. No other callback can be registered for this command
+  *
+  * @param family: Generic netlink family
+  * @param policy: Netlink policy to be used for attribute checking
+  * @param command: Command that should be handled by the tx extension (message type of expected response)
+  * @return ops structure that was registered (can be used for later deregistration)
+  */
+struct genl_ops* genlmsg_register_tx_ops(struct genl_family *family, struct nla_policy* policy, u8 command);
+
+#endif
--- linux-3.7.1_original/clondike/src/director/netlink/msg_skeleton.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/director/netlink/msg_skeleton.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,5 @@
+#ifndef MSG_SKELETON_H
+#define MSG_SKELETON_H
+
+
+#endif
\ No newline at end of file
--- linux-3.7.1_original/clondike/src/director/netlink/immigration_confirmed_msg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/director/netlink/immigration_confirmed_msg.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,18 @@
+#ifndef IMMIGRATION_CONFIRMED_MSG_H
+#define IMMIGRATION_CONFIRMED_MSG_H
+
+#include <linux/types.h>
+
+/**
+ * Notification about successful imigration
+ *
+ * @param slot_index Index of the remote core node manager that requests immigration to this node
+ * @param uid Uid of user on the remote node that is requesting the migration
+ * @param name Name of the binary the process (executable) that should be immigrated
+ * @param local_pid Local pid of the task
+ * @param remote_pid Pid of the task on core node
+ * @return 0 on success, error code otherwise
+ */
+int immigration_confirmed(int slot_index, uid_t uid, const char* name, pid_t local_pid, pid_t remote_pid);
+
+#endif
--- linux-3.7.1_original/clondike/src/director/netlink/comm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/director/netlink/comm.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,241 @@
+#include "msgs.h"
+#include "comm.h"
+#include "genl_ext.h"
+
+#include <linux/skbuff.h>
+#include <linux/resource.h>
+#include <dbg.h>
+
+#include "generic_user_message_send_handler.h"
+
+const char* DIRECTOR_CHANNEL_NAME = "DIRECTORCHNL";
+
+/** Pid of associated user space process (if any) */
+static u32 user_director_pid = 0;
+/** Sequence generating unique transaction numbers */
+static atomic_t director_seq = ATOMIC_INIT(1);
+
+/** Read timeout in seconds */
+static int read_timeout = 5;
+
+static struct genl_family director_gnl_family = {
+	.id = GENL_ID_GENERATE,
+	.hdrsize = 0,
+	.name = "DIRECTORCHNL", /*DIRECTOR_CHANNEL_NAME... MUST BE SHORTER THAN 16 CHARS!!!!!!!!!!!!!!!!! */
+	.version = 1,
+	.maxattr = DIRECTOR_ATTR_MAX
+};
+
+/* Attribute policies */
+static struct nla_policy director_genl_policy[DIRECTOR_ATTR_MAX + 1] = {
+	[DIRECTOR_A_PID] = { .type = NLA_U32 },
+	[DIRECTOR_A_LENGTH] = { .type = NLA_U32 },
+	[DIRECTOR_A_EXIT_CODE] = { .type = NLA_U32 },
+	[DIRECTOR_A_ERRNO] = { .type = NLA_U32 },
+	[DIRECTOR_A_RUSAGE] = { .type = NLA_BINARY, .len = sizeof(struct rusage) },
+};
+
+/**
+ * Checks, if the transaction returned an error.
+ *
+ * @return 0, if there was no error, error code otherwise
+ */
+static int check_for_error(struct genl_info* info) {
+	struct nlattr* attr;
+	int err;
+
+	attr = nlmsg_find_attr(info->nlhdr, sizeof(struct genlmsghdr), DIRECTOR_A_ERRNO);
+	if ( attr == NULL ) {
+		return 0;
+	}
+
+	err = nla_get_u32(attr); 
+	minfo(ERR3, "Error code from user deamon: %d", err);
+	return err;
+}
+
+/** Returns pid of director process if there is user-space director connected, 0 otherwise */
+static int is_director_connected(void) {
+	return user_director_pid;
+}
+
+int is_director_pid(pid_t ppid) {
+	return (u32)ppid == user_director_pid;
+}
+
+/** Returns unique sequence number for transaction */
+static int get_unique_seq(void) {
+	return atomic_inc_return(&director_seq);
+}
+
+/* Callback for initial daemon registration */
+static int register_pid_handler(struct sk_buff *skb, struct genl_info *info) {
+	struct nlattr* attr;
+
+	attr = nlmsg_find_attr(info->nlhdr, sizeof(struct genlmsghdr), DIRECTOR_A_PID);
+	if ( attr == NULL ) {
+		return -1;
+	}
+
+	user_director_pid = nla_get_u32(attr);
+	minfo(INFO1, "Registered director pid: %u", user_director_pid);
+
+
+	return 0;
+}
+
+static struct genl_ops register_pid_ops = {
+        .cmd = DIRECTOR_REGISTER_PID,
+        .flags = 0,
+        .policy = director_genl_policy,
+	.doit = register_pid_handler,
+	.dumpit = NULL,
+};
+
+static struct genl_ops send_user_message_ops = {
+        .cmd = DIRECTOR_SEND_GENERIC_USER_MESSAGE,
+        .flags = 0,
+        .policy = director_genl_policy,
+	.doit = handle_send_generic_user_message,
+	.dumpit = NULL,
+};
+
+static struct genl_ops* check_npm_ops_ref,
+		      * node_connected_ops_ref,
+		      * ack_ops_ref,
+	    	      * immigration_request_ops_ref;
+
+int init_director_comm(void) {
+	int ret;
+
+	ret = genl_register_family(&director_gnl_family);
+	if (ret != 0)
+		return ret;
+
+	// TODO: Release temporarily allocated resources ;)
+
+	/* Register callback for daemin PID registration */
+	genl_register_ops(&director_gnl_family, &register_pid_ops);
+
+	genl_register_ops(&director_gnl_family, &send_user_message_ops);	
+
+	/* Register generic dispatching callback for all other calls */
+	check_npm_ops_ref = genlmsg_register_tx_ops(&director_gnl_family, director_genl_policy, DIRECTOR_NPM_RESPONSE);
+	if ( !check_npm_ops_ref )
+		return -1;	
+
+	node_connected_ops_ref = genlmsg_register_tx_ops(&director_gnl_family, director_genl_policy, DIRECTOR_NODE_CONNECT_RESPONSE);
+	if ( !check_npm_ops_ref )
+		return -1;	
+
+	immigration_request_ops_ref = genlmsg_register_tx_ops(&director_gnl_family, director_genl_policy, DIRECTOR_IMMIGRATION_REQUEST_RESPONSE);
+	if ( !immigration_request_ops_ref )
+		return -1;	
+
+	ack_ops_ref = genlmsg_register_tx_ops(&director_gnl_family, director_genl_policy, DIRECTOR_ACK);
+	if ( !ack_ops_ref )
+		return -1;	
+
+
+	minfo(INFO3, "Director comm component initialized");
+
+	return 0;
+}
+
+void destroy_director_comm(void) {
+	//int res;
+
+//	if ( (res = shutdown_user_daemon_request()) ) {
+//		printk(KERN_ERR "Failed to stop the helper daemon: %d\n", res);
+//	}
+
+	genl_unregister_ops(&director_gnl_family, &register_pid_ops);
+	genl_unregister_ops(&director_gnl_family, &send_user_message_ops);
+	genl_unregister_ops(&director_gnl_family, check_npm_ops_ref);
+	genl_unregister_ops(&director_gnl_family, node_connected_ops_ref);
+	genl_unregister_ops(&director_gnl_family, ack_ops_ref);
+	genl_unregister_ops(&director_gnl_family, immigration_request_ops_ref);
+	genl_unregister_family(&director_gnl_family);
+
+	kfree(check_npm_ops_ref);
+}
+
+
+/****************** Msg support ************************/
+
+/** Helper method to create&send request */
+static int msg_transaction_request(int msg_code, struct genl_tx* tx, struct msg_transaction_ops* ops, void* params, int interruptible) {
+  int ret;
+  void *msg_head;
+  struct sk_buff *skb;
+  int seq, director_pid;
+
+  director_pid = is_director_connected();
+  if ( !director_pid )
+	return -EFAULT;
+
+  skb = nlmsg_new(63000, GFP_KERNEL);
+  if (skb == NULL)
+      return -1;
+
+  seq = get_unique_seq();
+
+  msg_head = genlmsg_put(skb, director_pid, seq, &director_gnl_family, 0, msg_code);
+  if (msg_head == NULL) {
+      ret = -ENOMEM;
+      goto failure;
+  }
+  
+  ret = ops->create_request(skb, params);
+  if (ret < 0)
+      goto failure;
+
+  ret = genlmsg_end(skb, msg_head);
+  if (ret < 0)
+      goto failure;
+
+  ret = genlmsg_unicast_tx(skb, director_pid, tx, interruptible);
+  if (ret != 0)
+      goto failure;
+
+  return ret;
+
+failure:
+  genlmsg_cancel(skb, msg_head);
+
+  return ret;
+}
+
+static int msg_transaction_response(struct genl_tx* tx, struct msg_transaction_ops* ops, void* params) {
+	struct sk_buff *skb;
+	struct genl_info info;
+	unsigned int ret = 0;
+
+	if ( (ret= genlmsg_read_response(tx, &skb, &info, read_timeout)) )
+		return ret;
+
+	if ( (ret=check_for_error(&info)) )
+		goto done;
+
+
+	if ( ops->read_response ) {
+	  ret = ops->read_response(&info, params);
+	  if (ret < 0)
+		  goto done;
+	}
+
+done:
+	kfree_skb(skb);
+	return ret;
+}
+
+int msg_transaction_do(int msg_code, struct msg_transaction_ops* ops, void* params, int interruptible) {
+	struct genl_tx tx;
+
+	int res = msg_transaction_request(msg_code, &tx, ops, params, interruptible);
+
+	if ( res )
+		return res;
+
+	return msg_transaction_response(&tx, ops, params);
+}
--- linux-3.7.1_original/clondike/src/director/netlink/task_forked_msg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/director/netlink/task_forked_msg.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,63 @@
+#include "npm_msg.h"
+#include "msgs.h"
+#include "genl_ext.h"
+#include "comm.h"
+
+#include "task_forked_msg.h"
+
+#include <dbg.h>
+
+#include <linux/skbuff.h>
+
+struct task_forked_params {
+	/* In params */
+	u32 pid;
+	u32 ppid;
+
+	/* Out params -> NONE */
+
+};
+
+static int task_forked_create_request(struct sk_buff *skb, void* params) {
+  	int ret = 0;
+  	struct task_forked_params* task_forked_params = params;
+
+	ret = nla_put_u32(skb, DIRECTOR_A_PID, task_forked_params->pid);
+  	if (ret != 0)
+      		goto failure;
+
+	ret = nla_put_u32(skb, DIRECTOR_A_PPID, task_forked_params->ppid);
+  	if (ret != 0)
+      		goto failure;
+
+failure:
+	return ret;
+}
+
+
+static int task_forked_read_response(struct genl_info* info, void* params) {
+	int ret = 0;
+//	struct task_exitted_params* task_exitted_params = params;
+
+	return ret;
+}
+
+static struct msg_transaction_ops task_forked_msg_ops = {
+	.create_request = task_forked_create_request,
+	.read_response = task_forked_read_response
+};
+
+
+int task_forked(pid_t pid, pid_t ppid) {
+	struct task_forked_params params;
+	int ret;
+
+	params.pid = pid;
+	params.ppid = ppid;
+
+	ret = msg_transaction_do(DIRECTOR_TASK_FORK, &task_forked_msg_ops, &params, 1);
+
+	minfo(INFO3, "Task forked. Pid:  %u -> %u -> Res: %d", ppid, pid, ret);
+
+	return ret;
+}
--- linux-3.7.1_original/clondike/src/director/netlink/generic_user_message_send_handler.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/director/netlink/generic_user_message_send_handler.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,52 @@
+#include "msgs.h"
+#include "genl_ext.h"
+#include "comm.h"
+
+#include <dbg.h>
+
+#include <linux/skbuff.h>
+#include "generic_user_message_send_handler.h"
+
+/** Handler instance */
+static send_generic_user_message_handler_t generic_user_message_handler = NULL;
+
+void register_send_generic_user_message_handler(send_generic_user_message_handler_t handler) {
+	generic_user_message_handler = handler;
+};
+
+int handle_send_generic_user_message(struct sk_buff *skb, struct genl_info *info) {
+	struct nlattr* attr;
+	char* user_data;
+	int user_data_length, target_slot_index, target_slot_type;
+
+	// No handler registered?
+	if ( !generic_user_message_handler ) {
+		return -EINVAL;
+	}
+
+	attr = nlmsg_find_attr(info->nlhdr, sizeof(struct genlmsghdr), DIRECTOR_A_SLOT_INDEX);
+	if ( attr == NULL ) {
+		return -1;
+	}
+	target_slot_index = nla_get_u32(attr);
+
+	attr = nlmsg_find_attr(info->nlhdr, sizeof(struct genlmsghdr), DIRECTOR_A_SLOT_TYPE);
+	if ( attr == NULL ) {
+		return -1;
+	}
+	target_slot_type = nla_get_u32(attr);
+
+	attr = nlmsg_find_attr(info->nlhdr, sizeof(struct genlmsghdr), DIRECTOR_A_LENGTH);
+	if ( attr == NULL ) {
+		return -1;
+	}
+	user_data_length = nla_get_u32(attr);
+
+	attr = nlmsg_find_attr(info->nlhdr, sizeof(struct genlmsghdr), DIRECTOR_A_USER_DATA);
+	if ( attr == NULL ) {
+		return -1;
+	}
+	user_data = nla_data(attr);
+
+	return generic_user_message_handler(target_slot_type, target_slot_index, user_data_length, user_data);
+};
--- linux-3.7.1_original/clondike/src/director/netlink/task_forked_msg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/director/netlink/task_forked_msg.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,15 @@
+#ifndef TASK_FORKED_MSG_H
+#define TASK_FORKED_MSG_H
+
+#include <linux/types.h>
+
+/**
+ * Called, when a task forks
+ *
+ * @param pid Pid of the task that exists
+ * @param ppid Pid of a parent task that was forked
+ * @return 0 on success, error code otherwise. In case of error, output params are not valid!
+ */
+int task_forked(pid_t pid, pid_t ppid);
+
+#endif
--- linux-3.7.1_original/clondike/src/arch/arch_ids.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/arch/arch_ids.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,25 @@
+#ifndef ARCH_IDS_H
+#define ARCH_IDS_H
+
+/** Enumeration representing all supported architecture types */
+enum arch_ids {
+	UNKNOWN,
+	ARCH_I386,
+	ARCH_X86_64,
+	ARCH_UM,
+	
+	ARCH_COUNT
+};
+
+extern char* arch_names[];
+
+/** Definition of ARCH_CURRENT points to enum element representing architecture type of the current kernel */
+#if defined(__i386__)
+#define ARCH_CURRENT ARCH_I386
+#elif defined(__x86_64__)
+#define ARCH_CURRENT ARCH_X86_64
+#elif defined(__arch_um__)
+#define ARCH_CURRENT ARCH_UM
+#endif
+
+#endif
--- linux-3.7.1_original/clondike/src/arch/x86_64/thread.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/arch/x86_64/thread.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,106 @@
+#ifndef ARG_X86_64_THREAD_H
+#define ARG_X86_64_THREAD_H
+
+#if defined(__x86_64__)
+/** Simple alias for current thread struct */ 
+#define tcmi_thread tcmi_x86_64_thread
+#endif
+
+struct tcmi_x86_64_thread {
+	u_int64_t tls_array[GDT_ENTRY_TLS_ENTRIES];
+	u_int64_t gs, fs;
+	u_int32_t gsindex, fsindex;
+} __attribute__((__packed__));
+
+#if defined(__x86_64__)
+#include <arch/i386/thread.h>
+static inline void get_tcmi_thread(struct thread_struct* thread, struct tcmi_thread* tcmi_thread) {
+	memcpy(tcmi_thread->tls_array, thread->tls_array, sizeof(tcmi_thread->tls_array));
+	tcmi_thread->gs = thread->gs;
+	tcmi_thread->gsindex = thread->gsindex;
+	tcmi_thread->fs = thread->fs;
+	tcmi_thread->fsindex = thread->fsindex;
+
+	mdbg(INFO4, "GS  : %16lx    GS index : %4x",thread->gs, thread->gsindex);
+	mdbg(INFO4, "FS  : %16lx    FS index : %4x",thread->fs, thread->fsindex);
+}
+
+static inline void load_thread(struct tcmi_x86_64_thread* tcmi_thread, struct thread_struct* thread) {
+	memcpy(thread->tls_array, tcmi_thread->tls_array, sizeof(tcmi_thread->tls_array));
+	thread->gs = tcmi_thread->gs;
+	thread->gsindex = tcmi_thread->gsindex;
+	thread->fs = tcmi_thread->fs;
+	thread->fsindex = tcmi_thread->fsindex;
+
+	mdbg(INFO4, "GS  : %16lx    GS index : %4x",thread->gs, thread->gsindex);
+	mdbg(INFO4, "FS  : %16lx    FS index : %4x",thread->fs, thread->fsindex);
+
+	/*
+	thread->tls_array[0] = tcmi_thread->tls_array[1];
+	thread->tls_array[1] = tcmi_thread->tls_array[0];
+	thread->tls_array[2] = tcmi_thread->tls_array[2];
+
+	tcmi_thread->gs = thread->gs;
+	thread->gsindex = tcmi_thread->gsindex;
+	*/
+}
+
+static inline void load_i386_thread(struct tcmi_i386_thread* tcmi_thread, struct thread_struct* thread) {
+	/* FS and GS TLS are for whatever reason swaped on i386 and x86_64 */
+	thread->tls_array[0] = tcmi_thread->tls_array[1];
+	thread->tls_array[1] = tcmi_thread->tls_array[0];
+	thread->tls_array[2] = tcmi_thread->tls_array[2];
+
+	// TODO: Gs is now assumed to be used for TLS and so we simply load it, but some more checks, whether it was really like that, would be nice */
+	thread->gs = 0;
+	thread->gsindex = GS_TLS_SEL;
+	// TODO: Load fs
+	thread->fs = 0;
+	thread->fsindex = 0;
+}
+
+static inline void load_from_platform_thread(void* platform_thread, struct thread_struct* thread, enum arch_ids from_arch) {
+	if ( from_arch == ARCH_CURRENT ) { /* Equal architecture */
+		int i;
+		load_thread( (struct tcmi_x86_64_thread*) platform_thread, thread);
+
+		for ( i=0; i < 3; i++ ) {		
+			unsigned long long sg32bit = 1;
+			unsigned long long usablebit = 1;
+ 			sg32bit = sg32bit << 54;	
+			usablebit = usablebit << 52;
+			//mdbg(INFO3, "LDT[%d]: %llX is seg 32: %d Usable: %d", i, thread->tls_array[i], ((sg32bit & thread->tls_array[i]) > 0), ((usablebit & thread->tls_array[i])) > 0); 
+		}
+		return;
+	}
+
+	if ( from_arch == ARCH_I386 ) {
+		int i;
+		load_i386_thread( (struct tcmi_i386_thread*) platform_thread, thread);
+		for ( i=0; i < 3; i++ ) {		
+			unsigned long long sg32bit = 1;
+			unsigned long long usablebit = 1;
+ 			sg32bit = sg32bit << 54;	
+			usablebit = usablebit << 52;
+			//mdbg(INFO3, "LDT[%d]: %llX is seg 32: %d Usable: %d", i, thread->tls_array[i], ((sg32bit & thread->tls_array[i]) > 0), ((usablebit & thread->tls_array[i])) > 0); 
+		}
+		return;
+	}
+
+	mdbg(ERR3, "Unsupported source platform: %d", from_arch);
+}
+
+//asm volatile("movl %0,%%fs" :: "g"((thread)->fsindex));
+
+#define resolve_TLS(thread, cpu, regs) do { \
+	load_TLS(thread, cpu); \
+	load_gs_index((thread)->gsindex); \
+	if ( (thread)->fs )				\
+		wrmsrl(MSR_FS_BASE, (thread)->fs); \
+	\
+} while (0)
+
+#endif
+
+
+#endif
--- linux-3.7.1_original/clondike/src/arch/x86_64/make_syscall.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/arch/x86_64/make_syscall.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,67 @@
+#ifndef _MAKE_SYSCALL_H
+#define _MAKE_SYSCALL_H
+
+#include <linux/syscalls.h>
+
+#define __syscall "syscall"
+
+#define __syscall_clobber "r11","rcx","memory" 
+
+#define __syscall_return(type, res) \
+do { \
+        if ((unsigned long)(res) >= (unsigned long)(-127)) { \
+                errno = -(res); \
+                res = -1; \
+        } \
+        return (type) (res); \
+} while (0)
+
+#define _syscall0(type,name) \
+type name(void) \
+{ \
+long __res; \
+mm_segment_t old_fs;\
+old_fs = get_fs();\
+set_fs(KERNEL_DS);\
+__res = sys_##name(); \
+set_fs(old_fs);	\
+__syscall_return(type,__res); \
+}
+
+#define _syscall1(type,name,type1,arg1) \
+type name(type1 arg1) \
+{ \
+long __res; \
+mm_segment_t old_fs;\
+old_fs = get_fs();\
+set_fs(KERNEL_DS);\
+__res = sys_##name((type1)arg1); \
+set_fs(old_fs);		\
+__syscall_return(type,__res); \
+}
+
+#define _syscall2(type,name,type1,arg1,type2,arg2) \
+type name(type1 arg1,type2 arg2) \
+{ \
+long __res; \
+mm_segment_t old_fs;\
+old_fs = get_fs();\
+set_fs(KERNEL_DS);\
+__res = sys_##name((type1)arg1, (type2)arg2); \
+set_fs(old_fs);		\
+__syscall_return(type,__res); \
+}
+
+#define _syscall3(type,name,type1,arg1,type2,arg2,type3,arg3) \
+type name(type1 arg1,type2 arg2,type3 arg3) \
+{ \
+long __res; \
+mm_segment_t old_fs;\
+old_fs = get_fs();\
+set_fs(KERNEL_DS);\
+__res = sys_##name((type1)arg1, (type2)arg2, (type3)arg3); \
+set_fs(old_fs);		\
+__syscall_return(type,__res); \
+}
+
+#endif
--- linux-3.7.1_original/clondike/src/arch/x86_64/regs.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/arch/x86_64/regs.c	2013-03-11 11:40:43.000000000 +0100
@@ -0,0 +1,124 @@
+#include <linux/slab.h>       //Added include linux/slab.h for kmalloc | by Jiri Rakosnik
+
+#include "regs.h"
+
+#include <dbg.h>
+
+#if defined(__x86_64__)
+#include <arch/i386/regs.h>
+
+void* get_target_platform_registers(struct pt_regs* regs, enum arch_ids target_arch) {
+	if ( target_arch == ARCH_CURRENT ) {
+		struct tcmi_regs* result_regs = kmalloc(sizeof(struct tcmi_regs), GFP_KERNEL);
+		if ( !result_regs )
+			return NULL;
+
+		get_registers(regs, result_regs);
+		return result_regs;
+	}
+
+	if ( target_arch == ARCH_I386 ) {
+		struct tcmi_i386_regs* result_regs = kmalloc(sizeof(struct tcmi_i386_regs), GFP_KERNEL);
+		if ( !result_regs )
+			return NULL;
+
+		result_regs->orig_eax = regs->orig_ax;;
+		result_regs->eax = regs->ax;
+		result_regs->ebx = regs->bx;
+		result_regs->ecx = regs->cx;
+		result_regs->edx = regs->dx;
+
+		result_regs->esi = regs->si;
+		result_regs->edi = regs->di;
+
+		result_regs->xss = regs->ss;
+		result_regs->xcs = regs->cs;
+		result_regs->eip = regs->ip;
+		result_regs->eflags = regs->flags;
+		result_regs->ebp = regs->bp;
+		result_regs->esp = regs->sp;
+
+		/* TODO: How to restore fs and es? It is not stored on 64 stack.. */
+		result_regs->xfs = 0;
+		result_regs->xes = 0;
+
+		return result_regs;
+	}
+
+	mdbg(ERR3, "Unsupported target platform: %d", target_arch);
+
+	return NULL;
+};
+
+void load_from_platform_registers(void* platform_registers, struct pt_regs* regs, enum arch_ids from_arch, int is_32bit_app) {
+	if ( from_arch == ARCH_CURRENT ) {
+		/** Simple load of equal registers */
+		load_registers( (struct tcmi_regs*)platform_registers, regs);
+
+		if ( is_32bit_app ) {
+			regs->cs = __USER32_CS;		
+			regs->ss = __USER32_DS;
+		}
+
+		return;
+	}
+
+	if ( from_arch == ARCH_I386) {
+		struct tcmi_i386_regs* tcmi_regs = (struct tcmi_i386_regs*)platform_registers;
+		regs->orig_ax = tcmi_regs->orig_eax;;
+		regs->ax = tcmi_regs->eax;
+		regs->bx = tcmi_regs->ebx;
+		regs->cx = tcmi_regs->ecx;
+		regs->dx = tcmi_regs->edx;
+
+		regs->si = tcmi_regs->esi;
+		regs->di = tcmi_regs->edi;
+
+/*		regs->ss = tcmi_regs->xss;
+		regs->cs = tcmi_regs->xcs; */
+
+		regs->cs = __USER32_CS;		
+		regs->ss = __USER32_DS;
+		regs->ip = tcmi_regs->eip;
+		regs->flags = tcmi_regs->eflags;
+		regs->bp = tcmi_regs->ebp;
+		regs->sp = tcmi_regs->esp;
+
+		regs->r8 = 0;
+		regs->r9 = 0;
+		regs->r10 = 0;
+		regs->r11 = 0;
+		regs->r12 = 0;
+		regs->r13 = 0;
+		regs->r14 = 0;
+		regs->r15 = 0;
+
+		return;
+	}
+
+
+	mdbg(ERR3, "Unsupported source platform: %d", from_arch);
+};
+
+int is_in_syscall(struct pt_regs* regs) {
+	return (( (long)regs->orig_ax >= 0) &&			
+			   (regs->ax == -ERESTARTNOHAND ||		
+			    regs->ax == -ERESTARTSYS ||		
+			    regs->ax == -ERESTART_RESTARTBLOCK ||	
+			    regs->ax == -ERESTARTNOINTR));
+};
+
+void debug_registers(struct pt_regs* regs) {
+	mdbg(INFO4, "RSP  : %16lx    RBP : %16lx",regs->sp,regs->bp);
+	mdbg(INFO4, "RSI  : %16lx    RDI : %16lx",regs->si,regs->di);
+	mdbg(INFO4, "CS   : %16lx     SS  : %16lx", regs->cs,regs->ss);		
+	mdbg(INFO4, "RIP  : %16lx    ORAX: %16lX",regs->ip,regs->orig_ax);
+	mdbg(INFO4, "RAX  : %16lx    RBX : %16lX",regs->ax,regs->bx);
+	mdbg(INFO4, "RCX  : %16lx    RDX : %16lX",regs->cx,regs->dx);
+	mdbg(INFO4, "R08  : %16lx    R09 : %16lX",regs->r8,regs->r9);
+	mdbg(INFO4, "R10  : %16lx    R11 : %16lX",regs->r10,regs->r11);
+	mdbg(INFO4, "R12  : %16lx    R13 : %16lX",regs->r12,regs->r12);
+	mdbg(INFO4, "R14  : %16lx    R15 : %16lX",regs->r14,regs->r15);
+};
+
+#endif
--- linux-3.7.1_original/clondike/src/arch/x86_64/vma.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/arch/x86_64/vma.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,14 @@
+#ifndef ARG_X86_64_VMA_H
+#define ARG_X86_64_VMA_H
+
+/** Returns 1, if the vma should be ignored by checkpointing componenet */
+#define vma_ignore(ckpt, vma) ({ \
+	int res = 0; \
+ \
+	/* 32 bit applications emulated on 64 kernel have manually mapped vsyscall pages.. these should NOT be migrated */ \
+	if ( ckpt->hdr.is_32bit_application && vma->vm_start == 0xffffe000 ) \
+		res = 1; \
+	res; \
+})
+
+#endif
--- linux-3.7.1_original/clondike/src/arch/x86_64/restart_fixup.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/arch/x86_64/restart_fixup.h	2013-03-09 21:00:11.000000000 +0100
@@ -0,0 +1,128 @@
+#ifndef ARG_X86_64_RESTART_FIXUP_H
+#define ARG_X86_64_RESTART_FIXUP_H
+
+// TODO: Use vsdo attribute of mm_context to check for correct location of vsdo. It is not really supported by 64 bit now, but 32 bit kernel is using it and we must be able to handle this case also here!
+
+
+// TODO: Disable making of checkpoints, when we are in some part of vsdo other than syscall itself (otherwise we have to fixup stack & args for every possible EIP)
+
+#include <asm/processor.h>
+
+/** We need to export this in order to prepare vsyscall page for 32 bit applications */
+extern int syscall32_setup_pages(struct linux_binprm *bprm, int exstack);
+
+/** 
+ * This method is used for handling migration restart. There are 2 cases:
+ * 
+ * Application was in syscall:
+ *  We cannot directly restart the syscall, because as a part of process restart we do execve. The execve,
+ * if it succeeds, will set EAX to 0. This means, the restarted syscall will not be the original syscall, but sys_restartsyscall.
+ * Restart syscall is handled by the custom registered method in our case this method.
+ *
+ * Application was not in syscall:
+ *  We cannot simply restart the application, because again the execve will override EAX content! Here we use a special trick.
+ * We can assume EAX will contain 0 as in previous case (=execve succeeded, otherwise the program would not start anyway).
+ * With EAX == 0 we can set fake EIP just before the vsyscall sysenter (assuming it is mapped in the process on expected address)
+ * This way we will get sysretart called immediately and from the special restart function we return proper eax (and eip) in order to make 
+ * the application working as expected, with all registers set correctly.
+ */
+
+/* Commented function because struct restart_block doesn't contain arg1, arg2 and above all function is not called | by Jiri Rakosnik
+static long tcmi_restart_fixup(struct restart_block *restart) {
+	struct pt_regs *regs = task_pt_regs(current);
+
+	mdbg(INFO3, "Calling tcmi sys restart. EAX: %08lX (OEAX: %08lX Return EAX: %08lX) SP: %16lX BP: %16lX (Restore BP: %16lX)", regs_return_value(regs), original_ax(regs), restart->arg0, stack_pointer(regs), base_pointer(regs), restart->arg2);
+	//mdbg(INFO3, "Calling tcmi sys restart. EAX: %08lX (OEAX: %08lX Return EAX: %08lX). EBX: %08lX ECX: %08lX EDX: %08lX", regs->eax, regs->orig_eax, restart->arg0, regs->ebx, regs->ecx, regs->edx);
+
+	// TODO: Reset restart_block? 
+
+	// Reset EIP to original value (either again just before the syscall, or on the other completely unrelated address 
+	regs->ip = restart->arg1;			
+	
+	// Restore rcx 
+	regs->cx = restart->arg2;
+
+	// To prevent ECX & EDX clobbering via sysexit 
+	set_thread_flag(TIF_IRET);
+	// 
+    //       This is a trick how to get original EAX onto the stack.. return value of this syscall is what gets onto the stack 
+	  // When the syscall gets executed again (as we again set EIP) it will finally use correct EAX. The other registers are unclobbered and so we do not need to restore them
+	 //  If we were not originally in syscall, we will simply continue with correct EAX where we finished.
+         
+	return restart->arg0;
+}
+*/
+
+/** 64 bit apps do not need to use restart block.. TODO: Do this kernel patch also for 32 bit apps? */
+static inline int tcmi_resolve_restart_block_64bit_app(struct task_struct* task, struct pt_regs* regs) {
+	if ( is_in_syscall(regs) ) {
+		mdbg(INFO3, "Performing restart in 64 bit syscall.");
+		regs->ip -= 2;
+		regs->ax = regs->orig_ax;
+	} else {
+		// For 64 bit applications we have a modified execve and we use orig_rax to set application rax, so we do not need to do restart trick
+		// Do this only if we are not in syscall, otherwise we want current orig_eax to get into eax register
+		regs->orig_ax = regs->ax;			
+	}
+	return 0;
+}
+
+/** 32 bit apps do not need to use restart block */
+static inline int tcmi_resolve_restart_block_32bit_app(struct task_struct* task, struct pt_regs* regs, enum arch_ids from_arch) {
+	if ( is_in_syscall(regs) ) {
+		mdbg(INFO3, "Performing restart in 32 bit syscall.");
+		regs->ip -= 2;
+		regs->ax = regs->orig_ax;
+
+		if ( boot_cpu_data.x86_vendor == X86_VENDOR_AMD) { // Fixup needed on AMD, as it does not support syscall in compat mode
+			regs->sp += 8; /* Fixup stack pointer.. */
+			*((unsigned int*)(regs->sp)) = regs->bp; // Fixup stack content.. this will be pushed from stack
+			regs->bp = regs->cx; // This is normally done by 64 bit syscall, so we have to do it manually
+		}
+	} else {
+		// For 64 bit applications we have a modified execve and we use orig_rax to set application rax, so we do not need to do restart trick
+		// Do this only if we are not in syscall, otherwise we want current orig_eax to get into eax register
+		regs->orig_ax = regs->ax;	
+
+		if ( regs->ip == 0xffffe410 && boot_cpu_data.x86_vendor == X86_VENDOR_AMD) { // Fixup needed on AMD, as it does not support syscall in compat mode
+			mdbg(INFO3, "Performing restart in finished 32 bit syscall.");
+			/* We were in syscall, but the syscall was not interrupted and so we do not need to restart it */
+			regs->bp = *((unsigned int*)(regs->sp)); // Extract real RBP
+			mdbg(INFO3, "Real rbp was: %08lx.", regs->bp);
+			regs->sp += 8; /* Fixup stack pointer.. */
+			*((unsigned int*)(regs->sp)) = regs->bp; // Fixup stack content.. this will be pushed from stack
+			regs->bp = regs->cx; // This is normally done by 64 bit syscall, so we have to do it manually
+			regs->ip = 0xffffe405; // Modify return address to correct value
+		}				
+	}
+	return 0;
+}
+
+/**
+ * Registeres restart block and schedules restart syscall to be executed after the process resumes userspace for first time. The main motivaction for this is to 
+ * restore original AX register.
+ *
+ * @param task Current task
+ * @param regs Current registers of the task
+ * @param is_32bit_application 1 if, the application is 32 bit
+ * @return 0 on success
+ */
+static inline int tcmi_resolve_restart_block(struct task_struct* task, struct pt_regs* regs, enum arch_ids from_arch, int is_32bit_application) {
+	//struct restart_block* restart = &task->thread_info->restart_block;
+	mdbg(INFO3, "Setting tcmi sys restart block. EAX: %08lX (OEAX: %08lX). EBX: %08lX ECX: %08lX EDX: %08lX", regs->ax, regs->orig_ax, regs->bx, regs->cx, regs->dx);	
+
+	if ( !is_32bit_application )
+		return tcmi_resolve_restart_block_64bit_app(task, regs);
+
+	/* First we have to setup syscall page into 32 process space so that it can do vsyscalls */
+	if ( syscall32_setup_pages(NULL,0) ) {
+		mdbg(ERR3, "Failed to install syscall page");
+		return -EINVAL;
+	}
+	
+	return tcmi_resolve_restart_block_32bit_app(task, regs, from_arch);
+
+	//return 0;
+}
+
+#endif
--- linux-3.7.1_original/clondike/src/arch/x86_64/regs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/arch/x86_64/regs.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,91 @@
+#ifndef ARG_X86_64_REGS_H
+#define ARG_X86_64_REGS_H
+
+#include <arch/arch_ids.h>
+#include <linux/types.h>
+#include <linux/ptrace.h>
+
+#if defined(__x86_64__)
+/** Simple alias for current register struct */ 
+#define tcmi_regs tcmi_x86_64_regs
+#endif
+
+/**
+ * Copy of corresponding pt_regs struct in ptrace.h. Must be kept in sync with kernel pt_regs!
+ *
+ * The reason why we make a copy here is, that we want to use multiple pt_regs concurrently (of multiple platforms), but
+ * this is not possible with standard pt_regs, so we create our name-distinguished copy. 
+ * We also have to modify the types of the registers, to use platform neutral types.
+ */
+struct tcmi_x86_64_regs {
+	u_int64_t r15;
+	u_int64_t r14;
+	u_int64_t r13;
+	u_int64_t r12;
+	u_int64_t rbp;
+	u_int64_t rbx;
+/* arguments: non interrupts/non tracing syscalls only save upto here*/
+ 	u_int64_t r11;
+	u_int64_t r10;
+	u_int64_t r9;
+	u_int64_t r8;
+	u_int64_t rax;
+	u_int64_t rcx;
+	u_int64_t rdx;
+	u_int64_t rsi;
+	u_int64_t rdi;
+	u_int64_t orig_rax;
+/* end of arguments */
+/* cpu exception frame or undefined */
+	u_int64_t rip;
+	u_int64_t cs;
+	u_int64_t eflags;
+	u_int64_t rsp;
+	u_int64_t ss;
+/* top of stack page */
+}  __attribute__((__packed__));
+
+#include <arch/common/regs.h>
+
+#if defined(__x86_64__)
+#define stack_pointer(regs) ((regs)->sp)
+#define base_pointer(regs) ((regs)->bp)
+#define original_ax(regs) ((regs)->orig_ax)
+
+extern void* get_target_platform_registers(struct pt_regs* regs, enum arch_ids target_arch);
+extern void load_from_platform_registers(void* platform_registers, struct pt_regs* regs, enum arch_ids from_arch, int is_32bit_app);
+extern int is_in_syscall(struct pt_regs* regs);
+extern void debug_registers(struct pt_regs* regs);
+
+#define start_thread_32(regs,new_rip,new_rsp) do { \
+	asm volatile("movl %0,%%fs" :: "r" (0)); \
+	asm volatile("movl %0,%%es; movl %0,%%ds": :"r" (__USER32_DS)); \
+	load_gs_index(0); \
+	(regs)->ip = (new_rip); \
+	(regs)->sp = (new_rsp); \
+	(regs)->flags = 0x200; \
+	(regs)->cs = __USER32_CS; \
+	(regs)->ss = __USER32_DS; \
+	set_fs(USER_DS); \
+} while(0) 
+
+#define platform_start_thread(regs, new_rip, new_rsp, program_arch, is_32_bit) do { \
+	if ( program_arch == ARCH_CURRENT && !is_32_bit) { \
+		start_thread(regs, new_rip, new_rsp); \
+	} else \
+	if ( program_arch == ARCH_I386 || (program_arch == ARCH_CURRENT && is_32_bit) ) { \
+		start_thread_32(regs, new_rip, new_rsp); \
+	} else { \
+		/* Should not get here */ \
+		BUG_ON(1); \
+	}\
+} while(0)
+
+#define check_is_application_32bit() \
+	({ 							\
+        	test_thread_flag(TIF_IA32); \
+	})
+
+#endif
+
+#endif
--- linux-3.7.1_original/clondike/src/arch/types.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/arch/types.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,88 @@
+#ifndef ARCH_TYPES_H
+#define ARCH_TYPES_H
+
+#define CHECKED_UINT64_TO_ULONG(val) \
+	({ 							\
+		BUG_ON(val > ULONG_MAX); 	\
+		val;						\
+	})
+
+#endif
+
+#define copy_val(s,d,val) (d)->val = (s)->val
+
+/** Some platform independed structures (32vs64 bits).. suffixed by "_ind" */
+
+struct timeval_ind {
+         int64_t          tv_sec;         /* seconds */
+         int64_t     tv_usec;        /* microseconds */
+} __attribute__((__packed__));
+
+
+static inline void timeval_to_ind(struct timeval* s, struct timeval_ind* d) {
+	copy_val(s,d,tv_sec);
+	copy_val(s,d,tv_usec);
+}
+
+static inline void timeval_from_ind(struct timeval_ind* s, struct timeval* d) {
+	copy_val(s,d,tv_sec);
+	copy_val(s,d,tv_usec);
+}
+
+struct rusage_ind {
+        struct timeval_ind ru_utime;        /* user time used */
+        struct timeval_ind ru_stime;        /* system time used */
+        int64_t    ru_maxrss;              /* maximum resident set size */
+        int64_t    ru_ixrss;               /* integral shared memory size */
+        int64_t    ru_idrss;               /* integral unshared data size */
+        int64_t    ru_isrss;               /* integral unshared stack size */
+        int64_t    ru_minflt;              /* page reclaims */
+        int64_t    ru_majflt;              /* page faults */
+        int64_t    ru_nswap;               /* swaps */
+        int64_t    ru_inblock;             /* block input operations */
+        int64_t    ru_oublock;             /* block output operations */
+        int64_t    ru_msgsnd;              /* messages sent */
+        int64_t    ru_msgrcv;              /* messages received */
+        int64_t    ru_nsignals;            /* signals received */
+        int64_t    ru_nvcsw;               /* voluntary context switches */
+        int64_t    ru_nivcsw;              /* involuntary " */
+} __attribute__((__packed__));
+
+static inline void rusage_to_ind(struct rusage* s, struct rusage_ind* d) {
+	timeval_to_ind(&s->ru_utime, &d->ru_utime);
+	timeval_to_ind(&s->ru_stime, &d->ru_stime);
+	copy_val(s,d,ru_maxrss);
+	copy_val(s,d,ru_ixrss);
+	copy_val(s,d,ru_idrss);
+	copy_val(s,d,ru_isrss);
+	copy_val(s,d,ru_minflt);
+	copy_val(s,d,ru_majflt);
+	copy_val(s,d,ru_nswap);
+	copy_val(s,d,ru_inblock);
+	copy_val(s,d,ru_oublock);
+	copy_val(s,d,ru_msgsnd);
+	copy_val(s,d,ru_msgrcv);
+	copy_val(s,d,ru_nsignals);
+	copy_val(s,d,ru_nvcsw);
+	copy_val(s,d,ru_nivcsw);
+}
+
+static inline void rusage_from_ind(struct rusage_ind* s, struct rusage* d) {
+	timeval_from_ind(&s->ru_utime, &d->ru_utime);
+	timeval_from_ind(&s->ru_stime, &d->ru_stime);
+	copy_val(s,d,ru_maxrss);
+	copy_val(s,d,ru_ixrss);
+	copy_val(s,d,ru_idrss);
+	copy_val(s,d,ru_isrss);
+	copy_val(s,d,ru_minflt);
+	copy_val(s,d,ru_majflt);
+	copy_val(s,d,ru_nswap);
+	copy_val(s,d,ru_inblock);
+	copy_val(s,d,ru_oublock);
+	copy_val(s,d,ru_msgsnd);
+	copy_val(s,d,ru_msgrcv);
+	copy_val(s,d,ru_nsignals);
+	copy_val(s,d,ru_nvcsw);
+	copy_val(s,d,ru_nivcsw);
+}
+
--- linux-3.7.1_original/clondike/src/arch/i386/thread.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/arch/i386/thread.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,64 @@
+#ifndef ARG_I386_THREAD_H
+#define ARG_I386_THREAD_H
+
+#include <arch/arch_ids.h>
+#include <asm/processor.h>
+
+#if defined(__i386__)
+/** Simple alias for current thread struct */ 
+#define tcmi_thread tcmi_i386_thread
+#endif
+
+/**
+ * This structure contains all information of original thread_struct that we want to migrate.
+ * Only platform independed data types are used, so that we are able to read/write on both 32 and 64 bit platforms
+ */
+struct tcmi_i386_thread {
+	struct desc_struct tls_array[GDT_ENTRY_TLS_ENTRIES];
+	u_int32_t gs;
+}  __attribute__((__packed__));
+
+#if defined(__i386__)
+#include <arch/x86_64/thread.h>
+static inline void get_tcmi_thread(struct thread_struct* thread, struct tcmi_thread* tcmi_thread) {
+	memcpy(tcmi_thread->tls_array, thread->tls_array, sizeof(tcmi_thread->tls_array));
+	tcmi_thread->gs = thread->gs;
+}
+
+static inline void load_thread(struct tcmi_i386_thread* tcmi_thread, struct thread_struct* thread) {
+	memcpy(thread->tls_array, tcmi_thread->tls_array, sizeof(tcmi_thread->tls_array));	
+	thread->gs = tcmi_thread->gs;
+}
+
+static inline void load_x86_64_thread(struct tcmi_x86_64_thread* tcmi_thread, struct thread_struct* thread) {
+	/* FS and GS TLS are for whatever reason swaped on i386 and x86_64 */
+	memcpy(&thread->tls_array[0], &tcmi_thread->tls_array[1], sizeof(thread->tls_array[0]));
+	memcpy(&thread->tls_array[1], &tcmi_thread->tls_array[0], sizeof(thread->tls_array[1]));
+	memcpy(&thread->tls_array[2], &tcmi_thread->tls_array[2], sizeof(thread->tls_array[2]));
+	
+	thread->gs = 0x33; /* TODO: Hardcoded gs segment.. we can at least use constants in segment.h */ 
+}
+
+static inline void load_from_platform_thread(void* platform_thread, struct thread_struct* thread, enum arch_ids from_arch) {
+	if ( from_arch == ARCH_CURRENT ) { /* Equal architecture */
+		load_thread( (struct tcmi_i386_thread*) platform_thread, thread);
+		return;
+	}
+
+	if ( from_arch == ARCH_X86_64 ) {
+		load_x86_64_thread( (struct tcmi_x86_64_thread*) platform_thread, thread);
+		return;
+	}
+
+	mdbg(ERR3, "Unsupported source platform: %d", from_arch);
+}
+
+/** TODO: Check if we really were in TLS and if not do .. /? */
+#define resolve_TLS(thread, cpu, regs) do { \
+	load_TLS(thread, cpu); \
+	loadsegment(gs, (thread)->gs); \
+} while (0)
+
+#endif
+
+#endif
--- linux-3.7.1_original/clondike/src/arch/i386/make_syscall.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/arch/i386/make_syscall.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,71 @@
+#ifndef _MAKE_SYSCALL_H
+#define _MAKE_SYSCALL_H
+
+#define __syscall_return(type, res) \
+do { \
+	if ((unsigned long)(res) >= (unsigned long)(-(128 + 1))) { \
+		errno = -(res); \
+		res = -1; \
+	} \
+	return (type) (res); \
+} while (0)
+
+/* XXX - _foo needs to be __foo, while __NR_bar could be _NR_bar. */
+#define _syscall0(type,name) \
+type name(void) \
+{ \
+long __res; \
+__asm__ volatile ("int $0x80" \
+	: "=a" (__res) \
+	: "0" (__NR_##name)); \
+__syscall_return(type,__res); \
+}
+
+#define _syscall1(type,name,type1,arg1) \
+type name(type1 arg1) \
+{ \
+long __res; \
+__asm__ volatile ("push %%ebx ; movl %2,%%ebx ; int $0x80 ; pop %%ebx" \
+	: "=a" (__res) \
+	: "0" (__NR_##name),"ri" ((long)(arg1)) : "memory"); \
+__syscall_return(type,__res); \
+}
+
+#define _syscall2(type,name,type1,arg1,type2,arg2) \
+type name(type1 arg1,type2 arg2) \
+{ \
+long __res; \
+__asm__ volatile ("push %%ebx ; movl %2,%%ebx ; int $0x80 ; pop %%ebx" \
+	: "=a" (__res) \
+	: "0" (__NR_##name),"ri" ((long)(arg1)),"c" ((long)(arg2)) \
+	: "memory"); \
+__syscall_return(type,__res); \
+}
+
+#define _syscall3(type,name,type1,arg1,type2,arg2,type3,arg3) \
+type name(type1 arg1,type2 arg2,type3 arg3) \
+{ \
+long __res; \
+__asm__ volatile ("push %%ebx ; movl %2,%%ebx ; int $0x80 ; pop %%ebx" \
+	: "=a" (__res) \
+	: "0" (__NR_##name),"ri" ((long)(arg1)),"c" ((long)(arg2)), \
+		  "d" ((long)(arg3)) : "memory"); \
+__syscall_return(type,__res); \
+}
+
+#include <dbg.h>
+#include <linux/unistd.h>
+/** TODO: Export the original kernel_execve in kernel and use that instead */
+static inline int copyof_kernel_execve(const char *filename, char *const argv[], char *const envp[])
+{
+	long __res;
+	mdbg(INFO2, "Kexec before call");
+	asm volatile ("push %%ebx ; movl %2,%%ebx ; int $0x80 ; pop %%ebx"
+	: "=a" (__res)
+	: "0" (__NR_execve),"ri" (filename),"c" (argv), "d" (envp) : "memory");
+
+	mdbg(INFO2, "Kexec done with res: %ld", __res);
+	return __res;
+}
+
+#endif
--- linux-3.7.1_original/clondike/src/arch/i386/regs.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/arch/i386/regs.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,107 @@
+#include "regs.h"
+
+#if defined(__i386__)
+#include <dbg.h>
+
+void* get_target_platform_registers(struct pt_regs* regs, enum arch_ids target_arch) {
+	if ( target_arch == ARCH_CURRENT ) {
+		struct tcmi_regs* result_regs = kmalloc(sizeof(struct tcmi_regs), GFP_KERNEL);
+		if ( !result_regs )
+			return NULL;
+
+		get_registers(regs, result_regs);
+		return result_regs;
+	}
+
+	if ( target_arch == ARCH_X86_64 ) {
+		struct tcmi_x86_64_regs* result_regs = kmalloc(sizeof(struct tcmi_x86_64_regs), GFP_KERNEL);
+		if ( !result_regs )
+			return NULL;
+
+		result_regs->orig_rax = regs->orig_ax;;
+		result_regs->rax = regs->ax;
+		result_regs->rbx = regs->bx;
+		result_regs->rcx = regs->cx;
+		result_regs->rdx = regs->dx;
+
+		result_regs->rsi = regs->si;
+		result_regs->rdi = regs->di;
+
+		result_regs->ss = regs->ss;
+		result_regs->cs = regs->cs;
+		result_regs->rip = regs->ip;
+		result_regs->eflags = regs->flags;
+		result_regs->rbp = regs->bp;
+		result_regs->rsp = regs->sp;
+
+		result_regs->r8 = 0;
+		result_regs->r9 = 0;
+		result_regs->r10 = 0;
+		result_regs->r11 = 0;
+		result_regs->r12 = 0;
+		result_regs->r13 = 0;
+		result_regs->r14 = 0;
+		result_regs->r15 = 0;
+
+		return result_regs;
+	}
+
+	mdbg(ERR3, "Unsupported target platform: %d", target_arch);
+
+	return NULL;
+};
+
+void load_from_platform_registers(void* platform_registers, struct pt_regs* regs, enum arch_ids from_arch, int is_32bit_app) {
+	if ( from_arch == ARCH_CURRENT ) {
+		/** Simple load of compatible registers */
+		load_registers( (struct tcmi_regs*)platform_registers, regs);
+		return;
+	}
+
+	if ( from_arch == ARCH_X86_64) {
+		struct tcmi_x86_64_regs* tcmi_regs = (struct tcmi_x86_64_regs*)platform_registers;
+		regs->orig_ax = tcmi_regs->orig_rax;;
+		regs->ax = tcmi_regs->rax;
+		regs->bx = tcmi_regs->rbx;
+		regs->cx = tcmi_regs->rcx;
+		regs->dx = tcmi_regs->rdx;
+
+		regs->si = tcmi_regs->rsi;
+		regs->di = tcmi_regs->rdi;
+
+		regs->ss = tcmi_regs->ss;
+		regs->cs = tcmi_regs->cs;
+		regs->ip = tcmi_regs->rip;
+		regs->flags = tcmi_regs->eflags;
+		regs->bp = tcmi_regs->rbp;
+		regs->sp = tcmi_regs->rsp;
+
+		/* TODO: How to restore fs and es? It is not stored on 64 stack.. */
+		regs->fs = 0;
+		regs->es = 0;
+
+		return;
+	}
+
+
+	mdbg(ERR3, "Unsupported source platform: %d", from_arch);
+};
+
+int is_in_syscall(struct pt_regs* regs) {
+	return ((regs->orig_ax >= 0) &&
+			   (regs->ax == -ERESTARTNOHAND ||
+			    regs->ax == -ERESTARTSYS ||
+			    regs->ax == -ERESTART_RESTARTBLOCK ||
+			    regs->ax == -ERESTARTNOINTR));
+};
+
+void debug_registers(struct pt_regs* regs) {
+	mdbg(INFO4, "ESP  : %08lx    EBP : %08lx",regs->sp,regs->bp);
+	mdbg(INFO4, "ESI  : %08lx    EDI : %08lx",regs->si,regs->di);
+	mdbg(INFO4, "CS   : %08lx    DS  : %08lx", regs->cs,regs->ds);
+	mdbg(INFO4, "EIP  : %08lx    OEAX: %08lX",regs->ip,regs->orig_ax);
+	mdbg(INFO4, "EAX  : %08lx    EBX : %08lX",regs->ax,regs->bx);
+	mdbg(INFO4, "ECX  : %08lx    EDX : %08lX",regs->cx,regs->dx);
+};
+
+#endif
--- linux-3.7.1_original/clondike/src/arch/i386/vma.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/arch/i386/vma.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,10 @@
+#ifndef ARG_I386_VMA_H
+#define ARG_I386_VMA_H
+
+/** Returns 1, if the vma should be ignored by checkpointing componenet */
+#define vma_ignore(ckpt, vma) ({ \
+	/* i386 has all VMAs relevant */ \
+	0; \
+})
+
+#endif
\ No newline at end of file
--- linux-3.7.1_original/clondike/src/arch/i386/restart_fixup.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/arch/i386/restart_fixup.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,110 @@
+#ifndef ARG_I386_RESTART_FIXUP_H
+#define ARG_I386_RESTART_FIXUP_H
+
+// TODO: Use vsdo attribute of mm_context to check for correct location of vsdo
+// TODO: Disable making of checkpoints, when we are in some part of vsdo other than syscall itself (otherwise we have to fixup stack & args for every possible EIP)
+
+/** 
+ * This method is used for handling migration restart. There are 2 cases:
+ * 
+ * Application was in syscall:
+ *  We cannot directly restart the syscall, because as a part of process restart we do execve. The execve,
+ * if it succeeds, will set EAX to 0. This means, the restarted syscall will not be the original syscall, but sys_restartsyscall.
+ * Restart syscall is handled by the custom registered method in our case this method.
+ *
+ * Application was not in syscall:
+ *  We cannot simply restart the application, because again the execve will override EAX content! Here we use a special trick.
+ * We can assume EAX will contain 0 as in previous case (=execve succeeded, otherwise the program would not start anyway).
+ * With EAX == 0 we can set fake EIP just before the vsyscall sysenter (assuming it is mapped in the process on expected address)
+ * This way we will get sysretart called immediately and from the special restart function we return proper eax (and eip) in order to make 
+ * the application working as expected, with all registers set correctly.
+ */
+static long tcmi_restart_fixup(struct restart_block *restart) {
+	struct pt_regs *regs = task_pt_regs(current);
+
+	mdbg(INFO3, "Calling tcmi sys restart. Thread Flags: %08lX EAX: %08lX (OEAX: %08lX Return EAX: %08lX) SP: %16lX BP: %16lX (Restore BP: %16lX) IP: %08lX (Restore IP: %08lX)", current_thread_info()->flags, regs_return_value(regs), original_ax(regs), restart->arg0, stack_pointer(regs), base_pointer(regs), restart->arg2, regs->ip, restart->arg1);
+	/*mdbg(INFO3, "Calling tcmi sys restart. EAX: %08lX (OEAX: %08lX Return EAX: %08lX). EBX: %08lX ECX: %08lX EDX: %08lX", regs->eax, regs->orig_eax, restart->arg0, regs->ebx, regs->ecx, regs->edx);*/
+
+	/* TODO: Reset restart_block? */
+
+	/* Reset EIP to original value (either again just before the syscall, or on the other completely unrelated address */
+	regs->ip = restart->arg1;			
+	
+	/* Restore ebp, in case we were in syscall it won't have any effect, otherwise it will set proper EBP for the application */
+	base_pointer(regs) = restart->arg2;
+
+	/* To prevent ECX & EDX clobbering via sysexit */
+	set_thread_flag(TIF_IRET);
+	/* 
+           This is a trick how to get original EAX onto the stack.. return value of this syscall is what gets onto the stack 
+	   When the syscall gets executed again (as we again set EIP) it will finally use correct EAX. The other registers are unclobbered and so we do not need to restore them
+	   If we were not originally in syscall, we will simply continue with correct EAX where we finished.
+         */
+	return restart->arg0;
+}
+
+/** 
+ * If we were in 64 bit syscall, we have to fixup some regs to work correctly after resume to user space.
+ */
+static inline void fixup_64bit_stack(struct restart_block* restart, struct pt_regs* regs)  {
+	unsigned long stackEbp;
+	mdbg(INFO4, "64bit stack");
+	/* Avoid all poping after syscall as we have a different stack */
+	restart->arg1 = 0xffffe413;			
+	/* Extract ebp stored on top of the stack */
+	stackEbp = *((unsigned long*)(regs->sp));
+	/* Fixup both pointers to ebp */
+	regs->bp = stackEbp;
+	restart->arg2 = stackEbp;
+	/* Fixup stack length (unpopped ebp; ecx & edx were not pushed on stack by 64 bit) */
+	regs->sp += 4;
+}
+
+/**
+ * Registeres restart block and schedules restart syscall to be executed after the process resumes userspace for first time. The main motivaction for this is to 
+ * restore original AX register.
+ *
+ * @param task Current task
+ * @param regs Current registers of the task
+ * @param is_32bit_application 1, if application is 32 bit
+ * @return 0 on success
+ */
+static int tcmi_resolve_restart_block(struct task_struct* task, struct pt_regs* regs, enum arch_ids from_arch, int is_32bit_application) {
+	struct restart_block* restart = &(task_thread_info(task)->restart_block);
+	mdbg(INFO3, "Setting tcmi sys restart block. EAX: %08lX (OEAX: %08lX). EBX: %08lX ECX: %08lX EDX: %08lX", regs->ax, regs->orig_ax, regs->bx, regs->cx, regs->dx);	
+	/* EAX and EIP are required to be stored, the other registers won't get affected as they are already on stack (eax will be overriden by execve return value and EIP will be altered as the userspace process will execute restart syscall) */
+	restart->arg0 = original_ax(regs);
+	restart->arg1 = instruction_pointer(regs);	
+
+	/* 
+           EBP needs to be restored in case we were not in syscall, because in that case we execute fake syscall to get EAX on place and this fake vsyscall will clobber EBP. If we were originally in syscall,
+	   this won't matter, because the real EBP was pushed before call and will be poped after, but in case we were not in syscall, we do not have this comfort
+	   In order to make restart code easier, we simply store and restore EBP in both cases.
+	*/
+	restart->arg2 = base_pointer(regs);
+	
+	if ( !is_in_syscall(regs) ) {
+		mdbg(INFO3, "Performing restart out of syscall.");		
+		/* Set current EIP address just before the sysenter so that the restart block is executed */
+		regs->ip = 0xffffe403;
+		/* In addition if we are not in syscall we do not want to use orig_eax, but rather real eax */
+		restart->arg0 = regs_return_value(regs);
+
+		if ( from_arch == ARCH_X86_64 && restart->arg1 == 0xffffe405 ) {
+			/* We were in a 64 bit syscall, but it was not interrupted */
+			fixup_64bit_stack(restart, regs);
+		}
+	} else {		
+		regs->ip -= 2;
+		mdbg(INFO3, "Performing restart in syscall");		
+		if ( from_arch == ARCH_X86_64 && restart->arg1 == 0xffffe405) { // We were in 64 bit syscall of AMD => we need fixup
+			fixup_64bit_stack(restart, regs);
+		}
+	}
+
+	restart->fn = tcmi_restart_fixup;
+
+	return 0;
+}
+
+#endif
--- linux-3.7.1_original/clondike/src/arch/i386/regs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/arch/i386/regs.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,64 @@
+#ifndef ARG_I386_REGS_H
+#define ARG_I386_REGS_H
+
+#include <arch/arch_ids.h>
+#include <linux/types.h>
+#include <linux/ptrace.h>
+
+#if defined(__i386__)
+/** Simple alias for current register struct */ 
+#define tcmi_regs tcmi_i386_regs
+#endif
+
+/**
+ * Copy of corresponding pt_regs struct in ptrace.h. Must be kept in sync with kernel pt_regs!
+ *
+ * The reason why we make a copy here is, that we want to use multiple pt_regs concurrently (of multiple platforms), but
+ * this is not possible with standard pt_regs, so we create our name-distinguished copy. 
+* We also have to modify the types of the registers, to use platform neutral types.
+ */
+struct tcmi_i386_regs {
+	u_int32_t ebx;
+	u_int32_t ecx;
+	u_int32_t edx;
+	u_int32_t esi;
+	u_int32_t edi;
+	u_int32_t ebp;
+	u_int32_t eax;
+	u_int32_t  xds;
+	u_int32_t  xes;
+	u_int32_t  xfs;
+	int32_t  xgs; 
+	int32_t orig_eax; /* This is the only signed register as this register is never again seen by the user space and in kernel space we want to keep signess */
+	u_int32_t eip;
+	u_int32_t  xcs;
+	u_int32_t eflags;
+	u_int32_t esp;
+	u_int32_t  xss;
+}  __attribute__((__packed__));
+
+#include <arch/common/regs.h>
+#include <arch/x86_64/regs.h>
+
+#if defined(__i386__)
+#define stack_pointer(regs) ((regs)->sp)
+#define base_pointer(regs) ((regs)->bp)
+#define original_ax(regs) ((regs)->orig_ax)
+
+extern void* get_target_platform_registers(struct pt_regs* regs, enum arch_ids target_arch);
+extern void load_from_platform_registers(void* platform_registers, struct pt_regs* regs, enum arch_ids from_arch, int is_32bit_app);
+extern int is_in_syscall(struct pt_regs* regs);
+extern void debug_registers(struct pt_regs* regs);
+
+#define platform_start_thread(regs, new_rip, new_rsp, program_arch, is_32_bit) do { \
+	start_thread(regs, new_rip, new_rsp); \
+} while(0)
+
+#define check_is_application_32bit() \
+	({ 							\
+		1;						\
+	})
+
+#endif
+
+#endif
--- linux-3.7.1_original/clondike/src/arch/common/regs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/arch/common/regs.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,73 @@
+#ifndef REGS_COMMON_H
+#define REGS_COMMON_H
+
+#include <arch/arch_ids.h>
+#include <dbg.h>
+
+/**
+ * Loads value of pt_regs into the current architecture type specific regs. 
+ * It can be done directly by copying as both structures are same.
+ *
+ * @param regs Current registers
+ * @param tcmi_regs Target registers 
+ */
+static inline void get_registers(struct pt_regs* regs, struct tcmi_regs* tcmi_regs) {
+	mdbg(INFO4, "Regs size: %lu TCMI regs size: %lu:", (unsigned long)sizeof(struct pt_regs), (unsigned long)sizeof(struct tcmi_regs));
+	BUG_ON(sizeof(struct pt_regs) != sizeof(struct tcmi_regs));
+
+	memcpy(tcmi_regs, regs, sizeof(struct tcmi_regs));
+};
+
+/**
+ * Loads value of tcmi_regs into the regs. Used for restoring register context.
+ * It can be done directly by copying as both structures are same.
+ *
+ * @param tcmi_regs Source registers
+ * @param regs Target registers
+ */
+static inline void load_registers( struct tcmi_regs* tcmi_regs, struct pt_regs* regs) {
+	BUG_ON(sizeof(struct pt_regs) != sizeof(struct tcmi_regs));
+
+	memcpy(regs, tcmi_regs, sizeof(struct tcmi_regs));
+};
+
+/**
+ * Generic method that converts current registers to target platform registers and returns pointer to those registers.
+ * The whole flow of checkpoint/restart is as follow. 
+ *  - First application that is being checkpointed determines if it is able to migrate to the target_arch
+ *  - If so, it creates target arch registers
+ *  - Application that is being restarted simply loads registers of its own native type.
+ * 
+ * @param regs Current registers
+ * @param target_arch target architecture for which we want to have the registers
+ * @return Pointer to target architecture specific registers. Caller is responsible for freeing these registers!
+ */
+extern void* get_target_platform_registers(struct pt_regs* regs, enum arch_ids target_arch);
+
+/**
+ * Loads registers from checkpointed registers
+ *
+ * @param platform_registers tcmi_regs structure of the "from_arch"
+ * @param regs Registers to be filled
+ * @param from_arch Architecture used for creating provided tcmi_regs
+ * @param is_32bit_app 1 if the application being restored is 32 bit
+ */
+extern void load_from_platform_registers(void* platform_registers, struct pt_regs* regs, enum arch_ids from_arch, int is_32bit_app);
+
+/**
+ * Dumps debug information about current platform registers
+ *
+ * @param regs Current platform registers to be dumped
+ */
+extern void debug_registers(struct pt_regs* regs);
+
+
+/** Checks whether a process with specified registers has been in
+ * system call. A process in system call has:
+ * - orig_eax >=0 which denotes the original system call number
+ * - eax has one of the error values that describes why the
+ * process has terminated the system call prematurely.
+ */
+extern int is_in_syscall(struct pt_regs* regs);
+
+#endif
--- linux-3.7.1_original/clondike/src/arch/arch_ids.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/arch/arch_ids.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,3 @@
+#include "arch_ids.h"
+
+char* arch_names[] = { "i386", "x86_64" };
--- linux-3.7.1_original/clondike/src/proxyfs/proxyfs_server.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/proxyfs/proxyfs_server.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,150 @@
+/**
+ * @file proxyfs_server.h - Proxyfs server task.
+ *                      
+ * 
+ *
+ *
+ * Date: 08/12/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: proxyfs_server.h,v 1.6 2007/10/20 14:24:20 stavam2 Exp $
+ *
+ * This file is part of Proxy filesystem (ProxyFS)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * ProxyFS is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * ProxyFS is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _PROXYFS_SERVER_H_PUBLIC
+#define _PROXYFS_SERVER_H_PUBLIC
+
+/** @defgroup proxyfs_server_class proxyfs_server class 
+ * 
+ * @ingroup proxyfs_task_class
+ *
+ * \<\<singleton\>\> representing proxyfs_server task
+ * 
+ * @{
+ *
+ */
+
+#include <proxyfs/proxyfs_task.h>
+
+/** \<\<public\>\> "Steal" file to server */
+struct proxyfs_file_identifier* proxyfs_server_overtake_file(int fd);
+
+/** \<\<public\>\> \<\<exported\>\> Release all files */
+void proxyfs_server_release_all(void);
+
+/** 
+ * \<\<public\>\> \<\<exported\>\> Duplicates all file that were overtaken by a "parent" process and makes child as a owner of duplicates.
+ */
+void proxyfs_server_duplicate_all_parent(struct task_struct* parent, struct task_struct* child);
+
+/** \<\<public\>\> Main server thread */
+int proxyfs_server_thread(void *start_struct);
+
+
+#endif // _PROXYFS_SERVER_H_PUBLIC
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef PROXYFS_SERVER_PRIVATE
+#ifndef _PROXYFS_SERVER_H_PRIVATE
+#define _PROXYFS_SERVER_H_PRIVATE
+
+#include <linux/semaphore.h>
+#include <proxyfs/proxyfs_msg.h>
+#include <proxyfs/proxyfs_peer.h>
+#include <linux/poll.h>
+
+#define PROXYFS_REAL_FILE_PROTECTED   // Friend
+#include <proxyfs/proxyfs_real_file.h>
+
+#define PROXYFS_TASK_PROTECTED        // Parent
+#include <proxyfs/proxyfs_task.h>
+
+#define PROXYFS_SERVER_TASK(arg) ((struct proxyfs_server*)(arg))
+
+//#include <linux/sched.h>
+//#include <linux/list.h>
+
+
+/** \<\<private\>\> Structure representing server */
+struct proxyfs_server {
+	/** Parent structure */
+	struct proxyfs_task parent;
+	/** This semaphore prevents race conditions between server task and task adding 
+	 * file under server control */
+	struct semaphore files_sem;
+	/** Server is listening on this socket */
+	struct kkc_sock *server_sock;
+	/** For waiting on server socket */
+	wait_queue_t server_sock_wait;
+};
+
+/** \<\<private\>\> Structure used to queueing on file wait queue */
+struct hacked_poll_table {
+	/** Parent kernel struct */
+	struct poll_table_struct parent;
+	/** Our data - corresponding real file instance */
+	struct proxyfs_real_file *real_file;
+};
+
+/** \<\<private\>\> Writes data from buffer to file */
+void proxyfs_server_write_file_buf(struct proxyfs_real_file *file_row);
+
+/** \<\<private\>\> Start listening */
+int proxyfs_server_listen(const char *listen_str);
+
+/** \<\<private\>\> */
+int proxyfs_server_add_to_peers(struct kkc_sock *peer_sock);
+
+/** \<\<private\>\> Accept incoming connection (nonblocking) */
+int proxyfs_server_accept(void);
+
+/** \<\<private\>\> Main server loop */
+void proxyfs_server_loop(void);
+
+/** \<\<private\>\> Handle received message */
+static void proxyfs_server_handle_msg(struct proxyfs_task *self, struct proxyfs_peer_t *peer);
+
+/** \<\<private\>\> Try to write all write bufers to files (nonblocking) */
+void proxyfs_server_write_buffers(void);
+
+/** \<\<private\>\> Read and write from files */
+void proxyfs_server_read_and_write_real_files(void);
+
+static void proxyfs_server_free(struct proxyfs_task* self);
+
+/** \<\<private\>\> Method used for waiting on files, callback for poll structure */
+void proxyfs_server_poll_queue_proc(struct file *file, wait_queue_head_t *wait_head, struct poll_table_struct *wait_table);
+
+/** <\<\private\>\> Structure with pointers to virtual methods */
+static struct proxyfs_task_ops server_ops = {
+	/** Handle received message */
+	.handle_msg = proxyfs_server_handle_msg,
+	.handle_peer_dead = NULL,
+	/** Free task resources */
+	.free = proxyfs_server_free,
+};
+
+#endif //  _PROXYFS_SERVER_H_PRIVATE
+#endif // PROXYFS_SERVER_PRIVATE
+
+/**
+ * @}
+ */
+
+
--- linux-3.7.1_original/clondike/src/proxyfs/proxyfs_ioctl.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/proxyfs/proxyfs_ioctl.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,43 @@
+#ifndef _PROXYFS_IOCTL_H
+#define _PROXYFS_IOCTL_H
+
+
+#define IOCTL_READ   0x40000000
+#define IOCTL_WRITE  0x80000000
+#define IOCTL_RW     ( IOCTL_READ | IOCTL_WRITE )
+
+#define IOCTL_WILL_WRITE(arg)	( (arg) & IOCTL_WRITE )
+#define IOCTL_WILL_READ(arg)	( (arg) & IOCTL_READ )
+#define IOCTL_ARG_SIZE(arg)	( (arg) & 0x0FFFffff )
+
+extern const unsigned long const ioctl_table[];
+extern const unsigned long ioctl_table_nmemb;
+
+static inline unsigned long ioctl_get_info(int cmd){
+	int low = 0;
+	int high = ioctl_table_nmemb - 1;
+	int mid;
+
+	for(mid = high/2; low != high; mid = low + ((high - low) / 2)){
+		if( cmd < ioctl_table[mid*2] )
+			high = mid;
+		else if( cmd > ioctl_table[mid*2] )
+			low = mid + 1;
+		else
+			return ioctl_table[mid*2+1];
+	}
+	if( cmd == ioctl_table[low*2] )
+		return ioctl_table[low*2+1];
+	else
+		return 0;
+}
+
+#ifdef PROXYFS_IOCTL_PRIVATE
+#define IOCTL_INT    0x30000004
+#define IOCTL_VOID   0x30000000
+#define IOCTL_CHAR   0x30000003
+
+
+#endif /* PROXYFS_IOCTL_PRIVATE */
+
+#endif
--- linux-3.7.1_original/clondike/src/proxyfs/proxyfs_msg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/proxyfs/proxyfs_msg.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,156 @@
+/**
+ * @file proxyfs_msg.h - Proxyfs messages.
+ *                      
+ * 
+ *
+ *
+ * Date: 08/12/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: proxyfs_msg.h,v 1.7 2008/01/17 14:36:44 stavam2 Exp $
+ *
+ * This file is part of Proxy filesystem (ProxyFS)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * ProxyFS is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * ProxyFS is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _PROXYFS_MSG_H
+#define _PROXYFS_MSG_H
+#include <dbg.h>
+#include <kkc/kkc.h>
+/** @defgroup proxyfs_msg_class proxyfs_msg class
+ *
+ * @ingroup proxyfs_module_class
+ *
+ * This class represents connection between two peers
+ * allows sending and receiving messages
+ * 
+ * @{
+ */
+
+/** Proxyfs message header structure 
+ * We allways start sending with sending this structure 
+ **/
+struct proxyfs_msg_header {
+	/** Magic for error detection */
+	unsigned long magic;
+	/** Message type */
+	unsigned long msg_num;
+	/** Identifiktion of file which is the message afecting */
+	unsigned long file_ident;
+	/** Size of data which are send after header */
+	unsigned long data_size;
+	/** Open structure... */
+	u_int32_t data[];
+};
+
+/** Proxyfs message structure */
+struct proxyfs_msg {
+	/** Message header */
+	struct proxyfs_msg_header header;
+	/** Pointer to data which are send after header */
+	void *data;
+	/** Struct for queueing messagges */
+	struct list_head msg_queue;
+	/** How far we are in sending progress */
+	size_t send_start;
+	/** Call kfree on data after sending message */
+	int free;
+};
+
+
+/** \<\<public\>\> Size od message header */ 
+#define MSG_HDR_SIZE (sizeof(struct proxyfs_msg_header))
+/** \<\<public\>\> Magic number, each message starts with it */
+#define MSG_MAGIC 0x1ee7babe
+/** \<\<public\>\> Max. messagge size */
+#define MSG_MAX_SIZE (4 << 10)
+
+/** \<\<public\>\> msg_num for message which is send when opening file */
+#define MSG_OPEN 	1
+/** \<\<public\>\> msg_num for write message */
+#define MSG_WRITE 	3
+/** \<\<public\>\> msg_num for ioctl message */
+#define MSG_IOCTL	4
+/** \<\<public\>\> msg_num for message which is send when closing file */
+#define MSG_CLOSE	5
+/** \<\<public\>\> msg_num for message which is send when syncing file */
+#define MSG_FSYNC	6
+/** \<\<public\>\> Read request is used to notify server that the client is interested in reading from 
+ * a file. It is a workaround for not nice behaving programs like make, which open pipe, fork child and
+ * use correctly pipe as unidiractional, but they do not close the other end. We may then send the data to
+ * a reading end, which is not interested in this data, and the process that really wants the data from pipe
+ * won't ever get them..
+ */
+#define MSG_READ_REQUEST 7
+
+/** \<\<public\>\> msg_num for message which can be send as reply for #MSG_OPEN */
+#define MSG_OPEN_RESP_OK	101
+/** \<\<public\>\> msg_num for message which can be send as reply for #MSG_OPEN */
+#define MSG_OPEN_RESP_FAILED	102
+/** \<\<public\>\> msg_num for message which can be send as reply for #MSG_WRITE */
+#define MSG_WRITE_RESP		301
+/** \<\<public\>\> msg_num for message which can be send as reply for #MSG_IOCTL */
+#define MSG_IOCTL_RESP		401
+/** \<\<public\>\> msg_num for message which can be send as reply for #MSG_CLOSE */
+#define MSG_CLOSE_RESP		501
+/** \<\<public\>\> msg_num for message which can be send as reply for #MSG_FSYNC */
+#define MSG_FSYNC_RESP		601
+/** \<\<public\>\> msg_num for message which can be send as reply for #MSG_READ_REQUEST */
+#define MSG_READ_REQUEST_RESP	701
+
+/** write_resp msg constants */
+#define WRITE_RESP_BUFFER_FULL 1
+#define WRITE_RESP_BUFFER_NOT_FULL 2
+
+/** \<\<public\>\> Returns size of message (header + data)
+ * @param self - pointer to proxyfs_msg 
+ * @return message size
+ */
+static inline int proxyfs_msg_get_size(struct proxyfs_msg *self)
+{
+	if( self->header.magic != MSG_MAGIC ){
+		mdbg(ERR3, "Bad magic");
+		return 0;
+	}
+	else
+		return self->header.data_size + MSG_HDR_SIZE;
+}
+
+/** \<\<public\>\> Proxyfs message constructor */
+struct proxyfs_msg *proxyfs_msg_new(unsigned long msg_num, 
+		unsigned long file_ident, unsigned long data_size, void *data_ptr);
+
+/** \<\<public\>\> Proxyfs message constructor. In this version the message takes ownership of the data */
+struct proxyfs_msg *proxyfs_msg_new_takeover_ownership(unsigned long msg_num, 
+		unsigned long file_ident, unsigned long data_size, void *data_ptr);
+
+
+/** \<\<public\>\> Proxyfs message constructor */
+struct proxyfs_msg *proxyfs_msg_compose_new(unsigned long msg_num, 
+		unsigned long file_ident, ... );
+
+/** \<\<public\>\> Releases a message instance */
+void proxyfs_msg_destroy(struct proxyfs_msg* self);
+
+/** \<\<public\>\> Send message to socket */
+int proxyfs_msg_real_send(struct proxyfs_msg *self, struct kkc_sock *sock);
+
+/**
+ * @}
+ */
+
+#endif // _PROXYFS_MSG_H
--- linux-3.7.1_original/clondike/src/proxyfs/proxyfs_module.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/proxyfs/proxyfs_module.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,42 @@
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/module.h>
+
+#include <dbg.h>
+#include <proxyfs/proxyfs_fs.h>
+#include <proxyfs/proxyfs_server.h>
+
+/** Reference to proxy server task */
+static struct proxyfs_task* proxy_server_task;
+
+static char *server = "no_server";
+module_param(server, charp, S_IRUGO);
+
+
+static int proxyfs_module_init(void) {
+	mdbg(INFO3, "ProxyFS loading");
+
+	if( strncmp(server, "no_server", 20) != 0 ){
+		mdbg(INFO3, "Request to start server on %s", server);
+		if ( (proxy_server_task = proxyfs_task_run( proxyfs_server_thread, server )) == NULL ){
+			mdbg(ERR1, "Failed to start server on %s", server);
+			return -EINVAL;
+		}
+	}
+
+	return proxyfs_fs_init();
+}
+
+static void proxyfs_module_exit(void) {
+	mdbg(INFO3, "ProxyFS unloading");
+
+	proxyfs_task_put(proxy_server_task);
+	proxyfs_fs_exit();
+	mdbg(INFO3, "ProxyFS unloaded");
+}
+
+module_init(proxyfs_module_init);
+module_exit(proxyfs_module_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Petr Malat");
--- linux-3.7.1_original/clondike/src/proxyfs/proxyfs_tty_real_file.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/proxyfs/proxyfs_tty_real_file.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,119 @@
+/**
+ * @file proxyfs_tty_real_file.h - File class sepcialized on tty access 
+ * (used by proxyfs_server_task)
+ *                      
+ * 
+ *
+ *
+ * Date: 08/02/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: proxyfs_tty_real_file.h,v 1.3 2007/10/20 14:24:20 stavam2 Exp $
+ *
+ * This file is part of Proxy filesystem (ProxyFS)
+ * Copyleft (C) 2007 Petr Malat
+ * 
+ * ProxyFS is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * ProxyFS is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+/********************** PUBLIC METHODS AND DATA *********************************/
+#ifndef _PROXYFS_TTY_REAL_FILE_H_PUBLIC
+#define _PROXYFS_TTY_REAL_FILE_H_PUBLIC
+
+#include "proxyfs_real_file.h"
+
+/**
+ * @defgroup proxyfs_tty_real_file_class proxyfs_tty_real_file class
+ * @ingroup proxyfs_real_file_class
+ *
+ * This class is used by server task for accessing to TTYs
+ *
+ * @{
+ */
+
+/** tty_real_file declaration */
+struct proxyfs_tty_real_file;
+
+/** \<\<public\>\> Initialize tty_real_file */
+int proxyfs_tty_real_file_init(struct proxyfs_tty_real_file *self);
+
+/** \<\<public\>\> Deinitialize tty_real_file */
+void proxyfs_tty_real_file_destroy(struct proxyfs_tty_real_file *self);
+
+/** \<\<public\>\> tty_real_file construktor */
+struct proxyfs_tty_real_file *proxyfs_tty_real_file_new(void);
+
+/** \<\<public\>\> Casts to struct proxyfs_real_file_t * */
+#define PROXYFS_TTY_REAL_FILE(arg) ((struct proxyfs_tty_real_file*)(arg))
+
+#endif // _PROXYFS_TTY_REAL_FILE_H_PUBLIC
+
+/********************** PROTECTED METHODS AND DATA ******************************/
+#ifdef  PROXYFS_TTY_REAL_FILE_PROTECTED
+#ifndef _PROXYFS_TTY_REAL_FILE_H_PROTECTED
+#define _PROXYFS_TTY_REAL_FILE_H_PROTECTED
+
+#define PROXYFS_REAL_FILE_PROTECTED // Parent
+#include "proxyfs_real_file.h"
+
+/** tty_real_file definition */
+struct proxyfs_tty_real_file {
+	/** Parent class */
+	struct proxyfs_real_file parent;
+};
+
+#endif // _PROXYFS_TTY_REAL_FILE_H_PROTECTED
+#endif //  PROXYFS_TTY_REAL_FILE_PROTECTED
+
+/********************** PRIVATE METHODS AND DATA *********************************/
+#ifdef  PROXYFS_TTY_REAL_FILE_PRIVATE
+#ifndef _PROXYFS_TTY_REAL_FILE_H_PRIVATE
+#define _PROXYFS_TTY_REAL_FILE_H_PRIVATE
+
+/** \<\<private\>\> Read from tty */
+static ssize_t proxyfs_tty_real_file_tty_read(struct file * file, char *buf, size_t count, loff_t *ppos);
+
+/** \<\<private\>\> Write to file from read buffer */
+static int proxyfs_tty_real_file_write(struct proxyfs_real_file *self);
+
+/** \<\<private\>\> Reads from file and write to writte buffer */
+static int proxyfs_tty_real_file_read(struct proxyfs_real_file *self);
+
+/** \<\<private\>\> "Open" file and send response message */
+static int proxyfs_tty_real_file_open(struct proxyfs_real_file *self, struct proxyfs_peer_t *peer);
+
+/** \<\<public\>\> Duplicates a proxyfs real file */
+static struct proxyfs_real_file* proxyfs_tty_real_file_duplicate(struct proxyfs_real_file *self);
+
+
+/** <\<\private\>\> Structure with pointers to virtual methods */
+static struct proxyfs_real_file_ops tty_real_file_ops = {
+	/** Reads from file and write to writte buffer */
+	.read = &proxyfs_tty_real_file_read,
+	/** Write to file from read buffer */
+	.write = &proxyfs_tty_real_file_write,
+	/** "Open" file and send response message */
+	.open = &proxyfs_tty_real_file_open,
+	.duplicate = &proxyfs_tty_real_file_duplicate,
+};
+
+#endif // _PROXYFS_TTY_REAL_FILE_H_PRIVATE
+#endif //  PROXYFS_TTY_REAL_FILE_PRIVATE
+
+/**
+ * @}
+ */
--- linux-3.7.1_original/clondike/src/proxyfs/proxyfs_file.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/proxyfs/proxyfs_file.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,211 @@
+/**
+ * @file proxyfs_file.c - Main file class (used by proxyfs_task)
+ *                      
+ * 
+ *
+ *
+ * Date: 08/02/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: proxyfs_file.c,v 1.6 2008/05/02 19:59:20 stavam2 Exp $
+ *
+ * This file is part of Proxy filesystem (ProxyFS)
+ * Copyleft (C) 2007 Petr Malat
+ * 
+ * ProxyFS is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * ProxyFS is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include <dbg.h>
+
+#define PROXYFS_FILE_PRIVATE
+#define PROXYFS_FILE_PROTECTED // Own header
+#include "proxyfs_file.h"
+#include "proxyfs_peer.h"
+
+#include "buffer.h"
+#include "virtual.h"
+
+/** \<\<public\>\> Get file status 
+ * @param self - pointer to this file instance
+ * @param status - status we asking for
+ *
+ * @return true if status is set for file
+ * */
+unsigned proxyfs_file_get_status(struct proxyfs_file_t* self, unsigned status)
+{
+	unsigned rtn = 0;
+	if( status & PROXYFS_FILE_RO_STATUS ){
+		if( status & PROXYFS_FILE_CAN_WRITE ){
+			if( circ_buf_get_write_size( & self->write_buf ) )
+				rtn |= PROXYFS_FILE_CAN_WRITE;
+		}
+		if( status & PROXYFS_FILE_CAN_READ ){
+			if( circ_buf_count( & self->read_buf ) )
+				rtn |= PROXYFS_FILE_CAN_READ;
+		}
+		if( status & PROXYFS_FILE_ALL_WRITTEN ){
+			mdbg(INFO3, "file_get_status[%lu] all_written.. %d",proxyfs_file_get_file_ident(PROXYFS_FILE(self)),circ_buf_get_read_size(&self->write_buf));
+			if( circ_buf_get_read_size( & self->write_buf ) == 0 )
+				rtn |= PROXYFS_FILE_ALL_WRITTEN;
+		}
+		if( status & PROXYFS_FILE_ALL_READ ){
+			mdbg(INFO3, "file_get_status[%lu] all_read.. %d",proxyfs_file_get_file_ident(PROXYFS_FILE(self)),circ_buf_get_read_size( & self->read_buf ));
+			if( circ_buf_get_read_size( & self->read_buf ) == 0 )
+				rtn |= PROXYFS_FILE_ALL_READ;
+		}
+	}
+	if( status & PROXYFS_FILE_RW_STATUS ){
+		rtn |= self->state & (status & PROXYFS_FILE_RW_STATUS);
+	}
+	return rtn;
+}
+
+/** \<\<public\>\> Get file identifier */
+unsigned long proxyfs_file_get_file_ident(struct proxyfs_file_t* self) {
+	unsigned long res = ((uint32_t)self->file_identifier.file_owner_pid << 16) + self->file_identifier.file_ident;
+	return res;
+}
+
+/** \<\<public\>\> Set file identifier 
+ * @param self - File instance pointer
+ * @param encuded_identifier - File identifier encoded via get_file_ident method
+ */
+void proxyfs_file_set_file_ident(struct proxyfs_file_t* self, unsigned long encoded_identifier) {
+	self->file_identifier.file_ident = 0xffff & encoded_identifier;
+	self->file_identifier.file_owner_pid = (encoded_identifier - self->file_identifier.file_ident) >> 16;
+	mdbg(INFO3, "Set identifier: %d Pid: %d (encoded: %lu)", (int)self->file_identifier.file_ident, (int)self->file_identifier.file_owner_pid, encoded_identifier);
+}
+
+
+/** \<\<public\>\> Set file status 
+ * @param self - pointer to this file instance
+ * @param status - staus we asking for
+ *
+ * */
+void proxyfs_file_set_status(struct proxyfs_file_t* self, unsigned status)
+{
+	self->state |= status;
+}
+
+/** \<\<public\>\> Set file status 
+ * @param self - pointer to this file instance
+ * @param status - staus we asking for
+ *
+ * */
+void proxyfs_file_unset_status(struct proxyfs_file_t* self, unsigned status)
+{
+	self->state &= ~status;
+}
+
+/** \<\<public\>\> Set file status 
+ * @param ident - Unique file identification number
+ * @param start - List in which we are searching
+ *
+ * @return pointer to proxyfs_file or NULL
+ * */
+struct proxyfs_file_t* proxyfs_file_find_in_list(unsigned long ident, struct list_head *start)
+{
+	struct proxyfs_file_t *file = NULL; 
+	struct list_head *l;               
+
+	list_for_each( l, start ){  
+		file = list_entry(l, struct proxyfs_file_t, files);
+		if( proxyfs_file_get_file_ident(file) == ident )
+			return file;
+	}
+	return NULL;	
+}	
+
+/** \<\<public\>\> Initialize proxyfs_file struct
+ * @param self - pointer to this file instance
+ *
+ * @return zero on success 
+ * */
+int proxyfs_file_init(struct proxyfs_file_t* self)
+{
+	if( circ_buf_init( & self->write_buf, WRITE_BUF_SIZE ) != 0 ){
+		mdbg(ERR3, "Allocating write buffer for proxy_file failed");
+		goto exit0;
+	}
+	if( circ_buf_init( & self->read_buf, READ_BUF_SIZE ) != 0 ){
+		mdbg(ERR3, "Allocating read buffer for proxy_file failed");
+		goto exit1;
+	}
+
+	self->state = 0;
+	self->write_buf_unconfirmed = 0;
+	self->read_was_requested = 0;
+	self->peer = NULL;
+	return 0;
+exit1:
+	circ_buf_destroy( & self->write_buf ); 
+exit0:
+	return -1;
+}
+
+/** \<\<public\>\> Deinitialize proxyfs_file struct
+ * @param self - pointer to this file instance
+ *
+ * */
+void proxyfs_file_destroy(struct proxyfs_file_t* self)
+{
+	circ_buf_destroy( & self->write_buf ); 
+	circ_buf_destroy( & self->read_buf ); 
+	proxyfs_peer_put(self->peer);
+}
+
+/** \<\<public\>\> Writes to file from peer - writes to read buffer */
+int proxyfs_file_write_from_peer(struct proxyfs_file_t *self, const char *buf, size_t count)
+{
+	VIRTUAL_FUNC(write_from_peer, buf, count);
+}
+
+/** \<\<public\>\> Reads from file to peer - reads from write buffer */
+int proxyfs_file_read_to_peer(struct proxyfs_file_t *self, char *buf, size_t count)
+{
+	VIRTUAL_FUNC(read_to_peer, buf, count);
+}
+
+/** \<\<public\>\> Submit that data was written to file on other side */
+void proxyfs_file_submit_read_to_peer(struct proxyfs_file_t *self, size_t count)
+{
+	VIRTUAL_FUNC_VOID(submit_read_to_peer, count);
+}
+
+/** \<\<public\>\> Get maximum amount and address of data, that can be read at one time */
+void proxyfs_file_write_buf_info(struct proxyfs_file_t *self, size_t* total_size, size_t* size, void** addr)
+{
+	VIRTUAL_FUNC_VOID(write_buf_info, total_size, size, addr);
+}
+
+/** \<\<public\>\> Sets peer and aquires its reference. If there was some other peer set before, releases its reference */
+void proxyfs_file_set_peer(struct proxyfs_file_t *self, struct proxyfs_peer_t *peer) {
+	if ( self->peer ) 
+		mdbg(INFO3, "Switching from peer %p to peer %p", self->peer, peer);		
+	proxyfs_peer_get(peer); // Aquire ref of a new peer
+	proxyfs_peer_put(self->peer); // Release current peer
+	self->peer = peer;
+}
+
+/** \<\<public\>\> Checks, whether read was requested for this file */
+int proxyfs_file_was_read_requested(struct proxyfs_file_t* self) {
+	return self->read_was_requested;
+}
+
+/** \<\<public\>\> Marks the file as read requested */
+void proxyfs_file_mark_read_requested(struct proxyfs_file_t* self) {
+	self->read_was_requested = 1;
+}
+
--- linux-3.7.1_original/clondike/src/proxyfs/proxyfs_pipe_proxy_file.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/proxyfs/proxyfs_pipe_proxy_file.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,129 @@
+/**
+ * @file proxyfs_pipe_proxy_file.c -  client pipe file class (used by proxyfs_client_task)
+ *                      
+ * 
+ *
+ *
+ * Date: 08/02/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: proxyfs_pipe_proxy_file.c,v 1.4 2008/01/17 14:36:44 stavam2 Exp $
+ *
+ * This file is part of Proxy filesystem (ProxyFS)
+ * Copyleft (C) 2007 Petr Malat
+ * 
+ * ProxyFS is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * ProxyFS is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include <linux/types.h>
+#include <linux/wait.h>
+#include <asm/uaccess.h>
+#include <linux/semaphore.h>
+
+#define PROXYFS_PIPE_PROXY_FILE_PRIVATE
+#define PROXYFS_PIPE_PROXY_FILE_PROTECTED // Own header
+#include "proxyfs_pipe_proxy_file.h"
+
+/** \<\<private\>\> Write to file from user space buffer 
+ * @param *self - pointer to this file instance
+ * @param *buf - pointer to data in userspace
+ * @param count - size of data
+ *
+ * @return the number of bytes written or error (negative number)
+ * */
+static int proxyfs_pipe_proxy_file_write_user(struct proxyfs_proxy_file_t *self, const char *buf, size_t count)
+{
+	int lenght = 0;
+	uint32_t write_size;
+
+	if( ! access_ok(VERIFY_WRITE, buf, count) )
+		return -EFAULT;
+
+	down( & self->write_buf_sem );
+	write_size = circ_buf_free_space( & PROXYFS_FILE(self)->write_buf );
+
+	mdbg(INFO2, "[File %lu] Space in buf: %lu, writting %lu", proxyfs_file_get_file_ident(PROXYFS_FILE(self)), (unsigned long)write_size, (unsigned long)count);
+
+	if( write_size < 2*sizeof(write_size) ) // Won't write less then 4 bytes
+		lenght = -(2*(int)sizeof(write_size));
+	else if( count <= PIPE_BUF && write_size < sizeof(write_size) + count )
+			lenght = -(sizeof(write_size) + count); // Not enough space
+	else
+	{
+		write_size -= sizeof( write_size ); // Never overflow
+		write_size = write_size < count ? write_size : count;
+		circ_buf_write_user( & PROXYFS_FILE(self)->write_buf, (void*)&write_size, sizeof(write_size) );
+		lenght = circ_buf_write_user( & PROXYFS_FILE(self)->write_buf, buf, write_size );
+	}
+	up( & self->write_buf_sem );
+
+	mdbg(INFO2, "written %d", lenght);
+
+	return lenght;
+}
+
+
+/** \<\<private\>\> Read from file to user space buffer 
+ * @param *self - pointer to this file instance
+ * @param *buf - pointer to buffer in userspace
+ * @param count - size of data
+ *
+ * @return the number of bytes read or error (negative number)
+ */
+static int proxyfs_pipe_proxy_file_read_user(struct proxyfs_proxy_file_t *self, char *buf, size_t count)
+{
+	int lenght;
+	if( ! access_ok(VERIFY_WRITE, buf, count) )
+		return -EFAULT;
+
+	if ( !proxyfs_file_was_read_requested(PROXYFS_FILE(self)) ) {
+		// Pipe files need a special trick with read requested marking.. do it only 1st time read is called
+		struct proxyfs_msg *msg;
+		struct proxyfs_msg *msg_resp;
+
+		mdbg(INFO2, "[File %lu] read request syscall", proxyfs_file_get_file_ident(PROXYFS_FILE(self)));
+	
+		msg = proxyfs_msg_new(MSG_READ_REQUEST, proxyfs_file_get_file_ident(PROXYFS_FILE(self)), 0, NULL); 
+		if(msg != NULL){
+			msg_resp = proxyfs_client_do_syscall(self->task, self, msg);
+			
+			if( msg_resp != (void*)MSG_READ_REQUEST_RESP ) {
+				mdbg(ERR4, "[File %lu] read request failed", proxyfs_file_get_file_ident(PROXYFS_FILE(self)));
+				return -EINTR; // Or EAGAIN, or retry, or...??
+			}
+
+			mdbg(INFO2, "[File %lu] read request succeeded", proxyfs_file_get_file_ident(PROXYFS_FILE(self)));
+			proxyfs_file_mark_read_requested(PROXYFS_FILE(self));
+		}
+	}
+
+
+	down( & self->read_buf_sem );
+	lenght = circ_buf_read_user( & PROXYFS_FILE(self)->read_buf, buf, count );
+	up( & self->read_buf_sem );
+
+	return lenght;
+}
+
+/** \<\<public\>\> Specialize proxyfs_proxy_file to proxyfs_pipe_proxy_file
+ * @param self - pointer to initialized proxyfs_proxy_file structure
+ *
+ * @return proxyfs_pipe_proxy_file instance
+ * */
+struct proxyfs_pipe_proxy_file *proxyfs_pipe_proxy_file_from_proxy_file(struct proxyfs_proxy_file_t* self)
+{
+	self->ops = &pipe_proxy_file_ops;
+	return PROXYFS_PIPE_PROXY_FILE(self);
+}
--- linux-3.7.1_original/clondike/src/proxyfs/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/proxyfs/Makefile	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,35 @@
+##############################################################################
+# @file Makefile - Builds ProxyFS
+#
+# Author: Petr Malat
+#
+# This file is part of Clondike.
+#
+# Clondike is free software: you can redistribute it and/or modify it under 
+# the terms of the GNU General Public License version 2 as published by 
+# the Free Software Foundation.
+#
+# Clondike is distributed in the hope that it will be useful, but WITHOUT ANY
+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
+# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more 
+# details.
+# 
+# You should have received a copy of the GNU General Public License along with 
+# Clondike. If not, see http://www.gnu.org/licenses/.
+##############################################################################
+
+ccflags-y = `dbgenv $<`
+
+obj-$(CONFIG_TCMI) := proxyfs.o
+proxyfs-objs += proxyfs_module.o proxyfs_fs.o proxyfs_msg.o proxyfs_peer.o buffer.o proxyfs_ioctl_table_sorted.o \
+		proxyfs_real_file.o proxyfs_tty_real_file.o proxyfs_generic_real_file.o proxyfs_pipe_real_file.o \
+		proxyfs_proxy_file.o proxyfs_pipe_proxy_file.o proxyfs_generic_proxy_file.o \
+		proxyfs_file.o proxyfs_task.o proxyfs_client.o proxyfs_server.o 
+
+$(obj)/proxyfs_ioctl_table_sorted.s: $(src)/proxyfs_ioctl_table.s
+	proxyfs_ioctl_sort.pl < $< > $@
+$(obj)/proxyfs_ioctl_table.s: $(src)/proxyfs_ioctl_table.c
+$(obj)/proxyfs_ioctl_table_sorted.o: $(src)/proxyfs_ioctl_table_sorted.s
+	$(CC) -c $< -o $@
+
+
--- linux-3.7.1_original/clondike/src/proxyfs/proxyfs_file.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/proxyfs/proxyfs_file.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,198 @@
+/**
+ * @file proxyfs_file.h - Main file class (used by proxyfs_task)
+ *                      
+ * 
+ *
+ *
+ * Date: 08/02/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: proxyfs_file.h,v 1.6 2008/05/02 19:59:20 stavam2 Exp $
+ *
+ * This file is part of Proxy filesystem (ProxyFS)
+ * Copyleft (C) 2007 Petr Malat
+ * 
+ * ProxyFS is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * ProxyFS is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _PROXYFS_FILE_H_PUBLIC
+#define _PROXYFS_FILE_H_PUBLIC
+
+#include <linux/list.h>
+
+#define WRITE_BUF_SIZE (2 << 12)
+#define READ_BUF_SIZE (2 << 12)
+/**
+ * @defgroup proxyfs_file_class proxyfs_file class
+ * @ingroup proxyfs_module_class
+ *
+ * This is used on between VFS 
+ * and proxyfs_client task.
+ *
+ * @{
+ */
+
+/** \<\<public\>\> proxy_file_t declaration */
+struct proxyfs_file_t;
+struct proxyfs_peer_t;
+
+/** Unique identifier of a file managed by the proxy fs system */
+struct proxyfs_file_identifier {
+	/** Semi-unique number identificating file. It is not unique on its own, but only in combination with pid */
+	uint16_t file_ident;
+	/** Pid of the process on CCN that owned the file before we overtook it into the proxyfs */
+	uint16_t file_owner_pid;
+}  __attribute__((__packed__));
+
+/** \<\<public\>\> Get file status */
+unsigned proxyfs_file_get_status(struct proxyfs_file_t* self, unsigned status);
+
+/** \<\<public\>\> Get file identifier */
+unsigned long proxyfs_file_get_file_ident(struct proxyfs_file_t* self);
+
+/** \<\<public\>\> Set file identifier */
+void proxyfs_file_set_file_ident(struct proxyfs_file_t* self, unsigned long encoded_identifier);
+
+/** \<\<public\>\> Set file status */
+struct proxyfs_file_t* proxyfs_file_find_in_list(unsigned long ident, struct list_head *start);
+
+/** \<\<public\>\> Initialize proxyfs_file struct*/
+int proxyfs_file_init(struct proxyfs_file_t* self);
+
+/** \<\<public\>\> Deinitialize proxyfs_file struct*/
+void proxyfs_file_destroy(struct proxyfs_file_t* self);
+
+/** \<\<public\>\> Writes to file from peer - writes to read buffer */
+int proxyfs_file_write_from_peer(struct proxyfs_file_t *self, const char *buf, size_t count);
+
+/** \<\<public\>\> Reads from file to peer - reads from write buffer */
+int proxyfs_file_read_to_peer(struct proxyfs_file_t *self, char *buf, size_t count);
+
+/** \<\<public\>\> Submit that data was written to file on other side */
+void proxyfs_file_submit_read_to_peer(struct proxyfs_file_t *self, size_t count);
+
+/** \<\<public\>\> Get maximum amount and address of data, that can be read at one time */
+void proxyfs_file_write_buf_info(struct proxyfs_file_t *self, size_t* total_size, size_t* size, void** addr);
+
+/** \<\<public\>\> Sets peer and aquires its reference. If there was some other peer set before, releases its reference */
+void proxyfs_file_set_peer(struct proxyfs_file_t *self, struct proxyfs_peer_t *peer);
+
+/** \<\<public\>\> Checks, whether read was requested for this file */
+int proxyfs_file_was_read_requested(struct proxyfs_file_t* self);
+/** \<\<public\>\> Marks the file as read requested */
+void proxyfs_file_mark_read_requested(struct proxyfs_file_t* self);
+
+
+/** Cast to struct proxyfs_file_t* */
+#define PROXYFS_FILE(arg) ((struct proxyfs_file_t*)(arg))
+
+/** \<\<public\>\> Unset file status */
+void proxyfs_file_unset_status(struct proxyfs_file_t* self, unsigned status);
+
+/** \<\<public\>\> Set file status */
+void proxyfs_file_set_status(struct proxyfs_file_t* self, unsigned status);
+/** The file is opened and both sides known about it */
+#define PROXYFS_FILE_OPENED 		1
+/** The other side rejected opening file */
+#define PROXYFS_FILE_DONT_EXISTS 	2
+/** We are at and of file */
+#define PROXYFS_FILE_READ_EOF 		4
+/** There is space in write buffer (read only state) */
+#define PROXYFS_FILE_CAN_WRITE 		8
+/** There is space in read buffer (read only state) */
+#define PROXYFS_FILE_CAN_READ 		16
+/** There are no data pending in write buffer (read only state) */
+#define PROXYFS_FILE_ALL_WRITTEN	32
+/** There are no data pending in read buffer (read only state) */
+#define PROXYFS_FILE_ALL_READ		64
+/** Syscall transaction on file  */
+#define PROXYFS_FILE_IN_SYSCALL		128
+/** The file is opened and both sides known about it */
+#define PROXYFS_FILE_CLOSED 		256
+/** Reading end on peer is closed (pipe or socket only) */
+#define PROXYFS_FILE_EPIPE		512	
+
+/** Mask of read only file status */
+#define PROXYFS_FILE_RO_STATUS ( PROXYFS_FILE_CAN_WRITE | PROXYFS_FILE_CAN_READ | PROXYFS_FILE_ALL_WRITTEN | \
+				 PROXYFS_FILE_ALL_READ )
+/** Mask of read/write file status */
+#define PROXYFS_FILE_RW_STATUS ( PROXYFS_FILE_OPENED | PROXYFS_FILE_DONT_EXISTS | PROXYFS_FILE_READ_EOF | \
+				 PROXYFS_FILE_CLOSED | PROXYFS_FILE_EPIPE       | PROXYFS_FILE_IN_SYSCALL )
+					
+/** TTY file type */
+#define PROXYFS_FILE_TTY	1
+/** Generic file type */
+#define PROXYFS_FILE_GENERIC	2
+/** Pipe file type */
+#define PROXYFS_FILE_PIPE	3
+
+#endif // _PROXYFS_FILE_H_PUBLIC
+
+
+/********************** PROTECTED METHODS AND DATA ******************************/
+
+#ifdef PROXYFS_FILE_PROTECTED
+#ifndef _PROXYFS_FILE_H_PROTECTED
+#define _PROXYFS_FILE_H_PROTECTED
+
+#include <proxyfs/buffer.h>
+
+/** \<\<protected\>\> Operations supporting polymorphism */
+struct proxyfs_file_ops {
+	/** Writes to file from peer - writes to read buffer */
+	int (*write_from_peer)(struct proxyfs_file_t *, const char *, size_t);
+	/** Reads from file to peer - reads from write buffer */
+	int (*read_to_peer)(struct proxyfs_file_t *, char *, size_t);
+	/** Call this to submit that data was writen to file on other side */
+	void (*submit_read_to_peer)(struct proxyfs_file_t *, size_t);
+	/** Get write buf info */
+	void (*write_buf_info)(struct proxyfs_file_t *, size_t*, size_t*, void**);
+};
+
+/** \<\<protected\>\> Structure on which VFS and proxyfs_client task are interacting */
+struct proxyfs_file_t {
+	/** Unique file identifier */
+	struct proxyfs_file_identifier file_identifier;
+
+	/** Circular buffer for write() */
+	struct circ_buf write_buf;
+	/** Circular buffer for read() */
+	struct circ_buf read_buf;
+
+	/** Unconfirmed amount of data which was send */
+	size_t write_buf_unconfirmed;
+
+	/** Helper variable, telling whether the file was ever requested to read some data. see MSG_READ_REQUEST comment for details */	
+	int read_was_requested;
+
+	/** State of file */
+	unsigned state;
+	
+	/** Used when adding this structure to lists */
+	struct list_head files;
+
+	/** Peer asociated with this file */
+	struct proxyfs_peer_t *peer;
+	/** Polymorphism */
+	struct proxyfs_file_ops *ops;
+};
+
+#endif // _PROXYFS_FILE_H_PROTECTED
+#endif //PROXYFS_FILE_PROTECTED
+
+/**
+ * @}
+ */
+
--- linux-3.7.1_original/clondike/src/proxyfs/proxyfs_generic_real_file.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/proxyfs/proxyfs_generic_real_file.c	2013-03-07 20:22:21.000000000 +0100
@@ -0,0 +1,204 @@
+/**
+ * @file proxyfs_generic_real_file.c - File class for accessing generic files
+ * (used by proxyfs_server_task)
+ *                      
+ * 
+ *
+ *
+ * Date: 08/02/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: proxyfs_generic_real_file.c,v 1.6 2008/01/17 14:36:44 stavam2 Exp $
+ *
+ * This file is part of Proxy filesystem (ProxyFS)
+ * Copyleft (C) 2007 Petr Malat
+ * 
+ * ProxyFS is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * ProxyFS is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include <linux/fs.h>
+#include <linux/vfs.h>
+
+#include <dbg.h>
+
+#include <asm/poll.h>
+
+#define PROXYFS_GENERIC_REAL_FILE_PRIVATE
+#define PROXYFS_GENERIC_REAL_FILE_PROTECTED
+#include "proxyfs_generic_real_file.h"
+
+/** \<\<private\>\> Write to file from read buffer 
+ * @param *self - this real_file class instance
+ *
+ * @return amount of bytes written
+ * */
+static int proxyfs_generic_real_file_write(struct proxyfs_real_file *self)
+{
+	int lenght = 0, total= 0;
+	mm_segment_t old_fs;
+	void *buf_addr;
+	size_t buf_data;
+	loff_t pos;
+
+	buf_data = circ_buf_get_read_size( & PROXYFS_FILE(self)->read_buf );
+
+	mdbg(INFO3, "File %lu has at least %lu bytes pending in buffer.", proxyfs_file_get_file_ident(PROXYFS_FILE(self)), (unsigned long)buf_data );
+
+	if( buf_data ){
+		buf_addr = circ_buf_get_read_addr( & PROXYFS_FILE(self)->read_buf );
+		pos      = self->file->f_pos;
+		old_fs   = get_fs();
+
+		set_fs(KERNEL_DS);
+
+        	lenght = vfs_write( self->file, buf_addr, buf_data, &pos );
+		mdbg(INFO3, "vfs_write returned %d", lenght );
+
+		if( lenght > 0 ){
+			circ_buf_adjust_read_ptr( & PROXYFS_FILE(self)->read_buf, lenght );
+			total = lenght;
+			// If we wrote everything, we try to write one more time,
+			// because we are using circular buffer
+			if( lenght == buf_data ){ 
+				buf_data = circ_buf_get_read_size( & PROXYFS_FILE(self)->read_buf );
+				if( buf_data ){
+					buf_addr = circ_buf_get_read_addr( & PROXYFS_FILE(self)->read_buf );
+        				lenght   = vfs_write(self->file, buf_addr, buf_data, &pos);
+					mdbg(INFO3, "vfs_write returned %d", lenght );
+					if( lenght > 0 ){
+						circ_buf_adjust_read_ptr( & PROXYFS_FILE(self)->read_buf, lenght );
+						total += lenght;
+					}
+				}
+			}
+		}
+		else
+	
+	        self->file->f_pos = pos;
+		set_fs(old_fs);
+	}
+	return total;
+}
+
+
+/** \<\<private\>\> Reads from file and write to writte buffer 
+ * @param *self - this real_file class instance
+ *
+ * @return amount of bytes read
+ * */
+static int proxyfs_generic_real_file_read(struct proxyfs_real_file *self)
+{
+	int lenght = 0;
+	mm_segment_t old_fs;
+	void *buf_addr;
+	size_t buf_data;
+	loff_t pos;
+        
+	buf_data = circ_buf_get_write_size( & PROXYFS_FILE(self)->write_buf );
+	mdbg(INFO3, "Trying read file %lu, buffer space is at least %lu", proxyfs_file_get_file_ident(PROXYFS_FILE(self)), (unsigned long)buf_data );
+
+	if( buf_data ){
+		buf_addr = circ_buf_get_write_addr( & PROXYFS_FILE(self)->write_buf );
+		pos      = self->file->f_pos;
+		old_fs   = get_fs();
+
+		set_fs(KERNEL_DS);
+
+        	lenght = vfs_read(self->file, buf_addr, buf_data, &pos);
+
+		if( lenght > 0 ){
+			circ_buf_adjust_write_ptr( & PROXYFS_FILE(self)->write_buf, lenght );
+			// If we wrote everything, we try to write one more time, 
+			// because we are using circular buffer
+			if( lenght == buf_data ){ 
+				buf_data = circ_buf_get_write_size( & PROXYFS_FILE(self)->write_buf );
+				if( buf_data ){
+					buf_addr = circ_buf_get_write_addr( & PROXYFS_FILE(self)->write_buf );
+        				lenght = vfs_read(self->file, buf_addr, buf_data, &pos);
+					if( lenght > 0 ) 
+						circ_buf_adjust_write_ptr( & PROXYFS_FILE(self)->write_buf, lenght ); 
+				}
+			}
+		}
+	
+	        self->file->f_pos = pos;
+		set_fs(old_fs);
+	}
+
+	return lenght; // FIXME
+}
+
+/** \<\<private\>\> "Open" file and send response message 
+ * @param *self - pointer to this file instance
+ * @param *peer - instance of peer which is opening this file
+ *
+ * @return zero on success
+ */
+static int proxyfs_generic_real_file_open(struct proxyfs_real_file *self, struct proxyfs_peer_t *peer)
+{
+	struct proxyfs_msg *msg;
+	static u_int32_t const type = PROXYFS_FILE_GENERIC;
+
+	msg = proxyfs_msg_new(MSG_OPEN_RESP_OK,	proxyfs_file_get_file_ident(PROXYFS_FILE(self)), sizeof(type), (void*)&type);
+
+	if( msg != NULL ){
+		proxyfs_peer_send_msg( peer, msg );
+		proxyfs_file_set_peer(PROXYFS_FILE(self), peer);
+		return 0;
+	}
+
+	return -1;
+}
+
+/** \<\<public\>\> Initialize tty_real_file 
+ * @param *self - pointer to this file instance
+ *
+ * @return zero on success
+ * */
+int proxyfs_generic_real_file_init(struct proxyfs_generic_real_file *self)
+{
+	PROXYFS_REAL_FILE(self)->ops = &generic_real_file_ops;
+	return 0;
+}
+
+/** \<\<public\>\> generic_real_file construktor 
+ * @return new proxyfs_generic_real_file instance or NULL on error
+ * */
+struct proxyfs_generic_real_file *proxyfs_generic_real_file_new(void)
+{
+	struct proxyfs_generic_real_file *self;
+
+	self = (struct proxyfs_generic_real_file*)kmalloc(sizeof(struct proxyfs_generic_real_file), GFP_KERNEL);
+	if( self == NULL ){
+		mdbg(ERR3, "Allocating new proxyfs_generic_real_file failed");
+		goto exit0;
+	}
+	
+	if( proxyfs_real_file_init( PROXYFS_REAL_FILE(self) ) != 0 )
+		goto exit1;
+	if( proxyfs_generic_real_file_init( self ) != 0 )
+		goto exit2;
+	
+	return self;
+
+exit2:
+	proxyfs_real_file_destroy( PROXYFS_REAL_FILE(self) );
+exit1:
+	kfree(self);
+exit0:
+	return self;
+}
--- linux-3.7.1_original/clondike/src/proxyfs/proxyfs_tty_real_file.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/proxyfs/proxyfs_tty_real_file.c	2013-03-07 20:20:57.000000000 +0100
@@ -0,0 +1,294 @@
+/**
+ * @file proxyfs_tty_real_file.c - File class sepcialized on tty access 
+ * (used by proxyfs_server_task)
+ *                      
+ * 
+ *
+ *
+ * Date: 08/02/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: proxyfs_tty_real_file.c,v 1.9 2008/05/02 19:59:20 stavam2 Exp $
+ *
+ * This file is part of Proxy filesystem (ProxyFS)
+ * Copyleft (C) 2007 Petr Malat
+ * 
+ * ProxyFS is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * ProxyFS is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include <linux/fs.h>
+#include <linux/tty.h>
+#include <linux/sched.h>
+
+#include <dbg.h>
+
+#include <asm/poll.h>
+
+#define PROXYFS_TTY_REAL_FILE_PROTECTED
+#define PROXYFS_TTY_REAL_FILE_PRIVATE
+#include "proxyfs_tty_real_file.h"
+
+/** \<\<private\>\> Write to file from read buffer 
+ * @param *self - this real_file class instance
+ *
+ * @return amount of bytes written
+ * */
+static int proxyfs_tty_real_file_write(struct proxyfs_real_file *self)
+{
+	int lenght = 0, total= 0;
+	mm_segment_t old_fs;
+	void *buf_addr;
+	size_t buf_data;
+	loff_t pos;
+
+	buf_data = circ_buf_get_read_size( & PROXYFS_FILE(self)->read_buf );
+
+	mdbg(INFO3, "File %lu has at least %lu bytes pending in buffer", proxyfs_file_get_file_ident(PROXYFS_FILE(self)), (unsigned long)buf_data);
+
+	circ_buf_dump("Tty real file write", & PROXYFS_FILE(self)->read_buf);
+
+	if( buf_data ){
+		buf_addr = circ_buf_get_read_addr( & PROXYFS_FILE(self)->read_buf );
+		pos      = self->file->f_pos;
+		old_fs   = get_fs();
+
+		set_fs(KERNEL_DS);
+
+        	lenght = vfs_write( self->file, buf_addr, buf_data, &pos );
+		mdbg(INFO3, "vfs_write returned %d", lenght );
+
+		if( lenght > 0 ){
+			circ_buf_adjust_read_ptr( & PROXYFS_FILE(self)->read_buf, lenght );
+			total = lenght;
+			// If we wrote everything, we try to write one more time,
+			// because we are using circular buffer
+			if( lenght == buf_data ){ 
+				buf_data = circ_buf_get_read_size( & PROXYFS_FILE(self)->read_buf );
+				if( buf_data ){
+					buf_addr = circ_buf_get_read_addr( & PROXYFS_FILE(self)->read_buf );
+        				lenght   = vfs_write(self->file, buf_addr, buf_data, &pos);
+					mdbg(INFO3, "vfs_write returned %d", lenght );
+					if( lenght > 0 ){
+						circ_buf_adjust_read_ptr( & PROXYFS_FILE(self)->read_buf, lenght );
+						total += lenght;
+					}
+				}
+			}
+		}
+		else
+	
+	        self->file->f_pos = pos;
+		set_fs(old_fs);
+	}
+	return total;
+}
+
+
+/** \<\<private\>\> Reads from file and write to writte buffer 
+ * @param *self - this real_file class instance
+ *
+ * @return amount of bytes read
+ * */
+static int proxyfs_tty_real_file_read(struct proxyfs_real_file *self)
+{
+	int length = 0, total_read = 0;
+	mm_segment_t old_fs;
+	void *buf_addr;
+	size_t buf_data;
+	loff_t pos;
+	
+	if ( proxyfs_real_file_poll_read(self) < 1 ) // Are there some date pending?
+		return -EAGAIN;
+
+	buf_data = circ_buf_get_write_size( & PROXYFS_FILE(self)->write_buf );
+	mdbg(INFO3, "Trying read file %lu, buffer space is at least %lu", proxyfs_file_get_file_ident(PROXYFS_FILE(self)), (unsigned long)buf_data );
+	circ_buf_dump("Tty real file read", & PROXYFS_FILE(self)->write_buf);
+
+	if( buf_data ){
+		buf_addr = circ_buf_get_write_addr( & PROXYFS_FILE(self)->write_buf );
+		pos      = self->file->f_pos;
+		old_fs   = get_fs();
+
+		set_fs(KERNEL_DS);
+
+        	length = proxyfs_tty_real_file_tty_read(self->file, buf_addr, buf_data, &pos);
+		if( length > 0 ){
+			total_read = length;
+			circ_buf_adjust_write_ptr( & PROXYFS_FILE(self)->write_buf, length );
+			// If we wrote everything, we try to write one more time, 
+			// because we are using circular buffer
+			if( length == buf_data ){ 
+				buf_data = circ_buf_get_write_size( & PROXYFS_FILE(self)->write_buf );
+				if( buf_data ){
+					buf_addr = circ_buf_get_write_addr( & PROXYFS_FILE(self)->write_buf );
+        				length = proxyfs_tty_real_file_tty_read(self->file, buf_addr, buf_data, &pos);
+					if( length > 0 )  {
+						circ_buf_adjust_write_ptr( & PROXYFS_FILE(self)->write_buf, length ); 
+						total_read += length;
+					}
+				}
+			}
+		}
+
+	        self->file->f_pos = pos;
+		set_fs(old_fs);
+	}
+
+	return total_read;
+}
+
+/** \<\<private\>\> "Open" file and send response message 
+ * @param *self - pointer to this file instance
+ * @param *peer - instance of peer which is opening this file
+ *
+ * @return zero on success
+ */
+static int proxyfs_tty_real_file_open(struct proxyfs_real_file *self, struct proxyfs_peer_t *peer)
+{
+	struct proxyfs_msg *msg;
+	static u_int32_t const type = PROXYFS_FILE_TTY;
+
+	msg = proxyfs_msg_new(MSG_OPEN_RESP_OK,	proxyfs_file_get_file_ident(PROXYFS_FILE(self)), sizeof(type), (void*)&type);
+
+	if( msg != NULL ){
+		proxyfs_peer_send_msg( peer, msg );		
+		return 0;
+	}
+
+	return -1;
+}
+
+/** \<\<private\>\> Read function for TTY
+ * @TODO: Why is this copied here from kernel?
+ *
+ * @param *file   - pointer to file we wanted to read from 
+ * @param *buf    - pointer to buffer in kernelspace witch will be filled with data 
+ * @param count   - buffer size
+ * @param *ppos - pointer to file offset
+ *
+ * @return Amount of bytes read or error 
+ */
+static ssize_t proxyfs_tty_real_file_tty_read(struct file * file, char *buf, size_t count, loff_t *ppos)
+{
+         int i;
+         struct tty_struct * tty;
+         struct inode *inode;
+         struct tty_ldisc *ld = NULL;
+	 int state;
+ 
+         tty = (struct tty_struct *)file->private_data;
+         inode = file->f_path.dentry->d_inode;
+         //if (tty_paranoia_check(tty, inode, "tty_read"))
+         //        return -EIO;
+         if (!tty || (test_bit(TTY_IO_ERROR, &tty->flags)))
+                 return -EIO;
+ 
+         /* We not want to wait for the line discipline to sort out in this
+            situation */
+         ld = tty_ldisc_ref(tty);
+	 if(ld){
+	        //lock_kernel();        Commented kernel lock and unlock for new kernel by Jiri Rakosnik it is potential problem !!!!!
+        	if (ld->ops->read){
+			state = current->state;
+                	i = (ld->ops->read)(tty,file,buf,count);
+			current->state = state;
+		}
+	        else
+        	         i = -EIO;
+	        tty_ldisc_deref(ld);
+        	//unlock_kernel();
+         	if (i > 0)
+                 	inode->i_atime = current_fs_time(inode->i_sb);
+		return i;
+	 }
+	 else
+		 return -EAGAIN;
+}
+
+/** \<\<public\>\> Initialize tty_real_file 
+ * @param *self - pointer to this file instance
+ *
+ * @return zero on success
+ * */
+int proxyfs_tty_real_file_init(struct proxyfs_tty_real_file *self)
+{
+	int rtn = proxyfs_real_file_init( PROXYFS_REAL_FILE(self) );
+
+	if( rtn == 0 )
+		PROXYFS_REAL_FILE(self)->ops = &tty_real_file_ops;
+	return rtn;
+}
+
+/** \<\<public\>\> Deinitialize tty_real_file 
+ * @param *self - pointer to this file instance
+ * */
+void proxyfs_tty_real_file_destroy(struct proxyfs_tty_real_file *self)
+{
+	mdbg(INFO4, "Destroying tty file %lu", proxyfs_file_get_file_ident(PROXYFS_FILE(self)));
+	proxyfs_real_file_destroy( PROXYFS_REAL_FILE(self) );
+}
+
+/** \<\<public\>\> tty_real_file constructor 
+ * @return new proxyfs_tty_real_file instance or NULL on error
+ * */
+struct proxyfs_tty_real_file *proxyfs_tty_real_file_new(void)
+{
+	struct proxyfs_tty_real_file *self;
+
+	self = (struct proxyfs_tty_real_file*)kmalloc(sizeof(struct proxyfs_tty_real_file), GFP_KERNEL);
+	if( self == NULL ){
+		mdbg(ERR3, "Allocating new proxyfs_tty_real_file failed");
+		goto exit0;
+	}
+	if( proxyfs_tty_real_file_init( self ) != 0 )
+		goto exit1;
+	
+	return self;
+
+exit1:
+	kfree(self);	
+exit0:
+	return NULL;
+}
+
+/** \<\<public\>\> Duplicates a proxyfs real file
+ *
+ * @param *self - pointer to the instance to be duplicated
+ * @return Duplicated file instance
+ */
+static struct proxyfs_real_file* proxyfs_tty_real_file_duplicate(struct proxyfs_real_file *self)
+{
+
+	struct proxyfs_tty_real_file *clone;
+	mdbg(INFO4, "Duplicating file %lu", proxyfs_file_get_file_ident(PROXYFS_FILE(self)));	
+	clone = (struct proxyfs_tty_real_file*)kmalloc(sizeof(struct proxyfs_tty_real_file), GFP_KERNEL);	
+	if ( !clone )
+		return NULL;
+
+	if( proxyfs_tty_real_file_init( PROXYFS_TTY_REAL_FILE(clone) ) != 0 )
+		goto exit;
+
+	PROXYFS_FILE(clone)->file_identifier.file_ident = PROXYFS_FILE(self)->file_identifier.file_ident;
+	PROXYFS_FILE(clone)->file_identifier.file_owner_pid = PROXYFS_FILE(self)->file_identifier.file_owner_pid;
+	PROXYFS_REAL_FILE(clone)->file = PROXYFS_REAL_FILE(self)->file;
+	// We can do this here as we own a reference to file (the file being clonned) and we have a lock holding the file so it cannot be released
+	get_file(PROXYFS_REAL_FILE(self)->file);
+
+	return PROXYFS_REAL_FILE(clone);
+exit:
+	kfree(self);	
+	return NULL;
+}
+
--- linux-3.7.1_original/clondike/src/proxyfs/proxyfs_pipe_real_file.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/proxyfs/proxyfs_pipe_real_file.c	2013-03-12 15:15:31.000000000 +0100
@@ -0,0 +1,343 @@
+/**
+ * @file proxyfs_pipe_real_file.c - File class for accessing pipe files
+ * (used by proxyfs_server_task)
+ *                      
+ * 
+ *
+ *
+ * Date: 08/02/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: proxyfs_pipe_real_file.c,v 1.8 2008/05/02 19:59:20 stavam2 Exp $
+ *
+ * This file is part of Proxy filesystem (ProxyFS)
+ * Copyleft (C) 2007 Petr Malat
+ * 
+ * ProxyFS is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * ProxyFS is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include <linux/fs.h>
+#include <linux/vfs.h>
+
+#include <asm/poll.h>
+
+#include <dbg.h>
+
+#define PROXYFS_PIPE_REAL_FILE_PRIVATE
+#define PROXYFS_PIPE_REAL_FILE_PROTECTED
+#include "proxyfs_pipe_real_file.h"
+
+/** \<\<private\>\> Write to file from read buffer 
+ * @param *self - this real_file class instance
+ *
+ * @return amount of bytes written
+ * */
+static int proxyfs_pipe_real_file_write(struct proxyfs_real_file *self)
+{
+	int lenght, total= 0, poll_result, nread;
+	mm_segment_t old_fs;
+	void *buf_addr;
+	size_t buf_data;
+	loff_t pos;
+
+	mdbg(INFO3, "[File %lu] fmode %d", proxyfs_file_get_file_ident(PROXYFS_FILE(self)),
+	self->file->f_mode);	
+
+restart_write:
+	//nread = proxyfs_real_file_ioctl_nread(self); // TODO: Remove this, just for debugging now
+	poll_result = proxyfs_real_file_poll_write(self);
+	mdbg(INFO3, "[File %lu] polling result: %d (nread: %d)", proxyfs_file_get_file_ident(PROXYFS_FILE(self)), poll_result, nread);
+
+	if ( poll_result < 1 ) // No space for writing (in pipe it means no free buffer)
+		return total;
+
+	buf_data = circ_buf_get_read_size( & PROXYFS_FILE(self)->read_buf );
+
+	mdbg(INFO3, "[File %lu] At least %lu bytes pending in buffer", proxyfs_file_get_file_ident(PROXYFS_FILE(self)), (unsigned long)buf_data);
+	circ_buf_dump("Pipe real file write", & PROXYFS_FILE(self)->read_buf);
+
+	if( buf_data ){
+		pos = self->file->f_pos;
+		if( PROXYFS_PIPE_REAL_FILE(self)->write_counter == 0 ){
+			if( circ_buf_look_at( &PROXYFS_FILE(self)->read_buf, 
+				       (void*)&PROXYFS_PIPE_REAL_FILE(self)->write_counter, 
+				       sizeof(PROXYFS_PIPE_REAL_FILE(self)->write_counter), 0) 
+				== sizeof(PROXYFS_PIPE_REAL_FILE(self)->write_counter) )
+			{
+				mdbg(INFO3, "[File %lu] New write block size %d.", 
+						proxyfs_file_get_file_ident(PROXYFS_FILE(self)), 
+						PROXYFS_PIPE_REAL_FILE(self)->write_counter );
+
+				if( PROXYFS_PIPE_REAL_FILE(self)->write_counter <= PIPE_BUF )
+					PROXYFS_PIPE_REAL_FILE(self)->atomic_write = 1;
+				else
+					PROXYFS_PIPE_REAL_FILE(self)->atomic_write = 0;
+
+				circ_buf_adjust_read_ptr( & PROXYFS_FILE(self)->read_buf, 
+						sizeof(PROXYFS_PIPE_REAL_FILE(self)->write_counter) );
+
+				total += sizeof(PROXYFS_PIPE_REAL_FILE(self)->write_counter);
+				goto restart_write;
+			}
+			else
+				PROXYFS_PIPE_REAL_FILE(self)->write_counter = 0;
+		}
+		else if( PROXYFS_PIPE_REAL_FILE(self)->atomic_write ){ // Write must be atomic
+			int total_available = circ_buf_count(& PROXYFS_FILE(self)->read_buf);
+			if ( total_available < PROXYFS_PIPE_REAL_FILE(self)->write_counter )
+				goto done;
+
+			if( buf_data < PROXYFS_PIPE_REAL_FILE(self)->write_counter ){ // Data overlaps
+				circ_buf_look_at( &PROXYFS_FILE(self)->read_buf, 
+						PROXYFS_PIPE_REAL_FILE(self)->atomic_buf, 
+						PROXYFS_PIPE_REAL_FILE(self)->write_counter, 0);
+
+				old_fs = get_fs();
+				set_fs(KERNEL_DS);
+		        	lenght = vfs_write( self->file, PROXYFS_PIPE_REAL_FILE(self)->atomic_buf, 
+						PROXYFS_PIPE_REAL_FILE(self)->write_counter, &pos );
+				set_fs(old_fs);
+
+			}
+			else{ // Data doesn't overlap
+				buf_addr = circ_buf_get_read_addr( & PROXYFS_FILE(self)->read_buf );
+				old_fs = get_fs();
+				set_fs(KERNEL_DS);
+		        	lenght = vfs_write( self->file, buf_addr, 
+						PROXYFS_PIPE_REAL_FILE(self)->write_counter, &pos );
+				set_fs(old_fs);
+			}
+
+			if( lenght > 0 ){ // We wrote something
+				mdbg(INFO3, "[File %lu] Atomicaly written %d Bytes", 
+					proxyfs_file_get_file_ident(PROXYFS_FILE(self)), lenght);
+
+				if( lenght != PROXYFS_PIPE_REAL_FILE(self)->write_counter )
+					mdbg(ERR1, "[File %lu] Fatal error in atomic write", 
+							proxyfs_file_get_file_ident(PROXYFS_FILE(self)));
+
+				PROXYFS_PIPE_REAL_FILE(self)->write_counter = 0;
+		        	self->file->f_pos = pos;
+				total += lenght;
+				circ_buf_adjust_read_ptr( & PROXYFS_FILE(self)->read_buf, lenght );
+				goto restart_write;
+			}
+			else
+				mdbg(INFO3, "[File %lu] Write failed with %d",  
+					proxyfs_file_get_file_ident(PROXYFS_FILE(self)), lenght);
+		}	
+		else{ // Write hasn't to be atomic
+			buf_addr = circ_buf_get_read_addr( & PROXYFS_FILE(self)->read_buf );
+			if( buf_data > PROXYFS_PIPE_REAL_FILE(self)->write_counter )
+				buf_data = PROXYFS_PIPE_REAL_FILE(self)->write_counter;
+			
+			old_fs = get_fs();
+			set_fs(KERNEL_DS);
+        		lenght = vfs_write( self->file, buf_addr, buf_data, &pos );
+			set_fs(old_fs);
+
+			if( lenght > 0 ){
+				circ_buf_adjust_read_ptr( & PROXYFS_FILE(self)->read_buf, lenght );
+			        self->file->f_pos = pos;
+				PROXYFS_PIPE_REAL_FILE(self)->write_counter -= lenght;
+				total += lenght;
+				goto restart_write;
+			}
+		}
+	}
+
+done:
+	return total;
+}
+
+/** \<\<private\>\> Reads from file and write to writte buffer 
+ * @param *self - this real_file class instance
+ *
+ * @return amount of bytes read
+ * */
+static int proxyfs_pipe_real_file_read(struct proxyfs_real_file *self)
+{
+	int lenght = 0, total_read = 0, poll_result;
+	mm_segment_t old_fs;
+	void *buf_addr;
+	size_t buf_data, total_buffer_size;
+	loff_t pos;
+
+	// We read from pipe ONLY in case the remote process ever used it as a read pipe..
+	// Workaround for inpolite processes like Makefile.. see MSG_READ_REQUEST comments for details
+	if (!proxyfs_file_was_read_requested(PROXYFS_FILE(self)) )
+		return -EAGAIN;
+
+	poll_result = proxyfs_real_file_poll_read(self);
+	mdbg(INFO3, "[File %lu] polling result: %d", proxyfs_file_get_file_ident(PROXYFS_FILE(self)), poll_result);
+
+	if ( poll_result < 1 ) // Are there some date pending?
+		return -EAGAIN;
+
+	total_buffer_size = circ_buf_free_space( &PROXYFS_FILE(self)->write_buf );
+	if ( total_buffer_size == 0 ) // We do not have free space in the bufer at the moment
+		return -EAGAIN;
+
+	buf_data = circ_buf_get_write_size( & PROXYFS_FILE(self)->write_buf );
+
+	mdbg(INFO3, "Trying read file %lu, buffer space is at least %lu", proxyfs_file_get_file_ident(PROXYFS_FILE(self)), (unsigned long)buf_data);
+	circ_buf_dump("Pipe real file read", & PROXYFS_FILE(self)->write_buf);
+
+	if( buf_data ){
+		buf_addr = circ_buf_get_write_addr( & PROXYFS_FILE(self)->write_buf );
+		pos      = self->file->f_pos;
+		old_fs   = get_fs();
+
+		set_fs(KERNEL_DS);
+
+        	lenght = vfs_read(self->file, buf_addr, buf_data, &pos);
+
+		if( lenght > 0 ){
+			total_read = lenght;
+			mdbg(INFO3, "[File %lu] Read from pipe content %.*s.", proxyfs_file_get_file_ident(PROXYFS_FILE(self)), (int)lenght, (char*)buf_addr );
+
+
+			circ_buf_adjust_write_ptr( & PROXYFS_FILE(self)->write_buf, lenght );
+			// If we wrote everything, we try to write one more time, 
+			// because we are using circular buffer
+			if( lenght == buf_data ){ 
+				buf_data = circ_buf_get_write_size( & PROXYFS_FILE(self)->write_buf );
+				if( buf_data ){
+					// We have to poll once more, since now there may be no more data!
+					if ( !proxyfs_real_file_poll_read(self) ) {						
+						self->file->f_pos = pos;
+						set_fs(old_fs);					
+						goto out;
+					}
+
+					buf_addr = circ_buf_get_write_addr( & PROXYFS_FILE(self)->write_buf );
+        				lenght = vfs_read(self->file, buf_addr, buf_data, &pos);
+					if( lenght > 0 ) {
+						circ_buf_adjust_write_ptr( & PROXYFS_FILE(self)->write_buf, lenght ); 
+						total_read += lenght;
+					}
+				}
+			}
+		}
+	
+	        self->file->f_pos = pos;
+		set_fs(old_fs);
+	}
+
+out:
+	return total_read;
+}
+
+/** \<\<private\>\> "Open" file and send response message 
+ * @param *self - pointer to this file instance
+ * @param *peer - instance of peer which is opening this file
+ *
+ * @return zero on success
+ */
+static int proxyfs_pipe_real_file_open(struct proxyfs_real_file *self, struct proxyfs_peer_t *peer)
+{
+	struct proxyfs_msg *msg;
+	static u_int32_t const type = PROXYFS_FILE_PIPE;
+
+	msg = proxyfs_msg_new(MSG_OPEN_RESP_OK,	proxyfs_file_get_file_ident(PROXYFS_FILE(self)), sizeof(type), (void*)&type);
+
+
+	if( msg != NULL ){
+		proxyfs_peer_send_msg( peer, msg );
+		//proxyfs_file_set_peer(PROXYFS_FILE(self), peer);
+		return 0;
+	}
+
+	return -1;
+}
+
+/** \<\<public\>\> Initialize tty_real_file 
+ * @param *self - pointer to this file instance
+ *
+ * @return zero on success
+ * */
+int proxyfs_pipe_real_file_init(struct proxyfs_pipe_real_file *self)
+{
+	PROXYFS_REAL_FILE(self)->ops = &pipe_real_file_ops;
+	self->write_counter = 0;
+
+	return 0;
+}
+
+/** \<\<public\>\> pipe_real_file construktor 
+ * @return new proxyfs_pipe_real_file instance or NULL on error
+ * */
+struct proxyfs_pipe_real_file *proxyfs_pipe_real_file_new(void)
+{
+	struct proxyfs_pipe_real_file *self;
+
+	self = (struct proxyfs_pipe_real_file*)kmalloc(sizeof(struct proxyfs_pipe_real_file), GFP_KERNEL);
+	if( self == NULL ){
+		mdbg(ERR3, "Allocating new proxyfs_pipe_real_file failed");
+		goto exit0;
+	}
+	
+	if( proxyfs_real_file_init( PROXYFS_REAL_FILE(self) ) != 0 )
+		goto exit1;
+	if( proxyfs_pipe_real_file_init( self ) != 0 )
+		goto exit2;
+	
+	return self;
+
+exit2:
+	proxyfs_real_file_destroy( PROXYFS_REAL_FILE(self) );
+exit1:
+	kfree(self);
+exit0:
+	return self;
+}
+
+/** \<\<public\>\> Duplicates a proxyfs real file
+ *
+ * @param *self - pointer to the instance to be duplicated
+ * @return Duplicated file instance
+ */
+static struct proxyfs_real_file* proxyfs_pipe_real_file_duplicate(struct proxyfs_real_file *self)
+{
+
+	struct proxyfs_pipe_real_file *clone;
+	mdbg(INFO4, "Duplicating file %lu", proxyfs_file_get_file_ident(PROXYFS_FILE(self)));	
+	clone = (struct proxyfs_pipe_real_file*)kmalloc(sizeof(struct proxyfs_pipe_real_file), GFP_KERNEL);	
+	if ( !clone )
+		return NULL;
+
+	if( proxyfs_real_file_init( PROXYFS_REAL_FILE(clone) ) != 0 )
+		goto exit1;
+
+	if( proxyfs_pipe_real_file_init( PROXYFS_PIPE_REAL_FILE(clone) ) != 0 )
+		goto exit2;
+
+	PROXYFS_FILE(clone)->file_identifier.file_ident = PROXYFS_FILE(self)->file_identifier.file_ident;
+	PROXYFS_FILE(clone)->file_identifier.file_owner_pid = PROXYFS_FILE(self)->file_identifier.file_owner_pid;
+	PROXYFS_REAL_FILE(clone)->file = PROXYFS_REAL_FILE(self)->file;
+	// We can do this here as we own a reference to file (the file being clonned) and we have a lock holding the file so it cannot be released
+	get_file(PROXYFS_REAL_FILE(self)->file);
+
+	return PROXYFS_REAL_FILE(clone);
+
+exit2:
+	proxyfs_real_file_destroy( PROXYFS_REAL_FILE(self) );
+exit1:
+	kfree(self);	
+	return NULL;
+}
+
--- linux-3.7.1_original/clondike/src/proxyfs/proxyfs_pipe_real_file.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/proxyfs/proxyfs_pipe_real_file.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,123 @@
+/**
+ * @file proxyfs_pipe_real_file.h - File class for accessing pipe files
+ * (used by proxyfs_server_task)
+ *                      
+ * 
+ *
+ *
+ * Date: 08/02/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: proxyfs_pipe_real_file.h,v 1.3 2007/11/05 19:38:28 stavam2 Exp $
+ *
+ * This file is part of Proxy filesystem (ProxyFS)
+ * Copyleft (C) 2007 Petr Malat
+ * 
+ * ProxyFS is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * ProxyFS is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+/********************** PUBLIC METHODS AND DATA *********************************/
+#ifndef _PROXYFS_PIPE_REAL_FILE_H_PUBLIC
+#define _PROXYFS_PIPE_REAL_FILE_H_PUBLIC
+
+#include "proxyfs_real_file.h"
+
+/**
+ * @defgroup proxyfs_pipe_real_file_class proxyfs_pipe_real_file class
+ * @ingroup proxyfs_real_file_class
+ *
+ * This class is used by server task for accessing pipe files
+ *
+ * @{
+ */
+
+/** pipe_real_file declaration */
+struct proxyfs_pipe_real_file;
+
+/** \<\<public\>\> Initialize pipe_real_file */
+int proxyfs_pipe_real_file_init(struct proxyfs_pipe_real_file *self);
+
+/** \<\<public\>\> Deinitialize pipe_real_file */
+void proxyfs_pipe_real_file_destroy(struct proxyfs_pipe_real_file *self);
+
+/** \<\<public\>\> pipe_real_file construktor */
+struct proxyfs_pipe_real_file *proxyfs_pipe_real_file_new(void);
+
+/** \<\<public\>\> Casts to struct proxyfs_real_file_t * */
+#define PROXYFS_PIPE_REAL_FILE(arg) ((struct proxyfs_pipe_real_file*)(arg))
+
+#endif // _PROXYFS_PIPE_REAL_FILE_H_PUBLIC
+
+/********************** PROTECTED METHODS AND DATA ******************************/
+#ifdef  PROXYFS_PIPE_REAL_FILE_PROTECTED
+#ifndef _PROXYFS_PIPE_REAL_FILE_H_PROTECTED
+#define _PROXYFS_PIPE_REAL_FILE_H_PROTECTED
+
+#define PROXYFS_REAL_FILE_PROTECTED // Parent
+#include "proxyfs_real_file.h"
+
+/** \<\<protected\>\> pipe_real_file definition */
+struct proxyfs_pipe_real_file {
+	/** Parent class */
+	struct proxyfs_real_file parent;
+	/** Write counter */
+	uint32_t write_counter;
+	/** True if next write must be atomic */
+	int atomic_write;
+	/** Helper buffer for atomic write (used when data overlaps) */
+	char atomic_buf[PIPE_BUF];
+};
+
+#endif // _PROXYFS_PIPE_REAL_FILE_H_PROTECTED
+#endif //  PROXYFS_PIPE_REAL_FILE_PROTECTED
+
+/********************** PRIVATE METHODS AND DATA *********************************/
+#ifdef  PROXYFS_PIPE_REAL_FILE_PRIVATE
+#ifndef _PROXYFS_PIPE_REAL_FILE_H_PRIVATE
+#define _PROXYFS_PIPE_REAL_FILE_H_PRIVATE
+
+
+/** \<\<private\>\> Write to file from read buffer */
+static int proxyfs_pipe_real_file_write(struct proxyfs_real_file *self);
+
+/** \<\<private\>\> Reads from file and write to writte buffer */
+static int proxyfs_pipe_real_file_read(struct proxyfs_real_file *self);
+
+/** \<\<private\>\> "Open" file and send response message */
+static int proxyfs_pipe_real_file_open(struct proxyfs_real_file *self, struct proxyfs_peer_t *peer);
+
+/** \<\<private\>\> Duplicates file */
+static struct proxyfs_real_file* proxyfs_pipe_real_file_duplicate(struct proxyfs_real_file *self);
+
+
+/** <\<\private\>\> Structure with pointers to virtual methods */
+static struct proxyfs_real_file_ops pipe_real_file_ops = {
+	/** Reads from file and write to writte buffer */
+	.read = &proxyfs_pipe_real_file_read,
+	/** Write to file from read buffer */
+	.write = &proxyfs_pipe_real_file_write,
+	/** "Open" file and send response message */
+	.open = &proxyfs_pipe_real_file_open,
+	.duplicate = &proxyfs_pipe_real_file_duplicate,
+};
+
+#endif // _PROXYFS_PIPE_REAL_FILE_H_PRIVATE
+#endif //  PROXYFS_PIPE_REAL_FILE_PRIVATE
+
+/**
+ * @}
+ */
--- linux-3.7.1_original/clondike/src/proxyfs/proxyfs_client.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/proxyfs/proxyfs_client.c	2013-03-07 20:34:03.000000000 +0100
@@ -0,0 +1,449 @@
+/**
+ * @file proxyfs_client.c - proxyfs_client task.
+ *                      
+ * 
+ *
+ *
+ * Date: 08/12/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: proxyfs_client.c,v 1.10 2009-04-06 21:48:46 stavam2 Exp $
+ *
+ * This file is part of Proxy filesystem (ProxyFS)
+ * Copyleft (C) 2007 Petr Malat
+ * 
+ * ProxyFS is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * ProxyFS is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include <asm/uaccess.h>
+#include <linux/fs.h>
+
+#define PROXYFS_CLIENT_PROTECTED       // Own header
+#define PROXYFS_CLIENT_PRIVATE       // Own header
+#include "proxyfs_client.h"
+
+#define PROXYFS_PROXY_FILE_PROTECTED // Friend
+#include "proxyfs_proxy_file.h"
+#include "proxyfs_generic_proxy_file.h"
+#include "proxyfs_pipe_proxy_file.h"
+
+/** \<\<private\>\> Proxyfs client constructor 
+ * It's used by proxyfs_client_thread for data allocation and initialization 
+ *
+ * @return new proxyfs client class instance 
+ **/
+struct proxyfs_client_task* proxyfs_client_new(void)
+{
+	struct proxyfs_client_task *self;
+
+	self = (struct proxyfs_client_task*)kmalloc(sizeof(struct proxyfs_client_task), GFP_KERNEL);
+	if( self == NULL ){
+		mdbg(ERR2, "Allocating struct proxyfs_client failed");
+		return NULL;
+	}
+
+	proxyfs_task_init( PROXYFS_TASK(self) );
+
+	PROXYFS_TASK(self)->ops = &client_ops;
+
+	INIT_LIST_HEAD( & self->try_open );
+	INIT_LIST_HEAD( & self->try_open_send );
+	sema_init( & self->try_open_sem, 1 );
+	sema_init( & self->files_sem, 1 );
+
+	return self;
+}
+
+/** \<\<public\>\> This function is used as startup function for client thread
+ * @param start_struct - proxyfs task startup structure
+ */
+int proxyfs_client_thread(void *ss)
+{
+	struct proxyfs_client_task *self;
+	struct proxyfs_task_start_struct *start_struct = (struct proxyfs_task_start_struct *)ss;
+
+	if( (self = proxyfs_client_new()) == NULL )
+		goto exit0;
+
+	PROXYFS_TASK(self)->tsk = current;
+
+	//init_waitqueue_entry( &self.socket_wait, current );
+
+	if( (self->server = proxyfs_peer_new()) == NULL) {
+		mdbg(ERR2, "Failed to create a peer");
+		goto exit1;
+	}
+	
+	mdbg(INFO3, "Proxy fs client going to connect");
+
+	if( proxyfs_peer_connect( self->server, start_struct->addr_str) != 0 ) {
+		mdbg(ERR2, "Failed to connect a peer");
+		goto exit2;
+	}
+
+	kkc_sock_register_read_callback(self->server->sock, proxyfs_task_data_ready_callback, self);
+
+	mdbg(INFO3, "Proxy fs client connection wait");
+
+	if( proxyfs_peer_wait( self->server ) != 0 ) {
+		mdbg(ERR2, "Failed to wait for a peer");
+		goto exit3;
+	}
+
+	mdbg(INFO3, "Proxy fs client connected succesfully");
+
+	list_add(&self->server->peers, &PROXYFS_TASK(self)->peers );
+
+	proxyfs_task_complete( PROXYFS_TASK(self), start_struct ); // After this call *start_struct is invalid
+
+	proxyfs_client_loop(self);
+	return 0;
+
+exit3:
+	proxyfs_peer_disconnect(self->server);
+exit2:
+	proxyfs_peer_put(self->server);
+exit1:
+	proxyfs_task_put(PROXYFS_TASK(self));
+exit0:
+	mdbg(ERR2, "Failed to start client thread");
+	proxyfs_task_complete( NULL, start_struct );
+	return -EINVAL;
+}
+
+/** \<\<private\>\> Main client loop 
+ * @param self - pointer to proxyfs_client_task instance
+ **/
+void proxyfs_client_loop(struct proxyfs_client_task* self)
+{
+	while(!kthread_should_stop()){		
+		proxyfs_task_wait_for_data_ready(PROXYFS_TASK(self));
+		
+		down( & self->files_sem); // TODO: It may be nicer to make it more granual and lock only when needed, right? ;) At least add & remove must be locked
+		proxyfs_client_open_files( self );
+		proxyfs_task_send_buffers( PROXYFS_TASK(self) );
+		proxyfs_peer_real_send( self->server );
+		proxyfs_task_recv_peers( PROXYFS_TASK(self) );
+		up( & self->files_sem);
+
+		proxyfs_task_handle_dead_peers( PROXYFS_TASK(self) );		
+		
+		if ( !self->server ) {
+		    mdbg(ERR2, "Terminating client loop thread, peer is marked as dead");
+		    break;
+		}		  
+	}
+}
+
+/** \<\<private\>\> Send open message for all files submited to open since
+ * last execution of this method
+ *
+ * @param self - pointer to proxyfs_client_task instance
+ * */
+void proxyfs_client_open_files(struct proxyfs_client_task* self)
+{
+	struct proxyfs_file_t *proxy_file;
+	struct proxyfs_msg *msg;
+	struct list_head *p, *l;
+
+	down( & self->try_open_sem ); // Serialize access
+	list_for_each( l, &self->try_open ){
+		// up( & self.try_open_sem ); - list wouldn't be big
+
+		p = l->prev;
+		proxy_file = list_entry(l, struct proxyfs_file_t, files);
+		
+		msg = proxyfs_msg_new(MSG_OPEN, proxyfs_file_get_file_ident(proxy_file), 0, NULL );
+		
+		proxyfs_peer_send_msg( self->server, msg );
+		
+		list_move_tail(l, &self->try_open_send);
+		l = p;
+
+		// down( & self.try_open_sem );
+	}
+	up( & self->try_open_sem );
+}
+
+/** \<\<private\>\> Helper method that retrieves file by id either from open files or from "standard" files */
+static struct proxyfs_file_t* get_proxy_file_by_id(struct proxyfs_task *self, unsigned long identifier) {
+	struct proxyfs_file_t* proxy_file = NULL;
+
+	// First check in open files
+	proxy_file = proxyfs_file_find_in_list( identifier, &self->files );
+
+	if ( proxy_file == NULL ) // If not found in open files try in try open files
+		proxy_file = proxyfs_file_find_in_list( identifier, &PROXYFS_CLIENT_TASK(self)->try_open_send );
+
+	return proxy_file;
+}
+
+/** \<\<private\>\> Handle message specific for client
+ * @param self - pointer to proxyfs_client_task instance
+ * @param peer - peer struct with received message
+ * */
+void proxyfs_client_handle_msg(struct proxyfs_task *self, struct proxyfs_peer_t *peer)
+{
+	struct proxyfs_file_t *proxy_file;
+	struct proxyfs_msg *msg = proxyfs_peer_get_msg(peer);
+
+	switch( msg->header.msg_num ){
+		case MSG_OPEN_RESP_OK:
+			proxy_file = proxyfs_file_find_in_list( msg->header.file_ident, 
+					&PROXYFS_CLIENT_TASK(self)->try_open_send );
+			if( proxy_file != NULL ){
+				list_move_tail( &proxy_file->files, &self->files ); // Move to opened files
+				switch( msg->header.data[0] ){
+					case PROXYFS_FILE_TTY:
+					case PROXYFS_FILE_GENERIC:
+						mdbg(INFO2, "OPEN_OK: %lu is generic file or tty", 
+								msg->header.file_ident);
+						proxyfs_generic_proxy_file_from_proxy_file( 
+								PROXYFS_PROXY_FILE(proxy_file) );
+						break;
+					case PROXYFS_FILE_PIPE:
+						mdbg(INFO2, "OPEN_OK: %lu is pipe", msg->header.file_ident);
+						proxyfs_pipe_proxy_file_from_proxy_file( 
+								PROXYFS_PROXY_FILE(proxy_file) );
+						break;
+					default:
+						mdbg(ERR3, "OPEN_OK: Unknown file type, trying generic");
+						proxyfs_generic_proxy_file_from_proxy_file( 
+								PROXYFS_PROXY_FILE(proxy_file) );
+				}
+				proxyfs_file_set_peer(proxy_file, peer);
+				proxyfs_file_set_status( proxy_file, PROXYFS_FILE_OPENED );
+				wake_up( & PROXYFS_PROXY_FILE(proxy_file)->waiting_procs );
+				return;
+			}
+			mdbg(ERR3, "OPEN_OK: Unknown file identificator");
+			break;
+		case MSG_OPEN_RESP_FAILED:
+			proxy_file = proxyfs_file_find_in_list( msg->header.file_ident, 
+					&PROXYFS_CLIENT_TASK(self)->try_open_send );
+			if( proxy_file != NULL ){
+				list_del( & proxy_file->files ); // Delete from list
+				
+				proxyfs_file_set_status( proxy_file, PROXYFS_FILE_DONT_EXISTS  );
+				wake_up( & PROXYFS_PROXY_FILE(proxy_file)->waiting_procs );
+				return;
+			}
+			mdbg(ERR3, "OPEN_FAILED: Unknown file identificator");
+			break;
+		case MSG_IOCTL_RESP:
+			proxy_file = get_proxy_file_by_id(self, msg->header.file_ident);
+
+			if( proxy_file != NULL ){
+				*(PROXYFS_PROXY_FILE(proxy_file)->syscall_resp) = 
+					kmalloc( proxyfs_msg_get_size(msg), GFP_KERNEL );
+			       	if( *(PROXYFS_PROXY_FILE(proxy_file)->syscall_resp) != NULL ){
+					memcpy(*(PROXYFS_PROXY_FILE(proxy_file)->syscall_resp), msg, 
+							proxyfs_msg_get_size(msg)); 
+					PROXYFS_PROXY_FILE(proxy_file)->syscall_resp = NULL;
+				}
+				proxyfs_file_unset_status( proxy_file, PROXYFS_FILE_IN_SYSCALL );
+				wake_up( & PROXYFS_PROXY_FILE(proxy_file)->waiting_procs );
+				return;
+			}
+			mdbg(ERR3, "IOCTL_RESP: Unknown file identificator");
+			break;
+		case MSG_FSYNC_RESP:
+			proxy_file = get_proxy_file_by_id(self, msg->header.file_ident);
+
+			if( proxy_file != NULL ){
+				*(PROXYFS_PROXY_FILE(proxy_file)->syscall_resp) = (void*)MSG_FSYNC_RESP;
+				PROXYFS_PROXY_FILE(proxy_file)->syscall_resp = NULL;
+				proxyfs_file_unset_status( proxy_file, PROXYFS_FILE_IN_SYSCALL );
+				// Why would we want to remove from list here??? list_del( & proxy_file->files ); // Delete from list
+				wake_up( & PROXYFS_PROXY_FILE(proxy_file)->waiting_procs );
+				return;
+			}
+			mdbg(ERR3, "FSYNC_RESP: Unknown file identificator");
+			break;
+		case MSG_READ_REQUEST_RESP:
+			proxy_file = get_proxy_file_by_id(self, msg->header.file_ident);
+		
+			if( proxy_file != NULL ){
+				*(PROXYFS_PROXY_FILE(proxy_file)->syscall_resp) = (void*)MSG_READ_REQUEST_RESP;
+				PROXYFS_PROXY_FILE(proxy_file)->syscall_resp = NULL;
+				proxyfs_file_unset_status( proxy_file, PROXYFS_FILE_IN_SYSCALL );
+				wake_up( & PROXYFS_PROXY_FILE(proxy_file)->waiting_procs );
+				return;
+			}
+			mdbg(ERR3, "READ_REQUEST_RESP: Unknown file identificator: %lu", msg->header.file_ident);
+			break;
+		case MSG_CLOSE_RESP:
+			proxy_file = get_proxy_file_by_id(self, msg->header.file_ident);
+		
+			if( proxy_file != NULL ){
+				*(PROXYFS_PROXY_FILE(proxy_file)->syscall_resp) = (void*)MSG_CLOSE_RESP;
+				PROXYFS_PROXY_FILE(proxy_file)->syscall_resp = NULL;
+				proxyfs_file_unset_status( proxy_file, PROXYFS_FILE_IN_SYSCALL );
+				list_del( & proxy_file->files ); // Delete from list
+				wake_up( & PROXYFS_PROXY_FILE(proxy_file)->waiting_procs );
+				return;
+			}
+			mdbg(ERR3, "CLOSE_RESP: Unknown file identificator: %lu", msg->header.file_ident);
+			break;
+
+		default:
+			mdbg(ERR3, "Unknown msg number");
+	}
+
+}
+
+/** \<\<public\>\> Open new proxyfile - this is used by proxy_fs class
+ * @param self - pointer to proxyfs_client_task instance
+ * @param inode_num - unique file identification number
+ *
+ * @return Proxyfile or err ptr
+ */
+struct proxyfs_proxy_file_t *proxyfs_client_open_proxy(struct proxyfs_client_task* self, unsigned long inode_num){
+	struct proxyfs_proxy_file_t *proxy_file;
+
+	down( & self->files_sem);
+	proxy_file = PROXYFS_PROXY_FILE(get_proxy_file_by_id(PROXYFS_TASK(self), inode_num));
+	up( & self->files_sem);
+
+	if ( proxy_file ) {
+		mdbg(ERR3, "File is already open by the same task in this proxy client => cannot open once more!");
+		proxy_file = ERR_PTR(-EACCES);
+		goto exit0;		
+	}
+
+	proxy_file = (struct proxyfs_proxy_file_t *)kmalloc(sizeof(struct proxyfs_proxy_file_t), GFP_KERNEL);
+	if( proxy_file == NULL ){
+		mdbg(ERR3, "Allocating memory for proxy_file failed");
+		proxy_file = ERR_PTR(-ENOMEM);
+		goto exit0;
+	}
+
+	proxyfs_proxy_file_init(proxy_file); 
+	proxyfs_file_set_file_ident(PROXYFS_FILE(proxy_file), inode_num);
+	proxy_file->task = self;
+
+	down( & self->try_open_sem );
+	list_add_tail( & PROXYFS_FILE(proxy_file)->files, & self->try_open );
+	up( & self->try_open_sem );
+
+	mdbg(INFO3, "Proxyfile (file_ident=%lu) created and added to open queue", inode_num);
+	//proxyfs_task_wakeup(PROXYFS_TASK(self));
+	proxyfs_task_notify_data_ready(PROXYFS_TASK(self));
+
+	wait_event( proxy_file->waiting_procs, proxyfs_file_get_status( PROXYFS_FILE(proxy_file),
+			       PROXYFS_FILE_OPENED | PROXYFS_FILE_DONT_EXISTS ));
+
+	if( proxyfs_file_get_status( PROXYFS_FILE(proxy_file), PROXYFS_FILE_OPENED )){
+		mdbg(INFO3, "File opened");
+		return proxy_file;
+	}	
+
+	mdbg(INFO3, "File does not exists");
+	proxyfs_file_destroy(PROXYFS_FILE(proxy_file)); 
+
+	kfree( proxy_file );
+
+	proxy_file = ERR_PTR(-ENOENT);
+exit0:
+	return proxy_file;
+}
+
+static int check_syscall_done(struct proxyfs_proxy_file_t *file, struct proxyfs_peer_t* peer) {
+	int cond = ( !proxyfs_file_get_status( PROXYFS_FILE(file), PROXYFS_FILE_IN_SYSCALL) || 
+          (proxyfs_peer_get_state(peer) != PEER_CONNECTED));	
+
+	mdbg(INFO3, "File cond: %d.. ident: %lu... peer state: %d", cond, proxyfs_file_get_file_ident(PROXYFS_FILE(file)), proxyfs_peer_get_state(peer) );
+
+	return cond;
+};
+
+/** \<\<public\>\> Forward a syscall on file 
+ * @param *self - pointer to proxyfs_client_task instance
+ * @param *file - pointer to proxy file. System call will by called on coresponding real file.
+ * @param *msg  - pointer t system call messagge
+ *
+ * @return response messagge or NULL on error
+ */
+struct proxyfs_msg *proxyfs_client_do_syscall(struct proxyfs_client_task *self, 
+		struct proxyfs_proxy_file_t *file, struct proxyfs_msg *msg)
+{
+	struct proxyfs_msg *msg_resp = NULL;
+	struct proxyfs_peer_t* peer;
+
+	peer = PROXYFS_FILE(file)->peer;
+	file->syscall_resp = &msg_resp;
+	// TODO: Does this handle case of multiple simultaneous sys_calls? Not likely..
+	proxyfs_file_set_status( PROXYFS_FILE(file), PROXYFS_FILE_IN_SYSCALL );
+	proxyfs_peer_send_msg( peer , msg );	
+	proxyfs_task_notify_data_ready(PROXYFS_TASK(self));
+	
+	wait_event( file->waiting_procs, check_syscall_done(file, peer) );
+
+	mdbg(INFO3, "File syscall finished");
+
+	return msg_resp;
+}
+
+/** \<\<public\>\> Asynchronously sends a message */
+void proxyfs_client_send_message(struct proxyfs_client_task *self, 
+		struct proxyfs_proxy_file_t *file, struct proxyfs_msg *msg) {
+	struct proxyfs_peer_t* peer;
+
+	peer = PROXYFS_FILE(file)->peer;
+	proxyfs_peer_send_msg( peer , msg );	
+}
+
+
+static void proxyfs_client_handle_dead_peer(struct proxyfs_task* self, struct proxyfs_peer_t* peer) {
+	struct proxyfs_file_t *proxy_file;
+	struct list_head *tmp, *l;
+
+	mdbg(INFO1, "Client handling dead peer");
+
+	// We cannot release proxy files directly in here as they are held by other processes
+	// Instead, we just wake them all up in order to prevent all waiter to be stuck
+	// All following calls to the files won't block, because state of the peer won't be connected any more
+	list_for_each_safe( l, tmp, &self->files ) {
+		proxy_file = list_entry(l, struct proxyfs_file_t, files);
+
+		if ( proxy_file->peer == peer ) {
+			list_del( &proxy_file->files );
+			mdbg(INFO3, "Waking up file: %lu", proxyfs_file_get_file_ident(proxy_file));
+			wake_up( & PROXYFS_PROXY_FILE(proxy_file)->waiting_procs );
+		}
+		
+	}
+	
+	if ( PROXYFS_CLIENT_TASK(self)->server == peer ) {
+	    PROXYFS_CLIENT_TASK(self)->server = NULL;
+	} else {
+	    mdbg(ERR1, "Unexpected peer death being handled. Server was %p, but peer %p", PROXYFS_CLIENT_TASK(self)->server, peer);
+	}
+	  
+
+	mdbg(INFO1, "Client handling dead peers done");
+}
+
+static void proxyfs_client_free(struct proxyfs_task* self) {
+	mdbg(INFO1, "Freeing proxy client");
+
+/* Do not free peer direcly, it will be freed while freeing all peers of task
+	if ( client_self->server ) {
+		proxyfs_peer_disconnect(client_self->server);
+		proxyfs_peer_destroy(client_self->server);
+	}	
+*/
+	mdbg(INFO1, "Specific freeing proxy client finished");
+}
--- linux-3.7.1_original/clondike/src/proxyfs/proxyfs_fs_helper.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/proxyfs/proxyfs_fs_helper.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,13 @@
+static inline int my_atoi(const char *buf, const int len, unsigned long *num){
+	int i;
+	*num = 0;
+
+	for( i = 0; i < len; i++ ){
+		if( buf[i] <= '9' && buf[i] >= '0' ){
+			*num *= 10;
+			*num += buf[i] - '0';
+		}
+		else return -1;
+	}
+	return 0;
+}
--- linux-3.7.1_original/clondike/src/proxyfs/proxyfs_task.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/proxyfs/proxyfs_task.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,470 @@
+/**
+ * @file proxyfs_task.c - proxyfs task.
+ *                      
+ * 
+ *
+ *
+ * Date: 08/12/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: proxyfs_task.c,v 1.10 2008/05/05 19:50:44 stavam2 Exp $
+ *
+ * This file is part of Proxy filesystem (ProxyFS)
+ * Copyleft (C) 2007 Petr Malat
+ * 
+ * ProxyFS is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * ProxyFS is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include <asm/uaccess.h>
+#include <linux/fs.h>
+#include <linux/jiffies.h>
+
+#define PROXYFS_TASK_PROTECTED
+#define PROXYFS_TASK_PRIVATE    // Own header
+#include "proxyfs_task.h"
+
+#define PROXYFS_TASK_PROTECTED  // Friend
+#include "proxyfs_peer.h"
+
+#define PROXYFS_FILE_PROTECTED  // Friend
+#include "proxyfs_file.h"
+
+
+/** \<\<public\>\> Run new task 
+ * @param *func - pointer to thread function (proxyfs_client_thread or proxyfs_server_thread)
+ * @param *addr_str - server address for listenning or to connect to
+ *
+ * @return new task or NULL on error
+ */
+struct proxyfs_task *proxyfs_task_run( int(*func)(void*), const char *addr_str )
+{
+	struct proxyfs_task_start_struct start_struct;
+	start_struct.addr_str = addr_str;
+	init_completion( & start_struct.startup_done );
+
+	if( kthread_run( func, (void*)&start_struct, "ProxyFS %s", addr_str ) == ERR_PTR(-ENOMEM) )
+		return NULL;
+	wait_for_completion( & start_struct.startup_done );
+	return start_struct.task;
+}
+
+/** \<\<protected\>\> This is used by thread func, to tell caller, that we are ready with inicialization 
+ * @param *self - pointer to self instance or NULL
+ * @param *start_struct - proxyfs_thread_start_struct* that was used as thread parameter
+ */ 
+void proxyfs_task_complete(struct proxyfs_task *self, struct proxyfs_task_start_struct *start_struct)
+{
+	start_struct->task = self;
+	complete( & start_struct->startup_done ); // After this call *start_struct is invalid
+}
+
+/** Get reference and increase reference counter 
+ * @param *self - pointer to self instance
+ * 
+ * @return reference to proxyfs_task
+ */
+struct proxyfs_task* proxyfs_task_get(struct proxyfs_task* task) {
+	if ( task )
+		atomic_inc(&task->ref_count);
+
+	return task;
+}
+
+/** Releases reference and if it was the last reference, frees the task 
+ * @param *self - pointer to self instance
+ *
+ * */
+void proxyfs_task_put(struct proxyfs_task* task) {
+	if ( !task )
+		return;
+
+	if (atomic_dec_and_test(&task->ref_count)) {
+		mdbg(INFO3, "Destroying proxy task: %p", task);
+		proxyfs_task_free(task);
+		kfree(task);
+	}
+}
+
+/** \<\<public\>\> Initialize task 
+ * @param *self - pointer to self instance
+ *
+ * @return zero on success
+ * */
+int proxyfs_task_init(struct proxyfs_task *self)
+{
+	INIT_LIST_HEAD( & self->files );
+	INIT_LIST_HEAD( & self->peers );
+	self->ops = NULL;
+	atomic_set(&self->ref_count, 1);
+
+	self->data_ready = 0;
+	spin_lock_init(&self->data_ready_lock);
+	init_waitqueue_head( & self->data_ready_wait );
+
+	mdbg(INFO3, "Created proxy task: %p Current: %p", self, current);
+
+	return 0;
+}
+
+/** \<\<public\>\> Notifies task that there are data ready (either for writing/reading/both) */
+void proxyfs_task_notify_data_ready(struct proxyfs_task *self) {	
+	unsigned long flags;
+
+	spin_lock_irqsave(&self->data_ready_lock, flags);
+	self->data_ready = 1;
+	spin_unlock_irqrestore(&self->data_ready_lock,flags);
+	
+	wake_up( &self->data_ready_wait );
+	mdbg(INFO3, "Task: %p Data ready done", self);
+}
+
+/** Callback function that should be registered to all associated sockets. It will notify task about pending data to be read */
+void proxyfs_task_data_ready_callback(void* data, int bytes) {
+	struct proxyfs_task* self = data;
+	
+	mdbg(INFO3, "Task: %p Data arrived: %d", self, bytes);
+	proxyfs_task_notify_data_ready(self);
+}
+
+/**
+ * This method will wait till there are some data ready to be read, or the thread is requested to stop.
+ */
+void proxyfs_task_wait_for_data_ready(struct proxyfs_task* self) {
+	unsigned long flags;
+	// TODO: There is 100ms timeout.. it seems we are missing some events still.. I suspect it is file data ready event
+	// When we solve this, remove this timeout, it should not be required.. but can be kept as a "fallback" bulgarian fix
+	wait_event_timeout( self->data_ready_wait, self->data_ready || kthread_should_stop(), msecs_to_jiffies(100));
+
+	// Note: Here we assume, that all already arrived data will be read before next wait call. 
+	// If this is not the case, the mechanism must be changed
+	spin_lock_irqsave(&self->data_ready_lock, flags);
+	self->data_ready = 0;
+	spin_unlock_irqrestore(&self->data_ready_lock, flags);
+}
+
+/** \<\<protected\>\> Releases task files.. in fact they all should be already release we do just a consistency check at this place
+ * @param *self - pointer to self instance
+ */
+void proxyfs_task_release_files(struct list_head *files) {
+	struct list_head *l;
+	struct proxyfs_file_t *proxy_file;
+
+	list_for_each( l, files ) {
+		proxy_file = list_entry(l, struct proxyfs_file_t, files);
+
+		if ( !proxyfs_file_get_status( proxy_file, PROXYFS_FILE_CLOSED ) ) {
+			mdbg(WARN3, "Proxy file not closed on release: %lu", proxyfs_file_get_file_ident(proxy_file));
+		}
+		
+	}	
+}
+
+
+/** \<\<protected\>\> Releases task resources 
+ * @param *self - pointer to self instance
+ */
+void proxyfs_task_free(struct proxyfs_task* self) {
+	struct list_head *l, *nxt;
+	struct proxyfs_peer_t *peer;
+
+	// First stop the processing thread
+	int result;
+	if ( current == self->tsk ) { // Special case when we are invoked from the proxyfs task thread directly
+		result = -EINVAL;
+		mdbg(INFO3, "Failed to startup proxyfs task listening => release it");
+	} else {
+		mdbg(INFO3, "Proxy task requesting thread stop");
+		result = kthread_stop(self->tsk);
+	}
+
+	mdbg(INFO3, "Proxy task kthread stop result: %d Task: %p", result, self->tsk);
+
+	if ( result )
+		return;
+
+	// Process custom freeing	
+	if ( self->ops && self->ops->free )
+		self->ops->free(self);
+
+	// TODO: We can do this also in client free for open&open send files, right?
+	proxyfs_task_release_files(&self->files);
+
+	// Finally free all peers (we do this after custom free as custom free will first stop possible server listening)
+	list_for_each_safe( l, nxt, &self->peers ){
+		peer = list_entry(l, struct proxyfs_peer_t, peers);
+		proxyfs_peer_disconnect(peer);
+		proxyfs_peer_put(peer);	
+	}
+}
+
+
+/** \<\<protected\>\> Try to receive data from all peers 
+ * @param *self - pointer to self instance
+ */
+void proxyfs_task_recv_peers(struct proxyfs_task *self)
+{
+	struct list_head *l;
+	struct proxyfs_peer_t *peer;
+	int recv_res;
+
+	list_for_each( l,  &self->peers ){
+		peer = list_entry(l, struct proxyfs_peer_t, peers);
+recv_next:	recv_res = proxyfs_peer_real_recv(peer);
+		if ( recv_res == 1 ){ // Message received
+			mdbg(INFO3, "Message received");
+			proxyfs_task_handle_msg( self, peer );
+			proxyfs_peer_clear_msg(peer);
+			// Consider adding protection from receiving from only one peer
+			goto recv_next;
+		} else if ( recv_res == -ECONNRESET || recv_res == -ECONNABORTED ) {
+			// TODO: Some nicer general solution for removing (and detecting) lost peers.. but for now we need at least this
+			proxyfs_peer_set_state(peer, PEER_DEAD);
+			mdbg(INFO1, "Peer marked dead");
+		} else if (recv_res == -EAGAIN ) {
+			// Do nothing, repeat
+		} else {
+			mdbg(INFO1, "Unknown return code: %d", recv_res);
+		}
+
+	}
+}
+
+/** \<\<protected\>\> Try to send data to all peers 
+ * @param *self - pointer to self instance
+ */
+void proxyfs_task_send_peers(struct proxyfs_task *self)
+{
+	struct list_head *l;
+	struct proxyfs_peer_t *peer;
+
+	list_for_each( l, &self->peers ){
+		peer =  list_entry(l, struct proxyfs_peer_t, peers);
+		proxyfs_peer_real_send(peer);
+	}
+}
+
+/**
+ * Iterates over all peers and if the peer is marked as dead, handle its removal
+ *
+ */
+void proxyfs_task_handle_dead_peers(struct proxyfs_task *self) {
+	struct list_head *l, *tmp;
+	struct proxyfs_peer_t *peer;
+	//int recv_res;
+
+	list_for_each_safe( l, tmp, &self->peers ){
+		peer = list_entry(l, struct proxyfs_peer_t, peers);
+		if ( proxyfs_peer_get_state(peer) == PEER_DEAD ) {
+			mdbg(INFO2, "Removing dead peer %s (%p)", kkc_sock_getpeername2(peer->sock), peer);
+			list_del(l);
+			proxyfs_peer_disconnect(peer);
+			if ( self->ops && self->ops->handle_peer_dead )
+				self->ops->handle_peer_dead(self, peer);			
+			proxyfs_peer_put(peer);				
+		}
+	}
+};
+
+/** \<\<protected\>\> Handle receive messagge 
+ * @param *self - pointer to self instance
+ * @param *peer - peer instance with message we wanted to handle
+ */
+void proxyfs_task_handle_msg(struct proxyfs_task *self, struct proxyfs_peer_t *peer)
+{
+	struct proxyfs_file_t *file;
+	struct proxyfs_msg *msg = proxyfs_peer_get_msg(peer);
+	if ( !msg ) // Case, when we had incomplete message in the buffer
+		return;
+
+	mdbg(INFO1, "Msg for identifier has arrived: %lu",msg->header.file_ident);
+
+	switch( msg->header.msg_num ){
+		case MSG_WRITE_RESP:
+			if(( file = proxyfs_task_find_file(self, msg->header.file_ident)) != NULL){
+				if( msg->header.data[0] <= 0 ){
+					mdbg(ERR3, "Read must be > 0 but it is %lu", (unsigned long)msg->header.data[0]);
+					break;
+				}
+				else{
+					mdbg(INFO3, "Peer reads %lu bytes from file %lu buffer", 
+							(unsigned long)msg->header.data[0], proxyfs_file_get_file_ident(file));
+					/*if( self->ops && self->ops->file_read )
+						self->ops->file_read(file, msg->header.data[0]);*/
+					proxyfs_file_submit_read_to_peer( file, msg->header.data[0]);
+					break;
+				}
+			}
+			mdbg(ERR3, "WRITE_RESP: Unknown file identificator %lu", msg->header.file_ident);
+			break;
+		case MSG_WRITE:
+			if(( file = proxyfs_task_find_file(self, msg->header.file_ident)) != NULL){
+				mdbg(INFO3, "Peer writes %lu bytes to file %lu", msg->header.data_size, proxyfs_file_get_file_ident(file));
+
+				if( msg->header.data_size >= 0 ){
+					proxyfs_file_write_from_peer( file, (void*)msg->header.data, msg->header.data_size);
+				}
+				break;
+			}
+			mdbg(ERR3, "WRITE: Unknown file identificator %lu", msg->header.file_ident);
+			break;
+		default:
+			mdbg(INFO3, "Calling task specific msg handler");
+			if( self->ops && self->ops->handle_msg )
+				self->ops->handle_msg(self, peer);
+	}
+
+	// Do not free message here. Incoming messages are kept only in rcv buffer and the buffer is always reused, so no need to free
+}
+
+/** \<\<protected\>\> Try to create new messages from data in all file buffers
+ * @param *self - pointer to self instance
+ */
+void proxyfs_task_send_buffers(struct proxyfs_task *self)
+{
+	struct proxyfs_file_t *proxy_file;
+	struct list_head *l;
+	int res;
+
+	list_for_each( l, &self->files ){
+		proxy_file = list_entry(l, struct proxyfs_file_t, files);
+
+		// Send as long as there are some data
+		// We can consider some "starvation" prevention here. In this case, we have to notify task about "data_ready" if we do not send all data, so that we ensure a next iteration in a main processing loop is started
+		while ( (res = proxyfs_task_send_write_buf( self, proxy_file )) == -EAGAIN ) {};
+	}
+}
+
+
+/** \<\<protected\>\> Try to create new messages from data in buffer
+ * @param *self - pointer to self instance
+ * @param *file - proxyfs_file instance which data we wanted to send
+ * @return 0, if all required data were written, -EAGAIN if there are still some pending data
+ */
+int proxyfs_task_send_write_buf(struct proxyfs_task *self, struct proxyfs_file_t *file)
+{
+	struct proxyfs_msg *msg;
+	size_t total_size, data_size, send;
+	void *data_ptr;
+	char* read_buffer = NULL;
+	int res = 0;
+
+        mdbg(INFO3, "Proccessing file %lu", proxyfs_file_get_file_ident(file));
+
+	if( file->peer == NULL ){
+        	mdbg(INFO3, "No peer, skiping");
+		return 0;
+	}
+
+	proxyfs_file_write_buf_info(file, &total_size, &data_size, &data_ptr);
+        mdbg(INFO3, "(Total size %lu, Data size %lu, Data addr %p, Unconfirmed size %lu)", (unsigned long)total_size, (unsigned long)data_size, data_ptr, (unsigned long)file->write_buf_unconfirmed);
+
+	send = total_size - file->write_buf_unconfirmed;
+	if ( send == 0 )
+		return 0;
+
+	if( send > MSG_MAX_SIZE - MSG_HDR_SIZE ) {
+		send = MSG_MAX_SIZE - MSG_HDR_SIZE;
+		res = -EAGAIN;
+	}
+
+	read_buffer = kmalloc(send, GFP_KERNEL);
+	if ( !read_buffer )
+		goto exit0;
+
+	send = proxyfs_file_read_to_peer(file, read_buffer, send);
+	mdbg(INFO3, "Real send size: %lu", (unsigned long)send);
+	if ( send == 0 ) 
+		goto exit0;
+
+	msg = proxyfs_msg_new_takeover_ownership(MSG_WRITE, proxyfs_file_get_file_ident(file), send, read_buffer);
+	if ( !msg )
+		goto exit0;
+		
+	proxyfs_peer_send_msg( file->peer, msg );
+
+	return res;
+
+exit0:
+	kfree(read_buffer);
+	return -ENOMEM;
+/*
+	
+
+        mdbg(INFO3, "(Data size %lu, Data addr %p, Unconfirmed size %lu)", (unsigned long)data_size, data_ptr, (unsigned long)file->write_buf_unconfirmed);
+
+	if( data_size > file->write_buf_unconfirmed ){
+		if( data_size - file->write_buf_unconfirmed > MSG_MAX_SIZE - MSG_HDR_SIZE )
+			send = MSG_MAX_SIZE - MSG_HDR_SIZE;
+		else
+			send = data_size - file->write_buf_unconfirmed;
+        	mdbg(INFO3, "Data pending for file %lu (%d bytes at %p)(%d)", 
+				file->file_ident, data_size, data_ptr, file->write_buf_unconfirmed);
+
+		msg = proxyfs_msg_new(MSG_WRITE, file->file_ident, send, data_ptr + file->write_buf_unconfirmed );
+
+        	mdbg(INFO3, "Message created %p", msg); 
+		if ( file->peer ) {
+			proxyfs_peer_send_msg( file->peer, msg );
+			file->write_buf_unconfirmed += send;
+		} else {
+			mdbg(INFO3, "Msg ignored, peer NULL"); // TODO: Where is the msg free?
+		}		
+	}
+*/
+}
+
+/** \<\<public\>\> Wake up task 
+ * @param *self - pointer to self instance
+ */
+void proxyfs_task_wakeup(struct proxyfs_task *self){
+	if( current == self->tsk )
+		set_current_state(TASK_RUNNING);
+	else
+		wake_up_process(self->tsk);
+}
+
+/** \<\<private\>\> Create new peer from socket and add it to peers list
+ * @param *self - pointer to self instance
+ * @param *peer_sock - peer socket instance
+ *
+ * @return new proxyfs_peer instance or NULL on error
+ */
+struct proxyfs_peer_t* proxyfs_task_add_to_peers(struct proxyfs_task *self, struct kkc_sock *peer_sock){
+	struct proxyfs_peer_t *peer;
+	
+	if((peer = proxyfs_peer_new() ) == NULL){
+                mdbg(ERR2, "Couldn't add socket to peers");
+		return NULL;
+	}
+
+	peer->sock = peer_sock;
+	list_add( &peer->peers, &self->peers );
+
+	return peer;
+}
+
+struct proxyfs_file_t *proxyfs_task_find_file(struct proxyfs_task *task, unsigned long ident) 
+{
+	struct proxyfs_file_t *file = NULL;       
+	struct list_head *l;                      
+	list_for_each( l, &((task)->files) ){
+		mdbg(INFO3, "Checking file with id %lu", proxyfs_file_get_file_ident(list_entry(l, struct proxyfs_file_t, files)) );
+		if( proxyfs_file_get_file_ident(list_entry(l, struct proxyfs_file_t, files)) == (ident) ){ 
+			file = list_entry(l, struct proxyfs_file_t, files); 
+			break;			  
+		}                                 
+	}                                         
+	return file;
+}
--- linux-3.7.1_original/clondike/src/proxyfs/proxyfs_msg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/proxyfs/proxyfs_msg.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,198 @@
+/**
+ * @file proxyfs_msg.c - Proxyfs messages.
+ *                      
+ * 
+ *
+ *
+ * Date: 08/12/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: proxyfs_msg.c,v 1.4 2007/10/20 14:24:20 stavam2 Exp $
+ *
+ * This file is part of Proxy filesystem (ProxyFS)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * ProxyFS is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * ProxyFS is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <asm/uaccess.h>
+#include <kkc/kkc.h>
+
+#define PROXYFS_MSG_PRIVATE
+#include "proxyfs_msg.h"
+
+/** Maximum message size */
+
+
+
+static struct proxyfs_msg *proxyfs_msg_new_internal(unsigned long msg_num, 
+		unsigned long file_ident, unsigned long data_size, void *data_ptr, int take_ownership)
+{
+	struct proxyfs_msg *msg;
+
+	if( data_size > MSG_MAX_SIZE - MSG_HDR_SIZE ){
+		mdbg(ERR3, "Data too long");
+		return NULL;
+	}
+
+	msg = (struct proxyfs_msg *)kmalloc( sizeof(struct proxyfs_msg), GFP_KERNEL );
+	if( msg == NULL ){
+		mdbg(ERR3, "Proxyfs message allocation failed");
+		return NULL;
+	}
+
+	msg->header.magic = MSG_MAGIC;
+	msg->header.msg_num = msg_num;
+	msg->header.file_ident = file_ident;
+	msg->header.data_size = data_size;
+
+	msg->free = take_ownership;
+	msg->data = data_ptr;
+	msg->send_start = 0;
+
+	return msg;
+}
+
+/** \<\<public\>\> Proxyfs message constructor 
+ * @param msg_num - Message type identifikator
+ * @param file_ident - File identifikator 
+ * @param data_size - size of data which will be send after header
+ * @param data_ptr - pointer to data
+ *
+ * @return new message or NULL on error
+ */
+struct proxyfs_msg *proxyfs_msg_new(unsigned long msg_num, 
+		unsigned long file_ident, unsigned long data_size, void *data_ptr)
+{
+	return proxyfs_msg_new_internal(msg_num, file_ident, data_size, data_ptr, 0);
+}
+
+/** \<\<public\>\> Proxyfs message constructor. In this version the message takes ownership of the data */
+struct proxyfs_msg *proxyfs_msg_new_takeover_ownership(unsigned long msg_num, 
+		unsigned long file_ident, unsigned long data_size, void *data_ptr) {
+	return proxyfs_msg_new_internal(msg_num, file_ident, data_size, data_ptr, 1);
+}
+
+
+/** \<\<public\>\> Proxyfs message constructor 
+ * @param msg_num - Message type identifikator
+ * @param file_ident - File identifikator 
+ * @param ... - size of the first arg., pointer to the first arg., size of the second arg. 
+ * pointer to the second arg. etc... ended by 0
+ *
+ * @return new message or NULL on error
+ */
+struct proxyfs_msg *proxyfs_msg_compose_new(unsigned long msg_num, 
+		unsigned long file_ident, ... )
+{
+	struct proxyfs_msg *msg;
+	va_list args;
+	size_t msg_size, element_size;
+
+	msg = (struct proxyfs_msg *)kmalloc( sizeof(struct proxyfs_msg), GFP_KERNEL );
+	if( msg == NULL ){
+		mdbg(ERR3, "Proxyfs message allocation failed");
+		goto exit0;
+	}
+
+	va_start(args, file_ident);
+	for(msg_size = 0; (element_size = va_arg(args, u_int32_t)) != 0; va_arg(args, void*)) {
+		msg_size += element_size;
+	}
+	va_end(args);
+
+	if( (msg->data = kmalloc( msg_size, GFP_KERNEL ) ) == NULL ){
+		mdbg(ERR3, "Memory allocation for data (%lu bytes)  failed", (unsigned long)msg_size);
+		goto exit1;
+	}
+
+	va_start(args, file_ident);
+	for(msg_size = 0; (element_size = va_arg(args, u_int32_t)) != 0; msg_size += element_size ) {
+		void* from_pointer = va_arg(args, void*);
+		mdbg(INFO3, "Appending argument on post %lu. Arg size: %lu", (unsigned long)msg_size, (unsigned long)element_size);
+		memcpy( msg->data + msg_size, from_pointer, element_size );		
+	}
+	va_end(args);
+
+	msg->header.magic = MSG_MAGIC;
+	msg->header.msg_num = msg_num;
+	msg->header.file_ident = file_ident;
+	msg->header.data_size = msg_size;
+
+	msg->free = 1;
+	msg->send_start = 0;
+
+	return msg;
+exit1:
+	kfree(msg);
+exit0:
+	return NULL;
+}
+
+/** \<\<public\>\> Send message to socket 
+ * @param self - pointer to proxyfs_msg instance
+ * @param sock - socket used for sending
+ *
+ * @return 1 if the message was completely send
+ * */
+int proxyfs_msg_real_send(struct proxyfs_msg *self, struct kkc_sock *sock)
+{
+	int msg_size;
+	int result;
+
+	msg_size = proxyfs_msg_get_size( self );
+
+	mdbg(INFO3, "Sending message %lu for file %lu size %d peer_name %s;", 
+		self->header.msg_num, self->header.file_ident, msg_size,
+		kkc_sock_getpeername2(sock));
+
+	if( self->send_start < MSG_HDR_SIZE ){ // Header hasn't been send yet
+		result = kkc_sock_send( sock, self + self->send_start,
+		       	MSG_HDR_SIZE - self->send_start, KKC_SOCK_NONBLOCK);
+		if( result > 0 ){
+			mdbg(INFO3, "Send %d bytes", result); 
+			self->send_start += result;
+		}
+		else
+			return result;
+	}
+	if( self->send_start >= MSG_HDR_SIZE ){ // Header has been send 
+		if( self->send_start == msg_size )
+			return 1; // Message send
+		result = kkc_sock_send( sock, self->data + self->send_start - MSG_HDR_SIZE,
+		       	msg_size - self->send_start, KKC_SOCK_NONBLOCK);
+		if( result > 0 ){
+			mdbg(INFO3, "Send %d bytes", result); 
+			self->send_start += result;
+			if( self->send_start == msg_size )
+				return 1; // Message send
+		}
+		else
+			return result;
+	}
+	return 0;
+
+}
+
+/** \<\<public\>\> Releases a message instance */
+void proxyfs_msg_destroy(struct proxyfs_msg* self) {	
+	if ( self->free ) {
+		mdbg(INFO3, "Destroying message data: %p (Size: %lu)", self->data, self->header.data_size); 
+		kfree(self->data);
+	}
+	mdbg(INFO3, "Destroying message: %p", self); 	
+	kfree(self);
+};
--- linux-3.7.1_original/clondike/src/proxyfs/buffer.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/proxyfs/buffer.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,195 @@
+/**
+ * @file buffer.c - Class representing circullar buffer.
+ *                      
+ * 
+ *
+ *
+ * Date: 08/12/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: buffer.c,v 1.4 2008/05/02 19:59:20 stavam2 Exp $
+ *
+ * This file is part of Proxy filesystem (ProxyFS)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * ProxyFS is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * ProxyFS is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <linux/vmalloc.h>
+#include <linux/slab.h>
+#include <asm/uaccess.h>
+#include <dbg.h>
+
+#define BUFFER_PRIVATE
+#include "buffer.h"
+
+/** \<\<public\>\> Write to buffer 
+ * @param self - pointer to this buffer instance
+ * @param buf - pointer to data, which will be written
+ * @param count - data size
+ *
+ * @return amount of bytes written 
+ */
+int circ_buf_write(struct circ_buf *self, const char *buf, unsigned count)
+{
+	unsigned wrs;
+	wrs = circ_buf_get_write_size(self);
+	if(wrs){
+		if( count < wrs ){
+			memcpy( circ_buf_get_write_addr(self), buf, count );
+			circ_buf_adjust_write_ptr(self, count);
+			return count;
+		}
+		else{
+			memcpy( circ_buf_get_write_addr(self), buf, wrs );
+			circ_buf_adjust_write_ptr(self, wrs);
+			return wrs + circ_buf_write( self, buf + wrs, count - wrs );
+		}
+	}
+	return 0;
+}
+
+/** \<\<public\>\> Write to buffer from user space 
+ * @param self - pointer to this buffer instance
+ * @param buf - pointer to data in userspace, which will be written
+ * @param count - data size
+ *
+ * @return amount of bytes written 
+ */
+int circ_buf_write_user(struct circ_buf *self, const char *buf, unsigned count)
+{
+	unsigned wrs;
+	void *ptr;
+	wrs = circ_buf_get_write_size(self);
+	if(wrs){
+		if( count < wrs ){
+			ptr = circ_buf_get_write_addr(self);
+			if ( __copy_from_user( ptr, buf, count ) )
+				return -EFAULT;
+			circ_buf_adjust_write_ptr(self, count);
+			return count;
+		}
+		else{
+			ptr = circ_buf_get_write_addr(self);
+			if ( __copy_from_user( ptr, buf, wrs ) )
+				return -EFAULT;
+			circ_buf_adjust_write_ptr(self, wrs);
+			return wrs + circ_buf_write_user( self, buf + wrs, count - wrs );
+		}
+	}
+	return 0;
+}
+
+/** \<\<public\>\> Destructively read from buffer 
+ * @param self - pointer to this buffer instance
+ * @param buf - pointer to memory in which will be data written
+ * @param count - maximum data size. Can be actually more than current content size of buffer, in this case less bytes are read
+ *
+ * @return amount of bytes read 
+ */
+int circ_buf_read(struct circ_buf *self, char *buf, unsigned count)
+{
+	unsigned rs;
+	unsigned maximum_size = circ_buf_count(self);
+	if ( count > maximum_size )
+		count = maximum_size;
+
+	rs = circ_buf_get_read_size(self);
+	if(rs){
+		if( count < rs ){
+			memcpy( buf, circ_buf_get_read_addr(self), count );
+			circ_buf_adjust_read_ptr(self, count);
+			return count;
+		}
+		else{
+			memcpy( buf, circ_buf_get_read_addr(self), rs );
+			circ_buf_adjust_read_ptr(self, rs);
+			return rs + circ_buf_read( self, buf + rs, count - rs );
+		}
+	}
+	return 0;
+}
+
+/** \<\<public\>\> Destructively read from buffer to userspace
+ * @param self - pointer to this buffer instance
+ * @param buf - pointer to memory in which will be data written
+ * @param count - maximum data size
+ *
+ * @return amount of bytes read 
+ */
+int circ_buf_read_user(struct circ_buf *self, char *buf, unsigned count)
+{
+	unsigned rs;
+	unsigned maximum_size = circ_buf_count(self);
+	if ( count > maximum_size )
+		count = maximum_size;
+
+	rs = circ_buf_get_read_size(self);
+	if(rs){
+		if( count < rs ){
+			if ( __copy_to_user( buf, circ_buf_get_read_addr(self), count ) )
+				return -EFAULT;
+			circ_buf_adjust_read_ptr(self, count);
+			return count;
+		}
+		else{
+			if ( __copy_to_user( buf, circ_buf_get_read_addr(self), rs ) )
+				return -EFAULT;
+			circ_buf_adjust_read_ptr(self, rs);
+			return rs + circ_buf_read_user( self, buf + rs, count - rs );
+		}
+	}
+	return 0;
+}
+
+
+
+/** \<\<public\>\> Nondestructively read from buffer at offset 
+ * @param self - pointer to this buffer instance
+ * @param buf - pointer to memory in which will be data written
+ * @param count - maximum data size. Can be actually more than current content size of buffer, in this case less bytes are read
+ * @param offset - read offset
+ *
+ * @return amount of bytes read 
+ */
+int circ_buf_look_at(struct circ_buf *self, char *buf, unsigned count, size_t offset)
+{
+	int rs;
+	void *read = self->read;
+	int full = self->full;
+
+	circ_buf_adjust_read_ptr(self, offset);
+
+	rs = circ_buf_read(self, buf, count);
+
+	self->read = read;
+	self->full = full;
+	return rs;
+}
+
+/** \<\<public\>\> Method used for debugging purposes. Dumps content of a circular buffer to debug output */
+void circ_buf_dump(const char* prefix, struct circ_buf *self) {
+	if ( debug_enabled ) {
+		// Size till overlap
+		int read_size = circ_buf_get_read_size(self);
+		// Maximum read size
+		unsigned maximum_read_size = circ_buf_count(self);
+		mdbg(INFO3, "%s First part content (%d) %.*s.", prefix, (int)read_size, (int)read_size, (char*)circ_buf_get_read_addr(self));
+		if ( read_size < maximum_read_size ) {
+			mdbg(INFO3, "%s Second part content (%d) %.*s.", prefix, (int)maximum_read_size-read_size, (int)maximum_read_size-read_size, (char*)self->buf);
+		}
+	}
+}
--- linux-3.7.1_original/clondike/src/proxyfs/proxyfs_ioctl_table.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/proxyfs/proxyfs_ioctl_table.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,74 @@
+#include <linux/types.h>
+#include <linux/serial.h>
+#include <linux/tty.h>
+#include <linux/time.h>
+#include <asm/socket.h>
+#include <asm/termios.h>
+
+#define PROXYFS_IOCTL_PRIVATE
+#include "proxyfs_ioctl.h"
+
+const unsigned long const ioctl_table[] = {
+	// <include/asm-i386/socket.h>
+	FIOSETOWN,			sizeof( const int )			| IOCTL_WRITE,
+	SIOCSPGRP,			sizeof( const int )			| IOCTL_WRITE,
+	FIOGETOWN,			sizeof( int )				| IOCTL_READ,
+	SIOCGPGRP,			sizeof( int )				| IOCTL_READ,
+	SIOCATMARK,			sizeof( int )				| IOCTL_READ,
+	SIOCGSTAMP,			sizeof( struct timeval )		| IOCTL_READ,
+
+	// <include/asm-i386/termios.h>
+	TCGETS,				sizeof( struct termios )		| IOCTL_READ,
+	TCSETS,				sizeof( const struct termios )		| IOCTL_WRITE,
+	TCSETSW,			sizeof( const struct termios )		| IOCTL_WRITE,
+	TCSETSF,			sizeof( const struct termios )		| IOCTL_WRITE,
+	TCGETA,				sizeof( struct termio )			| IOCTL_READ,
+	TCSETA,				sizeof( const struct termio )		| IOCTL_WRITE,
+	TCSETAW,			sizeof( const struct termio )		| IOCTL_WRITE,
+	TCSETAF,			sizeof( const struct termio )		| IOCTL_WRITE,
+	TCSBRK,				IOCTL_INT,
+	TCXONC,				IOCTL_INT,
+	TCFLSH,				IOCTL_INT,
+	TIOCEXCL,			IOCTL_VOID,
+	TIOCNXCL,			IOCTL_VOID,
+	TIOCSCTTY,			IOCTL_INT,
+	TIOCGPGRP,			sizeof( pid_t )				| IOCTL_READ,
+	TIOCSPGRP,			sizeof( const pid_t )			| IOCTL_WRITE,
+	TIOCOUTQ,			sizeof( int )				| IOCTL_READ,
+	TIOCSTI,			sizeof( const char * )			| IOCTL_WRITE, // FIXME
+	TIOCGWINSZ,			sizeof( struct winsize )		| IOCTL_READ,
+	TIOCSWINSZ,			sizeof( const struct winsize )		| IOCTL_WRITE,
+	TIOCMGET,			sizeof( int )				| IOCTL_READ,
+	TIOCMBIS,			sizeof( const int )			| IOCTL_WRITE,
+	TIOCMBIC,			sizeof( const int )			| IOCTL_WRITE,
+	TIOCMSET,			sizeof( const int )			| IOCTL_WRITE,
+	TIOCGSOFTCAR,			sizeof( int )				| IOCTL_READ,
+	TIOCSSOFTCAR,			sizeof( const int ) 			| IOCTL_WRITE,
+	FIONREAD,			sizeof( int )				| IOCTL_READ,
+	TIOCINQ,			sizeof( int )				| IOCTL_READ,
+	TIOCLINUX,			sizeof( const char )			| IOCTL_WRITE, // MORE
+	TIOCCONS,			IOCTL_VOID,
+	TIOCGSERIAL,			sizeof( struct serial_struct )		| IOCTL_READ,
+	TIOCSSERIAL,			sizeof( const struct serial_struct )	| IOCTL_WRITE,
+	TIOCPKT,			sizeof( const int )			| IOCTL_WRITE,
+	FIONBIO,			sizeof( const int )			| IOCTL_WRITE,
+	TIOCNOTTY,			IOCTL_VOID,
+	TIOCSETD,			sizeof( const int )			| IOCTL_WRITE,
+	TIOCGETD,			sizeof( int )				| IOCTL_READ,
+	TCSBRKP,			IOCTL_INT,
+	//TIOCTTYGSTRUCT,			sizeof( struct tty_struct )		| IOCTL_READ,
+	FIONCLEX,			IOCTL_VOID,
+	FIOCLEX,			IOCTL_VOID,
+	FIOASYNC,			sizeof( const int )			| IOCTL_WRITE,
+	TIOCSERCONFIG,			IOCTL_VOID,
+	TIOCSERGWILD,			sizeof( int )				| IOCTL_READ,
+	TIOCSERSWILD,			sizeof( const int )			| IOCTL_WRITE,
+	TIOCGLCKTRMIOS,			sizeof( struct termios )		| IOCTL_READ,
+	TIOCSLCKTRMIOS,			sizeof( const struct termios )		| IOCTL_WRITE,
+	//TIOCSERGSTRUCT,			sizeof( struct async_struct )		| IOCTL_READ,
+	TIOCSERGETLSR,			sizeof( int )				| IOCTL_READ,
+	TIOCSERGETMULTI,		sizeof( struct serial_multiport_struct )| IOCTL_READ,
+	TIOCSERSETMULTI,		sizeof( const struct serial_multiport_struct  )		| IOCTL_WRITE,
+};
+
+const unsigned long ioctl_table_nmemb = sizeof(ioctl_table)/(2*sizeof(unsigned long));
--- linux-3.7.1_original/clondike/src/proxyfs/proxyfs_helper.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/proxyfs/proxyfs_helper.h	2013-03-11 09:10:20.000000000 +0100
@@ -0,0 +1,222 @@
+#ifndef PROXYFS_HELPER_H
+#define PROXYFS_HELPER_H
+
+#include <linux/fs.h>
+#include <linux/fs_struct.h>
+#include <linux/fdtable.h>
+
+/**
+ * Contains helper methods for working with proxyfs.
+ */
+
+static const char PROXYFS_MNT_POINT[] = "/mnt/proxy";
+
+/**
+ * Checks, whether the file is proxyfs file.
+ *
+ * @param path Path to the file
+ * @return 1 if the file is proxyfs file, 0 otherwise
+ */
+static inline int is_proxyfs_file(const char* path) {
+	int proxyfs_mnt_point_len = strlen(PROXYFS_MNT_POINT);
+	return strncmp(path, PROXYFS_MNT_POINT, proxyfs_mnt_point_len) == 0;
+}
+
+/**
+ * Returns true, if the path points to a dev null file
+ */
+static inline int is_dev_null(const char* path) {
+	return strncmp(path, "/dev/null", 9) == 0;
+}
+
+/**
+ * Creates a name of a proxy file
+ *
+ * @param owning_task Task, that is owning a reference to the physical file
+ * @param buffer Output buffer to be filled with the path
+ * @param proxy_ident Identifier of the file in the proxy file system 
+ */
+static inline void create_proxyfs_name(struct task_struct* owning_task, char* buffer, unsigned long proxy_ident) {
+	sprintf(buffer, "%s/%d-%lu", PROXYFS_MNT_POINT, task_tgid_vnr(owning_task), proxy_ident);
+}
+
+
+/**
+ * Modifies proxyfs file name to reflect a new owner of the file
+ *
+ * @param old_name Old name of proxy file
+ * @param new_owner_pid CCN pid of the task, that is owning a reference to the physical file (new task)
+ * @param buffer Output buffer to be filled with the path
+ * @return 0 on successful change, 1 if no change was required, negative error code otherwise
+ */
+static inline int alter_proxyfs_name_task_change(const char* old_name, pid_t new_owner_pid, char* buffer) {
+	if ( !is_proxyfs_file(old_name) ) {
+		mdbg(ERR2, "Old name is not a proxyfs file name! Name: %s", old_name);
+		return -EINVAL;
+	} else {
+		int proxyfs_mnt_point_len = strlen(PROXYFS_MNT_POINT);	
+		pid_t old_pid;
+		unsigned long proxy_ident;
+	
+		sscanf(old_name + proxyfs_mnt_point_len + 1, "%d-%lu",&old_pid, &proxy_ident);
+		if ( old_pid == new_owner_pid )
+			return 1; // No change required
+
+		sprintf(buffer, "%s/%d-%lu",PROXYFS_MNT_POINT, new_owner_pid, proxy_ident);
+	}
+
+	return 0;
+};
+
+/**
+ * Helper method, that is used for altering file names on distant fork.. this method resolves duplicate fds
+ * that should not be changed vie close/open, but just sys_dup-ed
+ */
+static inline int resolve_duplicates(int modified_fd, struct file* modified_file) {
+	int fd;
+	struct file* file;
+
+  // Replaced macro FD_ISSET to function test_bit with equal parameters by Jiri Rakosnik
+	for (fd = modified_fd+1, file = current->files->fdt->fd[fd]; 					\
+	     fd < current->files->fdt->max_fds; fd++, file = current->files->fdt->fd[fd])		\
+		if (test_bit(fd, current->files->fdt->open_fds)) {
+
+		// If this is a duplicate fd to file we had to modify => modify this fd to point to correct file
+		if ( file == modified_file )	{ 
+			mdbg(INFO3, "Resolving duplicate fd %d (duplicate of %d)", fd, modified_fd);
+			sys_close(fd);
+
+			if (sys_dup2(modified_fd, fd) != fd) {
+				mdbg(ERR3, "Error duplicating file descriptor %d into %d!", modified_fd, fd);
+				return -EFAULT;
+			}
+		}
+	}
+
+	return 0;
+}
+
+/**
+ * This method is used after remote-fork on a client side. It will iterate all open files of the client
+ * and if the file is a proxy file, it will be closed and a new file will be opened instead.
+ *
+ * On the serverside, there are created appropriated proxy files after the fork of shadow process, so they
+ * are already prepared to be used.
+ *
+ * By using this "file clonning" mechanism, we ensure that we have independend file connections from parent and child
+ * and so we can migrate parent on a different node that the child.
+ *
+ *
+ * @param new_owner_pid Pid of the process, for which we are making the clone (pid on CCN!)
+ * @return 0 on successs
+ */
+static inline int proxyfs_clone_file_names(pid_t new_owner_pid) {
+	int fd, res = 0;
+	struct file* file;
+	unsigned long page;
+	char* pathname;
+	mm_segment_t old_fs;
+
+
+	/* resolve the path name. */
+	if (!(page = __get_free_page(GFP_KERNEL))) {
+		mdbg(ERR3, "Can't allocate page for file pathname!");
+		return -ENOMEM;
+	}
+
+	old_fs = get_fs();
+	set_fs(get_ds());
+
+	for (fd = 0, file = current->files->fdt->fd[fd]; 					\
+	     fd < current->files->fdt->max_fds; fd++, file = current->files->fdt->fd[fd])		\
+		if (test_bit(fd, current->files->fdt->open_fds)) {
+			// Same "hack" with -1000 as in tcmi_ckpt_openfile.. see there for cmnt
+			if (IS_ERR(pathname = d_path(&file->f_path, (char*)page, PAGE_SIZE - 1000))) {
+				mdbg(ERR3, "Can't resolve pathname for '%s'", file->f_dentry->d_name.name);
+				res = -EINVAL;
+				goto exit1;
+			}
+
+			if ( is_proxyfs_file(pathname) ) {
+				u_int32_t flags;
+				u_int32_t mode;
+				u_int64_t pos;
+				int new_fd, alter_res;
+				
+				mdbg(INFO3, "Resolving proxy fs file %s [%d]", pathname, fd);
+
+				flags = file->f_flags;
+				mode = file->f_mode;
+				pos = file->f_pos;
+
+				// Change filename to new proper name				
+				alter_res = alter_proxyfs_name_task_change(pathname, new_owner_pid, (char*)page);
+				if ( alter_res == 1 ) {
+					continue; // File does not need to be changed.. it was a duplicate and is already changed	
+				} else if ( alter_res < 0 ) {
+					res = alter_res;
+					goto exit1;
+				}
+				pathname = (char*)page;
+
+				// Close old file
+				sys_close(fd);
+				// Open new file		
+				if ((new_fd = do_sys_open(AT_FDCWD, pathname, flags, mode)) < 0) {
+					mdbg(ERR3, "Error opening file '%s', err=%d", pathname, new_fd);
+					res = new_fd;
+					goto exit1;
+				}
+				// Ensure the new file has proper id
+				if (new_fd != fd) {
+					mdbg(INFO3, "Duplicating file descriptor %d into %d!", new_fd, fd);
+					if (sys_dup2(new_fd, fd) != fd) {
+						res = -EINVAL;
+						mdbg(ERR3, "Error duplicating file descriptor %d into %d!", new_fd, fd);
+						goto exit1;
+					}
+					// Close newly opened file that was not open with a proper fd
+					sys_close(new_fd);
+				}
+				/* setup the file position */
+				if (pos != vfs_llseek(current->files->fdt->fd[fd], pos, 0)) {
+					mdbg(ERR3, "Failed to set position %Lx in file '%s'", pos, pathname);
+					res = -EINVAL;
+					goto exit1;
+				}			
+
+				// Resolve all other fd's that were pointing to this file.. they should not open it, they should instead duplicate the fd
+				if ( resolve_duplicates(fd, file) ) {
+					mdbg(ERR3, "Failed to resolve duplicates");
+					res = -EINVAL;
+					goto exit1;
+				}
+			}
+	}
+
+exit1:
+	set_fs(old_fs);
+	free_page(page);
+	return res;
+}
+
+/** 
+ * Synchronizes all files open by "current" process 
+ *
+ * Iterates over all open files of the process and synchronizes it.. it is required, because the shadow process
+ * may end before the guest process and in this case some proxyfs files won't get synced on their close
+ */
+static inline void proxyfs_sync_files_on_exit(void) {
+	int fd;
+	struct file *file;
+
+	for (fd = 0, file = current->files->fdt->fd[fd]; 					
+	     fd < current->files->fdt->max_fds; fd++, file = current->files->fdt->fd[fd])	
+		if (test_bit(fd, current->files->fdt->open_fds)) {
+			mdbg(INFO3, "Synchronizing fd: %d", fd);
+			vfs_fsync(file, 0);     //Remove second parameter self->file->f_path.dentry because in new kernel it isn't by Jiri Rakosnik  
+      // TODO: Here we may do fsync unnecessarily multiple times as files can be alias by multiple fds
+	}
+}
+
+#endif
--- linux-3.7.1_original/clondike/src/proxyfs/proxyfs_server.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/proxyfs/proxyfs_server.c	2013-03-12 15:18:31.000000000 +0100
@@ -0,0 +1,535 @@
+/**
+ * @file proxyfs_server.c - Proxyfs server task.
+ *                      
+ * 
+ *
+ *
+ * Date: 08/12/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: proxyfs_server.c,v 1.13 2008/05/02 19:59:20 stavam2 Exp $
+ *
+ * This file is part of Proxy filesystem (ProxyFS)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * ProxyFS is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * ProxyFS is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <proxyfs/buffer.h>
+#include <asm/uaccess.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/kthread.h>
+#include <kkc/kkc.h>
+
+#include <dbg.h>
+#include <proxyfs/proxyfs_ioctl.h>
+#include <asm/ioctls.h>
+#include <asm/termbits.h>
+
+static int errno;
+#include <arch/current/make_syscall.h>
+static inline _syscall3(long, ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg);
+
+#define PROXYFS_SERVER_PRIVATE       // Own header
+#define PROXYFS_SERVER_PROTECTED       // Own header
+#include "proxyfs_server.h"
+
+#define PROXYFS_REAL_FILE_PROTECTED  // Friend
+#include "proxyfs_real_file.h"
+#include "proxyfs_tty_real_file.h"
+#include "proxyfs_generic_real_file.h"
+#include "proxyfs_pipe_real_file.h"
+
+#include <linux/mount.h>
+
+static struct proxyfs_server* self = NULL;
+
+/** \<\<public\>\> */
+int proxyfs_server_thread(void* ss)
+{
+	struct proxyfs_task_start_struct *start_struct = (struct proxyfs_task_start_struct*)ss;
+	self = kmalloc(sizeof(struct proxyfs_server), GFP_KERNEL);
+	if ( !self )
+		return -EINVAL;
+
+	proxyfs_task_init( PROXYFS_TASK(self) );
+	PROXYFS_TASK(self)->tsk = current;
+	PROXYFS_TASK(self)->ops = &server_ops;
+	sema_init(&self->files_sem, 1 );  // Replaced init_MUTEX macro to sema_init by Jiri Rakosnik 
+
+	if( proxyfs_server_listen(start_struct->addr_str) != 0 ){
+		proxyfs_task_complete( NULL, start_struct ); 
+		kfree(self);
+		return -EINVAL;	
+	}
+
+	proxyfs_task_complete( PROXYFS_TASK(self), start_struct ); 
+
+	proxyfs_server_loop();
+
+	return 0;
+}
+
+/** \<\<private\>\> Start listening on socket
+ * @param *listen_str - kkc address on which server will listen
+ *
+ * @return zero on succes
+ * */
+int proxyfs_server_listen(const char *listen_str){
+	int err;
+	if ((err = kkc_listen(&self->server_sock, listen_str))) {
+              mdbg(ERR3, "Failed creating KKC listening on '%s' error %d", listen_str, err);
+	      return -1;
+	}
+        mdbg(INFO3, "Server listening on '%s'", listen_str);
+	kkc_sock_register_read_callback(self->server_sock, proxyfs_task_data_ready_callback, self);
+	mdbg(INFO3, "Callback registered");
+	init_waitqueue_entry(&self->server_sock_wait, current );
+	return kkc_sock_add_wait_queue( self->server_sock, &self->server_sock_wait );
+}
+
+/** \<\<private\>\> Try to accept new connection 
+ * @return 1 if we accepted a new conection (and there can be another one waiting)
+ * */
+int proxyfs_server_accept(void){
+	struct kkc_sock *peer_sock;
+	struct proxyfs_peer_t *p;
+	int err;
+	if ((err = kkc_sock_accept( self->server_sock, &peer_sock, 
+                             KKC_SOCK_NONBLOCK)) < 0) {
+                //mdbg(INFO4, "No connection, accept would block %d", err);
+                return 0;
+        }
+        
+	mdbg(INFO3, "Accepted new connection");
+
+	p = proxyfs_task_add_to_peers(PROXYFS_TASK(self), peer_sock); // FIXME osetrit chybu
+	if( p != NULL ) {
+		kkc_sock_register_read_callback(peer_sock,proxyfs_task_data_ready_callback, self);
+		proxyfs_peer_wait(p);
+	}
+
+	return 1;
+}
+
+/** \<\<private\>\> Main server loop */
+void proxyfs_server_loop(void){
+	while(!kthread_should_stop()){
+		proxyfs_task_wait_for_data_ready(PROXYFS_TASK(self));
+		
+		// Accept all incoming conections
+		while( proxyfs_server_accept() == 1 );
+		// Try to recv from all socket.  
+		proxyfs_task_recv_peers( PROXYFS_TASK(self) );
+		//mdbg(INFO3, "STATE: %lx", current->state);
+		// Try to write all buffers to files and read from files.  
+		proxyfs_server_read_and_write_real_files();
+		//mdbg(INFO3, "STATE: %lx", current->state);
+
+		proxyfs_task_send_buffers( PROXYFS_TASK(self) );
+		//mdbg(INFO3, "STATE: %lx", current->state);
+		proxyfs_task_send_peers( PROXYFS_TASK(self) );
+		proxyfs_task_handle_dead_peers( PROXYFS_TASK(self) );	
+	}
+
+	mdbg(INFO1, "Finished server thread");
+}
+
+/** \<\<private\>\> Handle message specific for server
+ * @param self - pointer to this proxyfs_task instance
+ * @param peer - peer struct with received message
+ * */
+static void proxyfs_server_handle_msg(struct proxyfs_task *self, struct proxyfs_peer_t *peer )
+{
+	struct proxyfs_msg *msg = proxyfs_peer_get_msg(peer);
+	struct proxyfs_file_t *real_file;
+	u_int32_t exitting;
+	//long rtn;
+	
+	mdbg(INFO1, "Msg%lu DATA: (%p)",msg->header.file_ident ,msg);
+
+	switch( msg->header.msg_num ){
+		case MSG_OPEN:
+			mdbg(INFO1, "MSG_OPEN ident=%lu", msg->header.file_ident);
+			real_file = proxyfs_task_find_file( self, msg->header.file_ident);
+			if( real_file != NULL ){ 
+				mdbg(INFO1, "File found");
+				if( 0 && real_file->peer != NULL )
+					mdbg(INFO1, "Atempt to open already opened file, rejecting...");
+				else{
+					proxyfs_real_file_open( PROXYFS_REAL_FILE(real_file), peer );
+					return;
+				}
+			}
+			mdbg(INFO1, "File not found");
+			msg = proxyfs_msg_new(MSG_OPEN_RESP_FAILED, msg->header.file_ident, 0, NULL );
+			proxyfs_peer_send_msg( peer, msg );
+			break;
+		case MSG_IOCTL:
+			mdbg(INFO1, "MSG_IOCTL");
+			real_file = proxyfs_task_find_file( self, msg->header.file_ident);
+			if( real_file != NULL ){ 
+				u_int32_t ioctl_info = ioctl_get_info(msg->header.data[0]);
+				char* ioctl_buffer = kmalloc(IOCTL_ARG_SIZE(ioctl_info), GFP_KERNEL);
+				if ( ioctl_buffer ) {
+					u_int32_t result;
+					mdbg(INFO2, "MSG_IOCTL execute command: %d Arg size: %d", msg->header.data[0], IOCTL_ARG_SIZE(ioctl_info));
+					result = proxyfs_real_file_do_ioctl(PROXYFS_REAL_FILE(real_file), 
+							msg->header.data[0], (unsigned long)ioctl_buffer);
+	
+
+					mdbg(INFO2, "MSG_IOCTL performed with result: %d", result);
+					if( IOCTL_WILL_READ(ioctl_info) )
+						msg = proxyfs_msg_compose_new(MSG_IOCTL_RESP, proxyfs_file_get_file_ident(real_file), 
+							sizeof(u_int32_t), &result,
+							IOCTL_ARG_SIZE(ioctl_info), ioctl_buffer, 
+							(u_int32_t)0);
+					else
+						msg = proxyfs_msg_compose_new(MSG_IOCTL_RESP, proxyfs_file_get_file_ident(real_file), 
+							sizeof(u_int32_t), &result, 
+							(u_int32_t)0);
+
+					kfree(ioctl_buffer);
+					if( msg )
+						proxyfs_peer_send_msg( peer, msg );
+					else
+						mdbg(ERR2, "Failed creating response");
+				} else {
+					mdbg(ERR2, "Not enough memory to create ioctl read buffer of size: %d", IOCTL_ARG_SIZE(ioctl_info));
+				}
+				return;
+			}
+			mdbg(INFO1, "File not found");
+			/*msg = proxyfs_msg_new(MSG_OPEN_RESP_FAILED, msg->header.file_ident, 0, NULL );
+			proxyfs_peer_send_msg( peer, msg );*/
+			break;
+		case MSG_CLOSE:
+			exitting = msg->header.data[0];
+			mdbg(INFO1, "MSG_CLOSE ident=%lu was exitting: %d", msg->header.file_ident, exitting);
+			real_file = proxyfs_task_find_file( self, msg->header.file_ident);
+			if( real_file != NULL ){ 
+				mdbg(INFO1, "File found");
+				proxyfs_real_file_close( PROXYFS_REAL_FILE(real_file), peer );
+				if ( !exitting ) {
+					/* If the process was not exitted, the close was ordinary close request made 
+					   by the process, so we can mark the file closed, since nobody is going to 
+					   open it again */
+					mdbg(INFO1, "Marking physical file closed");
+					proxyfs_file_set_status( real_file, PROXYFS_FILE_CLOSED );	
+				}
+				return;
+			}
+			msg = proxyfs_msg_new(MSG_CLOSE_RESP, msg->header.file_ident, 0, NULL );
+			proxyfs_peer_send_msg( peer, msg );
+			break;
+		case MSG_FSYNC:
+			mdbg(INFO1, "MSG_FSYNC ident=%lu", msg->header.file_ident);
+			real_file = proxyfs_task_find_file( self, msg->header.file_ident);
+			if( real_file != NULL ){ 
+				mdbg(INFO1, "File found");
+				proxyfs_real_file_fsync( PROXYFS_REAL_FILE(real_file), peer );
+				return;
+			}
+			msg = proxyfs_msg_new(MSG_FSYNC_RESP, msg->header.file_ident, 0, NULL );
+			proxyfs_peer_send_msg( peer, msg );
+			break;
+		case MSG_READ_REQUEST:
+			mdbg(INFO1, "MSG_READ_REQUEST ident=%lu", msg->header.file_ident);
+			real_file = proxyfs_task_find_file( self, msg->header.file_ident);
+			if( real_file != NULL ){ 
+				mdbg(INFO1, "File found");
+				proxyfs_real_file_mark_read_request( PROXYFS_REAL_FILE(real_file), peer );
+				return;
+			}
+			msg = proxyfs_msg_new(MSG_READ_REQUEST_RESP, msg->header.file_ident, 0, NULL );
+			proxyfs_peer_send_msg( peer, msg );
+			break;
+		default:
+			mdbg(ERR3, "Unknown msg number");
+	}
+}
+
+
+
+/** \<\<private\>\> Try to write all write buffers to file 
+ *
+ */
+void proxyfs_server_read_and_write_real_files(void){
+	struct list_head *l, *nxt;
+	struct proxyfs_msg *msg;
+	struct proxyfs_real_file *real_file;
+	struct proxyfs_peer_t *peer;
+	u_int32_t length;
+
+	down( & self->files_sem ); // Serialize access
+	list_for_each_safe( l, nxt, & PROXYFS_TASK(self)->files ){
+		// up( & self.files_sem ); // Adding new file can wait :-)
+		real_file = PROXYFS_REAL_FILE( list_entry(l, struct proxyfs_file_t, files) );
+		peer = PROXYFS_FILE(real_file)->peer;
+		mdbg(INFO4, "Processing %lu, status %x", proxyfs_file_get_file_ident(PROXYFS_FILE(real_file)),
+			proxyfs_file_get_status( PROXYFS_FILE(real_file), 0xffff ) );
+		// write to file
+		if( (length = proxyfs_real_file_write(real_file)) > 0 ){
+			mdbg(INFO3, "Sending WRITE_RESP msg for file %lu, ack %d", 
+				proxyfs_file_get_file_ident(PROXYFS_FILE(real_file)), length );
+
+			if ( peer ) {
+				msg = proxyfs_msg_compose_new(MSG_WRITE_RESP, proxyfs_file_get_file_ident(PROXYFS_FILE(real_file)),
+					sizeof(u_int32_t), &length, 0 );			
+				proxyfs_peer_send_msg( peer, msg );
+			}
+		}
+		// Close file if it should be closed
+		if( proxyfs_file_get_status( PROXYFS_FILE(real_file), PROXYFS_FILE_CLOSED ) && 
+		    proxyfs_file_get_status( PROXYFS_FILE(real_file), PROXYFS_FILE_ALL_READ )){
+			struct file* physical_file = real_file->file;
+			mdbg(INFO3, "Closing file %lu. Ref count: %ld",	proxyfs_file_get_file_ident(PROXYFS_FILE(real_file)), file_count(real_file->file) );
+			//l = l->next;
+			list_del( & PROXYFS_FILE(real_file)->files ); // Delete from list
+			proxyfs_real_file_destroy( real_file );
+			kfree( real_file );
+			// Close file AFTER we de-list proxy file.. fput may actually destroy the file, if we hold last reference
+			fput( physical_file );
+			continue;
+		}
+		// read from file
+		if ( peer && !proxyfs_file_get_status( PROXYFS_FILE(real_file), PROXYFS_FILE_READ_EOF ) &&
+				proxyfs_real_file_read(real_file) == 0 ){ // EOF
+			msg = proxyfs_msg_compose_new(MSG_WRITE, proxyfs_file_get_file_ident(PROXYFS_FILE(real_file)), 0);
+			proxyfs_peer_send_msg(peer , msg );
+			proxyfs_file_set_status( PROXYFS_FILE(real_file), PROXYFS_FILE_READ_EOF );
+		}
+		// down( & self.files_sem );
+	}
+	up( & self->files_sem );
+
+}
+
+/** \<\<public\>\> \<\<exported\>\> Release all files
+ * taken from current proccess
+ */
+void proxyfs_server_release_all(void)
+{
+	struct proxyfs_file_t *file;
+	struct list_head *l;
+
+	if ( !self )
+		return;
+
+	down( & self->files_sem );
+	list_for_each( l, &PROXYFS_TASK(self)->files ){
+		file = list_entry(l, struct proxyfs_file_t, files);
+		if( proxyfs_real_file_remove_shadow(PROXYFS_REAL_FILE(file),current) == 1 ){ // Did we remove last shadow reference?
+			proxyfs_file_set_status( file, PROXYFS_FILE_CLOSED );
+			mdbg(INFO2, "Releasing %lu (from task %d)", proxyfs_file_get_file_ident(file), current->pid);
+		}
+	}
+	up( & self->files_sem );
+}
+
+EXPORT_SYMBOL_GPL(proxyfs_server_release_all);
+
+static int proxyfs_server_register_poll_callback(struct proxyfs_real_file* file) {
+	struct hacked_poll_table table;
+
+	// Poll hack
+	INIT_LIST_HEAD(& file->waiters_list );
+	table.parent._qproc = proxyfs_server_poll_queue_proc;                  //Added underscore by Jiri Rakosnik for new kernel 3.7.x but warning in source of kernel is 
+                                                                        // Do not touch the structure directly, use the access functions * poll_does_not_wait() and poll_requested_events() instead.
+	table.real_file = file;
+
+	if (file->file->f_op && file->file->f_op->poll ) {
+		file->file->f_op->poll( file->file, (struct poll_table_struct*)&table );
+	} else {
+		mdbg(ERR3, "Poll unavailable! File op: %p", file->file->f_op);
+		if ( file->file->f_vfsmnt)
+			//mdbg(ERR3, "Mount point: %s", file->file->f_vfsmnt->mnt_devname);	
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/** \<\<public\>\> \<\<exported\>\> Make file available trought proxyfs 
+ * @param fd - file descriptor of a file, which will be proxied 
+ *
+ * @return File identifier or null
+ */
+struct proxyfs_file_identifier* proxyfs_server_overtake_file(int fd){
+	struct file *filp;
+	struct proxyfs_real_file *file_row;
+	static int ident = 1; 
+	//struct termios termios_buf;
+	mm_segment_t old_fs;
+
+	if ( !self )
+		goto exit0;
+
+	filp = fget(fd);
+	if( filp == NULL ){
+		goto exit0;
+	}
+
+	if( S_ISCHR(filp->f_dentry->d_inode->i_mode) ){
+		old_fs = get_fs();
+		set_fs(KERNEL_DS);
+		// Does not work on 64 bit :( => commented out
+		//if( ioctl(fd, TCGETS, (unsigned long)&termios_buf) == -ENOTTY )
+		//	file_row = PROXYFS_REAL_FILE( proxyfs_generic_real_file_new() );
+		//else
+			file_row = PROXYFS_REAL_FILE( proxyfs_tty_real_file_new()  );
+		set_fs(old_fs);
+	}
+	else if( S_ISFIFO(filp->f_dentry->d_inode->i_mode) ){
+		file_row = PROXYFS_REAL_FILE( proxyfs_pipe_real_file_new() );
+	}
+	else{
+		mdbg(ERR3, "Unsupported file type!");
+		goto exit1;
+	}
+
+	if( file_row == NULL ){
+		mdbg(ERR3, "File allocation failed!");
+		goto exit1;
+	}
+
+	down( & self->files_sem );
+
+	PROXYFS_FILE(file_row)->file_identifier.file_ident = ++ident;
+	PROXYFS_FILE(file_row)->file_identifier.file_owner_pid = task_tgid_vnr(current);
+	file_row->file = filp;
+	proxyfs_real_file_add_shadow(file_row, current);
+	//file_row->shadow_current = current;
+
+	// DO NOT DO THIS! The file structure is (potentially) shared among multiple process and it will change behavior of the other processes!
+	//filp->f_flags |= O_NONBLOCK; // Force nonblocking asynchronous mode
+	if ( proxyfs_server_register_poll_callback(file_row) )
+		goto exit2;
+
+	list_add_tail( & PROXYFS_FILE(file_row)->files, &PROXYFS_TASK(self)->files ); 
+
+	up( & self->files_sem );
+	mdbg(INFO3, "Added file %d", ident);
+
+	return &PROXYFS_FILE(file_row)->file_identifier;
+
+exit2:
+	proxyfs_real_file_destroy( file_row );
+exit1:
+	fput(filp);
+exit0:
+	return NULL;
+}
+
+EXPORT_SYMBOL_GPL(proxyfs_server_overtake_file);
+
+
+static void proxyfs_server_duplicate_overtaken_file(struct proxyfs_real_file* file, struct task_struct* new_owner) {
+	struct proxyfs_real_file* clone = NULL;
+
+	if ( file->ops == NULL || file->ops->duplicate == NULL ) {
+		mdbg(ERR1, "Cannot duplicate file [%lu], it does not have duplicate method defined", proxyfs_file_get_file_ident(PROXYFS_FILE(file)));
+		return;
+	}
+
+	clone = file->ops->duplicate(file);
+	if ( clone == NULL ) {
+		mdbg(ERR1, "Failed to duplicate file [%lu].", proxyfs_file_get_file_ident(PROXYFS_FILE(file)));
+		return;
+	}
+
+	PROXYFS_FILE(clone)->file_identifier.file_owner_pid = task_tgid_vnr(new_owner);
+	proxyfs_real_file_add_shadow(clone, new_owner);
+
+	if ( proxyfs_server_register_poll_callback(clone) )
+		goto exit;
+
+	list_add_tail( & PROXYFS_FILE(clone)->files, &PROXYFS_TASK(self)->files ); 
+
+	return;
+
+exit:
+	fput(clone->file);
+	proxyfs_real_file_destroy(clone);
+}
+
+/** 
+ * \<\<public\>\> \<\<exported\>\> Duplicates all file that were overtaken by a "parent" process and makes child as a owner of duplicates.
+ */
+void proxyfs_server_duplicate_all_parent(struct task_struct* parent, struct task_struct* child)
+{
+	struct proxyfs_file_t *file;
+	struct list_head *l, *nxt;
+
+	if ( !self )
+		return;
+
+	if ( task_tgid_vnr(parent) == task_tgid_vnr(child) ) {
+		mdbg(INFO2, "No duplication performed as tasks are from a same group (task %d in group %d)", child->pid, task_tgid_vnr(child));
+		return;
+	}
+
+	down( & self->files_sem );
+	
+	list_for_each_safe( l, nxt, &PROXYFS_TASK(self)->files ) {
+		file = list_entry(l, struct proxyfs_file_t, files);
+		if( proxyfs_real_file_has_shadow(PROXYFS_REAL_FILE(file),parent) ){
+			mdbg(INFO2, "Going to duplicate file %lu (for task %d)", proxyfs_file_get_file_ident(file), child->pid);
+			proxyfs_server_duplicate_overtaken_file(PROXYFS_REAL_FILE(file), child);
+		}
+	}
+	up( & self->files_sem );
+
+	mdbg(INFO2, "File duplicating done");
+}
+
+EXPORT_SYMBOL_GPL(proxyfs_server_duplicate_all_parent);
+
+
+/** \<\<private\>\> Method used for waiting on files, callback for poll structure 
+ * @param *file - pointer to file in which wait queue this task will be added
+ * @param *wait_head - pointer to struct used for queueing in wait queues
+ * @param *wait_table - pointer to poll table
+ * */
+void proxyfs_server_poll_queue_proc(struct file *file, 
+		wait_queue_head_t *wait_head, struct poll_table_struct *wait_table)
+{
+	struct hacked_poll_table *table = (struct hacked_poll_table *)wait_table;
+	struct proxyfs_real_file_waiter *waiter;
+
+	waiter = (struct proxyfs_real_file_waiter *)kmalloc( sizeof(struct proxyfs_real_file_waiter), GFP_KERNEL);
+	if( waiter == NULL ){
+		mdbg(ERR3, "Waiter allocation failed");
+		return;
+	}
+
+	waiter->wait_head = wait_head;
+
+	// File keeps track of all its waiters in its "waiter_list" member
+	list_add( &waiter->waiters_list, &table->real_file->waiters_list );
+	init_waitqueue_entry(&waiter->wait, PROXYFS_TASK(self)->tsk);
+	// The waiter itself is registered to a file wait queue, this establishing relation between the physical file and the proxy_real_file
+	add_wait_queue(wait_head, &waiter->wait);
+
+	mdbg(INFO3, "Server added to wait queue on file %lu", proxyfs_file_get_file_ident(PROXYFS_FILE(table->real_file)));
+}
+
+static void proxyfs_server_free(struct proxyfs_task* self) {
+	mdbg(INFO1, "Freeing proxy server");
+	kkc_sock_put( PROXYFS_SERVER_TASK(self)->server_sock );
+};
+
--- linux-3.7.1_original/clondike/src/proxyfs/proxyfs_peer.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/proxyfs/proxyfs_peer.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,237 @@
+/**
+ * @file proxyfs_peer.c - Represents connection between client and server.
+ *                      
+ * 
+ *
+ *
+ * Date: 08/12/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: proxyfs_peer.c,v 1.8 2009-04-06 21:48:46 stavam2 Exp $
+ *
+ * This file is part of Proxy filesystem (ProxyFS)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * ProxyFS is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * ProxyFS is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include <linux/vmalloc.h>
+#include <linux/slab.h>
+#include <kkc/kkc.h>
+
+#define PROXYFS_PEER_PRIVATE
+#include "proxyfs_peer.h"
+
+#define USE_VMALLOC ( 4 << 10 )
+
+/** \<\<public\>\> Create proxyfs_peer instance
+ * @return new proxyfs_peer instance or NULL on error
+ */
+struct proxyfs_peer_t *proxyfs_peer_new(void)
+{
+	struct proxyfs_peer_t *self;
+	self = (struct proxyfs_peer_t *)kmalloc( sizeof(struct proxyfs_peer_t), GFP_KERNEL );
+	if( self == NULL ){
+		mdbg(ERR3, "Allocating proxyfs_peer failed");
+		goto exit0;
+	}
+
+	if( proxyfs_peer_init(self) != 0 )
+		goto exit1;
+
+	return self;
+exit1:
+	kfree(self);
+exit0:
+	return NULL;
+}
+
+/** \<\<public\>\> Initialize proxyfs_peer instance
+ * @param self - pointer to proxyfs_peer_t instance
+ * @return 0 on success
+ */
+int proxyfs_peer_init(struct proxyfs_peer_t *self)
+{
+	if( MSG_MAX_SIZE >= USE_VMALLOC )
+		self->recv_buf = vmalloc( MSG_MAX_SIZE );
+	else
+		self->recv_buf = kmalloc( MSG_MAX_SIZE, GFP_KERNEL );
+
+	if( self->recv_buf == NULL ){
+		mdbg(ERR3, "Allocating recv_buf failed");
+		return -1;
+	}
+	self->recv_start = 0;
+	atomic_set(&self->ref_count, 1);
+	spin_lock_init(&self->enqueue_msg_lock);
+	self->state = PEER_CREATED;
+	INIT_LIST_HEAD( & self->msg_queue );
+	return 0;
+}
+
+/** \<\<public\>\> Puts proxyfs_peer instance reference and on reaching zero destroys the instance
+ * @param self - pointer to proxyfs_peer_t instance
+ */ 
+void proxyfs_peer_put(struct proxyfs_peer_t *self)
+{	
+	if (!self)
+		return;
+
+	if ( self->sock )
+		mdbg(INFO4, "Dropping peer reference %s - ref count: %d", kkc_sock_getpeername2(self->sock), atomic_read(&self->ref_count));
+	else
+		mdbg(INFO4, "Dropping peer reference - ref count: %d", atomic_read(&self->ref_count));
+
+	if (atomic_dec_and_test(&self->ref_count)) {		  
+		mdbg(INFO3, "Freeing peer");
+		if( MSG_MAX_SIZE >= USE_VMALLOC )
+			vfree(self->recv_buf);
+		else
+			kfree(self->recv_buf);
+		kkc_sock_put(self->sock);
+		
+		self->state = PEER_DISCONNECTED;
+		self->sock = NULL;
+		
+		kfree(self);
+		mdbg(INFO3, "Peer released");
+	}
+}
+
+/** \<\<public\>\> Nonblocking send queued messages 
+ * @param self - pointer to proxyfs_peer_t instance 
+ */
+void proxyfs_peer_real_send(struct proxyfs_peer_t *self)
+{
+	struct proxyfs_msg *msg;
+	int status;
+
+	// Cannot send in non-connected state
+	if ( self->state == PEER_DISCONNECTED || !self->sock) {
+		mdbg(INFO3, "Skipping real send for peer %s. Not connected (was in state %d)", kkc_sock_getpeername2(self->sock), self->state );
+		return;
+	}
+
+send_n:	if( ! list_empty( & self->msg_queue ) ){
+		msg = list_entry( self->msg_queue.next, struct proxyfs_msg, msg_queue );
+		status = proxyfs_msg_real_send( msg, self->sock );
+		if( status == 1 ){
+			mdbg(INFO3, "Message was send");
+			list_del( self->msg_queue.next );
+			proxyfs_msg_destroy(msg);
+			goto send_n;
+		}
+		else
+			mdbg(INFO3, "Sending returned %d", status);
+	}
+	else {
+		//mdbg(INFO3, "Message queue for %s is empty", kkc_sock_getpeername2(self->sock));
+	}
+}
+
+/** \<\<public\>\> Nonblocking recv messages 
+ * @param self - pointer to proxyfs_peer_t instance
+ *
+ * @return 1 when complete message is received
+ */
+int proxyfs_peer_real_recv(struct proxyfs_peer_t *self)
+{
+	int result = 0;
+	int msg_size;
+
+	if( self->recv_start < MSG_HDR_SIZE ){
+		result = kkc_sock_recv( self->sock, self->recv_buf + self->recv_start,
+		       	MSG_HDR_SIZE - self->recv_start, KKC_SOCK_NONBLOCK);
+
+		if( result == -EAGAIN ){
+			//mdbg(INFO3, "No incoming data from %s", kkc_sock_getpeername2(self->sock));
+		}
+		else if( result > 0 ){
+			mdbg(INFO3, "Received %d bytes from %s", result, kkc_sock_getpeername2(self->sock));
+			self->recv_start += result;
+		}
+		else
+			mdbg(ERR3, "recv(%s) returned %d", kkc_sock_getpeername2(self->sock), result);
+	}
+	if( self->recv_start >=  MSG_HDR_SIZE ){
+		msg_size = proxyfs_msg_get_size( self->recv_buf );
+
+		if( msg_size == self->recv_start )
+			return 1; // Message is complete
+
+		result = kkc_sock_recv( self->sock, self->recv_buf + self->recv_start,
+		       	msg_size - self->recv_start, KKC_SOCK_NONBLOCK);
+
+		if( result == -EAGAIN ){
+			//mdbg(INFO3, "No incoming data from %s", kkc_sock_getpeername2(self->sock));
+		}
+		else if( result > 0 ){
+			mdbg(INFO3, "Received %d bytes from %s", result, kkc_sock_getpeername2(self->sock));
+			self->recv_start += result;
+			if( self->recv_start == proxyfs_msg_get_size(self->recv_buf) )
+				return 1; // Message is complete
+			else
+				return 0;
+		}
+		else
+			mdbg(ERR3, "recv(%s) returned %d", kkc_sock_getpeername2(self->sock), result);
+	}
+	return result;
+}
+
+/** Conects to peer
+ * @param self - pointer to proxyfs_peer_t instance
+ * @param connect_str - connection string for peer we are connecting to
+ *
+ * @return 0 when success
+ */
+int proxyfs_peer_connect(struct proxyfs_peer_t *self, const char *connect_str){
+	int err;
+	if ((err = kkc_connect(&(self->sock), connect_str))) {
+	      self->sock = NULL;
+              mdbg(ERR3, "Failed creating KKC connecting to '%s' error %d", connect_str, err);
+	      return -1;
+	}
+
+	self->state = PEER_CONNECTED;
+
+	return 0;
+}
+
+/** \<\<public\>\> Disconnects  peer 
+ * @param self - pointer to proxyfs_peer_t instance
+ *
+ * @return 0 when success
+ */
+int proxyfs_peer_disconnect(struct proxyfs_peer_t *self){
+	if( self->sock != NULL && self->state == PEER_CONNECTED ) {
+		self->state = PEER_DISCONNECTED;
+		return kkc_sock_shutdown(self->sock);
+	}
+
+	return 0;
+
+}
+
+/** \<\<public> Wait on  peer 
+ * @param self - pointer to proxyfs_peer_t instance
+ *
+ * @return 0 when success
+ */
+int proxyfs_peer_wait(struct proxyfs_peer_t *self){
+	init_waitqueue_entry( &self->socket_wait, current );
+
+	return kkc_sock_add_wait_queue( self->sock, &self->socket_wait );
+}
--- linux-3.7.1_original/clondike/src/proxyfs/proxyfs_client.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/proxyfs/proxyfs_client.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,141 @@
+/**
+ * @file proxyfs_client.h - Proxyfs client task.
+ *                      
+ * 
+ *
+ *
+ * Date: 08/12/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: proxyfs_client.h,v 1.7 2008/05/02 19:59:20 stavam2 Exp $
+ *
+ * This file is part of Proxy filesystem (ProxyFS)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * ProxyFS is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * ProxyFS is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _PROXYFS_CLIENT_H_PUBLIC
+#define _PROXYFS_CLIENT_H_PUBLIC
+
+#include "proxyfs_task.h"
+#include "proxyfs_proxy_file.h"
+#include "proxyfs_msg.h"
+
+/** @defgroup proxyfs_client_class proxyfs_client class 
+ * 
+ * @ingroup proxyfs_task_class
+ *
+ * \<\<class\>\> representing proxyfs_client task
+ * 
+ * @{
+ *
+ */
+
+/** \<\<public\>\> Client task declaration */
+struct proxyfs_client_task; 
+
+/** \<\<public\>\> Cast to struct proxyfs_client_task* */
+#define PROXYFS_CLIENT_TASK(arg) ((struct proxyfs_client_task*)(arg))
+
+/** \<\<public\>\> Startup function for proxyfs client */
+int proxyfs_client_thread(void *start_struct);
+
+/** \<\<public\>\> Create new proxy file */
+struct proxyfs_proxy_file_t *proxyfs_client_open_proxy(struct proxyfs_client_task *self, unsigned long inode_num);
+
+/** \<\<public\>\> Do syscall */
+struct proxyfs_msg *proxyfs_client_do_syscall(struct proxyfs_client_task *self, 
+		struct proxyfs_proxy_file_t *file, struct proxyfs_msg *msg);
+
+/** \<\<public\>\> Asynchronously sends a message */
+void proxyfs_client_send_message(struct proxyfs_client_task *self, 
+		struct proxyfs_proxy_file_t *file, struct proxyfs_msg *msg);
+
+#endif // _PROXYFS_CLIENT_H_PUBLIC
+
+/********************** PROTECTED METHODS AND DATA ******************************/
+#ifdef PROXYFS_CLIENT_PROTECTED
+#ifndef _PROXYFS_CLIENT_H_PROTECTED
+#define _PROXYFS_CLIENT_H_PROTECTED
+
+#define PROXYFS_TASK_PROTECTED // Parent
+#include "proxyfs_task.h"
+
+#include <linux/list.h>
+#include <linux/semaphore.h>
+
+#include <proxyfs/proxyfs_peer.h>
+
+struct proxyfs_client_task {
+	struct proxyfs_task parent;
+
+	struct list_head try_open;
+	struct list_head try_open_send;
+	/** Guards try_open list.. */
+	struct semaphore try_open_sem;
+	/** This semaphore prevents race conditions between client task and checking for task presence in the client */
+	struct semaphore files_sem;
+	/** 
+	 * TODO: This reference is actually only an alias to a single element of list "peers" of task structure. Having this alias is causing race like problems
+	 * and is not really well readable, so would be better to get rid of it
+	 */
+	struct proxyfs_peer_t *server;
+};
+#endif // _PROXYFS_CLIENT_H_PROTECTED
+#endif // PROXYFS_CLIENT_PROTECTED
+
+
+
+/********************** PROTECTED METHODS AND DATA ******************************/
+
+#ifdef PROXYFS_CLIENT_PRIVATE
+#ifndef _PROXYFS_CLIENT_H_PRIVATE
+#define _PROXYFS_CLIENT_H_PRIVATE
+
+/** \<\<private\>\> Proxyfs client constructor */
+struct proxyfs_client_task* proxyfs_client_new(void);
+
+/** \<\<private\>\> Main client loop */
+void proxyfs_client_loop(struct proxyfs_client_task *self);
+
+/** \<\<private\>\> Send open message for queued files */
+void proxyfs_client_open_files(struct proxyfs_client_task *self);
+
+/** \<\<private\>\> Handle task specific received message */
+static void proxyfs_client_handle_msg(struct proxyfs_task *self, struct proxyfs_peer_t *peer);
+
+/** \<\<private\>\> Free task resources */
+static void proxyfs_client_free(struct proxyfs_task* self);
+
+/** \<\<private\>\> Handling of dead peer */
+static void proxyfs_client_handle_dead_peer(struct proxyfs_task* self, struct proxyfs_peer_t* peer);
+
+/** <\<\private\>\> Structure with pointers to virtual methods */
+struct proxyfs_task_ops client_ops = {
+	/** Handle received message */
+	.handle_msg = proxyfs_client_handle_msg,
+	.handle_peer_dead = proxyfs_client_handle_dead_peer,
+	/** Free task resources */
+	.free = proxyfs_client_free,
+};
+
+#endif // _PROXYFS_CLIENT_H_PRIVATE
+#endif // PROXYFS_CLIENT_PRIVATE
+
+/**
+ * @}
+ */
+
--- linux-3.7.1_original/clondike/src/proxyfs/proxyfs_fs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/proxyfs/proxyfs_fs.h	2013-03-01 18:10:03.000000000 +0100
@@ -0,0 +1,142 @@
+/**
+ * @file proxyfs_fs.h - Proxy filesystem for file related system calls 
+ * forwarding
+ *                      
+ * 
+ *
+ *
+ * Date: 08/02/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: proxyfs_fs.h,v 1.5 2007/10/20 14:24:20 stavam2 Exp $
+ *
+ * This file is part of Proxy filesystem (ProxyFS)
+ * Copyleft (C) 2007 Petr Malat
+ * 
+ * ProxyFS is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * ProxyFS is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef _PROXYFS_FS_H
+#define _PROXYFS_FS_H
+
+/** @defgroup proxyfs_fs_class proxyfs_fs class 
+ * @ingroup proxyfs_module_class
+ *
+ * @{
+ */
+
+/** \<\<public\>\> Registr proxyfs in kernel */
+int proxyfs_fs_init(void);
+
+/** \<\<public\>\> Unregistr proxyfs in kernel */
+void proxyfs_fs_exit(void);
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef PROXYFS_FS_PRIVATE
+
+/* \<\<private\>\> Returns superblock */
+static struct dentry * proxyfs_fs_mount(struct file_system_type *, int, const char *, void *);		//Delete last parameter vfsmount mnt* and rename function from get_sb to mount for kernel 3.7.1 by Jiri Rakosnik
+/* \<\<private\>\> Frees superblock */
+static void proxyfs_fs_kill_sb(struct super_block *);
+
+
+
+/* super_operations */
+/** \<\<private\>\> Called when reading superinode */
+//static void proxyfs_fs_super_read_inode(struct inode *);
+/** \<\<private\>\> Called when writing inode */
+static int proxyfs_fs_super_write_inode(struct inode *, struct writeback_control *wbc);	// Fix for kernel 3.7.1. Changed second parameter from int to struct writeback_control *wbc by Jiri Rakosnik
+
+
+
+/* inode_operations */
+/** \<\<private\>\> lookup inode */
+static struct dentry *proxyfs_fs_rootinode_lookup(struct inode *, struct dentry *, unsigned int );  // Fix for kernel 3.7.1. Changed second parameter from struct nameidata * to unsigned int by Jiri Rakosnik
+
+
+/** \<\<private\>\> getattr */
+static int proxyfs_fs_fdinode_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat);
+
+/** \<\<private\>\> release */
+static int proxyfs_fs_fdinode_release(struct inode *inode, struct file *file);
+
+/** \<\<private\>\> Sequentional read */
+static ssize_t proxyfs_fs_fdinode_read(struct file *file, char __user *buf, size_t count, loff_t *offset);
+
+/** \<\<private\>\> Sequentional write */
+static ssize_t proxyfs_fs_fdinode_write(struct file *file, const char __user *buf, size_t count, loff_t *offset);
+
+/** \<\<private\>\> Open file */
+static int proxyfs_fs_fdinode_open(struct inode *, struct file *);
+
+/** \<\<private\>\> ioctl */
+static long proxyfs_fs_fdinode_ioctl (struct file *file, unsigned int cmd, unsigned long arg);
+
+/** \<\<private\>\> Fsync function for VFS */
+static int proxyfs_fs_fdinode_fsync(struct file *file, loff_t, loff_t, int datasync);   // Fix for kernel 3.7.1. Changed second parameter from struct dentry * to two parameters type loff_t by Jiri Rakosnik
+
+
+/** \<\<private\>\> poll */
+#define proxyfs_fs_fdinode_poll proxyfs_file_poll
+
+/*
+ * Structures with operations
+ */
+
+/** \<\<private\>\> Superblock operations */
+static struct super_operations proxyfs_sops = {
+	//.read_inode 	= proxyfs_fs_super_read_inode,
+	.statfs 	= simple_statfs, /* handler from libfs */
+	.write_inode 	= proxyfs_fs_super_write_inode
+};
+
+/** \<\<private\>\> Rootinode inode operations */
+static struct inode_operations rootinode_iops = {
+	.lookup = proxyfs_fs_rootinode_lookup
+};
+
+/** \<\<private\>\> fdinode file operations */
+static struct file_operations fdinode_fops = {
+	.open 	 	= proxyfs_fs_fdinode_open,
+	.read 	 	= proxyfs_fs_fdinode_read,
+	.write 	 	= proxyfs_fs_fdinode_write,
+	.unlocked_ioctl = proxyfs_fs_fdinode_ioctl,
+	.release 	= proxyfs_fs_fdinode_release,
+	.fsync 	 	= proxyfs_fs_fdinode_fsync,
+};
+/** \<\<private\>\> Inode operations  */
+static struct inode_operations fdinode_iops = {
+	.getattr 	= proxyfs_fs_fdinode_getattr,
+};
+
+/** \<\<private\>\> filesystem type structure */
+static struct file_system_type proxyfs = {
+	.name 	 = "proxyfs",
+	.mount  = proxyfs_fs_mount,			// Change record and pointer to function from get_sb to mount by Jiri Rakosnik
+	.kill_sb = proxyfs_fs_kill_sb,
+	.owner 	 = THIS_MODULE
+};
+
+/** \<\<private\>\> Pointer to root inode */
+//static struct inode *rootinode;
+int file_size = 42;
+#endif /* PROXYFS_FS_PRIVATE */
+
+/**
+ * @}
+ */
+
+#endif /* _PROXYFS_FS_H */
--- linux-3.7.1_original/clondike/src/proxyfs/proxyfs_proxy_file.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/proxyfs/proxyfs_proxy_file.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,165 @@
+/**
+ * @file proxyfs_proxy_file.h - Main client file class (used by proxyfs_client_task)
+ *                      
+ * 
+ *
+ *
+ * Date: 08/02/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: proxyfs_proxy_file.h,v 1.3 2007/10/07 15:54:00 stavam2 Exp $
+ *
+ * This file is part of Proxy filesystem (ProxyFS)
+ * Copyleft (C) 2007 Petr Malat
+ * 
+ * ProxyFS is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * ProxyFS is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _PROXYFS_PROXY_FILE_H_PUBLIC
+#define _PROXYFS_PROXY_FILE_H_PUBLIC
+
+#include <linux/types.h>
+#include <linux/poll.h>
+#include <dbg.h>
+#include "proxyfs_client.h"
+
+#include "proxyfs_file.h" // Parent
+
+/**
+ * @defgroup proxyfs_proxy_file_class proxyfs_proxy_file class
+ * @ingroup proxyfs_file_class
+ *
+ * This is used on between VFS 
+ * and proxyfs_client task.
+ *
+ * @{
+ */
+
+/** \<\<public\>\> proxyfs_proxy_file_t declaration */
+struct proxyfs_proxy_file_t;
+
+/** \<\<public\>\> Write to file from user space buffer */
+int proxyfs_proxy_file_write_user(struct proxyfs_proxy_file_t *proxyfile, const char *buf, size_t count);
+
+/** \<\<public\>\> Read from file to user space buffer */
+int proxyfs_proxy_file_read_user(struct proxyfs_proxy_file_t *proxyfile, char *buf, size_t count);
+
+/** \<\<public\>\> Reads from file to peer - reads from write buffer */
+unsigned proxyfs_proxy_file_wait_interruptible(struct proxyfs_proxy_file_t *self, unsigned status);
+
+/** \<\<public\>\> Call ioctl with arg in user space */
+long proxyfs_proxy_file_ioctl_user(struct proxyfs_proxy_file_t *self, unsigned int cmd, unsigned long arg);
+
+/** \<\<public\>\> Poll for VFS */
+unsigned int proxyfs_file_poll(struct file *file, struct poll_table_struct *wait); 
+
+/** \<\<public\>\> Initialize proxyfs_file struct */
+int proxyfs_proxy_file_init(struct proxyfs_proxy_file_t* self);
+
+/** \<\<public\>\> Deinitialize proxyfs_file struct */
+void proxyfs_proxy_file_destroy(struct proxyfs_proxy_file_t* self);
+
+/** \<\<public\>\> Interruptible wait for space in file */
+unsigned proxyfs_proxy_file_wait_for_space_interruptible(struct proxyfs_proxy_file_t *self, unsigned space);
+
+/** \<\<public\>\> Close proxyfile */
+int proxyfs_proxy_file_close(struct proxyfs_proxy_file_t *self);
+
+/** \<\<public\>\> Fsync proxyfile and coresponding real file */
+int proxyfs_proxy_file_fsync(struct proxyfs_proxy_file_t *self);
+
+/** \<\<public\>\> Cast to struct proxyfs_proxy_file_t * */
+#define PROXYFS_PROXY_FILE(arg) ((struct proxyfs_proxy_file_t *)(arg))
+
+
+#endif // _PROXYFS_PROXY_FILE_H_PUBLIC
+
+/********************** PROTECTED METHODS AND DATA ******************************/
+
+#ifdef PROXYFS_PROXY_FILE_PROTECTED
+#ifndef _PROXYFS_PROXY_FILE_H_PROTECTED
+#define _PROXYFS_PROXY_FILE_H_PROTECTED
+
+#define PROXYFS_FILE_PROTECTED  // parent
+#include "proxyfs_file.h"
+
+struct proxyfs_proxy_file_t;
+
+/** \<\<protected\>\> Operations supporting polymorphism */
+struct proxyfs_proxy_file_ops {
+	/** Write to file from user space buffer */
+	int(*write_user)(struct proxyfs_proxy_file_t *, const char *, size_t);
+	/** Read from file to user space buffer */
+	int(*read_user)(struct proxyfs_proxy_file_t *, char *, size_t);
+};
+
+/** \<\<protected\>\> Structure on which VFS and proxyfs_client task are interacting */
+struct proxyfs_proxy_file_t {
+	/** Parrent structure */
+	struct proxyfs_file_t parent;
+	/** Semaphore protecting write_buf */
+	struct semaphore write_buf_sem;
+	/** Semaphore protecting read_buf */
+	struct semaphore read_buf_sem;
+	/** Processes waiting for change on this file */
+	wait_queue_head_t waiting_procs;
+	/** Processes waiting for change on this file */
+	struct proxyfs_msg **syscall_resp;
+	/** Processes waiting for change on this file */
+	struct proxyfs_client_task *task;
+	/** Polymorphism */
+	struct proxyfs_proxy_file_ops *ops;
+};
+
+
+#endif // _PROXYFS_PROXY_FILE_H_PROTECTED
+#endif // PROXYFS_PROXY_FILE_PROTECTED
+
+#ifdef PROXYFS_PROXY_FILE_PRIVATE
+#ifndef _PROXYFS_PROXY_FILE_H_PRIVATE
+#define _PROXYFS_PROXY_FILE_H_PRIVATE
+
+/** \<\<private\>\> Writes to file from peer - writes to read buffer */
+static int proxyfs_proxy_file_write_from_peer(struct proxyfs_file_t *self, const char *buf, size_t count);
+
+/** \<\<private\>\> Reads from file to peer - reads from write buffer */
+static int proxyfs_proxy_file_read_to_peer(struct proxyfs_file_t *self, char *buf, size_t count);
+
+/** \<\<private\>\> Submit that data was written to file on other side */
+static void proxyfs_proxy_file_submit_read_to_peer(struct proxyfs_file_t *self, size_t count);
+
+/** \<\<private\>\> Get maximum amount and address of data, that can be read at one time */
+static void proxyfs_proxy_file_write_buf_info(struct proxyfs_file_t *self, size_t* total_size, size_t* size, void** addr);
+
+/** <\<\private\>\> Structure with pointers to virtual methods */
+static struct proxyfs_file_ops proxy_file_ops = {
+	/** Writes to file from peer - writes to read buffer */
+	.write_from_peer = &proxyfs_proxy_file_write_from_peer,
+	/** Reads from file to peer - reads from write buffer */
+	.read_to_peer = &proxyfs_proxy_file_read_to_peer,
+	/** Call this to submit that data was writen to file on other side */
+	.submit_read_to_peer = proxyfs_proxy_file_submit_read_to_peer,
+	/** Get write buf info */
+	.write_buf_info = proxyfs_proxy_file_write_buf_info,
+};
+
+
+#endif // _PROXYFS_PROXY_FILE_H_PRIVATE
+#endif // PROXYFS_PROXY_FILE_PRIVATE
+
+/**
+ * @}
+ */
+
--- linux-3.7.1_original/clondike/src/proxyfs/proxyfs_generic_real_file.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/proxyfs/proxyfs_generic_real_file.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,112 @@
+/**
+ * @file proxyfs_generic_real_file.h - File class for accessing generic files
+ * (used by proxyfs_server_task)
+ *                      
+ * 
+ *
+ *
+ * Date: 08/02/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: proxyfs_generic_real_file.h,v 1.2 2007/09/03 09:27:08 malatp1 Exp $
+ *
+ * This file is part of Proxy filesystem (ProxyFS)
+ * Copyleft (C) 2007 Petr Malat
+ * 
+ * ProxyFS is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * ProxyFS is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+/********************** PUBLIC METHODS AND DATA *********************************/
+#ifndef _PROXYFS_GENERIC_REAL_FILE_H_PUBLIC
+#define _PROXYFS_GENERIC_REAL_FILE_H_PUBLIC
+
+#include "proxyfs_real_file.h"
+
+/**
+ * @defgroup proxyfs_generic_real_file_class proxyfs_generic_real_file class
+ * @ingroup proxyfs_real_file_class
+ *
+ * This class is used by server task for accessing generic files
+ *
+ * @{
+ */
+
+/** Generic_real_file declaration */
+struct proxyfs_generic_real_file;
+
+/** \<\<public\>\> Initialize generic_real_file */
+int proxyfs_generic_real_file_init(struct proxyfs_generic_real_file *self);
+
+/** \<\<public\>\> Deinitialize generic_real_file */
+void proxyfs_generic_real_file_destroy(struct proxyfs_generic_real_file *self);
+
+/** \<\<public\>\> generic_real_file construktor */
+struct proxyfs_generic_real_file *proxyfs_generic_real_file_new(void);
+
+/** \<\<public\>\> Casts to struct proxyfs_real_file_t * */
+#define PROXYFS_GENERIC_REAL_FILE(arg) ((struct proxyfs_generic_real_file*)(arg))
+
+#endif // _PROXYFS_GENERIC_REAL_FILE_H_PUBLIC
+
+/********************** PROTECTED METHODS AND DATA ******************************/
+#ifdef  PROXYFS_GENERIC_REAL_FILE_PROTECTED
+#ifndef _PROXYFS_GENERIC_REAL_FILE_H_PROTECTED
+#define _PROXYFS_GENERIC_REAL_FILE_H_PROTECTED
+
+#define PROXYFS_REAL_FILE_PROTECTED // Parent
+#include "proxyfs_real_file.h"
+
+/** \<\<protected\>\> Generic_real_file definition */
+struct proxyfs_generic_real_file {
+	/** Parent class */
+	struct proxyfs_real_file parent;
+};
+
+#endif // _PROXYFS_GENERIC_REAL_FILE_H_PROTECTED
+#endif //  PROXYFS_GENERIC_REAL_FILE_PROTECTED
+
+/********************** PRIVATE METHODS AND DATA *********************************/
+#ifdef  PROXYFS_GENERIC_REAL_FILE_PRIVATE
+#ifndef _PROXYFS_GENERIC_REAL_FILE_H_PRIVATE
+#define _PROXYFS_GENERIC_REAL_FILE_H_PRIVATE
+
+
+/** \<\<private\>\> Write to file from read buffer */
+static int proxyfs_generic_real_file_write(struct proxyfs_real_file *self);
+
+/** \<\<private\>\> Reads from file and write to writte buffer */
+static int proxyfs_generic_real_file_read(struct proxyfs_real_file *self);
+
+/** \<\<private\>\> "Open" file and send response message */
+static int proxyfs_generic_real_file_open(struct proxyfs_real_file *self, struct proxyfs_peer_t *peer);
+
+/** \<\<private\>\> Structure with operations supporting polymorphism */
+static struct proxyfs_real_file_ops generic_real_file_ops = {
+	/** Reads from file and write to writte buffer */
+	.read = &proxyfs_generic_real_file_read,
+	/** Write to file from read buffer */
+	.write = &proxyfs_generic_real_file_write,
+	/** "Open" file and send response message */
+	.open = &proxyfs_generic_real_file_open,
+};
+
+#endif // _PROXYFS_GENERIC_REAL_FILE_H_PRIVATE
+#endif //  PROXYFS_GENERIC_REAL_FILE_PRIVATE
+
+/**
+ * @}
+ */
--- linux-3.7.1_original/clondike/src/proxyfs/proxyfs_task.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/proxyfs/proxyfs_task.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,187 @@
+/**
+ * @file proxyfs_task.h - Proxyfs task class.
+ *                      
+ * 
+ *
+ *
+ * Date: 08/12/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: proxyfs_task.h,v 1.4 2007/10/07 15:54:00 stavam2 Exp $
+ *
+ * This file is part of Proxy filesystem (ProxyFS)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * ProxyFS is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * ProxyFS is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <linux/kthread.h> 
+#include <linux/completion.h> 
+#include <linux/spinlock.h>
+#ifndef _PROXYFS_TASK_H_PUBLIC
+#define _PROXYFS_TASK_H_PUBLIC
+
+/** @defgroup proxyfs_task_class proxyfs_task class 
+ * 
+ * @ingroup proxyfs_module_class
+ *
+ * \<\<class\>\> representing proxyfs task
+ * 
+ * @{
+ *
+ */
+
+/** \<\<public\>\> Task declaration */
+struct proxyfs_task;
+
+/** \<\<public\>\> Initialize task */
+int proxyfs_task_init(struct proxyfs_task *self);
+
+/** \<\<public\>\> Task declaration */
+struct proxyfs_task_start_struct; 
+
+/** \<\<public\>\> Cast to struct proxyfs_task* */
+#define PROXYFS_TASK(arg) ((struct proxyfs_task*)(arg))
+
+/** \<\<public\>\> Wake up client TODO: Obsolete, remove*/
+void proxyfs_task_wakeup(struct proxyfs_task *self);
+
+/** \<\<public\>\> Notifies task that there are data ready (either for writing/reading/both) */
+void proxyfs_task_notify_data_ready(struct proxyfs_task *self);
+
+/** \<\<public\>\> Run new task */
+struct proxyfs_task *proxyfs_task_run( int (*func)(void*), const char *addr_str );
+
+/** \<\<public\>\> Releases reference and if it was the last reference, frees the task */
+void proxyfs_task_put(struct proxyfs_task* task);
+
+/** \<\<public\>\> Get reference and increase reference counter */
+struct proxyfs_task* proxyfs_task_get(struct proxyfs_task* task);
+
+
+#endif  // _PROXYFS_TASK_H_PUBLIC
+
+/********************** PRIVATE METHODS AND DATA ******************************/
+#ifdef PROXYFS_TASK_PROTECTED
+
+#ifndef _PROXYFS_TASK_H_PROTECTED
+#define _PROXYFS_TASK_H_PROTECTED
+#include <proxyfs/proxyfs_msg.h>
+#include <proxyfs/proxyfs_file.h>
+#include <proxyfs/proxyfs_peer.h>
+
+/** \<\<protected\>\> Structure used for polymorphism */
+struct proxyfs_task_ops {
+	/** Handles task specefic messages */
+	void (*handle_msg)(struct proxyfs_task*, struct proxyfs_peer_t*);
+	/** Actions to be performed on detection of dead peer */
+	void (*handle_peer_dead)(struct proxyfs_task*, struct proxyfs_peer_t*);
+	/** Frees dynamicaly allocated resources */ 
+	void (*free)(struct proxyfs_task*);
+};
+
+/** \<\<protected\>\> Structure used for starting new task */
+struct proxyfs_task_start_struct {
+	/** Server addr (for listenning or to connect to) */
+	const char *addr_str;
+	/** Completion */
+	struct completion startup_done;
+	/** Pointer to created task */
+	struct proxyfs_task *task;
+};
+
+/** \<\<protected\>\> Proxyfs_task class definition */
+struct proxyfs_task {
+	/** process descriptor of current task */
+	struct task_struct *tsk;
+
+	/** Files list */
+	struct list_head files;
+	/** Peers list */
+	struct list_head peers;
+
+	/** Reference counter */
+	atomic_t ref_count;
+	/** Operations specific to server or client tasks */
+	struct proxyfs_task_ops *ops;
+
+	/** Guards data_ready flag */
+	spinlock_t data_ready_lock;
+	/** Flag, indicating whether there are some data ready to be read in any of the connected socket */
+	int data_ready;
+	/** For waiting on data arrival */
+	wait_queue_head_t data_ready_wait;
+};
+
+/** \<\<protected\>\> This is used by thread func, to tell caller, that we are ready with inicialization */
+void proxyfs_task_complete(struct proxyfs_task *self, struct proxyfs_task_start_struct *start_struct);
+
+/** \<\<protected\>\> Find file by ident 
+ * @param self - pointer to self instance 
+ * @param ident - Unique file identifikator
+ *
+ * @return pointer to proxyfs_file_t or NULL 
+ */
+struct proxyfs_file_t *proxyfs_task_find_file(struct proxyfs_task *task, unsigned long ident);
+	/*
+#define proxyfs_task_find_file(task, ident) ({    \
+	struct proxyfs_file_t *file = NULL;       \
+	struct list_head *l;                      \
+	list_for_each( l, &((task)->files) ){       \
+			if( list_entry(l, struct proxyfs_file_t, files)->file_ident == (ident) ){ \
+				file = list_entry(l, struct proxyfs_file_t, files); \
+				break;			  \
+			}                                 \
+	}                                         \
+	file;})*/
+
+/** \<\<protected\>\> Releases task resources */
+void proxyfs_task_free(struct proxyfs_task* self);
+
+/** \<\<protected\>\> Receives data from peer */
+void proxyfs_task_recv_peers(struct proxyfs_task *self);
+
+/** \<\<protected\>\> Sends data to peer */
+void proxyfs_task_send_peers(struct proxyfs_task *self);
+
+/** \<\<protected\>\> Handle received message */
+void proxyfs_task_handle_msg(struct proxyfs_task *self, struct proxyfs_peer_t *peer);
+
+/** \<\<protected\>\> Handle deed peers */
+void proxyfs_task_handle_dead_peers(struct proxyfs_task *self);
+
+/** \<\<protected\>\> Try to queue write messages for each file */
+void proxyfs_task_send_buffers(struct proxyfs_task *self);
+
+/** \<\<protected\>\> Queue write message */
+int proxyfs_task_send_write_buf(struct proxyfs_task *self, struct proxyfs_file_t *proxy_file);
+
+/** \<\<protected\>\> Add socket to peers */
+struct proxyfs_peer_t* proxyfs_task_add_to_peers(struct proxyfs_task *self, struct kkc_sock *peer_sock);
+
+/** \<\<protected\>\> Callback function on data ready */
+void proxyfs_task_data_ready_callback(void* data, int bytes);
+/** \<\<protected\>\> Function to wait for data ready */
+void proxyfs_task_wait_for_data_ready(struct proxyfs_task* self);
+
+
+#endif // _PROXYFS_TASK_H_PROTECTED
+#endif // PROXYFS_TASK_PROTECTED
+
+/**
+ * @}
+ */
+
--- linux-3.7.1_original/clondike/src/proxyfs/proxyfs_real_file.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/proxyfs/proxyfs_real_file.h	2013-03-07 20:17:28.000000000 +0100
@@ -0,0 +1,269 @@
+/**
+ * @file proxyfs_real_file.h - Main real file class (used by proxyfs_server_task)
+ *                      
+ * 
+ *
+ *
+ * Date: 08/02/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: proxyfs_real_file.h,v 1.6 2008/05/02 19:59:20 stavam2 Exp $
+ *
+ * This file is part of Proxy filesystem (ProxyFS)
+ * Copyleft (C) 2007 Petr Malat
+ * 
+ * ProxyFS is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * ProxyFS is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+/********************** PUBLIC METHODS AND DATA *********************************/
+#ifndef _PROXYFS_REAL_FILE_H_PUBLIC
+#define _PROXYFS_REAL_FILE_H_PUBLIC
+
+#include <linux/types.h>
+#include "proxyfs_peer.h"
+
+/**
+ * @defgroup proxyfs_real_file_class proxyfs_real_file class
+ * @ingroup proxyfs_file_class
+ *
+ * This is used on real file 
+ * and proxyfs_server task.
+ *
+ * @{
+ */
+
+/** \<\<public\>\> Declaration of proxyfs_real_file */
+struct proxyfs_real_file;
+
+/** \<\<public\>\> Do ioctl */
+long proxyfs_real_file_do_ioctl(struct proxyfs_real_file *self, unsigned int cmd, unsigned long arg);
+
+/** \<\<public\>\> Write to real file */
+int proxyfs_real_file_write(struct proxyfs_real_file *self);
+
+/** \<\<public\>\> Read from real file */
+int proxyfs_real_file_read(struct proxyfs_real_file *self);
+
+/** \<\<public\>\> "Open" file and send response message */
+int proxyfs_real_file_open(struct proxyfs_real_file *self, struct proxyfs_peer_t *peer);
+
+/** \<\<public\>\> "Close" file */
+int proxyfs_real_file_close(struct proxyfs_real_file *self, struct proxyfs_peer_t *peer);
+/** \<\<public\>\> Marks file as read requested.. see MSG_READ_REQUEST comment for details */
+int proxyfs_real_file_mark_read_request(struct proxyfs_real_file *self, struct proxyfs_peer_t *peer);
+
+/** \<\<public\>\> Initialize real_file */
+int proxyfs_real_file_init(struct proxyfs_real_file *self);
+
+/** \<\<public\>\> Deinitialize real_file */
+void proxyfs_real_file_destroy(struct proxyfs_real_file *self);
+
+/** \<\<public\>\> Casts to struct proxyfs_real_file_t * */
+#define PROXYFS_REAL_FILE(arg) ((struct proxyfs_real_file*)(arg))
+
+/** \<\<public\>\> fsync file  */
+int proxyfs_real_file_fsync(struct proxyfs_real_file *self, struct proxyfs_peer_t *peer);
+
+#endif // _PROXYFS_REAL_FILE_H_PUBLIC
+
+/********************** PROTECTED METHODS AND DATA ******************************/
+#ifdef  PROXYFS_REAL_FILE_PROTECTED
+#ifndef _PROXYFS_REAL_FILE_H_PROTECTED
+#define _PROXYFS_REAL_FILE_H_PROTECTED
+
+#define PROXYFS_FILE_PROTECTED // Parent
+#include "proxyfs_file.h"
+
+#include <asm/ioctls.h>
+
+/** \<\<private\>\> Structure for methods supporting polymorphism */
+struct proxyfs_real_file_ops{
+	/** Write to file from read buffer */
+	int (*write)(struct proxyfs_real_file *);
+	/** Reads from file and write to writte buffer */
+	int (*read)(struct proxyfs_real_file *);
+	/** "Open" file and send response message */
+	int (*open)(struct proxyfs_real_file *, struct proxyfs_peer_t *);
+
+	struct proxyfs_real_file* (*duplicate)(struct proxyfs_real_file* file);
+};
+
+
+/** \<\<private\>\> Proxyfs_real_file structure */
+struct proxyfs_real_file {
+	/** Parent class */
+	struct proxyfs_file_t parent;
+	/** "Real" file */
+	struct file *file;
+	/** Used to queue to wait queues.. keeps collection of "proxyfs_real_file_waiter"s */
+	struct list_head waiters_list;
+	/** Operations supporting polymorphism */
+	struct proxyfs_real_file_ops *ops;
+	/** 
+         * In this collection we keep the task we from which we stole the file + all tasks, that were forked from that task
+         * after the stealing
+         */
+	struct list_head shadow_list;
+};
+
+/** 
+ * Helper structure for registering proxy files to poll wait queues of real files
+ */
+struct proxyfs_real_file_waiter {
+	/** Element used to register into the "physical" file queue */
+	wait_queue_t wait;
+	/** Wait queue, in which is this waiter enqueued.. required for dequeueing */
+	wait_queue_head_t* wait_head;
+	/** Element used to register into a proxyfs_real_file "waiters_list" */
+	struct list_head waiters_list;
+};
+
+/** Helper structure to enlist shadow tasks into real files */
+struct proxyfs_real_file_task {
+	/** Associated shadow */
+	struct task_struct* shadow;
+	/** Used for enlisting into a shadow_list */
+	struct list_head shadow_list;
+};
+
+/** 
+ * \<\<public\>\> Adds shadow task into a shadow list of the file  
+ *
+ * @return 0 on success
+ */
+int proxyfs_real_file_add_shadow(struct proxyfs_real_file *self, struct task_struct* shadow);
+
+/** 
+ * \<\<public\>\> Removes shadow task from a shadow list of the file  
+ *
+ * @return 1, if list become empty, 0 otherwise
+ */
+int proxyfs_real_file_remove_shadow(struct proxyfs_real_file *self, struct task_struct* shadow);
+
+/** 
+ * \<\<public\>\> Checks, whether shadow task is in list of shadow tasks of this file
+ *
+ * @return 1, if the file is used also by provided shadow task
+ */
+int proxyfs_real_file_has_shadow(struct proxyfs_real_file *self, struct task_struct* shadow);
+
+
+/** 
+ * Polls real file and checks, if there are some data that can be read 
+ * @return 0 if there are no data, positive number otherwise (negative on error)
+ */
+static inline int proxyfs_real_file_poll_read(struct proxyfs_real_file* self) {
+	unsigned long mask;
+
+	if (self->file->f_op && self->file->f_op->poll ) {
+		mask = self->file->f_op->poll( self->file, NULL );
+		mdbg(INFO3, "TEMPORARY DEBUG.. poll mask %lu", mask);
+		if ( !(mask & (POLLIN|POLLHUP)) ) // We chak as well for POLLHUP so that we get EOF
+			return 0; // Nothing can be read
+	} else {
+		mdbg(ERR1, "Cannot poll real file!");
+		return -1;
+	}
+	return 1;
+}
+
+/** 
+ * Polls real file and checks, if there is some to which we can writte 
+ * @return 0 if there is no space, positive number otherwise (negative on error)
+ */
+static inline int proxyfs_real_file_poll_write(struct proxyfs_real_file* self) {
+	unsigned long mask;
+
+	if (self->file->f_op && self->file->f_op->poll ) {
+		mask = self->file->f_op->poll( self->file, NULL );
+		mdbg(INFO3, "TEMPORARY DEBUG.. write poll mask %lu", mask);
+		if ( !(mask & (POLLOUT)) )
+			return 0; // Nothing can be written
+	} else {
+		mdbg(ERR1, "Cannot poll real file!");
+		return -1;
+	}
+	return 1;
+}
+
+/** 
+ * Tries to get via IOCTL count of bytes that can be read from the real file
+ * @return counf of the files that can be read
+ */
+/* Commented by Jiru Rakosnik because ioctl file operation is not exist in kernel 3.x
+
+static inline int proxyfs_real_file_ioctl_nread(struct proxyfs_real_file* self) {
+	if (self->file->f_op && self->file->f_op->ioctl ) {
+		int nread, error;
+		int cmd = FIONREAD;
+		mm_segment_t old_fs;
+		old_fs = get_fs();
+
+			
+		set_fs(KERNEL_DS);	
+		lock_kernel();
+		error = self->file->f_op->ioctl(self->file->f_path.dentry->d_inode, self->file, cmd, (unsigned long)&nread);
+		unlock_kernel();
+		set_fs(old_fs);
+
+		mdbg(INFO3, "Nread: %d, error: %d", nread, error);
+		if ( error < 0 )
+			return error;
+
+		return nread;
+	}
+
+	mdbg(INFO3, "Read file does not support IO ctl operations! Id: %lu", proxyfs_file_get_file_ident(PROXYFS_FILE(self)));
+	return -1;
+}
+*/
+
+#endif // _PROXYFS_REAL_FILE_H_PROTECTED
+#endif //  PROXYFS_REAL_FILE_PROTECTED
+
+/********************** PRIVATE METHODS AND DATA *********************************/
+#ifdef  PROXYFS_REAL_FILE_PRIVATE
+#ifndef _PROXYFS_REAL_FILE_H_PRIVATE
+#define _PROXYFS_REAL_FILE_H_PRIVATE
+
+/** \<\<private\>\> Writes to file from peer - writes to read buffer */
+static int proxyfs_real_file_write_from_peer(struct proxyfs_file_t *self, const char *buf, size_t count);
+
+/** \<\<private\>\> Reads from file to peer - reads from write buffer */
+static int proxyfs_real_file_read_to_peer(struct proxyfs_file_t *self, char *buf, size_t count);
+
+/** \<\<private\>\> Submit that data was written to file on other side */
+static void proxyfs_real_file_submit_read_to_peer(struct proxyfs_file_t *self, size_t count);
+
+/** \<\<private\>\> Get maximum amount and address of data, that can be read at one time */
+static void proxyfs_real_file_write_buf_info(struct proxyfs_file_t *self, size_t* total_size, size_t* size, void** addr);
+
+/** <\<\private\>\> Structure with pointers to virtual methods */
+static struct proxyfs_file_ops real_file_ops = {
+	/** Writes to file from peer - writes to read buffer */
+	.write_from_peer = &proxyfs_real_file_write_from_peer,
+	/** Reads from file to peer - reads from write buffer */
+	.read_to_peer = &proxyfs_real_file_read_to_peer,
+	/** Call this to submit that data was writen to file on other side */
+	.submit_read_to_peer = proxyfs_real_file_submit_read_to_peer,
+	/** Get write buf info */
+	.write_buf_info = proxyfs_real_file_write_buf_info,
+};
+
+#endif // _PROXYFS_REAL_FILE_H_PRIVATE
+#endif //  PROXYFS_REAL_FILE_PRIVATE
+/**
+ * @}
+ */
--- linux-3.7.1_original/clondike/src/proxyfs/proxyfs_proxy_file.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/proxyfs/proxyfs_proxy_file.c	2013-03-07 20:30:29.000000000 +0100
@@ -0,0 +1,406 @@
+/**
+ * @file proxyfs_proxy_file.c - Main client file class (used by proxyfs_client_task)
+ *                      
+ * 
+ *
+ *
+ * Date: 08/02/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: proxyfs_proxy_file.c,v 1.7 2008/05/02 19:59:20 stavam2 Exp $
+ *
+ * This file is part of Proxy filesystem (ProxyFS)
+ * Copyleft (C) 2007 Petr Malat
+ * 
+ * ProxyFS is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * ProxyFS is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include <linux/types.h>
+#include <linux/wait.h>
+#include <asm/uaccess.h>
+
+#define PROXYFS_PROXY_FILE_PRIVATE
+#define PROXYFS_PROXY_FILE_PROTECTED // Own header
+#include "proxyfs_proxy_file.h"
+#include "proxyfs_peer.h"
+#include "proxyfs_ioctl.h"
+#include "virtual.h"
+
+/** \<\<public\>\> Write to file from user space buffer 
+ * @param *self - pointer to this file instance
+ * @param *buf - pointer to data in userspace
+ * @param count - size of data
+ *
+ * @return the number of bytes written or error (negative number)
+ * */
+int proxyfs_proxy_file_write_user(struct proxyfs_proxy_file_t *self, const char *buf, size_t count)
+{
+	VIRTUAL_FUNC(write_user, buf, count);
+}
+
+
+static inline int virtual_proxyfs_proxy_file_read_user(struct proxyfs_proxy_file_t *self, char *buf, size_t count) {
+	VIRTUAL_FUNC(read_user, buf, count);
+}
+
+/** \<\<public\>\> Read from file to user space buffer 
+ * @param *self - pointer to this file instance
+ * @param *buf - pointer to buffer in userspace
+ * @param count - size of data
+ *
+ * @return the number of bytes read or error (negative number)
+ */
+int proxyfs_proxy_file_read_user(struct proxyfs_proxy_file_t *self, char *buf, size_t count)
+{
+	struct proxyfs_msg *msg;
+	u_int32_t read_count = virtual_proxyfs_proxy_file_read_user(self, buf, count);
+	
+	msg = proxyfs_msg_compose_new(MSG_WRITE_RESP, proxyfs_file_get_file_ident(PROXYFS_FILE(self)),
+		sizeof(u_int32_t), &read_count, 0 );			
+	proxyfs_client_send_message( self->task, self, msg );
+
+	return read_count;
+}
+
+/** \<\<private\>\> Writes to file from peer - writes to read buffer 
+ * @param *self - pointer to this file instance
+ * @param *buf - pointer to data in kernelspace
+ * @param count - size of data
+ *
+ * @return the number of bytes written 
+ * */
+static int proxyfs_proxy_file_write_from_peer(struct proxyfs_file_t *self, const char *buf, size_t count)
+{
+	int lenght = 0;
+	down( & PROXYFS_PROXY_FILE(self)->read_buf_sem );
+	if( count == 0 ){
+		proxyfs_file_set_status( self, PROXYFS_FILE_READ_EOF );
+		mdbg(INFO2, "EOF on file %lu", proxyfs_file_get_file_ident(self));
+	}
+	else
+		lenght = circ_buf_write( & self->read_buf, buf, count );
+	up( & PROXYFS_PROXY_FILE(self)->read_buf_sem );
+
+	mdbg(INFO4, "Waking up sleepers on %lu", proxyfs_file_get_file_ident(self));
+	wake_up( &PROXYFS_PROXY_FILE(self)->waiting_procs );
+	return lenght;
+}
+
+/** \<\<private\>\> Reads from file to peer - reads from write buffer 
+ * @param *self - pointer to this file instance
+ * @param *buf - pointer to buffer in kernelspace
+ * @param count - size of data
+ *
+ * @TODO: This is never used, is it correct? The functionality is done directly in task buffer sending..
+ * @return the number of bytes read or error (negative number)
+ */
+static int proxyfs_proxy_file_read_to_peer(struct proxyfs_file_t *self, char *buf, size_t count)
+{
+	int lenght;
+	down( & PROXYFS_PROXY_FILE(self)->write_buf_sem );
+
+	lenght = circ_buf_look_at( & self->write_buf, buf, count, self->write_buf_unconfirmed);
+	if( lenght > 0 )
+		self->write_buf_unconfirmed += lenght;
+	
+	up( & PROXYFS_PROXY_FILE(self)->write_buf_sem );
+	return lenght;
+}
+
+
+/** \<\<private\>\> Submit that data was written to file on other side 
+ * (can be safely deleted from proxyfs_file buffer) 
+ * @param *self - pointer to this file instance
+ * @param count - amount of submited data  
+ */
+static void proxyfs_proxy_file_submit_read_to_peer(struct proxyfs_file_t *self, size_t count)
+{
+	down( & PROXYFS_PROXY_FILE(self)->write_buf_sem );
+	circ_buf_adjust_read_ptr( & self->write_buf, count);
+	self->write_buf_unconfirmed -= count;
+	up( & PROXYFS_PROXY_FILE(self)->write_buf_sem );
+
+	mdbg(INFO3, "Waking up file after peer read (%lu). Unconfirmed size : %lu", (unsigned long)count, (unsigned long) self->write_buf_unconfirmed);
+
+	wake_up( & PROXYFS_PROXY_FILE(self)->waiting_procs );
+}
+
+/** \<\<public\>\> Interruptible wait on file 
+ * @param *self - pointer to this file instance
+ * @param status - status on which function returns
+ *
+ * @return - file status or zero if interrupted by signal
+ * */
+unsigned proxyfs_proxy_file_wait_interruptible(struct proxyfs_proxy_file_t *self, unsigned status)
+{
+	unsigned rtn = 0;
+wait:	if ( wait_event_interruptible( self->waiting_procs, 
+			proxyfs_file_get_status( PROXYFS_FILE(self), status ) ||
+			proxyfs_peer_get_state(PROXYFS_FILE(self)->peer) != PEER_CONNECTED) == -ERESTARTSYS) 
+		return 0;
+	else {
+		if ( proxyfs_peer_get_state(PROXYFS_FILE(self)->peer) != PEER_CONNECTED ) {
+			mdbg(INFO3, "Peer not connected in wait. Peer state: %d\n", proxyfs_peer_get_state(PROXYFS_FILE(self)->peer));		
+			return PROXYFS_FILE_CLOSED; // TODO: Or rather some BROKEN state?
+		}
+
+		rtn = proxyfs_file_get_status( PROXYFS_FILE(self), status );
+		mdbg(INFO3, "Waiting on state: %u ... was interrupted in state %u\n", status, proxyfs_file_get_status( PROXYFS_FILE(self), status ));
+		if( rtn & status)
+			return rtn;
+		goto wait;
+	}
+}
+
+/** \<\<public\>\> Interruptible wait for space in file 
+ * @param *self - pointer to this file instance
+ * @param space - wanted amount of bytes
+ *
+ * @return - file status or zero if interrupted by signal
+ * */
+unsigned proxyfs_proxy_file_wait_for_space_interruptible(struct proxyfs_proxy_file_t *self, unsigned space)
+{
+	if( wait_event_interruptible( self->waiting_procs, 
+			circ_buf_free_space( &PROXYFS_FILE(self)->write_buf ) >= space) == -ERESTARTSYS )
+		return 0;
+	else{
+		return proxyfs_file_get_status( PROXYFS_FILE(self), 0xffffFFFF );
+	}
+}
+
+/** \<\<public\>\> Do ioctl on remote file
+ * @param *self - pointer to this file instance
+ * @param cmd - ioctl cmd
+ * @param arg - ioctl arg
+ *
+ * @return - return code of ioctl
+ * */
+long proxyfs_proxy_file_ioctl_user(struct proxyfs_proxy_file_t *self, unsigned int cmd, unsigned long arg)
+{
+	unsigned long ioctl_info;
+	struct proxyfs_msg *msg;
+	struct proxyfs_msg *msg_resp;
+	size_t arg_size;
+	void *ker_buf = NULL;
+	u_int32_t command = cmd;
+	long rtn = -ERESTARTSYS;
+
+	ioctl_info = ioctl_get_info(cmd);
+	arg_size = IOCTL_ARG_SIZE(ioctl_info);
+
+	// Check access to memory 
+	if( IOCTL_WILL_READ(ioctl_info) && !access_ok(VERIFY_WRITE, (void*)arg, arg_size) ){
+		mdbg(ERR3, "Bad read pointer");
+		return -EFAULT;
+	}
+	else if( IOCTL_WILL_WRITE(ioctl_info) && !access_ok(VERIFY_READ, (void*)arg, arg_size) ){
+		mdbg(ERR3, "Bad write pointer");
+		return -EFAULT;
+	}
+
+	// empty write buf
+	switch ( proxyfs_proxy_file_wait_interruptible(self, PROXYFS_FILE_ALL_WRITTEN ) ) {
+		case 0:
+			return -ERESTARTSYS;
+		case PROXYFS_FILE_CLOSED:
+			return -EFAULT;
+		// Otherwise process further
+	}
+
+	if( IOCTL_WILL_WRITE(ioctl_info) ){
+		ker_buf = kmalloc( arg_size + sizeof(u_int32_t), GFP_KERNEL );
+		if( ker_buf == NULL ){
+			mdbg(ERR3, "Allocating memory for message data failed");
+			goto exit0;
+		}
+		*(u_int32_t*)ker_buf = command;
+		if( __copy_from_user( ker_buf + sizeof(u_int32_t), (void*)arg, arg_size ) != 0 )
+			goto exit1;
+
+		msg = proxyfs_msg_new(MSG_IOCTL, proxyfs_file_get_file_ident(PROXYFS_FILE(self)), sizeof(u_int32_t) + arg_size, ker_buf); 
+		if(msg == NULL)
+			goto exit1;
+	}
+	else{
+		msg = proxyfs_msg_new(MSG_IOCTL, proxyfs_file_get_file_ident(PROXYFS_FILE(self)), sizeof(u_int32_t), &command); 
+		if(msg == NULL)
+			goto exit0;
+	}
+
+	msg_resp = proxyfs_client_do_syscall(self->task, self, msg);
+
+	if( msg_resp ){
+		rtn = msg_resp->header.data[0];
+		if( IOCTL_WILL_READ(ioctl_info) ){
+			if( __copy_to_user( (void*)arg, &msg_resp->header.data[1], arg_size ) != 0 )
+				mdbg(ERR3, "Copying result back failed");
+		}
+		kfree( msg_resp );	
+	}
+	if( IOCTL_WILL_WRITE(ioctl_info) )
+		kfree(ker_buf);
+	return rtn;
+
+exit1:
+	kfree(ker_buf);
+exit0:
+	return -ERESTARTSYS;
+
+}
+
+/** \<\<public\>\> Close proxyfile
+ * @param *self - pointer to this file instance
+ *
+ * @return zero on succes
+ * */
+int proxyfs_proxy_file_close(struct proxyfs_proxy_file_t *self)
+{
+	struct proxyfs_msg *msg;
+	struct proxyfs_msg *msg_resp;
+	long rtn = -ERESTARTSYS;
+	u_int32_t exitting = current->flags & PF_EXITING;
+
+	mdbg(INFO2, "Close proxy file requested. Ident: %lu Exitting: %d", proxyfs_file_get_file_ident(PROXYFS_FILE(self)), exitting );
+	
+	// We have to wait for a write buffer empty event..
+	// TODO: however, if the peer connection is broken, this will never happen, and the close method will block.. what to do? Likely we should wait with some long timeout and then just break (or at least recheck connection)
+	if( proxyfs_proxy_file_wait_interruptible(self, PROXYFS_FILE_ALL_WRITTEN ) == 0 ) {
+		minfo(ERR2, "Closing of ident: %lu failed. Not all written", proxyfs_file_get_file_ident(PROXYFS_FILE(self)));
+		return -ERESTARTSYS;
+	}
+
+	msg = proxyfs_msg_new(MSG_CLOSE, proxyfs_file_get_file_ident(PROXYFS_FILE(self)), sizeof(exitting), &exitting); 
+	if(msg != NULL){
+		msg_resp = proxyfs_client_do_syscall(self->task, self, msg);
+		// What the fck?????
+		if( msg_resp == (void*)MSG_CLOSE_RESP )
+			rtn = 0;
+	}
+
+  
+	if ( rtn != 0 && proxyfs_peer_get_state(PROXYFS_FILE(self)->peer) != PEER_CONNECTED) {
+	      // Even if our remote syscall has failed, we have to pretend it succeded as the peer is no longer connected and there is no chance of further close success
+	      rtn = 0;
+	}
+
+	mdbg(INFO2, "Close proxy file request DONE, Res: %ld", rtn);
+
+	return rtn;
+}
+
+/** \<\<public\>\> Fsync proxyfile and coresponding real file
+ * @param *self - pointer to this file instance
+ *
+ * @return zero on succes
+ * */
+int proxyfs_proxy_file_fsync(struct proxyfs_proxy_file_t *self)
+{
+	struct proxyfs_msg *msg;
+	struct proxyfs_msg *msg_resp;
+	long rtn = -ERESTARTSYS;
+
+	mdbg(INFO2, "Fsync requested. Ident: %lu", proxyfs_file_get_file_ident(PROXYFS_FILE(self)));
+
+	// empty write buf
+	switch ( proxyfs_proxy_file_wait_interruptible(self, PROXYFS_FILE_ALL_WRITTEN ) ) {
+		case 0:
+			mdbg(INFO2, "Cannot fsync, interrupted. Ident: %lu", proxyfs_file_get_file_ident(PROXYFS_FILE(self)));
+			return -ERESTARTSYS;
+		case PROXYFS_FILE_CLOSED:
+			mdbg(INFO2, "Cannot fsync, already closed. Ident: %lu", proxyfs_file_get_file_ident(PROXYFS_FILE(self)));
+			return -EFAULT;
+		default:
+			mdbg(INFO3, "Fsync all written, may proceed");		
+		// Otherwise process further
+	}
+
+	mdbg(INFO2, "Sending fsync request. Ident: %lu", proxyfs_file_get_file_ident(PROXYFS_FILE(self)));
+
+	msg = proxyfs_msg_new(MSG_FSYNC, proxyfs_file_get_file_ident(PROXYFS_FILE(self)), 0, NULL); 
+	if(msg != NULL){
+		msg_resp = proxyfs_client_do_syscall(self->task, self, msg);
+		if( msg_resp == (void*)MSG_FSYNC_RESP )
+			rtn = 0;
+	}
+	return rtn;
+}
+
+/** \<\<public\>\> Poll call for VFS 
+ * @param *self - pointer to this file instance
+ * @param *wait - pointer to poll table
+ *
+ * @return - mask of file status
+ * */
+unsigned int proxyfs_file_poll(struct file *file, struct poll_table_struct *wait)
+{
+	struct proxyfs_proxy_file_t *proxyfile = file->private_data;
+	unsigned mask = 0;
+
+	poll_wait(file, &proxyfile->waiting_procs, wait);
+
+	if( proxyfs_file_get_status( PROXYFS_FILE(proxyfile), PROXYFS_FILE_CAN_READ ) )
+		mask |= POLLIN | POLLRDNORM;   
+	if( proxyfs_file_get_status( PROXYFS_FILE(proxyfile), PROXYFS_FILE_CAN_WRITE ) )
+    		mask |= POLLOUT | POLLWRNORM; 
+	return mask;
+}
+
+/** \<\<private\>\> Get maximum amount and address of data, that can be read at one time
+ * @param *self - pointer to this file instance
+ * @param *total_size - pointer to size_t into which a total available data count will be written
+ * @param *size - pointer to size_t into which the data size will be written 
+ * @param **addr - pointer to void* into which the data address will be written 
+ *
+ * */
+static void proxyfs_proxy_file_write_buf_info(struct proxyfs_file_t *self, size_t* total_size, size_t* size, void** addr)
+{
+	down( & PROXYFS_PROXY_FILE(self)->write_buf_sem );
+
+	*total_size = circ_buf_count( & self->write_buf );
+	*size = circ_buf_get_read_size( & self->write_buf );
+	*addr = circ_buf_get_read_addr( & self->write_buf );
+
+	up( & PROXYFS_PROXY_FILE(self)->write_buf_sem ); 
+}
+
+/** \<\<public\>\> Initialize proxyfs_file struct
+ * @param self - pointer to uninitialized proxyfs_proxy_file_t structure
+ *
+ * @return zero on success 
+ * */
+int proxyfs_proxy_file_init(struct proxyfs_proxy_file_t* self)
+{
+	int rtn;
+
+	if( (rtn = proxyfs_file_init( PROXYFS_FILE(self) )) == 0 ){
+		sema_init(& self->write_buf_sem, 1);        // Replaced init_MUTEX macro to sema_init by Jiri Rakosnik
+		sema_init(& self->read_buf_sem, 1);
+		init_waitqueue_head( & self->waiting_procs );
+		PROXYFS_FILE(self)->ops = &proxy_file_ops;
+	}
+
+	return rtn;
+}
+
+/** \<\<public\>\> Deinitialize proxyfs_file struct
+ * @param self - pointer to uninitialized proxyfs_proxy_file_t structure
+ *
+ * @return zero on success 
+ * */
+void proxyfs_proxy_file_destroy(struct proxyfs_proxy_file_t* self)
+{
+	wake_up( & self->waiting_procs );
+	proxyfs_file_destroy( PROXYFS_FILE(self) );
+}
--- linux-3.7.1_original/clondike/src/proxyfs/proxyfs_fs.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/proxyfs/proxyfs_fs.c	2013-03-04 13:01:15.000000000 +0100
@@ -0,0 +1,477 @@
+/**
+ * @file proxyfs_fs.c - Proxy filesystem for file related system calls 
+ * forwarding
+ *                      
+ * 
+ *
+ *
+ * Date: 08/02/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: proxyfs_fs.c,v 1.10 2008/05/02 19:59:20 stavam2 Exp $
+ *
+ * This file is part of Proxy filesystem (ProxyFS)
+ * Copyleft (C) 2007 Petr Malat
+ * 
+ * ProxyFS is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * ProxyFS is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/statfs.h>
+#include <linux/vmalloc.h>
+#include <linux/mm.h>
+#include <linux/buffer_head.h>
+#include <linux/pagemap.h> 
+#include <asm/uaccess.h>
+#include <asm/errno.h>
+
+
+#include <dbg.h>
+#include <proxyfs/buffer.h> 
+#include <proxyfs/proxyfs_client.h> 
+#include <proxyfs/proxyfs_proxy_file.h> 
+
+#define PROXYFS_FS_PRIVATE
+#include "proxyfs_fs.h" 
+#include "proxyfs_fs_helper.h" 
+#include "proxyfs_ioctl.h" 
+#include "proxyfs_task.h" 
+
+#define PROXYFS_TASK_PROTECTED
+#include <proxyfs/proxyfs_task.h> 
+//#include "proxyfs_fs_ioctl.h" 
+
+/** \<\<private\>\> Fill proxyfs superblock
+ *
+ * @param sb     - pointer to superblock
+ * @param data   - mount options etc...
+ * @param silent -
+ *
+ * @return Zero on success
+ */
+static int proxyfs_fs_fill_super(struct super_block *sb, void *data, int silent)
+{
+	struct inode *rootinode;
+
+	sb->s_blocksize      = 1024;
+	sb->s_blocksize_bits = 10;
+	sb->s_magic 	     = 0x28021985;
+	sb->s_op   	     = &proxyfs_sops; // super block operations
+	sb->s_type 	     = &proxyfs;      // file_system_type
+	sb->s_fs_info	     = data;          // proxyfs_client task
+
+	rootinode = iget_locked(sb, 0xFFFFFFFF); // allocate an inode
+	rootinode->i_op   = &rootinode_iops; // set the inode ops
+	//rootinode->i_fop  = &rootinode_fops;
+	rootinode->i_mode = S_IFDIR | S_IRUSR | S_IXUSR;
+	rootinode->i_mtime = rootinode->i_atime = rootinode->i_ctime = CURRENT_TIME;
+
+  //Fix change call function from d_alloc_root to d_make_root for kernel 3.7.1 by Jiri Rakosnik
+	if( !(sb->s_root = d_make_root(rootinode)) ){  
+		iput(rootinode);
+		return -ENOMEM;
+	}
+
+	unlock_new_inode(rootinode);
+
+	return 0;
+}
+
+static struct dentry * proxyfs_fs_mount(struct file_system_type *fs_type, 
+		int flags, const char *devname, void *data) 
+{
+	struct proxyfs_task *task;
+	mdbg(INFO3, "Mounting ProxyFS, server is on %s", devname);
+	
+
+	if ( (task = proxyfs_task_run( proxyfs_client_thread, devname )) == NULL  )
+		return (void *)-EINVAL;       //Convert to void* for remove warning by Jiri Rakosnik
+
+//	return get_sb_single(fs_type, flags, task, proxyfs_fs_fill_super, mnt);
+	return mount_nodev(fs_type, flags, task, proxyfs_fs_fill_super);
+}
+
+/**
+ * Called on unmount
+ */
+static void proxyfs_fs_kill_sb(struct super_block *super) 
+{
+	struct proxyfs_task *task = PROXYFS_TASK(super->s_fs_info); 
+	mdbg(INFO3, "Unmounting ProxyFS, task %p", task);
+	proxyfs_task_put(task);
+	kill_anon_super(super);
+}
+
+/*
+ * Super-Block Operations
+ */
+
+//static void proxyfs_fs_super_read_inode(struct inode *inode) 
+//{
+//	mdbg(INFO3, "Read inode i_ino=%lx Mode=%d", inode->i_ino, inode->i_mode);
+//	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
+//}
+
+// Fix for kernel 3.7.1. Changed second parameter from int to struct writeback_control *wbc by Jiri Rakosnik
+static int proxyfs_fs_super_write_inode(struct inode *inode, struct writeback_control *wbc) 
+{
+	mdbg(INFO3, "write inode i_ino=%lx %d", inode->i_ino, (int)i_size_read(inode));
+	return 0;
+}
+
+/*
+ * Inode Operations
+ */
+
+/** \<\<private\>\> root inode lookup 
+ *
+ * @param parent_inode - 
+ * @param dentry       -
+ * @param flags    - 
+ *
+ * @return pointer to dentry with filled inode or NULL on error
+ */
+static struct dentry *proxyfs_fs_rootinode_lookup(
+		struct inode *parent_inode, struct dentry *dentry, unsigned int flags) 
+{
+	struct inode *fileinode; 
+	unsigned long inode_num;
+	uint32_t file_number;
+	uint32_t owner_pid;
+
+	memory_sanity_check("Prescan");
+	
+	mdbg(INFO3, "filename %s", dentry->d_name.name);
+
+
+	if ( sscanf(dentry->d_name.name, "%u-%u", &owner_pid, &file_number) != 2 ) 
+		goto not_found; // Invalid format
+
+	memory_sanity_check("Postscan");
+	
+	inode_num = (owner_pid << 16) + file_number;
+
+	mdbg(INFO3, "rootinode lookup %lx (pid: %d, file_num: %d)\n", inode_num, owner_pid, file_number);
+	fileinode = iget_locked(parent_inode->i_sb, inode_num);
+	//fileinode = iget(parent_inode->i_sb, inode_num);
+	
+	if(!fileinode){
+		mdbg(INFO3, "Cannot access proxyfs inode");
+		goto not_found; // Number isn't pid of tcmi_task
+	}
+
+	//fileinode->i_mode = S_IFREG | S_IRUSR | S_IWUSR | S_IRGRP;
+	// TODO: Was reg, changed to char.. maybe we should decide based on original file`s mode?
+	fileinode->i_mode = S_IFCHR | S_IRUSR | S_IWUSR | S_IRGRP;
+	fileinode->i_fop  = &fdinode_fops;
+	fileinode->i_op   = &fdinode_iops;
+
+	d_add(dentry, fileinode);
+
+	if (fileinode->i_state & I_NEW) {
+                unlock_new_inode(fileinode);
+        }
+
+	return NULL;
+
+not_found:
+	d_add(dentry, NULL);
+	return ERR_PTR(-EACCES);
+}
+
+/*
+ * File Operations
+ */
+
+/** \<\<private\>\> Open function for VFS
+ *
+ * @param *inode - pointer to inode identificating file we wanted to open
+ * @param *file  - pointer to struct file, which will be representing the newly opened file
+ *
+ * @return zero on success
+ */
+static int proxyfs_fs_fdinode_open(struct inode *inode, struct file *file) 
+{
+	struct proxyfs_proxy_file_t *proxy_file;
+	struct proxyfs_client_task *task = PROXYFS_CLIENT_TASK( inode->i_sb->s_fs_info );
+
+	mdbg(INFO2, "Opening file %lu. Its private data are %p", inode->i_ino, file->private_data);
+
+	proxy_file = proxyfs_client_open_proxy(task, inode->i_ino);
+
+	if( IS_ERR(proxy_file) )
+		return PTR_ERR(proxy_file);
+	file->private_data = proxy_file;
+	file->f_pos = 0;
+	
+	return 0;
+}
+
+/** \<\<private\>\> Release function for VFS (called on close)
+ * @param *inode - pointer to inode identificating file we wanted to open
+ * @param *file  - pointer to struct file, which will be representing the newly opened file
+ *
+ * @return zero on success
+ */
+static int proxyfs_fs_fdinode_release(struct inode *inode, struct file *file)
+{
+	int rtn;
+	struct proxyfs_proxy_file_t *proxy_file = file->private_data;
+
+	mdbg(INFO2, "file %p release called", proxy_file);
+
+	rtn = proxyfs_proxy_file_close(proxy_file);
+	if( rtn == 0){
+		proxyfs_proxy_file_destroy(proxy_file);
+		kfree(proxy_file);
+	}
+	return rtn;
+}
+
+/** \<\<private\>\> Fsync function for VFS 
+ * @param *file    - pointer to file we wanted to fsync 
+ * @param start  -  offset start byte
+ * @param end    -  offset end byte
+ * @param datasync - true for fdatasync system call
+ *
+ * @return zero on success
+ */
+static int proxyfs_fs_fdinode_fsync(struct file *file, loff_t start, loff_t end, int datasync)
+{
+	struct proxyfs_proxy_file_t *proxy_file = file->private_data;
+
+	mdbg(INFO2, "file %p sync called", proxy_file);
+
+	return proxyfs_proxy_file_fsync(proxy_file);
+}
+
+
+/** \<\<private\>\> Write function for VFS
+ * @param *file   - pointer to file we wanted to write to
+ * @param *buf    - pointer to buffer in userspace with data 
+ * @param count   - size of data
+ * @param *offset - pointer to file offset
+ *
+ * @return Amount of bytes written or error 
+ */
+static ssize_t proxyfs_fs_fdinode_write(struct file *file, const char *buf, size_t count, loff_t *offset)
+{
+	int length, total = 0;
+	struct proxyfs_proxy_file_t *proxyfile;
+	struct proxyfs_task *task = PROXYFS_TASK( file->f_dentry->d_inode->i_sb->s_fs_info );
+
+	proxyfile = (struct proxyfs_proxy_file_t *) file->private_data;
+
+	if((ssize_t) count < 0) return -EINVAL;
+
+	mdbg(INFO2, "file %p, buf %p, count %lu, offset %llu", proxyfile, buf, (unsigned long)count, (unsigned long long)*offset);
+	mdbg(INFO2, "Content %.*s", (int)count, buf);
+
+write:	length = proxyfs_proxy_file_write_user(proxyfile, buf + total, count - total);
+	
+	mdbg(INFO2, "file %p, written, %d", proxyfile, (int)length);
+
+	if( length > 0 ){
+		*offset += length;
+		//proxyfs_task_wakeup( task );
+		proxyfs_task_notify_data_ready(task);
+		total += length;
+		if( total == count || file->f_flags & O_NONBLOCK )
+			return total;
+		else
+			goto write;
+	}
+	else if( length == 0 ){ // Buffer is full
+		if( file->f_flags & O_NONBLOCK ) {
+			mdbg(INFO2, "Buffer full in non-block mode -> EAGAIN");
+			return -EAGAIN;
+		}
+		else { // Block on file
+			mdbg(INFO2, "Buffer full in block mode -> wait");
+			switch( proxyfs_proxy_file_wait_interruptible(proxyfile, 
+				PROXYFS_FILE_CAN_WRITE | PROXYFS_FILE_EPIPE | PROXYFS_FILE_CLOSED)){				
+				case PROXYFS_FILE_EPIPE:
+					return -EPIPE;  // This is seen by reading process only if it catches 
+							// or ignore SIGPIPE
+				case PROXYFS_FILE_CLOSED:
+					return -EBADF;
+				case PROXYFS_FILE_CAN_WRITE:
+					goto write;
+				case 0:
+					return -ERESTARTSYS;
+			}
+		}
+	}
+	else if( length < -4 ){ // Writing to pipe, needs -length bytes.
+		if( file->f_flags & O_NONBLOCK ) {
+			mdbg(INFO2, "Returning AGAIN");
+			return -EAGAIN;
+		} else { // Block on file
+			int file_state = proxyfs_proxy_file_wait_for_space_interruptible(proxyfile, -length);
+			if ( file_state & PROXYFS_FILE_CAN_WRITE ) {
+				mdbg(INFO2, "Restarting write");
+				goto write;
+			}
+
+			switch( file_state){
+
+				case PROXYFS_FILE_EPIPE:
+					mdbg(INFO2, "Returning EPIPE");
+					return -EPIPE;  // This is seen by reading process only if it catches 
+					// or ignore SIGPIPE
+				case 0:
+					mdbg(INFO2, "Returning ERESTARTSYS");
+					return -ERESTARTSYS;
+				default:
+					mdbg(INFO2, "Unknown file state: %d", file_state);
+			}
+
+		}
+	}
+	return -1;	
+}
+
+/** \<\<private\>\> Read function for VFS
+ * @param *file   - pointer to file we wanted to read from
+ * @param *buf    - pointer to buffer in userspace witch will be filled with data 
+ * @param count   - size of buffer
+ * @param *offset - pointer to file offset
+ *
+ * @return Amount of bytes read or error 
+ */
+static ssize_t proxyfs_fs_fdinode_read(struct file *file, char *buf, size_t count, loff_t *offset)
+{
+	size_t length;
+	struct proxyfs_proxy_file_t *proxyfile;
+
+	proxyfile = (struct proxyfs_proxy_file_t *) file->private_data;
+
+	if((ssize_t) count < 0) return -EINVAL;
+
+	mdbg(INFO2, "file %p, buf %p, count %lu, offset %llu", proxyfile, buf, (unsigned long)count, (unsigned long long)*offset);
+
+read:	length = proxyfs_proxy_file_read_user(proxyfile, buf, count);
+	
+	mdbg(INFO2, "Read content %.*s", (int)length, buf);
+
+	mdbg(INFO2, "file %p, read, %d", proxyfile, (int)length);
+
+	if( length > 0 ){
+		*offset += length;
+		return length;
+	}
+	else if( length == 0 ){ // Buffer is empty
+		if( proxyfs_file_get_status( PROXYFS_FILE( proxyfile ), PROXYFS_FILE_READ_EOF ) ){
+			mdbg(INFO4, "EOF");
+			// The following condition is check for a situation, where we got data + eof after the read was processed
+			// In that case, old read may return 0, but now there are data and in addition EOF is set
+			if ( proxyfs_file_get_status( PROXYFS_FILE( proxyfile ), PROXYFS_FILE_CAN_READ) ) {
+				mdbg(INFO4, "Still can read -> read buffer before eof");
+				goto read;
+			}
+			return 0;	
+		}
+		if( file->f_flags & O_NONBLOCK )
+			return -EAGAIN;
+		else { // Block on file 
+			mdbg(INFO2, "file %p, waiting for can read", proxyfile);
+			switch( proxyfs_proxy_file_wait_interruptible(proxyfile, 
+				PROXYFS_FILE_CAN_READ | PROXYFS_FILE_READ_EOF )){
+				// Can read shall be checked before EOF. It is possible to have both can_read and EOF up. In that case,
+				// we first read and eof after the buffer is empty
+				case PROXYFS_FILE_CAN_READ:
+					goto read;
+				case PROXYFS_FILE_READ_EOF:
+					return 0; // End of file
+				case 0:
+					return -EINTR;
+			}
+		}
+	}
+	return length;	
+}
+
+// TODO: Do we need setattr support?
+
+/** \<\<private\>\> Getattr function for VFS
+ * @param *mnt     - 
+ * @param *dentry  -  
+ * @param count - size of buffer
+ * @param *stat - pointer to kernel stat structure, which will be filled
+ *
+ * @return getattr return code 
+ */
+static int proxyfs_fs_fdinode_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
+{
+	unsigned long i_ino = dentry->d_inode->i_ino;
+	int fd;
+  fd = i_ino >> 16;
+
+	mdbg(INFO3, "GETATTR fd: %d; i_ino: %08lx; stat: %p;", fd, i_ino, stat);
+	generic_fillattr(dentry->d_inode, stat);
+
+	return 0;
+}
+
+/** \<\<private\>\> Ioctl function for VFS
+ * @param *file - pointer to file we wanted to call ioctl on
+ * @param cmd   - ioctl command
+ * @param arg   - ioctl argument
+ *
+ * @return ioctl return code 
+ */
+static long proxyfs_fs_fdinode_ioctl (struct file *file, unsigned int cmd, unsigned long arg){
+	struct proxyfs_proxy_file_t *proxyfile;
+	unsigned long ioctl_info;
+	size_t arg_size;
+
+	proxyfile = (struct proxyfs_proxy_file_t *) file->private_data;
+	ioctl_info = ioctl_get_info(cmd);
+	arg_size = IOCTL_ARG_SIZE(ioctl_info);
+
+	mdbg(INFO3, "IOCTL file: %lu cmd: %u arg: %lx arg_size: %lu", 
+			file->f_dentry->d_inode->i_ino, cmd, arg, (unsigned long)arg_size);
+
+	if( ioctl_info )
+		return proxyfs_proxy_file_ioctl_user(proxyfile, cmd, arg);
+	mdbg(ERR3, "Unknown IOCTL command %x", cmd);
+	return -ENOTTY;
+}
+
+/**
+ * \<\<public\>\> Registr proxyfs in kernel
+ *
+ * @return zero on succes
+ */
+int proxyfs_fs_init(void)
+{
+	return register_filesystem(&proxyfs);
+}
+
+/**
+ * \<\<public\>\> Unregistr proxyfs in kernel
+ *
+ */
+void proxyfs_fs_exit(void)
+{
+	unregister_filesystem(&proxyfs);
+}
+
--- linux-3.7.1_original/clondike/src/proxyfs/proxyfs_generic_proxy_file.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/proxyfs/proxyfs_generic_proxy_file.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,89 @@
+/**
+ * @file proxyfs_generic_proxy_file.c -  client generic fileclass (used by proxyfs_client_task)
+ *                      
+ * 
+ *
+ *
+ * Date: 08/02/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: proxyfs_generic_proxy_file.c,v 1.1 2007/09/03 03:40:45 malatp1 Exp $
+ *
+ * This file is part of Proxy filesystem (ProxyFS)
+ * Copyleft (C) 2007 Petr Malat
+ * 
+ * ProxyFS is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * ProxyFS is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include <linux/types.h>
+#include <linux/wait.h>
+#include <asm/uaccess.h>
+#include <linux/semaphore.h>
+
+#define PROXYFS_GENERIC_PROXY_FILE_PRIVATE
+#define PROXYFS_GENERIC_PROXY_FILE_PROTECTED // Own header
+#include "proxyfs_generic_proxy_file.h"
+
+/** \<\<private\>\> Write to file from user space buffer 
+ * @param *self - pointer to this file instance
+ * @param *buf - pointer to data in userspace
+ * @param count - size of data
+ *
+ * @return the number of bytes written or error (negative number)
+ * */
+static int proxyfs_generic_proxy_file_write_user(struct proxyfs_proxy_file_t *self, const char *buf, size_t count)
+{
+	int lenght;
+	if( ! access_ok(VERIFY_WRITE, buf, count) )
+		return -EFAULT;
+
+	down( & self->write_buf_sem );
+	lenght = circ_buf_write_user( & PROXYFS_FILE(self)->write_buf, buf, count );
+	up( & self->write_buf_sem );
+
+	return lenght;
+}
+
+
+/** \<\<private\>\> Read from file to user space buffer 
+ * @param *self - pointer to this file instance
+ * @param *buf - pointer to buffer in userspace
+ * @param count - size of data
+ *
+ * @return the number of bytes read or error (negative number)
+ */
+static int proxyfs_generic_proxy_file_read_user(struct proxyfs_proxy_file_t *self, char *buf, size_t count)
+{
+	int lenght;
+	if( ! access_ok(VERIFY_WRITE, buf, count) )
+		return -EFAULT;
+
+	down( & self->read_buf_sem );
+	lenght = circ_buf_read_user( & PROXYFS_FILE(self)->read_buf, buf, count );
+	up( & self->read_buf_sem );
+
+	return lenght;
+}
+
+/** \<\<public\>\> Specialize proxyfs_proxy_file to proxyfs_generic_proxy_file
+ * @param self - pointer to initialized proxyfs_proxy_file structure
+ *
+ * @return proxyfs_generic_proxy_file instance
+ * */
+struct proxyfs_generic_proxy_file *proxyfs_generic_proxy_file_from_proxy_file(struct proxyfs_proxy_file_t* self)
+{
+	self->ops = &generic_proxy_file_ops;
+	return PROXYFS_GENERIC_PROXY_FILE(self);
+}
--- linux-3.7.1_original/clondike/src/proxyfs/proxyfs_generic_proxy_file.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/proxyfs/proxyfs_generic_proxy_file.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,98 @@
+/**
+ * @file proxyfs_generic_proxy_file.h - Main client file class (used by proxyfs_client_task)
+ *                      
+ * 
+ *
+ *
+ * Date: 08/02/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: proxyfs_generic_proxy_file.h,v 1.2 2007/09/03 09:27:08 malatp1 Exp $
+ *
+ * This file is part of Proxy filesystem (ProxyFS)
+ * Copyleft (C) 2007 Petr Malat
+ * 
+ * ProxyFS is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * ProxyFS is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _PROXYFS_GENERIC_PROXY_FILE_H_PUBLIC
+#define _PROXYFS_GENERIC_PROXY_FILE_H_PUBLIC
+
+#include "proxyfs_proxy_file.h" // Parent
+
+/**
+ * @defgroup proxyfs_generic_proxy_file_class proxyfs_generic_proxy_file class
+ * @ingroup proxyfs_proxy_file_class
+ *
+ * This is used between VFS and proxyfs_client task for proxying generics
+ *
+ * @{
+ */
+
+/** \<\<public\>\> proxyfs_proxy_file_t declaration */
+struct proxyfs_generic_proxy_file;
+
+/** \<\<public\>\> Specialize proxyfs_proxy_file to proxyfs_generic_proxy_file */
+struct proxyfs_generic_proxy_file *proxyfs_generic_proxy_file_from_proxy_file(struct proxyfs_proxy_file_t* self);
+
+/** \<\<public\>\> Cast to struct proxyfs_proxy_file_t * */
+#define PROXYFS_GENERIC_PROXY_FILE(arg) ((struct proxyfs_generic_proxy_file *)(arg))
+
+#endif // _PROXYFS_GENERIC_PROXY_FILE_H_PUBLIC
+
+/********************** PROTECTED METHODS AND DATA ******************************/
+
+#ifdef PROXYFS_GENERIC_PROXY_FILE_PROTECTED
+#ifndef _PROXYFS_GENERIC_PROXY_FILE_H_PROTECTED
+#define _PROXYFS_GENERIC_PROXY_FILE_H_PROTECTED
+
+#define PROXYFS_PROXY_FILE_PROTECTED  // parent
+#include "proxyfs_proxy_file.h"
+
+/** \<\<protected\>\> Structure on which VFS and proxyfs_client task are interacting */
+struct proxyfs_generic_proxy_file {
+	/** Parrent structure */
+	struct proxyfs_proxy_file_t parent;
+};
+
+#endif // _PROXYFS_GENERIC_PROXY_FILE_H_PROTECTED
+#endif // PROXYFS_GENERIC_PROXY_FILE_PROTECTED
+
+#ifdef PROXYFS_GENERIC_PROXY_FILE_PRIVATE
+#ifndef _PROXYFS_GENERIC_PROXY_FILE_H_PRIVATE
+#define _PROXYFS_GENERIC_PROXY_FILE_H_PRIVATE
+
+/** \<\<private\>\> Write to file from user space buffer */
+static int proxyfs_generic_proxy_file_write_user(struct proxyfs_proxy_file_t *proxyfile, const char *buf, size_t count);
+
+/** \<\<private\>\> Read from file to user space buffer */
+static int proxyfs_generic_proxy_file_read_user(struct proxyfs_proxy_file_t *proxyfile, char *buf, size_t count);
+
+/** <\<\private\>\> Structure with pointers to virtual methods */
+static struct proxyfs_proxy_file_ops generic_proxy_file_ops = {
+	/** Write to file from user space buffer */
+	.write_user = &proxyfs_generic_proxy_file_write_user,
+	/** Read from file to user space buffer */
+	.read_user = &proxyfs_generic_proxy_file_read_user,
+};
+
+
+#endif // _PROXYFS_GENERIC_PROXY_FILE_H_PRIVATE
+#endif // PROXYFS_GENERIC_PROXY_FILE_PRIVATE
+
+/**
+ * @}
+ */
+
--- linux-3.7.1_original/clondike/src/proxyfs/virtual.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/proxyfs/virtual.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,14 @@
+#ifndef _VIRTUAL_H
+#define _VIRTUAL_H
+
+#define VIRTUAL_FUNC_VOID(call_name, args...)({\
+	if( self->ops && self->ops->call_name )\
+		self->ops->call_name(self, args);})
+
+
+#define VIRTUAL_FUNC(call_name, args...)({\
+	if( self->ops && self->ops->call_name )\
+		return self->ops->call_name(self, args);\
+	return 0;})
+
+#endif // _VIRTUAL_H
--- linux-3.7.1_original/clondike/src/proxyfs/proxyfs_peer.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/proxyfs/proxyfs_peer.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,181 @@
+/**
+ * @file proxyfs_peer.h - Represents connection between client and server.
+ *                      
+ * 
+ *
+ *
+ * Date: 08/12/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: proxyfs_peer.h,v 1.4 2008/01/17 14:36:44 stavam2 Exp $
+ *
+ * This file is part of Proxy filesystem (ProxyFS)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * ProxyFS is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * ProxyFS is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _PROXYFS_PEER_H
+#define _PROXYFS_PEER_H
+
+#include <linux/list.h>
+#include <asm/atomic.h>
+#include <linux/spinlock.h>
+
+#include <dbg.h>
+#include <kkc/kkc.h>
+#include <proxyfs/proxyfs_msg.h>
+
+/** @defgroup proxyfs_peer_class proxyfs_peer class
+ *
+ * @ingroup proxyfs_module_class
+ *
+ * This class represents connection between two peers
+ * allows sending and receiving messages
+ * 
+ * @{
+ */
+
+typedef enum {
+	PEER_CREATED,
+	PEER_CONNECTED,
+	PEER_DISCONNECTED,
+	PEER_DEAD,
+} proxyfs_peer_state_t;
+
+
+/** Structure representing peer connection */
+struct proxyfs_peer_t {
+	/** Comunication socket */
+	struct kkc_sock *sock;
+
+	/** Buffer for receiving */
+	void   *recv_buf;
+	/** Receiving offset to rec_buf */
+	size_t recv_start;
+
+	/** Queue of messages */ 
+	struct list_head msg_queue;
+
+	/** Peers list */
+	struct list_head peers;
+
+	/** For waiting on this socket */
+	wait_queue_t  socket_wait;
+	/** Lock guarding message enqueueing */
+	spinlock_t enqueue_msg_lock;
+
+	/** reference counter */
+	atomic_t ref_count;
+	/** State of the peer */
+	proxyfs_peer_state_t state;
+};
+
+/** Cast to struct proxyfs_peer_t * */
+#define PROXYFS_PEER(arg) ((struct proxyfs_peer_t *)arg)
+
+/** \<\<public\>\> Create proxyfs_peer instance */
+struct proxyfs_peer_t *proxyfs_peer_new(void);
+
+/** \<\<public\>\> Initialize proxyfs_peer instance */
+int proxyfs_peer_init(struct proxyfs_peer_t *self);
+
+/** \<\<public\>\> Gets proxyfs peers reference */
+static inline struct proxyfs_peer_t* proxyfs_peer_get(struct proxyfs_peer_t *self) {
+	if (self) {
+		atomic_inc(&self->ref_count);
+	}
+	return self;	
+};
+
+/** \<\<public\>\> Puts proxyfs peers reference */
+void proxyfs_peer_put(struct proxyfs_peer_t *self);
+
+/** \<\<public\>\> Nonblocking send queued messages */
+void proxyfs_peer_real_send(struct proxyfs_peer_t *self);
+
+/** \<\<public\>\> Nonblocking recv messages  */
+int proxyfs_peer_real_recv(struct proxyfs_peer_t *self);
+
+/** \<\<public\>\> Getter of peer state */
+static inline proxyfs_peer_state_t proxyfs_peer_get_state(struct proxyfs_peer_t *self) {
+	return self->state;
+};
+
+/** \<\<public\>\> Setter of peer state */
+static inline void proxyfs_peer_set_state(struct proxyfs_peer_t *self, proxyfs_peer_state_t state) {
+	self->state = state;
+};
+
+/** \<\<public\>\> Delete received message, and prepare to receiving new one
+ * @param self - pointer to proxyfs_peer_t instance 
+ * @return Zero on success
+ */
+static inline int proxyfs_peer_clear_msg(struct proxyfs_peer_t *self)
+{
+	if( self->recv_start >=  MSG_HDR_SIZE &&
+			proxyfs_msg_get_size( self->recv_buf ) == self->recv_start){
+		self->recv_start = 0;
+		return 0;
+	}
+	else
+	{
+		mdbg(ERR2, "Attempt to clear incomplete message");
+		return -1;
+	}
+}
+
+/** \<\<public\>\> Recv message  
+ * @param self - pointer to proxyfs_peer_t instance 
+ * @return Pointer to received message or NULL if there is none
+ */
+static inline struct proxyfs_msg *proxyfs_peer_get_msg(struct proxyfs_peer_t *self)
+{
+	if( self->recv_start >=  MSG_HDR_SIZE &&
+			proxyfs_msg_get_size( self->recv_buf ) == self->recv_start)
+		return (struct proxyfs_msg *)self->recv_buf;
+	else{
+		mdbg(INFO4, "Attempt to get incomplete message");
+		return NULL;
+	}
+}
+
+/** \<\<public\>\> Add message to sending queue
+ * @param self - pointer to proxyfs_peer_t instance 
+ * @param msg  - pointer to msg, which will be added to queue
+ */
+static inline void proxyfs_peer_send_msg(struct proxyfs_peer_t *self, struct proxyfs_msg *msg)
+{
+	mdbg(INFO4, "Adding msg %p to a send queue of peer %p", msg, self);
+	spin_lock(&self->enqueue_msg_lock);
+	list_add_tail( & msg->msg_queue, & self->msg_queue );
+	spin_unlock(&self->enqueue_msg_lock);
+	mdbg(INFO3, "Queued message %lu for file %lu", msg->header.msg_num, msg->header.file_ident);
+}
+
+/** \<\<public\>\> Connects to peer */
+int proxyfs_peer_connect(struct proxyfs_peer_t *self, const char *connect_str);
+
+/** \<\<public\>\> Disconnects  peer */
+int proxyfs_peer_disconnect(struct proxyfs_peer_t *self);
+
+/** \<\<public> Wait on till peer is connected */
+int proxyfs_peer_wait(struct proxyfs_peer_t *self);
+
+/**
+ * @}
+ */
+
+#endif // _PROXYFS_PEER_H
--- linux-3.7.1_original/clondike/src/proxyfs/buffer.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/proxyfs/buffer.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,230 @@
+/**
+ * @file buffer.h - Class representing circullar buffer.
+ *                      
+ * 
+ *
+ *
+ * Date: 08/12/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: buffer.h,v 1.4 2008/05/02 19:59:20 stavam2 Exp $
+ *
+ * This file is part of Proxy filesystem (ProxyFS)
+ * Copyleft (C) 2007  Petr Malat
+ * 
+ * ProxyFS is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * ProxyFS is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _BUFFER_H
+#define _BUFFER_H
+
+#include <linux/vmalloc.h>
+#include <linux/slab.h>
+#include <asm/uaccess.h>
+
+/**
+ * @defgroup circ_buf_clas circ_buf class
+ * @ingroup proxyfs_module_class
+ *
+ * This class represent circular buffer used as read/write file buffers in ProxyFS
+ *
+ * @{
+ */
+
+#define CIRC_BUF_USE_VMALLOC ( 4 << 10 )
+
+/** Circular buffer structure */
+struct circ_buf {
+	/** Pointer to memory which is used for buffering */
+	void *buf;
+	/** Write pointer */
+	void *write;
+	/** Read pointer */
+	void *read;
+	/** True if buffer is full */
+	int full;
+	/** Memory size */
+	unsigned size;
+};
+
+/** \<\<public\>\> Initialize buffer structure 
+ * @param self - pointer to this buffer instance
+ * @param size - buffer size
+ *
+ * @return zero on success
+ */
+
+/** \<\<public\>\> Write to buffer */
+int circ_buf_write(struct circ_buf *self, const char *buf, unsigned count);
+
+/** \<\<public\>\> Write to buffer from user space  */
+int circ_buf_write_user(struct circ_buf *self, const char *buf, unsigned count);
+
+/** \<\<public\>\> Destructively read from buffer */
+int circ_buf_read(struct circ_buf *self, char *buf, unsigned count);
+
+/** \<\<public\>\> Destructively read from buffer to userspace */
+int circ_buf_read_user(struct circ_buf *self, char *buf, unsigned count);
+
+static inline int circ_buf_init(struct circ_buf *self, unsigned size)
+{
+	if( size >= CIRC_BUF_USE_VMALLOC )
+		self->buf = vmalloc( size );
+	else
+		self->buf = kmalloc( size, GFP_KERNEL );
+
+	if( self->buf == NULL ) return -1;
+
+	self->size = size;
+	self->read = self->buf;
+	self->write = self->buf;
+	self->full = 0;
+	return 0;
+}
+
+/** \<\<public\>\> Opossite function to circ_buf_init
+ * @param self - pointer to this buffer instance
+ */
+static inline void circ_buf_destroy(struct circ_buf *self)
+{
+	if( self->size >= CIRC_BUF_USE_VMALLOC )
+	 	vfree(self->buf);
+	else
+		kfree(self->buf);
+	self->size = 0;
+	self->read = NULL;
+	self->write = NULL;
+}
+
+/** \<\<public\>\> Returns maximum amount of data which  are continuos - 
+ * can by copied with one memcpy call
+ * @param self - pointer to this buffer instance
+ *
+ * @return the amount of data
+ */
+static inline unsigned circ_buf_get_read_size(const struct circ_buf *self)
+{
+	if( self->write > self->read )
+		return self->write - self->read;
+	else if( self->write < self->read || self->full )
+		return (self->buf + self->size) - self->read;
+	return 0;
+}
+
+/** \<\<public\>\> Returns base address for reading - 
+ * @param self - pointer to this buffer instance
+ *
+ * @return address from which read should start 
+ */
+static inline void *circ_buf_get_read_addr(const struct circ_buf *self)
+{
+	return self->read;
+}
+
+/** \<\<public\>\> Returns maximum amount of free space which is continuos - 
+ * can by filled with one memcpy call
+ * @param self - pointer to this buffer instance
+ *
+ * @return the amount of data
+ */
+static inline unsigned circ_buf_get_write_size(const struct circ_buf *self)
+{
+	if( self->write > self->read )
+		return self->buf + self->size - self->write;
+	else if( self->write < self->read )
+		return self->read - self->write;
+	else if( self->full )
+		return 0;
+	// buf is empty
+	return self->buf + self->size - self->write;
+}
+
+/** \<\<public\>\> Returns base address for writting - 
+ * @param self - pointer to this buffer instance
+ *
+ * @return address from which write should start 
+ */
+static inline void *circ_buf_get_write_addr(const struct circ_buf *self)
+{
+	return self->write;
+}
+
+/** \<\<public\>\> Adjust read pointer
+ * @param self - pointer to this buffer instance
+ * @param count - how much adjust <b>WARNING: count must be between 0 and data total in buffer</b>
+ */
+static inline void circ_buf_adjust_read_ptr(struct circ_buf *self, const unsigned count)
+{
+	if( count > 0 ){
+		self->full = 0;
+		self->read += count;
+		if( self->read >= self->buf + self->size || self->read < self->buf )
+			self->read -= self->size;		
+	}
+}
+
+/** \<\<public\>\> Adjust write pointer
+ * @param self - pointer to this buffer instance
+ * @param count - how much adjust <b>WARNING: count must be between 0 and free space in buffer</b>
+ */
+static inline void circ_buf_adjust_write_ptr(struct circ_buf *self, const unsigned count)
+{
+	if( count > 0 ){
+		self->write += count;
+		if( self->write >= self->buf + self->size || self->write < self->buf )
+			self->write -= self->size;
+		if( self->write == self->read ) self->full = 1;
+	}
+}
+
+/** \<\<public\>\> get total free space in buffer
+ * @param self - pointer to this buffer instance
+ *
+ * @return amount of free bytes in buffer
+ */
+static inline unsigned circ_buf_free_space(struct circ_buf *self)
+{
+	if( self->write > self->read )
+		return (self->size - (self->write - self->read));
+	else if( self->write < self->read )
+		return self->read - self->write;
+	else if( self->full )
+		return 0;
+	// buf is empty
+	return self->size;
+}
+
+/** \<\<public\>\> get count of total data contained in the buffer
+ * @param self - pointer to this buffer instance
+ *
+ * @return total bytes contained by the buffer
+ */
+static inline unsigned circ_buf_count(struct circ_buf *self)
+{
+	return self->size - circ_buf_free_space(self);
+}
+
+/** \<\<public\>\> Nondestructively read from buffer at offset */
+int circ_buf_look_at(struct circ_buf *self, char *buf, unsigned count, size_t offset);
+
+/** \<\<public\>\> Method used for debugging purposes. Dumps content of a circular buffer to debug output */
+void circ_buf_dump(const char* prefix, struct circ_buf *self);
+
+/**
+ * @}
+ */
+
+
+#endif // _BUFER_H
--- linux-3.7.1_original/clondike/src/proxyfs/proxyfs_pipe_proxy_file.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/proxyfs/proxyfs_pipe_proxy_file.h	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,98 @@
+/**
+ * @file proxyfs_pipe_proxy_file.h - Main client file class (used by proxyfs_client_task)
+ *                      
+ * 
+ *
+ *
+ * Date: 08/02/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: proxyfs_pipe_proxy_file.h,v 1.2 2007/09/03 09:27:08 malatp1 Exp $
+ *
+ * This file is part of Proxy filesystem (ProxyFS)
+ * Copyleft (C) 2007 Petr Malat
+ * 
+ * ProxyFS is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * ProxyFS is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _PROXYFS_PIPE_PROXY_FILE_H_PUBLIC
+#define _PROXYFS_PIPE_PROXY_FILE_H_PUBLIC
+
+#include "proxyfs_proxy_file.h" // Parent
+
+/**
+ * @defgroup proxyfs_pipe_proxy_file_class proxyfs_pipe_proxy_file class
+ * @ingroup proxyfs_proxy_file_class
+ *
+ * This is used between VFS and proxyfs_client task for proxying pipes
+ *
+ * @{
+ */
+
+/** \<\<public\>\> proxyfs_proxy_file_t declaration */
+struct proxyfs_pipe_proxy_file;
+
+/** \<\<public\>\> Specialize proxyfs_proxy_file to proxyfs_pipe_proxy_file */
+struct proxyfs_pipe_proxy_file *proxyfs_pipe_proxy_file_from_proxy_file(struct proxyfs_proxy_file_t* self);
+
+/** \<\<public\>\> Cast to struct proxyfs_proxy_file_t * */
+#define PROXYFS_PIPE_PROXY_FILE(arg) ((struct proxyfs_pipe_proxy_file *)(arg))
+
+#endif // _PROXYFS_PIPE_PROXY_FILE_H_PUBLIC
+
+/********************** PROTECTED METHODS AND DATA ******************************/
+
+#ifdef PROXYFS_PIPE_PROXY_FILE_PROTECTED
+#ifndef _PROXYFS_PIPE_PROXY_FILE_H_PROTECTED
+#define _PROXYFS_PIPE_PROXY_FILE_H_PROTECTED
+
+#define PROXYFS_PROXY_FILE_PROTECTED  // parent
+#include "proxyfs_proxy_file.h"
+
+/** \<\<protected\>\> Structure on which VFS and proxyfs_client task are interacting */
+struct proxyfs_pipe_proxy_file {
+	/** Parrent structure */
+	struct proxyfs_proxy_file_t parent;
+};
+
+#endif // _PROXYFS_PIPE_PROXY_FILE_H_PROTECTED
+#endif // PROXYFS_PIPE_PROXY_FILE_PROTECTED
+
+#ifdef PROXYFS_PIPE_PROXY_FILE_PRIVATE
+#ifndef _PROXYFS_PIPE_PROXY_FILE_H_PRIVATE
+#define _PROXYFS_PIPE_PROXY_FILE_H_PRIVATE
+
+/** \<\<private\>\> Write to file from user space buffer */
+static int proxyfs_pipe_proxy_file_write_user(struct proxyfs_proxy_file_t *proxyfile, const char *buf, size_t count);
+
+/** \<\<private\>\> Read from file to user space buffer */
+static int proxyfs_pipe_proxy_file_read_user(struct proxyfs_proxy_file_t *proxyfile, char *buf, size_t count);
+
+/** <\<\private\>\> Structure with pointers to virtual methods */
+static struct proxyfs_proxy_file_ops pipe_proxy_file_ops = {
+	/** Write to file from user space buffer */
+	.write_user = &proxyfs_pipe_proxy_file_write_user,
+	/** Read from file to user space buffer */
+	.read_user = &proxyfs_pipe_proxy_file_read_user,
+};
+
+
+#endif // _PROXYFS_PIPE_PROXY_FILE_H_PRIVATE
+#endif // PROXYFS_PIPE_PROXY_FILE_PRIVATE
+
+/**
+ * @}
+ */
+
--- linux-3.7.1_original/clondike/src/proxyfs/proxyfs_real_file.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/proxyfs/proxyfs_real_file.c	2013-03-07 20:17:17.000000000 +0100
@@ -0,0 +1,353 @@
+/**
+ * @file proxyfs_real_file.c - Main real file class (used by proxyfs_server_task)
+ *                      
+ * 
+ *
+ *
+ * Date: 08/02/2007
+ *
+ * Author: Petr Malat
+ *
+ * $Id: proxyfs_real_file.c,v 1.8 2008/01/17 14:36:44 stavam2 Exp $
+ *
+ * This file is part of Proxy filesystem (ProxyFS)
+ * Copyleft (C) 2007 Petr Malat
+ * 
+ * ProxyFS is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * ProxyFS is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/vfs.h>
+
+#include <asm/poll.h>
+
+#include <dbg.h>
+#include <proxyfs/proxyfs_peer.h>
+
+#define PROXYFS_REAL_FILE_PRIVATE
+#define PROXYFS_REAL_FILE_PROTECTED
+#include "proxyfs_real_file.h"
+
+/** \<\<public\>\> Do ioctl 
+ * @param *self - pointer to this file instance
+ * @param cmd - ioctl cmd
+ * @param arg - ioctl arg
+ *
+ * @return - return code of ioctl
+ * */
+long proxyfs_real_file_do_ioctl(struct proxyfs_real_file *self, unsigned int cmd, unsigned long arg)
+{
+	int error = -ENOTTY;
+	mm_segment_t old_fs;
+	old_fs = get_fs();
+
+	if (S_ISREG(self->file->f_path.dentry->d_inode->i_mode))
+		goto out;
+
+	if (!self->file->f_op)
+		goto out;
+	
+	set_fs(KERNEL_DS);
+
+	if (self->file->f_op->unlocked_ioctl) {
+		error = self->file->f_op->unlocked_ioctl(self->file, cmd, arg);
+		if (error == -ENOIOCTLCMD) {
+			error = -EINVAL;
+			mdbg(ERR2, "No ioctl cmd %d for file %lu", cmd, proxyfs_file_get_file_ident(PROXYFS_FILE(self)));
+		}
+		goto out;
+	}
+  /* Commented by Jiru Rakosnik because ioctl fileoperation is not exist in kernel 3.x
+   else if (self->file->f_op->ioctl) {
+		lock_kernel();
+		error = self->file->f_op->ioctl(self->file->f_path.dentry->d_inode,
+				self->file, cmd, arg);
+		unlock_kernel();
+	}
+   */
+out:
+	set_fs(old_fs);
+	return error;
+}
+
+/** \<\<public\>\> Write to real file 
+ * @param *self - pointer to this file instance
+ *
+ * @return amount of bytes written
+ */
+int proxyfs_real_file_write(struct proxyfs_real_file *self)
+{
+	if( self->ops && self->ops->write )
+		return self->ops->write(self);
+	else{
+		mdbg(ERR3, "No write method");
+		return -1;
+	}
+}
+
+/** \<\<public\>\> Read from real file 
+ * @param *self - pointer to this file instance
+ *
+ * @return amount of bytes read
+ */
+int proxyfs_real_file_read(struct proxyfs_real_file *self)
+{
+	if( self->ops && self->ops->read )
+		return self->ops->read(self);
+	else{
+		mdbg(ERR3, "No read method");
+		return -1;
+	}
+}
+
+/** \<\<public\>\> Initialize real_file 
+ * @param *self - pointer to this file instance
+ *
+ * @return zero on success
+ */
+int proxyfs_real_file_init(struct proxyfs_real_file *self)
+{
+	int rtn = proxyfs_file_init( PROXYFS_FILE( self ) );
+	if( rtn == 0 ) {
+		PROXYFS_FILE( self )->ops = &real_file_ops;
+		INIT_LIST_HEAD( & self->shadow_list );
+	}
+	return rtn;
+}
+
+/** \<\<public\>\> "Open" file and send response message 
+ * @param *self - pointer to this file instance
+ * @param *peer - instance of peer which is opening this file
+ *
+ * @return zero on success
+ */
+int proxyfs_real_file_open(struct proxyfs_real_file *self, struct proxyfs_peer_t *peer)
+{
+	int res;
+	if( self->ops && self->ops->open ) {
+		res = self->ops->open(self, peer);
+		if ( !res )
+			proxyfs_file_set_peer(PROXYFS_FILE(self),peer);
+		return res;
+	} else{
+		mdbg(ERR3, "No open method");
+		return -EINVAL;
+	}
+}
+
+/** \<\<public\>\> "Close" file  
+ * @param *self - pointer to this file instance
+ * @param *peer - instance of peer which is closing this file
+ *
+ * @return zero on success
+ */
+int proxyfs_real_file_close(struct proxyfs_real_file *self, struct proxyfs_peer_t *peer)
+{
+	struct proxyfs_msg *msg;
+	int rtn = 0;
+
+	if( PROXYFS_FILE(self)->peer == peer ){
+		msg = proxyfs_msg_new(MSG_CLOSE_RESP, proxyfs_file_get_file_ident(PROXYFS_FILE(self)), 0, NULL );
+		if ( !msg )
+			return -ENOMEM;
+
+		proxyfs_peer_send_msg( peer, msg );
+		proxyfs_file_set_peer(PROXYFS_FILE(self),NULL);
+		PROXYFS_FILE(self)->write_buf_unconfirmed = 0;
+	}
+	else{
+		mdbg(ERR3, "Close message come from peer which hasn't opened the file");
+		rtn = -1;
+	}
+
+	return rtn;
+}
+
+/** \<\<public\>\> fsync file  
+ * @param *self - pointer to this file instance
+ * @param *peer - instance of peer which is fsyncing this file
+ *
+ * @return zero on success
+ */
+int proxyfs_real_file_fsync(struct proxyfs_real_file *self, struct proxyfs_peer_t *peer)
+{
+	struct proxyfs_msg *msg;
+	int rtn;
+
+	if( PROXYFS_FILE(self)->peer == peer ){
+		rtn = vfs_fsync( self->file, 0 );    //Remove second parameter self->file->f_path.dentry because in new kernel it isn't by Jiri Rakosnik 
+		// TODO: How do we send the result of fsync back? Or is there some fsync failed msg to be sent?
+		msg = proxyfs_msg_new(MSG_FSYNC_RESP, proxyfs_file_get_file_ident(PROXYFS_FILE(self)), 0, NULL );
+		if ( !msg )
+			return -ENOMEM;
+
+		proxyfs_peer_send_msg( peer, msg );
+	}
+	else{
+		mdbg(ERR3, "Fsync message come from peer which hasn't opened the file");
+		rtn = -1;
+	}
+
+	return rtn;
+}
+
+int proxyfs_real_file_mark_read_request(struct proxyfs_real_file *self, struct proxyfs_peer_t *peer) {
+	struct proxyfs_msg *msg;
+
+	msg = proxyfs_msg_new(MSG_READ_REQUEST_RESP, proxyfs_file_get_file_ident(PROXYFS_FILE(self)), 0, NULL );
+	if ( !msg )
+		return -ENOMEM;
+
+	proxyfs_file_mark_read_requested(PROXYFS_FILE(self));
+
+	proxyfs_peer_send_msg( peer, msg );
+
+	return 0;
+}
+
+/** \<\<public\>\> Deinitialize real_file 
+ * @param *self - pointer to this file instance
+ */
+void proxyfs_real_file_destroy(struct proxyfs_real_file *self)
+{	
+	struct list_head *l, *nxt;
+	struct proxyfs_real_file_waiter* waiter;
+	mdbg(INFO3, "Destroying real file: %lu", proxyfs_file_get_file_ident(PROXYFS_FILE(self)));
+
+	list_for_each_safe( l, nxt, &self->waiters_list ){
+		waiter = list_entry(l, struct proxyfs_real_file_waiter, waiters_list);
+		remove_wait_queue(waiter->wait_head, &waiter->wait);
+		mdbg(INFO3, "Remove from waitqueue: %lu", proxyfs_file_get_file_ident(PROXYFS_FILE(self)));
+		kfree(waiter);
+	}
+
+	proxyfs_file_destroy( PROXYFS_FILE( self ) );
+}
+
+/** \<\<private\>\> Get maximum amount and address of data, that can be read at one time
+ * @param *self - pointer to this file instance
+ * @param *total_size - pointer to size_t into which a total available data count will be written
+ * @param *size - pointer to size_t into which the data size will be written 
+ * @param **addr - pointer to void* into which the data address will be written 
+ *
+ * */
+static void proxyfs_real_file_write_buf_info(struct proxyfs_file_t *self, size_t* total_size, size_t* size, void** addr)
+{
+	// TODO: No need of lock here? Comment why ;)
+	*total_size = circ_buf_count( & self->write_buf );
+	*size = circ_buf_get_read_size( & self->write_buf );
+	*addr = circ_buf_get_read_addr( & self->write_buf );
+}
+
+/** \<\<private\>\> Writes to file from peer - writes to read buffer 
+ * @param *self - pointer to this file instance
+ * @param *buf - pointer to data in kernelspace
+ * @param count - size of data
+ *
+ * @return the number of bytes written 
+ * */
+static int proxyfs_real_file_write_from_peer(struct proxyfs_file_t *self, const char *buf, size_t count)
+{
+	int lenght;
+
+	lenght = circ_buf_write( & self->read_buf, buf, count );
+	
+	return lenght;
+}
+
+/** \<\<private\>\> Reads from file to peer - reads from write buffer 
+ * @param *self - pointer to this file instance
+ * @param *buf - pointer to buffer in kernelspace
+ * @param count - size of data
+ *
+ * @return the number of bytes read or error (negative number)
+ */
+static int proxyfs_real_file_read_to_peer(struct proxyfs_file_t *self, char *buf, size_t count)
+{
+	int lenght;
+
+	lenght = circ_buf_look_at( & self->write_buf, buf, count, self->write_buf_unconfirmed);
+	if( lenght > 0 )
+		self->write_buf_unconfirmed += lenght;
+	
+	return lenght;
+}
+
+/** \<\<private\>\> Submit that data was written to file on other side 
+ * (can be safely deleted from proxyfs_file buffer) 
+ * @param *self - pointer to this file instance
+ * @param count - ammount of submited data  
+ */
+static void proxyfs_real_file_submit_read_to_peer(struct proxyfs_file_t *self, size_t count)
+{
+	circ_buf_adjust_read_ptr( & self->write_buf, count);
+	self->write_buf_unconfirmed -= count;
+}
+
+/** 
+ * \<\<public\>\> Adds shadow task into a shadow list of the file  
+ *
+ * @return 0 on success
+ */
+int proxyfs_real_file_add_shadow(struct proxyfs_real_file *self, struct task_struct* shadow) {
+	struct proxyfs_real_file_task* file_task = kmalloc(sizeof(struct proxyfs_real_file_task), GFP_KERNEL);
+	if ( !file_task )
+		return -ENOMEM;
+
+	file_task->shadow = shadow;
+	list_add( &file_task->shadow_list, &self->shadow_list );
+
+	return 0;	
+}
+
+/** 
+ * \<\<public\>\> Removes shadow task from a shadow list of the file  
+ *
+ * @return 1, if list become empty, 0 otherwise
+ */
+int proxyfs_real_file_remove_shadow(struct proxyfs_real_file *self, struct task_struct* shadow) {
+	struct list_head *l, *nxt;
+	struct proxyfs_real_file_task* file_task;
+
+	list_for_each_safe( l, nxt, &self->shadow_list ){
+		file_task = list_entry(l, struct proxyfs_real_file_task, shadow_list);
+		if ( file_task->shadow == shadow ) {
+			list_del(l);
+			kfree(file_task);
+			break;
+		}
+	}
+
+	return list_empty(&self->shadow_list);
+}
+
+/** 
+ * \<\<public\>\> Checks, whether shadow task is in list of shadow tasks of this file
+ *
+ * @return 1, if the file is used also by provided shadow task
+ */
+int proxyfs_real_file_has_shadow(struct proxyfs_real_file *self, struct task_struct* shadow) {
+	struct list_head *l;
+	struct proxyfs_real_file_task* file_task;
+
+	list_for_each( l,  &self->shadow_list ){
+		file_task = list_entry(l, struct proxyfs_real_file_task, shadow_list);
+		if ( file_task->shadow == shadow ) {
+			return 1;
+		}
+	}
+
+	return 0;
+}
--- linux-3.7.1_original/clondike/src/scripts/dbgenv.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/src/scripts/dbgenv.c	2013-01-07 11:26:37.000000000 +0100
@@ -0,0 +1,45 @@
+/**
+ * @file dbgenv.c - sets debug flags according to environment
+ *                      
+ * Author: Petr Malat
+ *
+ * This file is part of Clondike.
+ *
+ * Clondike is free software: you can redistribute it and/or modify it under 
+ * the terms of the GNU General Public License version 2 as published by 
+ * the Free Software Foundation.
+ *
+ * Clondike is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more 
+ * details.
+ * 
+ * You should have received a copy of the GNU General Public License along with 
+ * Clondike. If not, see http://www.gnu.org/licenses/.
+ */
+
+#include <libgen.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+int main(int argc, char *argv[])
+{
+	char buf[64], *env, *appname;
+	const char * const mdbgvars[] = {
+		"CRIT", "ERR", "WARN", "INFO"
+	};
+	unsigned i;
+
+	if (argc != 2) return -1;
+
+	appname = basename(dirname(argv[1]));
+	printf("-DAPP_NAME=clondike-%s ", appname);
+
+	for (i = 0; i < sizeof mdbgvars/sizeof mdbgvars[0]; i++) {
+		sprintf(buf, "MDBG_%s_%s", appname, mdbgvars[i]);
+		env = getenv(buf);
+		if (env) printf("-DMDBG_%s=%s ", mdbgvars[i], env);
+	}
+
+	return 0;
+}
--- linux-3.7.1_original/clondike/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/clondike/Kconfig	2013-01-07 11:22:45.000000000 +0100
@@ -0,0 +1,56 @@
+#
+# Clondike
+#
+
+menu "Clondike"
+
+config TCMI
+	tristate "Enable TCMI"
+	select TCMI_HOOKS
+	help
+	  Clondike is a clustering project started at FEE CTU Prague.
+	  To read more see project website at http://clondike.felk.cvut.cz
+	  This option enables Task Checkpointing and Migration Infrastructure(TCMI) 
+	  support in the kernel. 
+	
+
+	  If unsure, say N.
+
+config TCMI_HOOKS
+	bool "TCMI hooks"
+	depends on TCMI
+	help
+	  This option enables kernel hooks used by Task Checkpointing
+	  and Migration Infrastructure(TCMI) to intercept various system
+	  calls and install migration mode handler. 
+
+
+config TCMI_CCN
+	bool "Enable TCMI CCN support"
+	depends on TCMI
+	help
+	  Enables Cluster Core Node (CCN) support in TCMI framework.
+
+
+	  If unsure, say N.
+
+config TCMI_PEN
+	bool "Enable TCMI PEN support"
+	depends on TCMI
+	help
+	  Enables Process Execution Node (PEN) support in TCMI framework.
+
+
+	  If unsure, say N.
+
+config TCMI_DEBUG
+	bool "Enable TCMI debug messages"
+	depends on TCMI
+	help
+	  Enables TCMI debug messages
+	
+	
+	  If unsure, say N.
+
+endmenu
+
--- linux-3.7.1_original/include/clondike/tcmi/tcmi_dbg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/include/clondike/tcmi/tcmi_dbg.h	2013-01-31 10:18:05.000000000 +0100
@@ -0,0 +1,31 @@
+/**
+* @file tcmi_dbg.h - Helper module when debugging TCMI tasks in kernel
+* 
+* 
+* 
+* 
+* 
+* 
+*
+* Date: 04/21/2005
+*
+* Author: Jan Capek
+*
+* $Id: linux-2.6.23-uml-clondike.patch,v 1.1 2009-01-20 14:22:16 andrep1 Exp $
+*
+* License....
+*/
+
+#ifndef _TCMI_DBG_H
+#define _TCMI_DBG_H
+
+
+extern int tcmi_dbg;
+
+#define TCMI_ON_DEBUG if (tcmi_dbg && current->tcmi.tcmi_task)
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_DBG_H */
\ No newline at end of file
--- linux-3.7.1_original/include/clondike/tcmi/tcmi_hooks_factory.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/include/clondike/tcmi/tcmi_hooks_factory.h	2013-02-20 12:47:16.000000000 +0100
@@ -0,0 +1,125 @@
+/**
+ * @file tcmi_hooks_factory.h - Declaration of all a factory class that
+ *                              produces hooks declarations and definitions
+ * 
+ * 
+ * 
+ * 
+ * 
+ *
+ * Date: 04/21/2005
+ *
+ * Author: Jan Capek, based on lmmdefs.h by Martin Kacer
+ *
+ * $Id: linux-2.6.23-uml-clondike.patch,v 1.1 2009-01-20 14:22:16 andrep1 Exp $
+ *
+ * License....
+ */
+
+#ifndef _TCMI_HOOKS_FACTORY_H
+#define _TCMI_HOOKS_FACTORY_H
+
+
+/** @defgroup tcmi_hooks_factory_class tcmi_hooks_factory class 
+ * 
+ * This \<\<singleton\>\> class allows declaration and definition
+ * of new kernel hooks. A component that wants to create a new hook
+ * adds its definition in tcmi_hooks.h, using TCMI_HOOKS_DEFINE macro. 
+ * The hook method is then called using TCMI_HOOKS_CALL macro from
+ * appropriate place in the kernel. The parameters passed to the call
+ * must match the hook definition.
+ *
+ * Any module that wants to register a method that will always be
+ * called by the hook calls
+ * tcmi_hooks_register_NAME(custom_method). Where the NAME suffix is
+ * the identifier used in HOOK definition in tcmi_hooks.h.
+ * 
+ * The benefit of this solution, is that we have to export only one
+ * new symbol - the hook pointer. Everything else is handled by static
+ * inline methods or macros.
+ *
+ *
+ *@{
+ */
+
+/** 
+ * Defines a hook that requires:
+ *
+ * - declaration of new data type for the method that is to be
+ * registered. This method is then required as a parameter for the
+ * registration method.
+ *
+ * - declaration of registration/unregistration methods
+ * - declares the pointer to the hooks method
+ *
+ * In addition, since this file is also included by tcmi_hooks.c
+ * module it will define the registration and unregistration function,
+ * and a the default hook method - NULL
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+/* When used as private, we generate also definitions */
+#ifdef TCMI_HOOKS_FACTORY_PRIVATE
+/** 
+ * Following macro is used by the public TCMI_HOOKS_DEFINE to define the actual
+ * hook method pointer and export it. This is done in tcmi_hooks.c and the user
+ * doesn't have to worry about it anymore as it will get linked into the kernel.
+ */
+#define TCMI_HOOKS_DEFINE_PRIVATE(method, args...)					\
+tcmi_hooks_##method##_t *tcmi_hooks_##method = NULL;					\
+EXPORT_SYMBOL(tcmi_hooks_##method);					
+
+#else
+/* empty macro, when included from some place else*/
+#define TCMI_HOOKS_DEFINE_PRIVATE(method, args...)
+#endif /* TCMI_HOOKS_FACTORY_PRIVATE */
+
+/** 
+ * This macro is to declare the hook method pointer in tcmi_hooks.h.
+ * In the tcmi_hooks.c, it also defines the hook pointer.
+ */
+#define TCMI_HOOKS_DEFINE(method, args...)						\
+typedef long tcmi_hooks_##method##_t(args);						\
+extern tcmi_hooks_##method##_t *tcmi_hooks_##method;					\
+static inline void tcmi_hooks_register_##method(tcmi_hooks_##method##_t *method)	\
+{											\
+	tcmi_hooks_##method = method;							\
+}											\
+static inline void tcmi_hooks_unregister_##method(void)					\
+{											\
+	tcmi_hooks_##method = NULL;							\
+}											\
+TCMI_HOOKS_DEFINE_PRIVATE(method, args);
+
+
+
+/**
+ * Since each hook method returns an int, this macro generates an
+ * expression, that calls the hook method if one is defined.
+ * The value of the expression is 0, if no hook method has been registered.
+ * If there is a valid hook method registered, we get back the value
+ * returned by this method. 
+ *
+ * @param method - name of the method(e.g. exec) that
+ * is to be called
+ * @param args - arguments of the method
+ */
+#define TCMI_HOOKS_CALL(method, args...)		\
+({							\
+	int __tcmi_hook_ret = 0;			\
+ if (tcmi_hooks_##method != NULL)		\
+		__tcmi_hook_ret =			\
+			tcmi_hooks_##method(args);	\
+	__tcmi_hook_ret;				\
+})
+
+
+#define TCMI_TASK_GUEST if (current->tcmi.tcmi_task && current->tcmi.task_type == guest)
+
+/**
+ * @}
+ */
+ 
+#endif /* _TCMI_HOOKS_FACTORY_H */
\ No newline at end of file
--- linux-3.7.1_original/include/clondike/tcmi/tcmi_hooks.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/include/clondike/tcmi/tcmi_hooks.h	2013-03-12 18:55:27.000000000 +0100
@@ -0,0 +1,104 @@
+/**
+ * @file tcmi_hooks.h - Declaration of all hooks that are to be used in the kernel.
+ * 
+ * 
+ * 
+ * 
+ * 
+ * 
+ *
+ * Date: 04/21/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: linux-2.6.23-uml-clondike.patch,v 1.1 2009-01-20 14:22:16 andrep1 Exp $
+ *
+ * License....
+ */
+
+#ifndef _TCMI_HOOKS_H
+#define _TCMI_HOOKS_H
+
+#include <clondike/tcmi/tcmi_hooks_factory.h>
+#include <asm/ptrace.h>
+#include <asm/siginfo.h>
+#include <linux/capability.h>
+#include <linux/resource.h>
+
+/** execve */
+TCMI_HOOKS_DEFINE(execve, const char *, const char * const*, const char * const*, struct pt_regs *);
+
+/** wait */
+TCMI_HOOKS_DEFINE(sys_wait4, pid_t, int __user *, int, struct rusage __user *);
+
+/** fork hooks */
+/** Called in the beginning of the fork */
+TCMI_HOOKS_DEFINE(pre_fork, unsigned long, unsigned long, struct pt_regs *, unsigned long, int __user *, int __user *);
+/** Called in the middle of fork (used to attach shadow/guest task to a newly forked task). Takes new child as a param */
+TCMI_HOOKS_DEFINE(in_fork, struct task_struct*);
+/** 
+ * Called in the end of the fork. Takes as param return value of fork, pid of process forked on associated CCN + result buffers (so that
+ * we can reset them, in case fork failed and we've filled them in prefork.
+ *
+ * The method is called after succesful fork, but befor the process is actually started
+ */
+TCMI_HOOKS_DEFINE(post_fork, struct task_struct*, long, pid_t, int __user *, int __user *);
+
+/** exit hook */
+TCMI_HOOKS_DEFINE(exit, long);
+
+/** syscalls **/
+/** signal */
+TCMI_HOOKS_DEFINE(sys_kill, int, int);
+TCMI_HOOKS_DEFINE(do_tkill, int, int, int);
+TCMI_HOOKS_DEFINE(sys_rt_sigqueueinfo, int, int, siginfo_t*);
+
+/** pid, gid and session manipulation */
+TCMI_HOOKS_DEFINE(sys_getpid, void);
+TCMI_HOOKS_DEFINE(sys_getppid, void);
+TCMI_HOOKS_DEFINE(sys_getpgid, pid_t);
+TCMI_HOOKS_DEFINE(sys_setpgid, pid_t, pid_t);
+TCMI_HOOKS_DEFINE(sys_getsid, pid_t);
+TCMI_HOOKS_DEFINE(sys_setsid, void);
+TCMI_HOOKS_DEFINE(sys_getpgrp, void);
+
+/** user identification */
+TCMI_HOOKS_DEFINE(sys_geteuid, void);
+TCMI_HOOKS_DEFINE(sys_getuid, void);
+TCMI_HOOKS_DEFINE(sys_getresuid, uid_t*, uid_t*, uid_t*);
+TCMI_HOOKS_DEFINE(sys_setresuid, uid_t, uid_t, uid_t);
+TCMI_HOOKS_DEFINE(sys_setuid, uid_t);
+TCMI_HOOKS_DEFINE(sys_setreuid, uid_t, uid_t);
+
+/** group identification */
+TCMI_HOOKS_DEFINE(sys_getegid, void);
+TCMI_HOOKS_DEFINE(sys_getgid, void);
+TCMI_HOOKS_DEFINE(sys_getgroups, int, gid_t *);
+TCMI_HOOKS_DEFINE(sys_getresgid, gid_t*, gid_t*, gid_t*);
+TCMI_HOOKS_DEFINE(sys_setgid, gid_t);
+TCMI_HOOKS_DEFINE(sys_setregid, gid_t, gid_t);
+TCMI_HOOKS_DEFINE(sys_setresgid, gid_t, gid_t, gid_t);
+TCMI_HOOKS_DEFINE(sys_setgroups, int, gid_t *);
+
+/** other */
+TCMI_HOOKS_DEFINE(sys_capget, cap_user_header_t, cap_user_data_t);
+
+
+/** SIGUNUSED default signal handler hook */
+TCMI_HOOKS_DEFINE(sig_unused, struct pt_regs*);
+TCMI_HOOKS_DEFINE(sig_deliver, int);
+TCMI_HOOKS_DEFINE(sig_delivered, int);
+TCMI_HOOKS_DEFINE(did_stop, int);
+TCMI_HOOKS_DEFINE(group_stop, int);
+TCMI_HOOKS_DEFINE(deq_sig, int);
+TCMI_HOOKS_DEFINE(send_sig, int);
+TCMI_HOOKS_DEFINE(doing_sigfatal, int, int);
+
+
+TCMI_HOOKS_DEFINE(replace_proc_self_file, const char*, const char**);
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_HOOKS_H */
\ No newline at end of file
--- linux-3.7.1_original/include/clondike/tcmi/tcmi_struct.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.7.1_clondike/include/clondike/tcmi/tcmi_struct.h	2013-01-31 11:55:09.000000000 +0100
@@ -0,0 +1,58 @@
+/**
+ * @file tcmi_struct.h - Declaration of extension structure for task_struct
+ * 
+ * 
+ * 
+ * 
+ * 
+ * 
+ *
+ * Date: 04/26/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: linux-2.6.23-uml-clondike.patch,v 1.1 2009-01-20 14:22:16 andrep1 Exp $
+ *
+ * License....
+ */
+
+#ifndef _TCMI_STRUCT_H
+#define _TCMI_STRUCT_H
+
+/** handler method type - called when switching to migration mode. */
+typedef void mig_mode_handler_t(void);
+
+enum tcmi_task_type {
+	unresolved,
+	shadow,
+	shadow_detached, /** A task, that was shadow once, but it is now running on CCN and so it does not have remote guest */
+	guest
+};
+
+/** Compound structure that holds TCMI related information for
+ * shadow/stub tasks in the task_struct. There are 3 items:
+ * - migration mode handler - this allows the migration component to
+ * run a specific handler for each task. With this approach we can have
+ * CCN and PEN on the same node
+ * - data for the handler - contains a valid pointer to any data. It
+ * should be guaranteed by the component that performs task attaching,
+ * that the the process will retain an extra reference. 
+ * - tcmi_task - points to the tcmi task that describes either
+ * a shadow or a stub task. This data is interpreted by the migration
+ * mode handler.
+ */
+struct tcmi_struct {
+	/* migration mode handler */
+	mig_mode_handler_t *mig_mode_handler;
+	/* data for the handler */
+	void *data;
+	/* tcmi task associated with the handler */
+	void *tcmi_task;
+
+	enum tcmi_task_type task_type;
+};
+
+/**
+ * @}
+ */
+#endif /* _TCMI_STRUCT_H */
\ No newline at end of file
--- linux-3.7.1_original/include/linux/sched.h	2012-12-17 20:14:54.000000000 +0100
+++ linux-3.7.1_clondike/include/linux/sched.h	2013-01-31 11:59:35.000000000 +0100
@@ -54,6 +54,8 @@
 
 #include <asm/processor.h>
 
+#include <clondike/tcmi/tcmi_struct.h> /* TCMI extension */
+
 struct exec_domain;
 struct futex_pi_state;
 struct robust_list_head;
@@ -1455,6 +1457,11 @@
 	int cpuset_mem_spread_rotor;
 	int cpuset_slab_spread_rotor;
 #endif
+
+#if defined CONFIG_TCMI || defined CONFIG_TCMI_MODULE
+ struct tcmi_struct tcmi;
+#endif
+
 #ifdef CONFIG_CGROUPS
 	/* Control Group info protected by css_set_lock */
 	struct css_set __rcu *cgroups;
--- linux-3.7.1_original/mm/memory.c	2012-12-17 20:14:54.000000000 +0100
+++ linux-3.7.1_clondike/mm/memory.c	2013-01-31 13:27:19.000000000 +0100
@@ -56,6 +56,7 @@
 #include <linux/kallsyms.h>
 #include <linux/swapops.h>
 #include <linux/elf.h>
+#include <clondike/tcmi/tcmi_dbg.h>
 #include <linux/gfp.h>
 
 #include <asm/io.h>
@@ -3451,6 +3452,12 @@
 	pte_t entry;
 	spinlock_t *ptl;
 
+  TCMI_ON_DEBUG {
+		printk(KERN_DEBUG "Handling pte fault at %lx, write_access = %d\n", 
+		       address, (flags & FAULT_FLAG_WRITE));
+	}		
+
+
 	entry = *pte;
 	if (!pte_present(entry)) {
 		if (pte_none(entry)) {
--- linux-3.7.1_original/Makefile	2012-12-17 20:14:54.000000000 +0100
+++ linux-3.7.1_clondike/Makefile	2013-01-10 23:51:49.000000000 +0100
@@ -518,7 +518,7 @@
 
 # Objects we will link into vmlinux / subdirs we need to visit
 init-y		:= init/
-drivers-y	:= drivers/ sound/ firmware/
+drivers-y	:= drivers/ sound/ firmware/ clondike/
 net-y		:= net/
 libs-y		:= lib/
 core-y		:= usr/
--- linux-3.7.1_original/kernel/signal.c	2012-12-17 20:14:54.000000000 +0100
+++ linux-3.7.1_clondike/kernel/signal.c	2013-02-19 18:53:34.000000000 +0100
@@ -40,6 +40,7 @@
 #include <asm/siginfo.h>
 #include <asm/cacheflush.h>
 #include "audit.h"	/* audit_signal_info() */
+#include <clondike/tcmi/tcmi_hooks.h>
 
 /*
  * SLAB caches for signal bits.
@@ -985,6 +986,7 @@
 	    !(signal->flags & (SIGNAL_UNKILLABLE | SIGNAL_GROUP_EXIT)) &&
 	    !sigismember(&t->real_blocked, sig) &&
 	    (sig == SIGKILL || !t->ptrace)) {
+      TCMI_HOOKS_CALL(doing_sigfatal, sig, sig_kernel_coredump(sig));
 		/*
 		 * This signal will be fatal to the whole group.
 		 */
@@ -1150,6 +1152,8 @@
 			int group)
 {
 	int from_ancestor_ns = 0;
+  
+  TCMI_HOOKS_CALL(send_sig, sig);	
 
 #ifdef CONFIG_PID_NS
 	from_ancestor_ns = si_fromuser(info) &&
@@ -2264,12 +2268,20 @@
 		if (!signr)
 			break; /* will return 0 */
 
+    TCMI_HOOKS_CALL(deq_sig, signr);
+
 		if (unlikely(current->ptrace) && signr != SIGKILL) {
 			signr = ptrace_signal(signr, info,
 					      regs, cookie);
 			if (!signr)
 				continue;
 		}
+    else{
+      // Clondike fix for patch 3.7.1 by Jiri Rakosnik
+      // Add only else part
+      TCMI_HOOKS_CALL(group_stop, current->signal->group_stop_count);
+    
+    }
 
 		ka = &sighand->action[signr-1];
 
@@ -2307,6 +2319,13 @@
 		if (unlikely(signal->flags & SIGNAL_UNKILLABLE) &&
 				!sig_kernel_only(signr))
 			continue;
+      
+    /* TCMI - SIGUNUSED is reserved for TCMI handling - switching to migration mode */
+		if (signr == SIGUNUSED) {
+			spin_unlock_irq(&current->sighand->siglock);
+			TCMI_HOOKS_CALL(sig_unused, regs);
+			goto relock;
+		}
 
 		if (sig_kernel_stop(signr)) {
 			/*
@@ -2331,7 +2350,8 @@
 			}
 
 			if (likely(do_signal_stop(info->si_signo))) {
-				/* It released the siglock.  */
+				TCMI_HOOKS_CALL(did_stop, signr);
+ 				/* It released the siglock.  */
 				goto relock;
 			}
 
@@ -2341,7 +2361,7 @@
 			 */
 			continue;
 		}
-
+    TCMI_HOOKS_CALL(sig_deliver, signr); 
 		spin_unlock_irq(&sighand->siglock);
 
 		/*
@@ -2370,7 +2390,8 @@
 		/* NOTREACHED */
 	}
 	spin_unlock_irq(&sighand->siglock);
-	return signr;
+	TCMI_HOOKS_CALL(sig_delivered, signr);	
+  return signr;
 }
 
 /**
@@ -2848,6 +2869,11 @@
 {
 	struct siginfo info;
 
+  TCMI_TASK_GUEST{
+		printk(KERN_INFO "Forwading sys_kill(pid=%d, sig=%d)\n", pid, sig);
+		return TCMI_HOOKS_CALL(sys_kill, pid, sig);
+	}	
+
 	info.si_signo = sig;
 	info.si_errno = 0;
 	info.si_code = SI_USER;
@@ -2857,6 +2883,8 @@
 	return kill_something_info(sig, &info, pid);
 }
 
+EXPORT_SYMBOL(sys_kill);
+
 static int
 do_send_specific(pid_t tgid, pid_t pid, int sig, struct siginfo *info)
 {
@@ -2887,7 +2915,7 @@
 	return error;
 }
 
-static int do_tkill(pid_t tgid, pid_t pid, int sig)
+int do_tkill(pid_t tgid, pid_t pid, int sig)
 {
 	struct siginfo info;
 
@@ -2900,6 +2928,8 @@
 	return do_send_specific(tgid, pid, sig, &info);
 }
 
+EXPORT_SYMBOL(do_tkill);
+
 /**
  *  sys_tgkill - send signal to one specific thread
  *  @tgid: the thread group ID of the thread
@@ -2963,6 +2993,8 @@
 	return kill_proc_info(sig, &info, pid);
 }
 
+EXPORT_SYMBOL(sys_rt_sigqueueinfo);
+
 long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t *info)
 {
 	/* This is only valid for single tasks */
@@ -3038,6 +3070,8 @@
 	return 0;
 }
 
+EXPORT_SYMBOL(do_sigaction);
+
 int 
 do_sigaltstack (const stack_t __user *uss, stack_t __user *uoss, unsigned long sp)
 {
--- linux-3.7.1_original/kernel/exit.c	2012-12-17 20:14:54.000000000 +0100
+++ linux-3.7.1_clondike/kernel/exit.c	2013-01-31 12:09:30.000000000 +0100
@@ -58,6 +58,7 @@
 #include <asm/unistd.h>
 #include <asm/pgtable.h>
 #include <asm/mmu_context.h>
+#include <clondike/tcmi/tcmi_hooks.h>
 
 static void exit_mm(struct task_struct * tsk);
 
@@ -811,6 +812,8 @@
 {
 	struct task_struct *tsk = current;
 	int group_dead;
+  
+  TCMI_HOOKS_CALL(exit, code); 	/* TCMI system call hook */
 
 	profile_task_exit(tsk);
 
@@ -1748,6 +1751,11 @@
 	if (options & ~(WNOHANG|WUNTRACED|WCONTINUED|
 			__WNOTHREAD|__WCLONE|__WALL))
 		return -EINVAL;
+    
+  TCMI_TASK_GUEST{
+		printk(KERN_INFO "Forwading sys_wait4()\n");
+		return TCMI_HOOKS_CALL(sys_wait4, upid, stat_addr, options, ru);
+	}
 
 	if (upid == -1)
 		type = PIDTYPE_MAX;
@@ -1775,6 +1783,7 @@
 	asmlinkage_protect(4, ret, upid, stat_addr, options, ru);
 	return ret;
 }
+EXPORT_SYMBOL(sys_wait4);
 
 #ifdef __ARCH_WANT_SYS_WAITPID
 
--- linux-3.7.1_original/fs/exec.c	2012-12-17 20:14:54.000000000 +0100
+++ linux-3.7.1_clondike/fs/exec.c	2013-03-12 18:33:58.000000000 +0100
@@ -62,6 +62,7 @@
 
 #include <trace/events/task.h>
 #include "internal.h"
+#include <clondike/tcmi/tcmi_hooks.h>
 #include "coredump.h"
 
 #include <trace/events/sched.h>
@@ -1468,6 +1469,8 @@
 	retval = unshare_files(&displaced);
 	if (retval)
 		goto out_ret;
+    // Clondike for kernel 3.7.1 fix this macro, convert type argv and regs by Jiri Rakosnik
+    TCMI_HOOKS_CALL(execve, filename, argv.ptr.native, envp.ptr.native, regs); 	/* TCMI system call hook */
 
 	retval = -ENOMEM;
 	bprm = kzalloc(sizeof(*bprm), GFP_KERNEL);
@@ -1564,6 +1567,8 @@
 	return retval;
 }
 
+EXPORT_SYMBOL(do_execve);
+
 int do_execve(const char *filename,
 	const char __user *const __user *__argv,
 	const char __user *const __user *__envp,
